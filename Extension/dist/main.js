module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/agent-base/index.js":
/*!******************************************!*\
  !*** ./node_modules/agent-base/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n__webpack_require__(/*! ./patch-core */ \"./node_modules/agent-base/patch-core.js\");\nconst inherits = __webpack_require__(/*! util */ \"util\").inherits;\nconst promisify = __webpack_require__(/*! es6-promisify */ \"./node_modules/es6-promisify/dist/promisify.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nmodule.exports = Agent;\n\nfunction isAgent(v) {\n  return v && typeof v.addRequest === 'function';\n}\n\n/**\n * Base `http.Agent` implementation.\n * No pooling/keep-alive is implemented by default.\n *\n * @param {Function} callback\n * @api public\n */\nfunction Agent(callback, _opts) {\n  if (!(this instanceof Agent)) {\n    return new Agent(callback, _opts);\n  }\n\n  EventEmitter.call(this);\n\n  // The callback gets promisified if it has 3 parameters\n  // (i.e. it has a callback function) lazily\n  this._promisifiedCallback = false;\n\n  let opts = _opts;\n  if ('function' === typeof callback) {\n    this.callback = callback;\n  } else if (callback) {\n    opts = callback;\n  }\n\n  // timeout for the socket to be returned from the callback\n  this.timeout = (opts && opts.timeout) || null;\n\n  this.options = opts;\n}\ninherits(Agent, EventEmitter);\n\n/**\n * Override this function in your subclass!\n */\nAgent.prototype.callback = function callback(req, opts) {\n  throw new Error(\n    '\"agent-base\" has no default implementation, you must subclass and override `callback()`'\n  );\n};\n\n/**\n * Called by node-core's \"_http_client.js\" module when creating\n * a new HTTP request with this Agent instance.\n *\n * @api public\n */\nAgent.prototype.addRequest = function addRequest(req, _opts) {\n  const ownOpts = Object.assign({}, _opts);\n\n  // Set default `host` for HTTP to localhost\n  if (null == ownOpts.host) {\n    ownOpts.host = 'localhost';\n  }\n\n  // Set default `port` for HTTP if none was explicitly specified\n  if (null == ownOpts.port) {\n    ownOpts.port = ownOpts.secureEndpoint ? 443 : 80;\n  }\n\n  const opts = Object.assign({}, this.options, ownOpts);\n\n  if (opts.host && opts.path) {\n    // If both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete opts.path;\n  }\n\n  delete opts.agent;\n  delete opts.hostname;\n  delete opts._defaultAgent;\n  delete opts.defaultPort;\n  delete opts.createConnection;\n\n  // Hint to use \"Connection: close\"\n  // XXX: non-documented `http` module API :(\n  req._last = true;\n  req.shouldKeepAlive = false;\n\n  // Create the `stream.Duplex` instance\n  let timeout;\n  let timedOut = false;\n  const timeoutMs = this.timeout;\n  const freeSocket = this.freeSocket;\n\n  function onerror(err) {\n    if (req._hadError) return;\n    req.emit('error', err);\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req._hadError = true;\n  }\n\n  function ontimeout() {\n    timeout = null;\n    timedOut = true;\n    const err = new Error(\n      'A \"socket\" was not created for HTTP request before ' + timeoutMs + 'ms'\n    );\n    err.code = 'ETIMEOUT';\n    onerror(err);\n  }\n\n  function callbackError(err) {\n    if (timedOut) return;\n    if (timeout != null) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    onerror(err);\n  }\n\n  function onsocket(socket) {\n    if (timedOut) return;\n    if (timeout != null) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    if (isAgent(socket)) {\n      // `socket` is actually an http.Agent instance, so relinquish\n      // responsibility for this `req` to the Agent from here on\n      socket.addRequest(req, opts);\n    } else if (socket) {\n      function onfree() {\n        freeSocket(socket, opts);\n      }\n      socket.on('free', onfree);\n      req.onSocket(socket);\n    } else {\n      const err = new Error(\n        'no Duplex stream was returned to agent-base for `' + req.method + ' ' + req.path + '`'\n      );\n      onerror(err);\n    }\n  }\n\n  if (!this._promisifiedCallback && this.callback.length >= 3) {\n    // Legacy callback function - convert to a Promise\n    this.callback = promisify(this.callback, this);\n    this._promisifiedCallback = true;\n  }\n\n  if (timeoutMs > 0) {\n    timeout = setTimeout(ontimeout, timeoutMs);\n  }\n\n  try {\n    Promise.resolve(this.callback(req, opts)).then(onsocket, callbackError);\n  } catch (err) {\n    Promise.reject(err).catch(callbackError);\n  }\n};\n\nAgent.prototype.freeSocket = function freeSocket(socket, opts) {\n  // TODO reuse sockets\n  socket.destroy();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL3BhdGNoLWNvcmUnKTtcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuY29uc3QgcHJvbWlzaWZ5ID0gcmVxdWlyZSgnZXM2LXByb21pc2lmeScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50O1xuXG5mdW5jdGlvbiBpc0FnZW50KHYpIHtcbiAgcmV0dXJuIHYgJiYgdHlwZW9mIHYuYWRkUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBCYXNlIGBodHRwLkFnZW50YCBpbXBsZW1lbnRhdGlvbi5cbiAqIE5vIHBvb2xpbmcva2VlcC1hbGl2ZSBpcyBpbXBsZW1lbnRlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBBZ2VudChjYWxsYmFjaywgX29wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFnZW50KSkge1xuICAgIHJldHVybiBuZXcgQWdlbnQoY2FsbGJhY2ssIF9vcHRzKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIFRoZSBjYWxsYmFjayBnZXRzIHByb21pc2lmaWVkIGlmIGl0IGhhcyAzIHBhcmFtZXRlcnNcbiAgLy8gKGkuZS4gaXQgaGFzIGEgY2FsbGJhY2sgZnVuY3Rpb24pIGxhemlseVxuICB0aGlzLl9wcm9taXNpZmllZENhbGxiYWNrID0gZmFsc2U7XG5cbiAgbGV0IG9wdHMgPSBfb3B0cztcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgIG9wdHMgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8vIHRpbWVvdXQgZm9yIHRoZSBzb2NrZXQgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgY2FsbGJhY2tcbiAgdGhpcy50aW1lb3V0ID0gKG9wdHMgJiYgb3B0cy50aW1lb3V0KSB8fCBudWxsO1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdHM7XG59XG5pbmhlcml0cyhBZ2VudCwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIHlvdXIgc3ViY2xhc3MhXG4gKi9cbkFnZW50LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1wiYWdlbnQtYmFzZVwiIGhhcyBubyBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCB5b3UgbXVzdCBzdWJjbGFzcyBhbmQgb3ZlcnJpZGUgYGNhbGxiYWNrKClgJ1xuICApO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgYnkgbm9kZS1jb3JlJ3MgXCJfaHR0cF9jbGllbnQuanNcIiBtb2R1bGUgd2hlbiBjcmVhdGluZ1xuICogYSBuZXcgSFRUUCByZXF1ZXN0IHdpdGggdGhpcyBBZ2VudCBpbnN0YW5jZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5BZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QocmVxLCBfb3B0cykge1xuICBjb25zdCBvd25PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgX29wdHMpO1xuXG4gIC8vIFNldCBkZWZhdWx0IGBob3N0YCBmb3IgSFRUUCB0byBsb2NhbGhvc3RcbiAgaWYgKG51bGwgPT0gb3duT3B0cy5ob3N0KSB7XG4gICAgb3duT3B0cy5ob3N0ID0gJ2xvY2FsaG9zdCc7XG4gIH1cblxuICAvLyBTZXQgZGVmYXVsdCBgcG9ydGAgZm9yIEhUVFAgaWYgbm9uZSB3YXMgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgaWYgKG51bGwgPT0gb3duT3B0cy5wb3J0KSB7XG4gICAgb3duT3B0cy5wb3J0ID0gb3duT3B0cy5zZWN1cmVFbmRwb2ludCA/IDQ0MyA6IDgwO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3duT3B0cyk7XG5cbiAgaWYgKG9wdHMuaG9zdCAmJiBvcHRzLnBhdGgpIHtcbiAgICAvLyBJZiBib3RoIGEgYGhvc3RgIGFuZCBgcGF0aGAgYXJlIHNwZWNpZmllZCB0aGVuIGl0J3MgbW9zdCBsaWtlbHkgdGhlXG4gICAgLy8gcmVzdWx0IG9mIGEgYHVybC5wYXJzZSgpYCBjYWxsLi4uIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBgcGF0aGAgcG9ydGlvbiBzb1xuICAgIC8vIHRoYXQgYG5ldC5jb25uZWN0KClgIGRvZXNuJ3QgYXR0ZW1wdCB0byBvcGVuIHRoYXQgYXMgYSB1bml4IHNvY2tldCBmaWxlLlxuICAgIGRlbGV0ZSBvcHRzLnBhdGg7XG4gIH1cblxuICBkZWxldGUgb3B0cy5hZ2VudDtcbiAgZGVsZXRlIG9wdHMuaG9zdG5hbWU7XG4gIGRlbGV0ZSBvcHRzLl9kZWZhdWx0QWdlbnQ7XG4gIGRlbGV0ZSBvcHRzLmRlZmF1bHRQb3J0O1xuICBkZWxldGUgb3B0cy5jcmVhdGVDb25uZWN0aW9uO1xuXG4gIC8vIEhpbnQgdG8gdXNlIFwiQ29ubmVjdGlvbjogY2xvc2VcIlxuICAvLyBYWFg6IG5vbi1kb2N1bWVudGVkIGBodHRwYCBtb2R1bGUgQVBJIDooXG4gIHJlcS5fbGFzdCA9IHRydWU7XG4gIHJlcS5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZTtcblxuICAvLyBDcmVhdGUgdGhlIGBzdHJlYW0uRHVwbGV4YCBpbnN0YW5jZVxuICBsZXQgdGltZW91dDtcbiAgbGV0IHRpbWVkT3V0ID0gZmFsc2U7XG4gIGNvbnN0IHRpbWVvdXRNcyA9IHRoaXMudGltZW91dDtcbiAgY29uc3QgZnJlZVNvY2tldCA9IHRoaXMuZnJlZVNvY2tldDtcblxuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGlmIChyZXEuX2hhZEVycm9yKSByZXR1cm47XG4gICAgcmVxLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAvLyBGb3IgU2FmZXR5LiBTb21lIGFkZGl0aW9uYWwgZXJyb3JzIG1pZ2h0IGZpcmUgbGF0ZXIgb25cbiAgICAvLyBhbmQgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgZG91YmxlLWZpcmUgdGhlIGVycm9yIGV2ZW50LlxuICAgIHJlcS5faGFkRXJyb3IgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb250aW1lb3V0KCkge1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQSBcInNvY2tldFwiIHdhcyBub3QgY3JlYXRlZCBmb3IgSFRUUCByZXF1ZXN0IGJlZm9yZSAnICsgdGltZW91dE1zICsgJ21zJ1xuICAgICk7XG4gICAgZXJyLmNvZGUgPSAnRVRJTUVPVVQnO1xuICAgIG9uZXJyb3IoZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrRXJyb3IoZXJyKSB7XG4gICAgaWYgKHRpbWVkT3V0KSByZXR1cm47XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIG9uZXJyb3IoZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uc29ja2V0KHNvY2tldCkge1xuICAgIGlmICh0aW1lZE91dCkgcmV0dXJuO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNBZ2VudChzb2NrZXQpKSB7XG4gICAgICAvLyBgc29ja2V0YCBpcyBhY3R1YWxseSBhbiBodHRwLkFnZW50IGluc3RhbmNlLCBzbyByZWxpbnF1aXNoXG4gICAgICAvLyByZXNwb25zaWJpbGl0eSBmb3IgdGhpcyBgcmVxYCB0byB0aGUgQWdlbnQgZnJvbSBoZXJlIG9uXG4gICAgICBzb2NrZXQuYWRkUmVxdWVzdChyZXEsIG9wdHMpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0KSB7XG4gICAgICBmdW5jdGlvbiBvbmZyZWUoKSB7XG4gICAgICAgIGZyZWVTb2NrZXQoc29ja2V0LCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIHNvY2tldC5vbignZnJlZScsIG9uZnJlZSk7XG4gICAgICByZXEub25Tb2NrZXQoc29ja2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAnbm8gRHVwbGV4IHN0cmVhbSB3YXMgcmV0dXJuZWQgdG8gYWdlbnQtYmFzZSBmb3IgYCcgKyByZXEubWV0aG9kICsgJyAnICsgcmVxLnBhdGggKyAnYCdcbiAgICAgICk7XG4gICAgICBvbmVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9wcm9taXNpZmllZENhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2subGVuZ3RoID49IDMpIHtcbiAgICAvLyBMZWdhY3kgY2FsbGJhY2sgZnVuY3Rpb24gLSBjb252ZXJ0IHRvIGEgUHJvbWlzZVxuICAgIHRoaXMuY2FsbGJhY2sgPSBwcm9taXNpZnkodGhpcy5jYWxsYmFjaywgdGhpcyk7XG4gICAgdGhpcy5fcHJvbWlzaWZpZWRDYWxsYmFjayA9IHRydWU7XG4gIH1cblxuICBpZiAodGltZW91dE1zID4gMCkge1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9udGltZW91dCwgdGltZW91dE1zKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuY2FsbGJhY2socmVxLCBvcHRzKSkudGhlbihvbnNvY2tldCwgY2FsbGJhY2tFcnJvcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIFByb21pc2UucmVqZWN0KGVycikuY2F0Y2goY2FsbGJhY2tFcnJvcik7XG4gIH1cbn07XG5cbkFnZW50LnByb3RvdHlwZS5mcmVlU29ja2V0ID0gZnVuY3Rpb24gZnJlZVNvY2tldChzb2NrZXQsIG9wdHMpIHtcbiAgLy8gVE9ETyByZXVzZSBzb2NrZXRzXG4gIHNvY2tldC5kZXN0cm95KCk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/agent-base/index.js\n");

/***/ }),

/***/ "./node_modules/agent-base/patch-core.js":
/*!***********************************************!*\
  !*** ./node_modules/agent-base/patch-core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst url = __webpack_require__(/*! url */ \"url\");\nconst https = __webpack_require__(/*! https */ \"https\");\n\n/**\n * This currently needs to be applied to all Node.js versions\n * in order to determine if the `req` is an HTTP or HTTPS request.\n *\n * There is currently no PR attempting to move this property upstream.\n */\nhttps.request = (function(request) {\n  return function(_options, cb) {\n    let options;\n    if (typeof _options === 'string') {\n      options = url.parse(_options);\n    } else {\n      options = Object.assign({}, _options);\n    }\n    if (null == options.port) {\n      options.port = 443;\n    }\n    options.secureEndpoint = true;\n    return request.call(https, options, cb);\n  };\n})(https.request);\n\n/**\n * This is needed for Node.js >= 9.0.0 to make sure `https.get()` uses the\n * patched `https.request()`.\n *\n * Ref: https://github.com/nodejs/node/commit/5118f31\n */\nhttps.get = function(options, cb) {\n  const req = https.request(options, cb);\n  req.end();\n  return req;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9wYXRjaC1jb3JlLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL3BhdGNoLWNvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbi8qKlxuICogVGhpcyBjdXJyZW50bHkgbmVlZHMgdG8gYmUgYXBwbGllZCB0byBhbGwgTm9kZS5qcyB2ZXJzaW9uc1xuICogaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBgcmVxYCBpcyBhbiBIVFRQIG9yIEhUVFBTIHJlcXVlc3QuXG4gKlxuICogVGhlcmUgaXMgY3VycmVudGx5IG5vIFBSIGF0dGVtcHRpbmcgdG8gbW92ZSB0aGlzIHByb3BlcnR5IHVwc3RyZWFtLlxuICovXG5odHRwcy5yZXF1ZXN0ID0gKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKF9vcHRpb25zLCBjYikge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgX29wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0gdXJsLnBhcnNlKF9vcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIF9vcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG51bGwgPT0gb3B0aW9ucy5wb3J0KSB7XG4gICAgICBvcHRpb25zLnBvcnQgPSA0NDM7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VjdXJlRW5kcG9pbnQgPSB0cnVlO1xuICAgIHJldHVybiByZXF1ZXN0LmNhbGwoaHR0cHMsIG9wdGlvbnMsIGNiKTtcbiAgfTtcbn0pKGh0dHBzLnJlcXVlc3QpO1xuXG4vKipcbiAqIFRoaXMgaXMgbmVlZGVkIGZvciBOb2RlLmpzID49IDkuMC4wIHRvIG1ha2Ugc3VyZSBgaHR0cHMuZ2V0KClgIHVzZXMgdGhlXG4gKiBwYXRjaGVkIGBodHRwcy5yZXF1ZXN0KClgLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC81MTE4ZjMxXG4gKi9cbmh0dHBzLmdldCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gIGNvbnN0IHJlcSA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgY2IpO1xuICByZXEuZW5kKCk7XG4gIHJldHVybiByZXE7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/agent-base/patch-core.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/Console.js":
/*!************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/Console.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js\");\r\nvar AutoCollectConsole = (function () {\r\n    function AutoCollectConsole(client) {\r\n        if (!!AutoCollectConsole.INSTANCE) {\r\n            throw new Error(\"Console logging adapter tracking should be configured from the applicationInsights object\");\r\n        }\r\n        this._client = client;\r\n        AutoCollectConsole.INSTANCE = this;\r\n    }\r\n    AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {\r\n        if (DiagChannel.IsInitialized) {\r\n            __webpack_require__(/*! ./diagnostic-channel/console.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js\").enable(isEnabled && collectConsoleLog, this._client);\r\n            __webpack_require__(/*! ./diagnostic-channel/bunyan.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js\").enable(isEnabled, this._client);\r\n            __webpack_require__(/*! ./diagnostic-channel/winston.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectConsole.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectConsole.prototype.dispose = function () {\r\n        AutoCollectConsole.INSTANCE = null;\r\n        this.enable(false, false);\r\n    };\r\n    AutoCollectConsole._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\r\n    return AutoCollectConsole;\r\n}());\r\nmodule.exports = AutoCollectConsole;\r\n//# sourceMappingURL=Console.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vQ29uc29sZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vQ29uc29sZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIERpYWdDaGFubmVsID0gcmVxdWlyZShcIi4vZGlhZ25vc3RpYy1jaGFubmVsL2luaXRpYWxpemF0aW9uXCIpO1xyXG52YXIgQXV0b0NvbGxlY3RDb25zb2xlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9Db2xsZWN0Q29uc29sZShjbGllbnQpIHtcclxuICAgICAgICBpZiAoISFBdXRvQ29sbGVjdENvbnNvbGUuSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc29sZSBsb2dnaW5nIGFkYXB0ZXIgdHJhY2tpbmcgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgZnJvbSB0aGUgYXBwbGljYXRpb25JbnNpZ2h0cyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcclxuICAgICAgICBBdXRvQ29sbGVjdENvbnNvbGUuSU5TVEFOQ0UgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgQXV0b0NvbGxlY3RDb25zb2xlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoaXNFbmFibGVkLCBjb2xsZWN0Q29uc29sZUxvZykge1xyXG4gICAgICAgIGlmIChEaWFnQ2hhbm5lbC5Jc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmUoXCIuL2RpYWdub3N0aWMtY2hhbm5lbC9jb25zb2xlLnN1YlwiKS5lbmFibGUoaXNFbmFibGVkICYmIGNvbGxlY3RDb25zb2xlTG9nLCB0aGlzLl9jbGllbnQpO1xyXG4gICAgICAgICAgICByZXF1aXJlKFwiLi9kaWFnbm9zdGljLWNoYW5uZWwvYnVueWFuLnN1YlwiKS5lbmFibGUoaXNFbmFibGVkLCB0aGlzLl9jbGllbnQpO1xyXG4gICAgICAgICAgICByZXF1aXJlKFwiLi9kaWFnbm9zdGljLWNoYW5uZWwvd2luc3Rvbi5zdWJcIikuZW5hYmxlKGlzRW5hYmxlZCwgdGhpcy5fY2xpZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RDb25zb2xlLnByb3RvdHlwZS5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0Q29uc29sZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBBdXRvQ29sbGVjdENvbnNvbGUuSU5TVEFOQ0UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlKGZhbHNlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RDb25zb2xlLl9tZXRob2ROYW1lcyA9IFtcImRlYnVnXCIsIFwiaW5mb1wiLCBcImxvZ1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcclxuICAgIHJldHVybiBBdXRvQ29sbGVjdENvbnNvbGU7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0NvbGxlY3RDb25zb2xlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25zb2xlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/Console.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Logging = __webpack_require__(/*! ../Library/Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js\");\r\nvar CorrelationContextManager = (function () {\r\n    function CorrelationContextManager() {\r\n    }\r\n    /**\r\n     *  Provides the current Context.\r\n     *  The context is the most recent one entered into for the current\r\n     *  logical chain of execution, including across asynchronous calls.\r\n     */\r\n    CorrelationContextManager.getCurrentContext = function () {\r\n        if (!CorrelationContextManager.enabled) {\r\n            return null;\r\n        }\r\n        return Zone.current.get(\"context\");\r\n    };\r\n    /**\r\n     *  A helper to generate objects conforming to the CorrelationContext interface\r\n     */\r\n    CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader) {\r\n        parentId = parentId || operationId;\r\n        if (this.enabled) {\r\n            return {\r\n                operation: {\r\n                    name: operationName,\r\n                    id: operationId,\r\n                    parentId: parentId\r\n                },\r\n                customProperties: new CustomPropertiesImpl(correlationContextHeader)\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     *  Runs a function inside a given Context.\r\n     *  All logical children of the execution path that entered this Context\r\n     *  will receive this Context object on calls to GetCurrentContext.\r\n     */\r\n    CorrelationContextManager.runWithContext = function (context, fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            var newZone = Zone.current.fork({\r\n                name: \"AI-\" + ((context && context.operation.parentId) || \"Unknown\"),\r\n                properties: { context: context }\r\n            });\r\n            newZone.run(fn);\r\n        }\r\n        else {\r\n            fn();\r\n        }\r\n    };\r\n    /**\r\n     *  Patches a callback to restore the correct Context when getCurrentContext\r\n     *  is run within it. This is necessary if automatic correlation fails to work\r\n     *  with user-included libraries.\r\n     *\r\n     *  The supplied callback will be given the same context that was present for\r\n     *  the call to wrapCallback.  */\r\n    CorrelationContextManager.wrapCallback = function (fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return Zone.current.wrap(fn, \"User-wrapped method\");\r\n        }\r\n        return fn;\r\n    };\r\n    /**\r\n     *  Enables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.enable = function () {\r\n        if (this.enabled) {\r\n            return;\r\n        }\r\n        if (!this.isNodeVersionCompatible()) {\r\n            this.enabled = false;\r\n            return;\r\n        }\r\n        // Run patches for Zone.js\r\n        if (!CorrelationContextManager.hasEverEnabled) {\r\n            this.hasEverEnabled = true;\r\n            // Load in Zone.js\r\n            try {\r\n                // Require zone if we can't detect its presence - guarded because of issue #346\r\n                // Note that usually multiple requires of zone.js does not error - but we see reports of it happening\r\n                // in the Azure Functions environment.\r\n                // This indicates that the file is being included multiple times in the same global scope,\r\n                // averting require's cache somehow.\r\n                if (typeof Zone === \"undefined\") {\r\n                    __webpack_require__(/*! zone.js */ \"./node_modules/zone.js/dist/zone-node.js\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Zone was already loaded even though we couldn't find its global variable\r\n                Logging.warn(\"Failed to require zone.js\");\r\n            }\r\n            DiagChannel.registerContextPreservation(function (cb) {\r\n                return Zone.current.wrap(cb, \"AI-ContextPreservation\");\r\n            });\r\n            this.patchError();\r\n            this.patchTimers([\"setTimeout\", \"setInterval\"]);\r\n        }\r\n        this.enabled = true;\r\n    };\r\n    /**\r\n     *  Disables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.disable = function () {\r\n        this.enabled = false;\r\n    };\r\n    /**\r\n     *  Reports if the CorrelationContextManager is able to run in this environment\r\n     */\r\n    CorrelationContextManager.isNodeVersionCompatible = function () {\r\n        // Unit tests warn of errors < 3.3 from timer patching. All versions before 4 were 0.x\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);\r\n    };\r\n    // Zone.js breaks concatenation of timer return values.\r\n    // This fixes that.\r\n    CorrelationContextManager.patchTimers = function (methodNames) {\r\n        methodNames.forEach(function (methodName) {\r\n            var orig = global[methodName];\r\n            global[methodName] = function () {\r\n                var ret = orig.apply(this, arguments);\r\n                ret.toString = function () {\r\n                    if (this.data && typeof this.data.handleId !== 'undefined') {\r\n                        return this.data.handleId.toString();\r\n                    }\r\n                    else {\r\n                        return Object.prototype.toString.call(this);\r\n                    }\r\n                };\r\n                return ret;\r\n            };\r\n        });\r\n    };\r\n    // Zone.js breaks deepEqual on error objects (by making internal properties enumerable).\r\n    // This fixes that by subclassing the error object and making all properties not enumerable\r\n    CorrelationContextManager.patchError = function () {\r\n        var orig = global.Error;\r\n        // New error handler\r\n        function AppInsightsAsyncCorrelatedErrorWrapper() {\r\n            if (!(this instanceof AppInsightsAsyncCorrelatedErrorWrapper)) {\r\n                return AppInsightsAsyncCorrelatedErrorWrapper.apply(Object.create(AppInsightsAsyncCorrelatedErrorWrapper.prototype), arguments);\r\n            }\r\n            // Is this object set to rewrite the stack?\r\n            // If so, we should turn off some Zone stuff that is prone to break\r\n            var stackRewrite = orig.stackRewrite;\r\n            if (orig.prepareStackTrace) {\r\n                orig.stackRewrite = false;\r\n                var stackTrace = orig.prepareStackTrace;\r\n                orig.prepareStackTrace = function (e, s) {\r\n                    // Remove some AI and Zone methods from the stack trace\r\n                    // Otherwise we leave side-effects\r\n                    // Algorithm is to find the first frame on the stack after the first instance(s)\r\n                    // of AutoCollection/CorrelationContextManager\r\n                    // Eg. this should return the User frame on an array like below:\r\n                    //  Zone | Zone | CorrelationContextManager | CorrelationContextManager | User\r\n                    var foundOne = false;\r\n                    for (var i = 0; i < s.length; i++) {\r\n                        var fileName = s[i].getFileName();\r\n                        if (fileName) {\r\n                            if (fileName.indexOf(\"AutoCollection/CorrelationContextManager\") === -1 &&\r\n                                fileName.indexOf(\"AutoCollection\\\\CorrelationContextManager\") === -1) {\r\n                                if (foundOne) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                foundOne = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    // Loop above goes one extra step\r\n                    i = Math.max(0, i - 1);\r\n                    if (foundOne) {\r\n                        s.splice(0, i);\r\n                    }\r\n                    return stackTrace(e, s);\r\n                };\r\n            }\r\n            // Apply the error constructor\r\n            orig.apply(this, arguments);\r\n            // Restore Zone stack rewriting settings\r\n            orig.stackRewrite = stackRewrite;\r\n            // Remove unexpected bits from stack trace\r\n            if (this.stack && typeof this.stack === \"string\") {\r\n                var stackFrames = this.stack.split(\"\\n\");\r\n                // Remove this class\r\n                if (stackFrames.length > 3) {\r\n                    if (stackFrames[2].trim().indexOf(\"at Error.AppInsightsAsyncCorrelatedErrorWrapper\") === 0) {\r\n                        stackFrames.splice(2, 1);\r\n                    }\r\n                    else if (stackFrames[1].trim().indexOf(\"at AppInsightsAsyncCorrelatedErrorWrapper.ZoneAwareError\") === 0\r\n                        && stackFrames[2].trim().indexOf(\"at new AppInsightsAsyncCorrelatedErrorWrapper\") === 0) {\r\n                        stackFrames.splice(1, 2);\r\n                    }\r\n                }\r\n                // Remove AI correlation ids\r\n                this.stack = stackFrames.map(function (v) {\r\n                    var startIndex = v.indexOf(\") [\");\r\n                    if (startIndex > -1) {\r\n                        v = v.substr(0, startIndex + 1);\r\n                    }\r\n                    return v;\r\n                }).join(\"\\n\");\r\n            }\r\n            // getOwnPropertyNames should be a superset of Object.keys...\r\n            // This appears to not always be the case\r\n            var props = Object.getOwnPropertyNames(this).concat(Object.keys(this));\r\n            // Zone.js will automatically create some hidden properties at read time.\r\n            // We need to proactively make those not enumerable as well as the currently visible properties\r\n            for (var i = 0; i < props.length; i++) {\r\n                var propertyName = props[i];\r\n                var hiddenPropertyName = Zone['__symbol__'](propertyName);\r\n                Object.defineProperty(this, propertyName, { enumerable: false });\r\n                Object.defineProperty(this, hiddenPropertyName, { enumerable: false, writable: true });\r\n            }\r\n            return this;\r\n        }\r\n        // Inherit from the Zone.js error handler\r\n        AppInsightsAsyncCorrelatedErrorWrapper.prototype = orig.prototype;\r\n        // We need this loop to copy outer methods like Error.captureStackTrace\r\n        var props = Object.getOwnPropertyNames(orig);\r\n        for (var i = 0; i < props.length; i++) {\r\n            var propertyName = props[i];\r\n            if (!AppInsightsAsyncCorrelatedErrorWrapper[propertyName]) {\r\n                Object.defineProperty(AppInsightsAsyncCorrelatedErrorWrapper, propertyName, Object.getOwnPropertyDescriptor(orig, propertyName));\r\n            }\r\n        }\r\n        // explicit cast to <any> required to avoid type error for captureStackTrace\r\n        // with latest node.d.ts (despite workaround above)\r\n        global.Error = AppInsightsAsyncCorrelatedErrorWrapper;\r\n    };\r\n    CorrelationContextManager.enabled = false;\r\n    CorrelationContextManager.hasEverEnabled = false;\r\n    return CorrelationContextManager;\r\n}());\r\nexports.CorrelationContextManager = CorrelationContextManager;\r\nvar CustomPropertiesImpl = (function () {\r\n    function CustomPropertiesImpl(header) {\r\n        this.props = [];\r\n        this.addHeaderData(header);\r\n    }\r\n    CustomPropertiesImpl.prototype.addHeaderData = function (header) {\r\n        var keyvals = header ? header.split(\", \") : [];\r\n        this.props = keyvals.map(function (keyval) {\r\n            var parts = keyval.split(\"=\");\r\n            return { key: parts[0], value: parts[1] };\r\n        }).concat(this.props);\r\n    };\r\n    CustomPropertiesImpl.prototype.serializeToHeader = function () {\r\n        return this.props.map(function (keyval) {\r\n            return keyval.key + \"=\" + keyval.value;\r\n        }).join(\", \");\r\n    };\r\n    CustomPropertiesImpl.prototype.getProperty = function (prop) {\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                return keyval.value;\r\n            }\r\n        }\r\n        return;\r\n    };\r\n    // TODO: Strictly according to the spec, properties which are recieved from\r\n    // an incoming request should be left untouched, while we may add our own new\r\n    // properties. The logic here will need to change to track that.\r\n    CustomPropertiesImpl.prototype.setProperty = function (prop, val) {\r\n        if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {\r\n            Logging.warn(\"Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: \" + prop + \" and value: \" + val);\r\n            return;\r\n        }\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                keyval.value = val;\r\n                return;\r\n            }\r\n        }\r\n        this.props.push({ key: prop, value: val });\r\n    };\r\n    CustomPropertiesImpl.bannedCharacters = /[,=]/;\r\n    return CustomPropertiesImpl;\r\n}());\r\n//# sourceMappingURL=CorrelationContextManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTG9nZ2luZyA9IHJlcXVpcmUoXCIuLi9MaWJyYXJ5L0xvZ2dpbmdcIik7XHJcbnZhciBEaWFnQ2hhbm5lbCA9IHJlcXVpcmUoXCIuL2RpYWdub3N0aWMtY2hhbm5lbC9pbml0aWFsaXphdGlvblwiKTtcclxudmFyIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIFByb3ZpZGVzIHRoZSBjdXJyZW50IENvbnRleHQuXHJcbiAgICAgKiAgVGhlIGNvbnRleHQgaXMgdGhlIG1vc3QgcmVjZW50IG9uZSBlbnRlcmVkIGludG8gZm9yIHRoZSBjdXJyZW50XHJcbiAgICAgKiAgbG9naWNhbCBjaGFpbiBvZiBleGVjdXRpb24sIGluY2x1ZGluZyBhY3Jvc3MgYXN5bmNocm9ub3VzIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gWm9uZS5jdXJyZW50LmdldChcImNvbnRleHRcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgQSBoZWxwZXIgdG8gZ2VuZXJhdGUgb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBDb3JyZWxhdGlvbkNvbnRleHQgaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuICAgIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIuZ2VuZXJhdGVDb250ZXh0T2JqZWN0ID0gZnVuY3Rpb24gKG9wZXJhdGlvbklkLCBwYXJlbnRJZCwgb3BlcmF0aW9uTmFtZSwgY29ycmVsYXRpb25Db250ZXh0SGVhZGVyKSB7XHJcbiAgICAgICAgcGFyZW50SWQgPSBwYXJlbnRJZCB8fCBvcGVyYXRpb25JZDtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcGVyYXRpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBvcGVyYXRpb25JZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBuZXcgQ3VzdG9tUHJvcGVydGllc0ltcGwoY29ycmVsYXRpb25Db250ZXh0SGVhZGVyKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICBSdW5zIGEgZnVuY3Rpb24gaW5zaWRlIGEgZ2l2ZW4gQ29udGV4dC5cclxuICAgICAqICBBbGwgbG9naWNhbCBjaGlsZHJlbiBvZiB0aGUgZXhlY3V0aW9uIHBhdGggdGhhdCBlbnRlcmVkIHRoaXMgQ29udGV4dFxyXG4gICAgICogIHdpbGwgcmVjZWl2ZSB0aGlzIENvbnRleHQgb2JqZWN0IG9uIGNhbGxzIHRvIEdldEN1cnJlbnRDb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLnJ1bldpdGhDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGZuKSB7XHJcbiAgICAgICAgaWYgKENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3Wm9uZSA9IFpvbmUuY3VycmVudC5mb3JrKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiQUktXCIgKyAoKGNvbnRleHQgJiYgY29udGV4dC5vcGVyYXRpb24ucGFyZW50SWQpIHx8IFwiVW5rbm93blwiKSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgY29udGV4dDogY29udGV4dCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuZXdab25lLnJ1bihmbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICBQYXRjaGVzIGEgY2FsbGJhY2sgdG8gcmVzdG9yZSB0aGUgY29ycmVjdCBDb250ZXh0IHdoZW4gZ2V0Q3VycmVudENvbnRleHRcclxuICAgICAqICBpcyBydW4gd2l0aGluIGl0LiBUaGlzIGlzIG5lY2Vzc2FyeSBpZiBhdXRvbWF0aWMgY29ycmVsYXRpb24gZmFpbHMgdG8gd29ya1xyXG4gICAgICogIHdpdGggdXNlci1pbmNsdWRlZCBsaWJyYXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSBzdXBwbGllZCBjYWxsYmFjayB3aWxsIGJlIGdpdmVuIHRoZSBzYW1lIGNvbnRleHQgdGhhdCB3YXMgcHJlc2VudCBmb3JcclxuICAgICAqICB0aGUgY2FsbCB0byB3cmFwQ2FsbGJhY2suICAqL1xyXG4gICAgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci53cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBpZiAoQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBab25lLmN1cnJlbnQud3JhcChmbiwgXCJVc2VyLXdyYXBwZWQgbWV0aG9kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgRW5hYmxlcyB0aGUgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5cclxuICAgICAqL1xyXG4gICAgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc05vZGVWZXJzaW9uQ29tcGF0aWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJ1biBwYXRjaGVzIGZvciBab25lLmpzXHJcbiAgICAgICAgaWYgKCFDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmhhc0V2ZXJFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzRXZlckVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBMb2FkIGluIFpvbmUuanNcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIFJlcXVpcmUgem9uZSBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRzIHByZXNlbmNlIC0gZ3VhcmRlZCBiZWNhdXNlIG9mIGlzc3VlICMzNDZcclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB1c3VhbGx5IG11bHRpcGxlIHJlcXVpcmVzIG9mIHpvbmUuanMgZG9lcyBub3QgZXJyb3IgLSBidXQgd2Ugc2VlIHJlcG9ydHMgb2YgaXQgaGFwcGVuaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgQXp1cmUgRnVuY3Rpb25zIGVudmlyb25tZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgZmlsZSBpcyBiZWluZyBpbmNsdWRlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSBnbG9iYWwgc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAvLyBhdmVydGluZyByZXF1aXJlJ3MgY2FjaGUgc29tZWhvdy5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgWm9uZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJ6b25lLmpzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBab25lIHdhcyBhbHJlYWR5IGxvYWRlZCBldmVuIHRob3VnaCB3ZSBjb3VsZG4ndCBmaW5kIGl0cyBnbG9iYWwgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcud2FybihcIkZhaWxlZCB0byByZXF1aXJlIHpvbmUuanNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRGlhZ0NoYW5uZWwucmVnaXN0ZXJDb250ZXh0UHJlc2VydmF0aW9uKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvbmUuY3VycmVudC53cmFwKGNiLCBcIkFJLUNvbnRleHRQcmVzZXJ2YXRpb25cIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGNoRXJyb3IoKTtcclxuICAgICAgICAgICAgdGhpcy5wYXRjaFRpbWVycyhbXCJzZXRUaW1lb3V0XCIsIFwic2V0SW50ZXJ2YWxcIl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIERpc2FibGVzIHRoZSBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLlxyXG4gICAgICovXHJcbiAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAgUmVwb3J0cyBpZiB0aGUgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlciBpcyBhYmxlIHRvIHJ1biBpbiB0aGlzIGVudmlyb25tZW50XHJcbiAgICAgKi9cclxuICAgIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIuaXNOb2RlVmVyc2lvbkNvbXBhdGlibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gVW5pdCB0ZXN0cyB3YXJuIG9mIGVycm9ycyA8IDMuMyBmcm9tIHRpbWVyIHBhdGNoaW5nLiBBbGwgdmVyc2lvbnMgYmVmb3JlIDQgd2VyZSAwLnhcclxuICAgICAgICB2YXIgbm9kZVZlciA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG5vZGVWZXJbMF0pID4gMyB8fCAocGFyc2VJbnQobm9kZVZlclswXSkgPiAyICYmIHBhcnNlSW50KG5vZGVWZXJbMV0pID4gMik7XHJcbiAgICB9O1xyXG4gICAgLy8gWm9uZS5qcyBicmVha3MgY29uY2F0ZW5hdGlvbiBvZiB0aW1lciByZXR1cm4gdmFsdWVzLlxyXG4gICAgLy8gVGhpcyBmaXhlcyB0aGF0LlxyXG4gICAgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5wYXRjaFRpbWVycyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lcykge1xyXG4gICAgICAgIG1ldGhvZE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWcgPSBnbG9iYWxbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgICAgIGdsb2JhbFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0eXBlb2YgdGhpcy5kYXRhLmhhbmRsZUlkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhbmRsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFpvbmUuanMgYnJlYWtzIGRlZXBFcXVhbCBvbiBlcnJvciBvYmplY3RzIChieSBtYWtpbmcgaW50ZXJuYWwgcHJvcGVydGllcyBlbnVtZXJhYmxlKS5cclxuICAgIC8vIFRoaXMgZml4ZXMgdGhhdCBieSBzdWJjbGFzc2luZyB0aGUgZXJyb3Igb2JqZWN0IGFuZCBtYWtpbmcgYWxsIHByb3BlcnRpZXMgbm90IGVudW1lcmFibGVcclxuICAgIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIucGF0Y2hFcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3JpZyA9IGdsb2JhbC5FcnJvcjtcclxuICAgICAgICAvLyBOZXcgZXJyb3IgaGFuZGxlclxyXG4gICAgICAgIGZ1bmN0aW9uIEFwcEluc2lnaHRzQXN5bmNDb3JyZWxhdGVkRXJyb3JXcmFwcGVyKCkge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXBwSW5zaWdodHNBc3luY0NvcnJlbGF0ZWRFcnJvcldyYXBwZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQXBwSW5zaWdodHNBc3luY0NvcnJlbGF0ZWRFcnJvcldyYXBwZXIuYXBwbHkoT2JqZWN0LmNyZWF0ZShBcHBJbnNpZ2h0c0FzeW5jQ29ycmVsYXRlZEVycm9yV3JhcHBlci5wcm90b3R5cGUpLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElzIHRoaXMgb2JqZWN0IHNldCB0byByZXdyaXRlIHRoZSBzdGFjaz9cclxuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCB0dXJuIG9mZiBzb21lIFpvbmUgc3R1ZmYgdGhhdCBpcyBwcm9uZSB0byBicmVha1xyXG4gICAgICAgICAgICB2YXIgc3RhY2tSZXdyaXRlID0gb3JpZy5zdGFja1Jld3JpdGU7XHJcbiAgICAgICAgICAgIGlmIChvcmlnLnByZXBhcmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnLnN0YWNrUmV3cml0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrVHJhY2UgPSBvcmlnLnByZXBhcmVTdGFja1RyYWNlO1xyXG4gICAgICAgICAgICAgICAgb3JpZy5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChlLCBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNvbWUgQUkgYW5kIFpvbmUgbWV0aG9kcyBmcm9tIHRoZSBzdGFjayB0cmFjZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBsZWF2ZSBzaWRlLWVmZmVjdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGdvcml0aG0gaXMgdG8gZmluZCB0aGUgZmlyc3QgZnJhbWUgb24gdGhlIHN0YWNrIGFmdGVyIHRoZSBmaXJzdCBpbnN0YW5jZShzKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIEF1dG9Db2xsZWN0aW9uL0NvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBFZy4gdGhpcyBzaG91bGQgcmV0dXJuIHRoZSBVc2VyIGZyYW1lIG9uIGFuIGFycmF5IGxpa2UgYmVsb3c6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIFpvbmUgfCBab25lIHwgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlciB8IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIgfCBVc2VyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kT25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHNbaV0uZ2V0RmlsZU5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUuaW5kZXhPZihcIkF1dG9Db2xsZWN0aW9uL0NvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJcIikgPT09IC0xICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUuaW5kZXhPZihcIkF1dG9Db2xsZWN0aW9uXFxcXENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJcIikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kT25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kT25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIGFib3ZlIGdvZXMgb25lIGV4dHJhIHN0ZXBcclxuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoMCwgaSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZE9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNwbGljZSgwLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrVHJhY2UoZSwgcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBlcnJvciBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgWm9uZSBzdGFjayByZXdyaXRpbmcgc2V0dGluZ3NcclxuICAgICAgICAgICAgb3JpZy5zdGFja1Jld3JpdGUgPSBzdGFja1Jld3JpdGU7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB1bmV4cGVjdGVkIGJpdHMgZnJvbSBzdGFjayB0cmFjZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayAmJiB0eXBlb2YgdGhpcy5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrRnJhbWVzID0gdGhpcy5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGNsYXNzXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tGcmFtZXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja0ZyYW1lc1syXS50cmltKCkuaW5kZXhPZihcImF0IEVycm9yLkFwcEluc2lnaHRzQXN5bmNDb3JyZWxhdGVkRXJyb3JXcmFwcGVyXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrRnJhbWVzLnNwbGljZSgyLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhY2tGcmFtZXNbMV0udHJpbSgpLmluZGV4T2YoXCJhdCBBcHBJbnNpZ2h0c0FzeW5jQ29ycmVsYXRlZEVycm9yV3JhcHBlci5ab25lQXdhcmVFcnJvclwiKSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzdGFja0ZyYW1lc1syXS50cmltKCkuaW5kZXhPZihcImF0IG5ldyBBcHBJbnNpZ2h0c0FzeW5jQ29ycmVsYXRlZEVycm9yV3JhcHBlclwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja0ZyYW1lcy5zcGxpY2UoMSwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIEFJIGNvcnJlbGF0aW9uIGlkc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrRnJhbWVzLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdi5pbmRleE9mKFwiKSBbXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHYuc3Vic3RyKDAsIHN0YXJ0SW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldE93blByb3BlcnR5TmFtZXMgc2hvdWxkIGJlIGEgc3VwZXJzZXQgb2YgT2JqZWN0LmtleXMuLi5cclxuICAgICAgICAgICAgLy8gVGhpcyBhcHBlYXJzIHRvIG5vdCBhbHdheXMgYmUgdGhlIGNhc2VcclxuICAgICAgICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMpKTtcclxuICAgICAgICAgICAgLy8gWm9uZS5qcyB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIHNvbWUgaGlkZGVuIHByb3BlcnRpZXMgYXQgcmVhZCB0aW1lLlxyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHByb2FjdGl2ZWx5IG1ha2UgdGhvc2Ugbm90IGVudW1lcmFibGUgYXMgd2VsbCBhcyB0aGUgY3VycmVudGx5IHZpc2libGUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuUHJvcGVydHlOYW1lID0gWm9uZVsnX19zeW1ib2xfXyddKHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHlOYW1lLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGhpZGRlblByb3BlcnR5TmFtZSwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaGVyaXQgZnJvbSB0aGUgWm9uZS5qcyBlcnJvciBoYW5kbGVyXHJcbiAgICAgICAgQXBwSW5zaWdodHNBc3luY0NvcnJlbGF0ZWRFcnJvcldyYXBwZXIucHJvdG90eXBlID0gb3JpZy5wcm90b3R5cGU7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGxvb3AgdG8gY29weSBvdXRlciBtZXRob2RzIGxpa2UgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VcclxuICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcmlnKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFBcHBJbnNpZ2h0c0FzeW5jQ29ycmVsYXRlZEVycm9yV3JhcHBlcltwcm9wZXJ0eU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwSW5zaWdodHNBc3luY0NvcnJlbGF0ZWRFcnJvcldyYXBwZXIsIHByb3BlcnR5TmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnLCBwcm9wZXJ0eU5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBsaWNpdCBjYXN0IHRvIDxhbnk+IHJlcXVpcmVkIHRvIGF2b2lkIHR5cGUgZXJyb3IgZm9yIGNhcHR1cmVTdGFja1RyYWNlXHJcbiAgICAgICAgLy8gd2l0aCBsYXRlc3Qgbm9kZS5kLnRzIChkZXNwaXRlIHdvcmthcm91bmQgYWJvdmUpXHJcbiAgICAgICAgZ2xvYmFsLkVycm9yID0gQXBwSW5zaWdodHNBc3luY0NvcnJlbGF0ZWRFcnJvcldyYXBwZXI7XHJcbiAgICB9O1xyXG4gICAgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5lbmFibGVkID0gZmFsc2U7XHJcbiAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmhhc0V2ZXJFbmFibGVkID0gZmFsc2U7XHJcbiAgICByZXR1cm4gQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyID0gQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlcjtcclxudmFyIEN1c3RvbVByb3BlcnRpZXNJbXBsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEN1c3RvbVByb3BlcnRpZXNJbXBsKGhlYWRlcikge1xyXG4gICAgICAgIHRoaXMucHJvcHMgPSBbXTtcclxuICAgICAgICB0aGlzLmFkZEhlYWRlckRhdGEoaGVhZGVyKTtcclxuICAgIH1cclxuICAgIEN1c3RvbVByb3BlcnRpZXNJbXBsLnByb3RvdHlwZS5hZGRIZWFkZXJEYXRhID0gZnVuY3Rpb24gKGhlYWRlcikge1xyXG4gICAgICAgIHZhciBrZXl2YWxzID0gaGVhZGVyID8gaGVhZGVyLnNwbGl0KFwiLCBcIikgOiBbXTtcclxuICAgICAgICB0aGlzLnByb3BzID0ga2V5dmFscy5tYXAoZnVuY3Rpb24gKGtleXZhbCkge1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBrZXl2YWwuc3BsaXQoXCI9XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IHBhcnRzWzBdLCB2YWx1ZTogcGFydHNbMV0gfTtcclxuICAgICAgICB9KS5jb25jYXQodGhpcy5wcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9tUHJvcGVydGllc0ltcGwucHJvdG90eXBlLnNlcmlhbGl6ZVRvSGVhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLm1hcChmdW5jdGlvbiAoa2V5dmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXl2YWwua2V5ICsgXCI9XCIgKyBrZXl2YWwudmFsdWU7XHJcbiAgICAgICAgfSkuam9pbihcIiwgXCIpO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbVByb3BlcnRpZXNJbXBsLnByb3RvdHlwZS5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXl2YWwgPSB0aGlzLnByb3BzW2ldO1xyXG4gICAgICAgICAgICBpZiAoa2V5dmFsLmtleSA9PT0gcHJvcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXZhbC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogU3RyaWN0bHkgYWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBwcm9wZXJ0aWVzIHdoaWNoIGFyZSByZWNpZXZlZCBmcm9tXHJcbiAgICAvLyBhbiBpbmNvbWluZyByZXF1ZXN0IHNob3VsZCBiZSBsZWZ0IHVudG91Y2hlZCwgd2hpbGUgd2UgbWF5IGFkZCBvdXIgb3duIG5ld1xyXG4gICAgLy8gcHJvcGVydGllcy4gVGhlIGxvZ2ljIGhlcmUgd2lsbCBuZWVkIHRvIGNoYW5nZSB0byB0cmFjayB0aGF0LlxyXG4gICAgQ3VzdG9tUHJvcGVydGllc0ltcGwucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3AsIHZhbCkge1xyXG4gICAgICAgIGlmIChDdXN0b21Qcm9wZXJ0aWVzSW1wbC5iYW5uZWRDaGFyYWN0ZXJzLnRlc3QocHJvcCkgfHwgQ3VzdG9tUHJvcGVydGllc0ltcGwuYmFubmVkQ2hhcmFjdGVycy50ZXN0KHZhbCkpIHtcclxuICAgICAgICAgICAgTG9nZ2luZy53YXJuKFwiQ29ycmVsYXRpb24gY29udGV4dCBwcm9wZXJ0eSBrZXlzIGFuZCB2YWx1ZXMgbXVzdCBub3QgY29udGFpbiAnLCcgb3IgJz0nLiBzZXRQcm9wZXJ0eSB3YXMgY2FsbGVkIHdpdGgga2V5OiBcIiArIHByb3AgKyBcIiBhbmQgdmFsdWU6IFwiICsgdmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGtleXZhbCA9IHRoaXMucHJvcHNbaV07XHJcbiAgICAgICAgICAgIGlmIChrZXl2YWwua2V5ID09PSBwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBrZXl2YWwudmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9wcy5wdXNoKHsga2V5OiBwcm9wLCB2YWx1ZTogdmFsIH0pO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbVByb3BlcnRpZXNJbXBsLmJhbm5lZENoYXJhY3RlcnMgPSAvWyw9XS87XHJcbiAgICByZXR1cm4gQ3VzdG9tUHJvcGVydGllc0ltcGw7XHJcbn0oKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/Exceptions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/Exceptions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar AutoCollectExceptions = (function () {\r\n    function AutoCollectExceptions(client) {\r\n        if (!!AutoCollectExceptions.INSTANCE) {\r\n            throw new Error(\"Exception tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectExceptions.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    Object.defineProperty(AutoCollectExceptions, \"UNCAUGHT_EXCEPTION_HANDLER_NAME\", {\r\n        get: function () { return \"uncaughtException\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AutoCollectExceptions, \"UNHANDLED_REJECTION_HANDLER_NAME\", {\r\n        get: function () { return \"unhandledRejection\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AutoCollectExceptions.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectExceptions.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        if (isEnabled) {\r\n            this._isInitialized = true;\r\n            var self = this;\r\n            if (!this._exceptionListenerHandle) {\r\n                var handle = function (reThrow, error) {\r\n                    _this._client.trackException({ exception: error });\r\n                    _this._client.flush({ isAppCrashing: true });\r\n                    if (reThrow) {\r\n                        var THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION = error;\r\n                        throw THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION; // Error originated somewhere else in your app\r\n                    }\r\n                };\r\n                this._exceptionListenerHandle = handle.bind(this, true);\r\n                this._rejectionListenerHandle = handle.bind(this, false);\r\n                process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n            }\r\n        }\r\n        else {\r\n            if (this._exceptionListenerHandle) {\r\n                process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n                this._exceptionListenerHandle = undefined;\r\n                this._rejectionListenerHandle = undefined;\r\n                delete this._exceptionListenerHandle;\r\n                delete this._rejectionListenerHandle;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectExceptions.prototype.dispose = function () {\r\n        AutoCollectExceptions.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectExceptions.INSTANCE = null;\r\n    return AutoCollectExceptions;\r\n}());\r\nmodule.exports = AutoCollectExceptions;\r\n//# sourceMappingURL=Exceptions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vRXhjZXB0aW9ucy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vRXhjZXB0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIEF1dG9Db2xsZWN0RXhjZXB0aW9ucyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdXRvQ29sbGVjdEV4Y2VwdGlvbnMoY2xpZW50KSB7XHJcbiAgICAgICAgaWYgKCEhQXV0b0NvbGxlY3RFeGNlcHRpb25zLklOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VwdGlvbiB0cmFja2luZyBzaG91bGQgYmUgY29uZmlndXJlZCBmcm9tIHRoZSBhcHBsaWNhdGlvbkluc2lnaHRzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXV0b0NvbGxlY3RFeGNlcHRpb25zLklOU1RBTkNFID0gdGhpcztcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b0NvbGxlY3RFeGNlcHRpb25zLCBcIlVOQ0FVR0hUX0VYQ0VQVElPTl9IQU5ETEVSX05BTUVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1bmNhdWdodEV4Y2VwdGlvblwiOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvQ29sbGVjdEV4Y2VwdGlvbnMsIFwiVU5IQU5ETEVEX1JFSkVDVElPTl9IQU5ETEVSX05BTUVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBdXRvQ29sbGVjdEV4Y2VwdGlvbnMucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RFeGNlcHRpb25zLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoaXNFbmFibGVkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXhjZXB0aW9uTGlzdGVuZXJIYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBmdW5jdGlvbiAocmVUaHJvdywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xpZW50LnRyYWNrRXhjZXB0aW9uKHsgZXhjZXB0aW9uOiBlcnJvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xpZW50LmZsdXNoKHsgaXNBcHBDcmFzaGluZzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVUaHJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgVEhJU19JU19BUFBMSUNBVElPTl9JTlNJR0hUU19SRVRIUk9XSU5HX1lPVVJfRVhDRVBUSU9OID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFRISVNfSVNfQVBQTElDQVRJT05fSU5TSUdIVFNfUkVUSFJPV0lOR19ZT1VSX0VYQ0VQVElPTjsgLy8gRXJyb3Igb3JpZ2luYXRlZCBzb21ld2hlcmUgZWxzZSBpbiB5b3VyIGFwcFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leGNlcHRpb25MaXN0ZW5lckhhbmRsZSA9IGhhbmRsZS5iaW5kKHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uTGlzdGVuZXJIYW5kbGUgPSBoYW5kbGUuYmluZCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm9uKEF1dG9Db2xsZWN0RXhjZXB0aW9ucy5VTkNBVUdIVF9FWENFUFRJT05fSEFORExFUl9OQU1FLCB0aGlzLl9leGNlcHRpb25MaXN0ZW5lckhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm9uKEF1dG9Db2xsZWN0RXhjZXB0aW9ucy5VTkhBTkRMRURfUkVKRUNUSU9OX0hBTkRMRVJfTkFNRSwgdGhpcy5fcmVqZWN0aW9uTGlzdGVuZXJIYW5kbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXhjZXB0aW9uTGlzdGVuZXJIYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoQXV0b0NvbGxlY3RFeGNlcHRpb25zLlVOQ0FVR0hUX0VYQ0VQVElPTl9IQU5ETEVSX05BTUUsIHRoaXMuX2V4Y2VwdGlvbkxpc3RlbmVySGFuZGxlKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoQXV0b0NvbGxlY3RFeGNlcHRpb25zLlVOSEFORExFRF9SRUpFQ1RJT05fSEFORExFUl9OQU1FLCB0aGlzLl9yZWplY3Rpb25MaXN0ZW5lckhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leGNlcHRpb25MaXN0ZW5lckhhbmRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkxpc3RlbmVySGFuZGxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V4Y2VwdGlvbkxpc3RlbmVySGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlamVjdGlvbkxpc3RlbmVySGFuZGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0RXhjZXB0aW9ucy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBBdXRvQ29sbGVjdEV4Y2VwdGlvbnMuSU5TVEFOQ0UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlKGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RFeGNlcHRpb25zLklOU1RBTkNFID0gbnVsbDtcclxuICAgIHJldHVybiBBdXRvQ29sbGVjdEV4Y2VwdGlvbnM7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0NvbGxlY3RFeGNlcHRpb25zO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeGNlcHRpb25zLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/Exceptions.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar Logging = __webpack_require__(/*! ../Library/Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar Util = __webpack_require__(/*! ../Library/Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ \"./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\");\r\nvar HttpDependencyParser = __webpack_require__(/*! ./HttpDependencyParser */ \"./node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js\");\r\nvar CorrelationContextManager_1 = __webpack_require__(/*! ./CorrelationContextManager */ \"./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\");\r\nvar DiagChannel = __webpack_require__(/*! ./diagnostic-channel/initialization */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js\");\r\nvar AutoCollectHttpDependencies = (function () {\r\n    function AutoCollectHttpDependencies(client) {\r\n        if (!!AutoCollectHttpDependencies.INSTANCE) {\r\n            throw new Error(\"Client request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpDependencies.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._initialize();\r\n        }\r\n        if (DiagChannel.IsInitialized) {\r\n            __webpack_require__(/*! ./diagnostic-channel/mongodb.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js\").enable(isEnabled, this._client);\r\n            __webpack_require__(/*! ./diagnostic-channel/mysql.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js\").enable(isEnabled, this._client);\r\n            __webpack_require__(/*! ./diagnostic-channel/redis.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js\").enable(isEnabled, this._client);\r\n            __webpack_require__(/*! ./diagnostic-channel/postgres.sub */ \"./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpDependencies.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalGet = http.get;\r\n        var originalRequest = http.request;\r\n        var originalHttpsRequest = https.request;\r\n        var clientRequestPatch = function (request, options) {\r\n            var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] &&\r\n                !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag];\r\n            request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = true;\r\n            if (request && options && shouldCollect) {\r\n                AutoCollectHttpDependencies.trackRequest(_this._client, { options: options, request: request });\r\n            }\r\n        };\r\n        // On node >= v0.11.12 and < 9.0 (excluding 8.9.0) https.request just calls http.request (with additional options).\r\n        // On node < 0.11.12, 8.9.0, and 9.0 > https.request is handled separately\r\n        // Patch both and leave a flag to not double-count on versions that just call through\r\n        // We add the flag to both http and https to protect against strange double collection in other scenarios\r\n        http.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        https.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        // Node 8 calls http.request from http.get using a local reference!\r\n        // We have to patch .get manually in this case and can't just assume request is enough\r\n        // We have to replace the entire method in this case. We can't call the original.\r\n        // This is because calling the original will give us no chance to set headers as it internally does .end().\r\n        http.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = http.request).call.apply(_a, [http, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n        https.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = https.request).call.apply(_a, [https, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks an outgoing request. Because it may set headers this method must be called before\r\n     * writing content to or ending the request.\r\n     */\r\n    AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {\r\n        if (!telemetry.options || !telemetry.request || !client) {\r\n            Logging.info(\"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \", !telemetry.options, !telemetry.request, !client);\r\n            return;\r\n        }\r\n        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);\r\n        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var uniqueRequestId = currentContext && currentContext.operation && (currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + '.');\r\n        // Add the source correlationId to the request headers, if a value was not already provided.\r\n        // The getHeader/setHeader methods aren't available on very old Node versions, and\r\n        // are not included in the v0.10 type declarations currently used. So check if the\r\n        // methods exist before invoking them.\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {\r\n            if (client.config && client.config.correlationId) {\r\n                var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);\r\n                if (correlationHeader) {\r\n                    var components = correlationHeader.split(\",\");\r\n                    var key_1 = RequestResponseHeaders.requestContextSourceKey + \"=\";\r\n                    if (!components.some(function (value) { return value.substring(0, key_1.length) === key_1; })) {\r\n                        telemetry.request.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + \",\" + RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n                    }\r\n                }\r\n                else {\r\n                    telemetry.request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n                }\r\n            }\r\n            if (currentContext && currentContext.operation) {\r\n                telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);\r\n                // Also set legacy headers\r\n                telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);\r\n                telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);\r\n                var correlationContextHeader = currentContext.customProperties.serializeToHeader();\r\n                if (correlationContextHeader) {\r\n                    telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);\r\n                }\r\n            }\r\n        }\r\n        // Collect dependency telemetry about the request when it finishes.\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on('response', function (response) {\r\n                requestParser.onResponse(response);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"http.ClientResponse\"] = response;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n            telemetry.request.on('error', function (e) {\r\n                requestParser.onError(e);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"Error\"] = e;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.dispose = function () {\r\n        AutoCollectHttpDependencies.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectHttpDependencies.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';\r\n    AutoCollectHttpDependencies.requestNumber = 1;\r\n    AutoCollectHttpDependencies.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpDependencies;\r\n}());\r\nmodule.exports = AutoCollectHttpDependencies;\r\n//# sourceMappingURL=HttpDependencies.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vSHR0cERlcGVuZGVuY2llcy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vSHR0cERlcGVuZGVuY2llcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcclxudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xyXG52YXIgTG9nZ2luZyA9IHJlcXVpcmUoXCIuLi9MaWJyYXJ5L0xvZ2dpbmdcIik7XHJcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uL0xpYnJhcnkvVXRpbFwiKTtcclxudmFyIFJlcXVlc3RSZXNwb25zZUhlYWRlcnMgPSByZXF1aXJlKFwiLi4vTGlicmFyeS9SZXF1ZXN0UmVzcG9uc2VIZWFkZXJzXCIpO1xyXG52YXIgSHR0cERlcGVuZGVuY3lQYXJzZXIgPSByZXF1aXJlKFwiLi9IdHRwRGVwZW5kZW5jeVBhcnNlclwiKTtcclxudmFyIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0NvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJcIik7XHJcbnZhciBEaWFnQ2hhbm5lbCA9IHJlcXVpcmUoXCIuL2RpYWdub3N0aWMtY2hhbm5lbC9pbml0aWFsaXphdGlvblwiKTtcclxudmFyIEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMoY2xpZW50KSB7XHJcbiAgICAgICAgaWYgKCEhQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLklOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCByZXF1ZXN0IHRyYWNraW5nIHNob3VsZCBiZSBjb25maWd1cmVkIGZyb20gdGhlIGFwcGxpY2F0aW9uSW5zaWdodHMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMuSU5TVEFOQ0UgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcclxuICAgIH1cclxuICAgIEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGlzRW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGlzRW5hYmxlZDtcclxuICAgICAgICBpZiAodGhpcy5faXNFbmFibGVkICYmICF0aGlzLl9pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERpYWdDaGFubmVsLklzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmVxdWlyZShcIi4vZGlhZ25vc3RpYy1jaGFubmVsL21vbmdvZGIuc3ViXCIpLmVuYWJsZShpc0VuYWJsZWQsIHRoaXMuX2NsaWVudCk7XHJcbiAgICAgICAgICAgIHJlcXVpcmUoXCIuL2RpYWdub3N0aWMtY2hhbm5lbC9teXNxbC5zdWJcIikuZW5hYmxlKGlzRW5hYmxlZCwgdGhpcy5fY2xpZW50KTtcclxuICAgICAgICAgICAgcmVxdWlyZShcIi4vZGlhZ25vc3RpYy1jaGFubmVsL3JlZGlzLnN1YlwiKS5lbmFibGUoaXNFbmFibGVkLCB0aGlzLl9jbGllbnQpO1xyXG4gICAgICAgICAgICByZXF1aXJlKFwiLi9kaWFnbm9zdGljLWNoYW5uZWwvcG9zdGdyZXMuc3ViXCIpLmVuYWJsZShpc0VuYWJsZWQsIHRoaXMuX2NsaWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy5wcm90b3R5cGUuaXNJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsR2V0ID0gaHR0cC5nZXQ7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsUmVxdWVzdCA9IGh0dHAucmVxdWVzdDtcclxuICAgICAgICB2YXIgb3JpZ2luYWxIdHRwc1JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0O1xyXG4gICAgICAgIHZhciBjbGllbnRSZXF1ZXN0UGF0Y2ggPSBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgc2hvdWxkQ29sbGVjdCA9ICFvcHRpb25zW0F1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy5kaXNhYmxlQ29sbGVjdGlvblJlcXVlc3RPcHRpb25dICYmXHJcbiAgICAgICAgICAgICAgICAhcmVxdWVzdFtBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMuYWxyZWFkeUF1dG9Db2xsZWN0ZWRGbGFnXTtcclxuICAgICAgICAgICAgcmVxdWVzdFtBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMuYWxyZWFkeUF1dG9Db2xsZWN0ZWRGbGFnXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ICYmIG9wdGlvbnMgJiYgc2hvdWxkQ29sbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLnRyYWNrUmVxdWVzdChfdGhpcy5fY2xpZW50LCB7IG9wdGlvbnM6IG9wdGlvbnMsIHJlcXVlc3Q6IHJlcXVlc3QgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIE9uIG5vZGUgPj0gdjAuMTEuMTIgYW5kIDwgOS4wIChleGNsdWRpbmcgOC45LjApIGh0dHBzLnJlcXVlc3QganVzdCBjYWxscyBodHRwLnJlcXVlc3QgKHdpdGggYWRkaXRpb25hbCBvcHRpb25zKS5cclxuICAgICAgICAvLyBPbiBub2RlIDwgMC4xMS4xMiwgOC45LjAsIGFuZCA5LjAgPiBodHRwcy5yZXF1ZXN0IGlzIGhhbmRsZWQgc2VwYXJhdGVseVxyXG4gICAgICAgIC8vIFBhdGNoIGJvdGggYW5kIGxlYXZlIGEgZmxhZyB0byBub3QgZG91YmxlLWNvdW50IG9uIHZlcnNpb25zIHRoYXQganVzdCBjYWxsIHRocm91Z2hcclxuICAgICAgICAvLyBXZSBhZGQgdGhlIGZsYWcgdG8gYm90aCBodHRwIGFuZCBodHRwcyB0byBwcm90ZWN0IGFnYWluc3Qgc3RyYW5nZSBkb3VibGUgY29sbGVjdGlvbiBpbiBvdGhlciBzY2VuYXJpb3NcclxuICAgICAgICBodHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdEFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RBcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gb3JpZ2luYWxSZXF1ZXN0LmNhbGwuYXBwbHkob3JpZ2luYWxSZXF1ZXN0LCBbaHR0cCwgb3B0aW9uc10uY29uY2F0KHJlcXVlc3RBcmdzKSk7XHJcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RQYXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBodHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG9yaWdpbmFsSHR0cHNSZXF1ZXN0LmNhbGwuYXBwbHkob3JpZ2luYWxIdHRwc1JlcXVlc3QsIFtodHRwcywgb3B0aW9uc10uY29uY2F0KHJlcXVlc3RBcmdzKSk7XHJcbiAgICAgICAgICAgIGNsaWVudFJlcXVlc3RQYXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBOb2RlIDggY2FsbHMgaHR0cC5yZXF1ZXN0IGZyb20gaHR0cC5nZXQgdXNpbmcgYSBsb2NhbCByZWZlcmVuY2UhXHJcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBwYXRjaCAuZ2V0IG1hbnVhbGx5IGluIHRoaXMgY2FzZSBhbmQgY2FuJ3QganVzdCBhc3N1bWUgcmVxdWVzdCBpcyBlbm91Z2hcclxuICAgICAgICAvLyBXZSBoYXZlIHRvIHJlcGxhY2UgdGhlIGVudGlyZSBtZXRob2QgaW4gdGhpcyBjYXNlLiBXZSBjYW4ndCBjYWxsIHRoZSBvcmlnaW5hbC5cclxuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgY2FsbGluZyB0aGUgb3JpZ2luYWwgd2lsbCBnaXZlIHVzIG5vIGNoYW5jZSB0byBzZXQgaGVhZGVycyBhcyBpdCBpbnRlcm5hbGx5IGRvZXMgLmVuZCgpLlxyXG4gICAgICAgIGh0dHAuZ2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IChfYSA9IGh0dHAucmVxdWVzdCkuY2FsbC5hcHBseShfYSwgW2h0dHAsIG9wdGlvbnNdLmNvbmNhdChyZXF1ZXN0QXJncykpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaHR0cHMuZ2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RBcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IChfYSA9IGh0dHBzLnJlcXVlc3QpLmNhbGwuYXBwbHkoX2EsIFtodHRwcywgb3B0aW9uc10uY29uY2F0KHJlcXVlc3RBcmdzKSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyBhbiBvdXRnb2luZyByZXF1ZXN0LiBCZWNhdXNlIGl0IG1heSBzZXQgaGVhZGVycyB0aGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcclxuICAgICAqIHdyaXRpbmcgY29udGVudCB0byBvciBlbmRpbmcgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy50cmFja1JlcXVlc3QgPSBmdW5jdGlvbiAoY2xpZW50LCB0ZWxlbWV0cnkpIHtcclxuICAgICAgICBpZiAoIXRlbGVtZXRyeS5vcHRpb25zIHx8ICF0ZWxlbWV0cnkucmVxdWVzdCB8fCAhY2xpZW50KSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhcIkF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy50cmFja1JlcXVlc3Qgd2FzIGNhbGxlZCB3aXRoIGludmFsaWQgcGFyYW1ldGVyczogXCIsICF0ZWxlbWV0cnkub3B0aW9ucywgIXRlbGVtZXRyeS5yZXF1ZXN0LCAhY2xpZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVxdWVzdFBhcnNlciA9IG5ldyBIdHRwRGVwZW5kZW5jeVBhcnNlcih0ZWxlbWV0cnkub3B0aW9ucywgdGVsZW1ldHJ5LnJlcXVlc3QpO1xyXG4gICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMS5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk7XHJcbiAgICAgICAgdmFyIHVuaXF1ZVJlcXVlc3RJZCA9IGN1cnJlbnRDb250ZXh0ICYmIGN1cnJlbnRDb250ZXh0Lm9wZXJhdGlvbiAmJiAoY3VycmVudENvbnRleHQub3BlcmF0aW9uLnBhcmVudElkICsgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLnJlcXVlc3ROdW1iZXIrKyArICcuJyk7XHJcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29ycmVsYXRpb25JZCB0byB0aGUgcmVxdWVzdCBoZWFkZXJzLCBpZiBhIHZhbHVlIHdhcyBub3QgYWxyZWFkeSBwcm92aWRlZC5cclxuICAgICAgICAvLyBUaGUgZ2V0SGVhZGVyL3NldEhlYWRlciBtZXRob2RzIGFyZW4ndCBhdmFpbGFibGUgb24gdmVyeSBvbGQgTm9kZSB2ZXJzaW9ucywgYW5kXHJcbiAgICAgICAgLy8gYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgdjAuMTAgdHlwZSBkZWNsYXJhdGlvbnMgY3VycmVudGx5IHVzZWQuIFNvIGNoZWNrIGlmIHRoZVxyXG4gICAgICAgIC8vIG1ldGhvZHMgZXhpc3QgYmVmb3JlIGludm9raW5nIHRoZW0uXHJcbiAgICAgICAgaWYgKFV0aWwuY2FuSW5jbHVkZUNvcnJlbGF0aW9uSGVhZGVyKGNsaWVudCwgcmVxdWVzdFBhcnNlci5nZXRVcmwoKSkgJiYgdGVsZW1ldHJ5LnJlcXVlc3QuZ2V0SGVhZGVyICYmIHRlbGVtZXRyeS5yZXF1ZXN0LnNldEhlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3JyZWxhdGlvbkhlYWRlciA9IHRlbGVtZXRyeS5yZXF1ZXN0LmdldEhlYWRlcihSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RDb250ZXh0SGVhZGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb3JyZWxhdGlvbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gY29ycmVsYXRpb25IZWFkZXIuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlfMSA9IFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRTb3VyY2VLZXkgKyBcIj1cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCBrZXlfMS5sZW5ndGgpID09PSBrZXlfMTsgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LnJlcXVlc3Quc2V0SGVhZGVyKFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRIZWFkZXIsIGNvcnJlbGF0aW9uSGVhZGVyICsgXCIsXCIgKyBSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RDb250ZXh0U291cmNlS2V5ICsgXCI9XCIgKyBjbGllbnQuY29uZmlnLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5yZXF1ZXN0LnNldEhlYWRlcihSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RDb250ZXh0SGVhZGVyLCBSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RDb250ZXh0U291cmNlS2V5ICsgXCI9XCIgKyBjbGllbnQuY29uZmlnLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGV4dCAmJiBjdXJyZW50Q29udGV4dC5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5yZXF1ZXN0LnNldEhlYWRlcihSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RJZEhlYWRlciwgdW5pcXVlUmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgIC8vIEFsc28gc2V0IGxlZ2FjeSBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnkucmVxdWVzdC5zZXRIZWFkZXIoUmVxdWVzdFJlc3BvbnNlSGVhZGVycy5wYXJlbnRJZEhlYWRlciwgY3VycmVudENvbnRleHQub3BlcmF0aW9uLmlkKTtcclxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5yZXF1ZXN0LnNldEhlYWRlcihSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJvb3RJZEhlYWRlciwgdW5pcXVlUmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3JyZWxhdGlvbkNvbnRleHRIZWFkZXIgPSBjdXJyZW50Q29udGV4dC5jdXN0b21Qcm9wZXJ0aWVzLnNlcmlhbGl6ZVRvSGVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ycmVsYXRpb25Db250ZXh0SGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LnJlcXVlc3Quc2V0SGVhZGVyKFJlcXVlc3RSZXNwb25zZUhlYWRlcnMuY29ycmVsYXRpb25Db250ZXh0SGVhZGVyLCBjb3JyZWxhdGlvbkNvbnRleHRIZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbGxlY3QgZGVwZW5kZW5jeSB0ZWxlbWV0cnkgYWJvdXQgdGhlIHJlcXVlc3Qgd2hlbiBpdCBmaW5pc2hlcy5cclxuICAgICAgICBpZiAodGVsZW1ldHJ5LnJlcXVlc3Qub24pIHtcclxuICAgICAgICAgICAgdGVsZW1ldHJ5LnJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyc2VyLm9uUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3lUZWxlbWV0cnkgPSByZXF1ZXN0UGFyc2VyLmdldERlcGVuZGVuY3lUZWxlbWV0cnkodGVsZW1ldHJ5LCB1bmlxdWVSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0cyA9IGRlcGVuZGVuY3lUZWxlbWV0cnkuY29udGV4dE9iamVjdHMgfHwge307XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VGVsZW1ldHJ5LmNvbnRleHRPYmplY3RzW1wiaHR0cC5SZXF1ZXN0T3B0aW9uc1wiXSA9IHRlbGVtZXRyeS5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0c1tcImh0dHAuQ2xpZW50UmVxdWVzdFwiXSA9IHRlbGVtZXRyeS5yZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0c1tcImh0dHAuQ2xpZW50UmVzcG9uc2VcIl0gPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIGNsaWVudC50cmFja0RlcGVuZGVuY3koZGVwZW5kZW5jeVRlbGVtZXRyeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkucmVxdWVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcnNlci5vbkVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3lUZWxlbWV0cnkgPSByZXF1ZXN0UGFyc2VyLmdldERlcGVuZGVuY3lUZWxlbWV0cnkodGVsZW1ldHJ5LCB1bmlxdWVSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0cyA9IGRlcGVuZGVuY3lUZWxlbWV0cnkuY29udGV4dE9iamVjdHMgfHwge307XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VGVsZW1ldHJ5LmNvbnRleHRPYmplY3RzW1wiaHR0cC5SZXF1ZXN0T3B0aW9uc1wiXSA9IHRlbGVtZXRyeS5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0c1tcImh0dHAuQ2xpZW50UmVxdWVzdFwiXSA9IHRlbGVtZXRyeS5yZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeS5jb250ZXh0T2JqZWN0c1tcIkVycm9yXCJdID0gZTtcclxuICAgICAgICAgICAgICAgIGNsaWVudC50cmFja0RlcGVuZGVuY3koZGVwZW5kZW5jeVRlbGVtZXRyeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLklOU1RBTkNFID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVuYWJsZShmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcy5kaXNhYmxlQ29sbGVjdGlvblJlcXVlc3RPcHRpb24gPSAnZGlzYWJsZUFwcEluc2lnaHRzQXV0b0NvbGxlY3Rpb24nO1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLnJlcXVlc3ROdW1iZXIgPSAxO1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLmFscmVhZHlBdXRvQ29sbGVjdGVkRmxhZyA9ICdfYXBwSW5zaWdodHNBdXRvQ29sbGVjdGVkJztcclxuICAgIHJldHVybiBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXM7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdHRwRGVwZW5kZW5jaWVzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = __webpack_require__(/*! url */ \"url\");\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar Util = __webpack_require__(/*! ../Library/Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ \"./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\");\r\nvar RequestParser = __webpack_require__(/*! ./RequestParser */ \"./node_modules/applicationinsights/out/AutoCollection/RequestParser.js\");\r\nvar CorrelationIdManager = __webpack_require__(/*! ../Library/CorrelationIdManager */ \"./node_modules/applicationinsights/out/Library/CorrelationIdManager.js\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpDependencyParser = (function (_super) {\r\n    __extends(HttpDependencyParser, _super);\r\n    function HttpDependencyParser(requestOptions, request) {\r\n        var _this = _super.call(this) || this;\r\n        if (request && request.method && requestOptions) {\r\n            // The ClientRequest.method property isn't documented, but is always there.\r\n            _this.method = request.method;\r\n            _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request);\r\n            _this.startTime = +new Date();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Called when the ClientRequest emits an error event.\r\n     */\r\n    HttpDependencyParser.prototype.onError = function (error) {\r\n        this._setStatus(undefined, error);\r\n    };\r\n    /**\r\n     * Called when the ClientRequest emits a response event.\r\n     */\r\n    HttpDependencyParser.prototype.onResponse = function (response) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);\r\n    };\r\n    /**\r\n     * Gets a dependency data contract object for a completed ClientRequest.\r\n     */\r\n    HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {\r\n        var urlObject = url.parse(this.url);\r\n        urlObject.search = undefined;\r\n        urlObject.hash = undefined;\r\n        var dependencyName = this.method.toUpperCase() + \" \" + urlObject.pathname;\r\n        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        var remoteDependencyTarget = urlObject.hostname;\r\n        if (this.correlationId) {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;\r\n            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {\r\n                remoteDependencyTarget = urlObject.hostname + \" | \" + this.correlationId;\r\n            }\r\n        }\r\n        else {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        }\r\n        var dependencyTelemetry = {\r\n            id: dependencyId,\r\n            name: dependencyName,\r\n            data: this.url,\r\n            duration: this.duration,\r\n            success: this._isSuccess(),\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            properties: this.properties || {},\r\n            dependencyTypeName: remoteDependencyType,\r\n            target: remoteDependencyTarget\r\n        };\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!dependencyTelemetry[key]) {\r\n                    dependencyTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    dependencyTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return dependencyTelemetry;\r\n    };\r\n    /**\r\n     * Builds a URL from request options, using the same logic as http.request(). This is\r\n     * necessary because a ClientRequest object does not expose a url property.\r\n     */\r\n    HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {\r\n        if (typeof options === 'string') {\r\n            options = url.parse(options);\r\n        }\r\n        else {\r\n            // Avoid modifying the original options object.\r\n            var originalOptions_1 = options;\r\n            options = {};\r\n            if (originalOptions_1) {\r\n                Object.keys(originalOptions_1).forEach(function (key) {\r\n                    options[key] = originalOptions_1[key];\r\n                });\r\n            }\r\n        }\r\n        // Oddly, url.format ignores path and only uses pathname and search,\r\n        // so create them from the path, if path was specified\r\n        if (options.path) {\r\n            var parsedQuery = url.parse(options.path);\r\n            options.pathname = parsedQuery.pathname;\r\n            options.search = parsedQuery.search;\r\n        }\r\n        // Simiarly, url.format ignores hostname and port if host is specified,\r\n        // even if host doesn't have the port, but http.request does not work\r\n        // this way. It will use the port if one is not specified in host,\r\n        // effectively treating host as hostname, but will use the port specified\r\n        // in host if it exists.\r\n        if (options.host && options.port) {\r\n            // Force a protocol so it will parse the host as the host, not path.\r\n            // It is discarded and not used, so it doesn't matter if it doesn't match\r\n            var parsedHost = url.parse(\"http://\" + options.host);\r\n            if (!parsedHost.port && options.port) {\r\n                options.hostname = options.host;\r\n                delete options.host;\r\n            }\r\n        }\r\n        // Mix in default values used by http.request and others\r\n        options.protocol = options.protocol || (request.agent && request.agent.protocol) || undefined;\r\n        options.hostname = options.hostname || 'localhost';\r\n        return url.format(options);\r\n    };\r\n    return HttpDependencyParser;\r\n}(RequestParser));\r\nmodule.exports = HttpDependencyParser;\r\n//# sourceMappingURL=HttpDependencyParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vSHR0cERlcGVuZGVuY3lQYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0F1dG9Db2xsZWN0aW9uL0h0dHBEZXBlbmRlbmN5UGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbnZhciBDb250cmFjdHMgPSByZXF1aXJlKFwiLi4vRGVjbGFyYXRpb25zL0NvbnRyYWN0c1wiKTtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vTGlicmFyeS9VdGlsXCIpO1xyXG52YXIgUmVxdWVzdFJlc3BvbnNlSGVhZGVycyA9IHJlcXVpcmUoXCIuLi9MaWJyYXJ5L1JlcXVlc3RSZXNwb25zZUhlYWRlcnNcIik7XHJcbnZhciBSZXF1ZXN0UGFyc2VyID0gcmVxdWlyZShcIi4vUmVxdWVzdFBhcnNlclwiKTtcclxudmFyIENvcnJlbGF0aW9uSWRNYW5hZ2VyID0gcmVxdWlyZShcIi4uL0xpYnJhcnkvQ29ycmVsYXRpb25JZE1hbmFnZXJcIik7XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gcmVhZCBkYXRhIGZyb20gdGhlIHJlcXVzdC9yZXNwb25zZSBvYmplY3RzIGFuZCBjb252ZXJ0IHRoZW0gaW50byB0aGUgdGVsZW1ldHJ5IGNvbnRyYWN0XHJcbiAqL1xyXG52YXIgSHR0cERlcGVuZGVuY3lQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEh0dHBEZXBlbmRlbmN5UGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSHR0cERlcGVuZGVuY3lQYXJzZXIocmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QubWV0aG9kICYmIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBDbGllbnRSZXF1ZXN0Lm1ldGhvZCBwcm9wZXJ0eSBpc24ndCBkb2N1bWVudGVkLCBidXQgaXMgYWx3YXlzIHRoZXJlLlxyXG4gICAgICAgICAgICBfdGhpcy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcclxuICAgICAgICAgICAgX3RoaXMudXJsID0gSHR0cERlcGVuZGVuY3lQYXJzZXIuX2dldFVybEZyb21SZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBDbGllbnRSZXF1ZXN0IGVtaXRzIGFuIGVycm9yIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBIdHRwRGVwZW5kZW5jeVBhcnNlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX3NldFN0YXR1cyh1bmRlZmluZWQsIGVycm9yKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBDbGllbnRSZXF1ZXN0IGVtaXRzIGEgcmVzcG9uc2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIEh0dHBEZXBlbmRlbmN5UGFyc2VyLnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0U3RhdHVzKHJlc3BvbnNlLnN0YXR1c0NvZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gVXRpbC5nZXRDb3JyZWxhdGlvbkNvbnRleHRUYXJnZXQocmVzcG9uc2UsIFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRUYXJnZXRLZXkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGRlcGVuZGVuY3kgZGF0YSBjb250cmFjdCBvYmplY3QgZm9yIGEgY29tcGxldGVkIENsaWVudFJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIEh0dHBEZXBlbmRlbmN5UGFyc2VyLnByb3RvdHlwZS5nZXREZXBlbmRlbmN5VGVsZW1ldHJ5ID0gZnVuY3Rpb24gKGJhc2VUZWxlbWV0cnksIGRlcGVuZGVuY3lJZCkge1xyXG4gICAgICAgIHZhciB1cmxPYmplY3QgPSB1cmwucGFyc2UodGhpcy51cmwpO1xyXG4gICAgICAgIHVybE9iamVjdC5zZWFyY2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdXJsT2JqZWN0Lmhhc2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY3lOYW1lID0gdGhpcy5tZXRob2QudG9VcHBlckNhc2UoKSArIFwiIFwiICsgdXJsT2JqZWN0LnBhdGhuYW1lO1xyXG4gICAgICAgIHZhciByZW1vdGVEZXBlbmRlbmN5VHlwZSA9IENvbnRyYWN0cy5SZW1vdGVEZXBlbmRlbmN5RGF0YUNvbnN0YW50cy5UWVBFX0hUVFA7XHJcbiAgICAgICAgdmFyIHJlbW90ZURlcGVuZGVuY3lUYXJnZXQgPSB1cmxPYmplY3QuaG9zdG5hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgICAgICByZW1vdGVEZXBlbmRlbmN5VHlwZSA9IENvbnRyYWN0cy5SZW1vdGVEZXBlbmRlbmN5RGF0YUNvbnN0YW50cy5UWVBFX0FJO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3JyZWxhdGlvbklkICE9PSBDb3JyZWxhdGlvbklkTWFuYWdlci5jb3JyZWxhdGlvbklkUHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVEZXBlbmRlbmN5VGFyZ2V0ID0gdXJsT2JqZWN0Lmhvc3RuYW1lICsgXCIgfCBcIiArIHRoaXMuY29ycmVsYXRpb25JZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3RlRGVwZW5kZW5jeVR5cGUgPSBDb250cmFjdHMuUmVtb3RlRGVwZW5kZW5jeURhdGFDb25zdGFudHMuVFlQRV9IVFRQO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVwZW5kZW5jeVRlbGVtZXRyeSA9IHtcclxuICAgICAgICAgICAgaWQ6IGRlcGVuZGVuY3lJZCxcclxuICAgICAgICAgICAgbmFtZTogZGVwZW5kZW5jeU5hbWUsXHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMudXJsLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgc3VjY2VzczogdGhpcy5faXNTdWNjZXNzKCksXHJcbiAgICAgICAgICAgIHJlc3VsdENvZGU6IHRoaXMuc3RhdHVzQ29kZSA/IHRoaXMuc3RhdHVzQ29kZS50b1N0cmluZygpIDogbnVsbCxcclxuICAgICAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzIHx8IHt9LFxyXG4gICAgICAgICAgICBkZXBlbmRlbmN5VHlwZU5hbWU6IHJlbW90ZURlcGVuZGVuY3lUeXBlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHJlbW90ZURlcGVuZGVuY3lUYXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFdlIHNob3VsZCBrZWVwIGFueSBwYXJhbWV0ZXJzIHRoZSB1c2VyIHBhc3NlZCBpblxyXG4gICAgICAgIC8vIEV4Y2VwdCB0aGUgZmllbGRzIGRlZmluZWQgYWJvdmUgaW4gcmVxdWVzdFRlbGVtZXRyeSwgd2hpY2ggdGFrZSBwcmlvcml0eVxyXG4gICAgICAgIC8vIEV4Y2VwdCB0aGUgcHJvcGVydGllcyBmaWVsZCwgd2hlcmUgdGhleSdyZSBtZXJnZWQgaW5zdGVhZCwgd2l0aCBiYXNlVGVsZW1ldHJ5IHRha2luZyBwcmlvcml0eVxyXG4gICAgICAgIGlmIChiYXNlVGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIENvcHkgbWlzc2luZyBmaWVsZHNcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJhc2VUZWxlbWV0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGVwZW5kZW5jeVRlbGVtZXRyeVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeVRlbGVtZXRyeVtrZXldID0gYmFzZVRlbGVtZXRyeVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgaWYgKGJhc2VUZWxlbWV0cnkucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJhc2VUZWxlbWV0cnkucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUZWxlbWV0cnkucHJvcGVydGllc1trZXldID0gYmFzZVRlbGVtZXRyeS5wcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lUZWxlbWV0cnk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBVUkwgZnJvbSByZXF1ZXN0IG9wdGlvbnMsIHVzaW5nIHRoZSBzYW1lIGxvZ2ljIGFzIGh0dHAucmVxdWVzdCgpLiBUaGlzIGlzXHJcbiAgICAgKiBuZWNlc3NhcnkgYmVjYXVzZSBhIENsaWVudFJlcXVlc3Qgb2JqZWN0IGRvZXMgbm90IGV4cG9zZSBhIHVybCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgSHR0cERlcGVuZGVuY3lQYXJzZXIuX2dldFVybEZyb21SZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gdXJsLnBhcnNlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQXZvaWQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvcHRpb25zIG9iamVjdC5cclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsT3B0aW9uc18xID0gb3B0aW9ucztcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxPcHRpb25zXzEpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9yaWdpbmFsT3B0aW9uc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBvcmlnaW5hbE9wdGlvbnNfMVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT2RkbHksIHVybC5mb3JtYXQgaWdub3JlcyBwYXRoIGFuZCBvbmx5IHVzZXMgcGF0aG5hbWUgYW5kIHNlYXJjaCxcclxuICAgICAgICAvLyBzbyBjcmVhdGUgdGhlbSBmcm9tIHRoZSBwYXRoLCBpZiBwYXRoIHdhcyBzcGVjaWZpZWRcclxuICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRRdWVyeSA9IHVybC5wYXJzZShvcHRpb25zLnBhdGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhdGhuYW1lID0gcGFyc2VkUXVlcnkucGF0aG5hbWU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2VhcmNoID0gcGFyc2VkUXVlcnkuc2VhcmNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW1pYXJseSwgdXJsLmZvcm1hdCBpZ25vcmVzIGhvc3RuYW1lIGFuZCBwb3J0IGlmIGhvc3QgaXMgc3BlY2lmaWVkLFxyXG4gICAgICAgIC8vIGV2ZW4gaWYgaG9zdCBkb2Vzbid0IGhhdmUgdGhlIHBvcnQsIGJ1dCBodHRwLnJlcXVlc3QgZG9lcyBub3Qgd29ya1xyXG4gICAgICAgIC8vIHRoaXMgd2F5LiBJdCB3aWxsIHVzZSB0aGUgcG9ydCBpZiBvbmUgaXMgbm90IHNwZWNpZmllZCBpbiBob3N0LFxyXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHRyZWF0aW5nIGhvc3QgYXMgaG9zdG5hbWUsIGJ1dCB3aWxsIHVzZSB0aGUgcG9ydCBzcGVjaWZpZWRcclxuICAgICAgICAvLyBpbiBob3N0IGlmIGl0IGV4aXN0cy5cclxuICAgICAgICBpZiAob3B0aW9ucy5ob3N0ICYmIG9wdGlvbnMucG9ydCkge1xyXG4gICAgICAgICAgICAvLyBGb3JjZSBhIHByb3RvY29sIHNvIGl0IHdpbGwgcGFyc2UgdGhlIGhvc3QgYXMgdGhlIGhvc3QsIG5vdCBwYXRoLlxyXG4gICAgICAgICAgICAvLyBJdCBpcyBkaXNjYXJkZWQgYW5kIG5vdCB1c2VkLCBzbyBpdCBkb2Vzbid0IG1hdHRlciBpZiBpdCBkb2Vzbid0IG1hdGNoXHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRIb3N0ID0gdXJsLnBhcnNlKFwiaHR0cDovL1wiICsgb3B0aW9ucy5ob3N0KTtcclxuICAgICAgICAgICAgaWYgKCFwYXJzZWRIb3N0LnBvcnQgJiYgb3B0aW9ucy5wb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaG9zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNaXggaW4gZGVmYXVsdCB2YWx1ZXMgdXNlZCBieSBodHRwLnJlcXVlc3QgYW5kIG90aGVyc1xyXG4gICAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8IChyZXF1ZXN0LmFnZW50ICYmIHJlcXVlc3QuYWdlbnQucHJvdG9jb2wpIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0bmFtZSB8fCAnbG9jYWxob3N0JztcclxuICAgICAgICByZXR1cm4gdXJsLmZvcm1hdChvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSHR0cERlcGVuZGVuY3lQYXJzZXI7XHJcbn0oUmVxdWVzdFBhcnNlcikpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBEZXBlbmRlbmN5UGFyc2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdHRwRGVwZW5kZW5jeVBhcnNlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = __webpack_require__(/*! url */ \"url\");\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar Util = __webpack_require__(/*! ../Library/Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ \"./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\");\r\nvar RequestParser = __webpack_require__(/*! ./RequestParser */ \"./node_modules/applicationinsights/out/AutoCollection/RequestParser.js\");\r\nvar CorrelationIdManager = __webpack_require__(/*! ../Library/CorrelationIdManager */ \"./node_modules/applicationinsights/out/Library/CorrelationIdManager.js\");\r\n/**\r\n * Helper class to read data from the requst/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpRequestParser = (function (_super) {\r\n    __extends(HttpRequestParser, _super);\r\n    function HttpRequestParser(request, requestId) {\r\n        var _this = _super.call(this) || this;\r\n        if (request) {\r\n            _this.method = request.method;\r\n            _this.url = _this._getAbsoluteUrl(request);\r\n            _this.startTime = +new Date();\r\n            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;\r\n            _this.parseHeaders(request, requestId);\r\n            if (request.connection) {\r\n                _this.connectionRemoteAddress = request.connection.remoteAddress;\r\n                _this.legacySocketRemoteAddress = request.connection[\"socket\"] && request.connection[\"socket\"].remoteAddress;\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {\r\n        this._setStatus(undefined, error);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {\r\n        var requestTelemetry = {\r\n            id: this.requestId,\r\n            name: this.method + \" \" + url.parse(this.url).pathname,\r\n            url: this.url,\r\n            /*\r\n            See https://github.com/Microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250\r\n            for reference\r\n            */\r\n            source: this.sourceCorrelationId,\r\n            duration: this.duration,\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            success: this._isSuccess(),\r\n            properties: this.properties\r\n        };\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!requestTelemetry[key]) {\r\n                    requestTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    requestTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return requestTelemetry;\r\n    };\r\n    HttpRequestParser.prototype.getRequestTags = function (tags) {\r\n        // create a copy of the context for requests since client info will be used here\r\n        var newTags = {};\r\n        for (var key in tags) {\r\n            newTags[key] = tags[key];\r\n        }\r\n        // don't override tags if they are already set\r\n        newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp();\r\n        newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId(\"ai_session\");\r\n        newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId(\"ai_user\");\r\n        newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId(\"ai_authUser\");\r\n        newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags);\r\n        newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags);\r\n        newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags);\r\n        return newTags;\r\n    };\r\n    HttpRequestParser.prototype.getOperationId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationId] || this.operationId;\r\n    };\r\n    HttpRequestParser.prototype.getOperationParentId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);\r\n    };\r\n    HttpRequestParser.prototype.getOperationName = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationName] || this.method + \" \" + url.parse(this.url).pathname;\r\n    };\r\n    HttpRequestParser.prototype.getRequestId = function () {\r\n        return this.requestId;\r\n    };\r\n    HttpRequestParser.prototype.getCorrelationContextHeader = function () {\r\n        return this.correlationContextHeader;\r\n    };\r\n    HttpRequestParser.prototype._getAbsoluteUrl = function (request) {\r\n        if (!request.headers) {\r\n            return request.url;\r\n        }\r\n        var encrypted = request.connection ? request.connection.encrypted : null;\r\n        var requestUrl = url.parse(request.url);\r\n        var pathName = requestUrl.pathname;\r\n        var search = requestUrl.search;\r\n        var absoluteUrl = url.format({\r\n            protocol: encrypted ? \"https\" : \"http\",\r\n            host: request.headers.host,\r\n            pathname: pathName,\r\n            search: search\r\n        });\r\n        return absoluteUrl;\r\n    };\r\n    HttpRequestParser.prototype._getIp = function () {\r\n        // regex to match ipv4 without port\r\n        // Note: including the port would cause the payload to be rejected by the data collector\r\n        var ipMatch = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/;\r\n        var check = function (str) {\r\n            var results = ipMatch.exec(str);\r\n            if (results) {\r\n                return results[0];\r\n            }\r\n        };\r\n        var ip = check(this.rawHeaders[\"x-forwarded-for\"])\r\n            || check(this.rawHeaders[\"x-client-ip\"])\r\n            || check(this.rawHeaders[\"x-real-ip\"])\r\n            || check(this.connectionRemoteAddress)\r\n            || check(this.socketRemoteAddress)\r\n            || check(this.legacySocketRemoteAddress);\r\n        // node v12 returns this if the address is \"localhost\"\r\n        if (!ip\r\n            && this.connectionRemoteAddress\r\n            && this.connectionRemoteAddress.substr\r\n            && this.connectionRemoteAddress.substr(0, 2) === \"::\") {\r\n            ip = \"127.0.0.1\";\r\n        }\r\n        return ip;\r\n    };\r\n    HttpRequestParser.prototype._getId = function (name) {\r\n        var cookie = (this.rawHeaders && this.rawHeaders[\"cookie\"] &&\r\n            typeof this.rawHeaders[\"cookie\"] === 'string' && this.rawHeaders[\"cookie\"]) || \"\";\r\n        var value = HttpRequestParser.parseId(Util.getCookie(name, cookie));\r\n        return value;\r\n    };\r\n    HttpRequestParser.prototype.parseHeaders = function (request, requestId) {\r\n        this.rawHeaders = request.headers || request.rawHeaders;\r\n        this.userAgent = request.headers && request.headers[\"user-agent\"];\r\n        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);\r\n        if (request.headers) {\r\n            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];\r\n            if (request.headers[RequestResponseHeaders.requestIdHeader]) {\r\n                this.parentId = request.headers[RequestResponseHeaders.requestIdHeader];\r\n                this.requestId = CorrelationIdManager.generateRequestId(this.parentId);\r\n                this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];\r\n            }\r\n            else {\r\n                // Legacy fallback\r\n                var rootId = request.headers[RequestResponseHeaders.rootIdHeader];\r\n                this.parentId = request.headers[RequestResponseHeaders.parentIdHeader];\r\n                this.requestId = CorrelationIdManager.generateRequestId(rootId || this.parentId);\r\n                this.correlationContextHeader = null;\r\n            }\r\n            if (requestId) {\r\n                // For the scenarios that don't guarantee an AI-created context,\r\n                // override the requestId with the provided one.\r\n                this.requestId = requestId;\r\n            }\r\n            this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n        }\r\n    };\r\n    HttpRequestParser.parseId = function (cookieValue) {\r\n        return cookieValue.substr(0, cookieValue.indexOf('|'));\r\n    };\r\n    HttpRequestParser.keys = new Contracts.ContextTagKeys();\r\n    return HttpRequestParser;\r\n}(RequestParser));\r\nmodule.exports = HttpRequestParser;\r\n//# sourceMappingURL=HttpRequestParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vSHR0cFJlcXVlc3RQYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0F1dG9Db2xsZWN0aW9uL0h0dHBSZXF1ZXN0UGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbnZhciBDb250cmFjdHMgPSByZXF1aXJlKFwiLi4vRGVjbGFyYXRpb25zL0NvbnRyYWN0c1wiKTtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vTGlicmFyeS9VdGlsXCIpO1xyXG52YXIgUmVxdWVzdFJlc3BvbnNlSGVhZGVycyA9IHJlcXVpcmUoXCIuLi9MaWJyYXJ5L1JlcXVlc3RSZXNwb25zZUhlYWRlcnNcIik7XHJcbnZhciBSZXF1ZXN0UGFyc2VyID0gcmVxdWlyZShcIi4vUmVxdWVzdFBhcnNlclwiKTtcclxudmFyIENvcnJlbGF0aW9uSWRNYW5hZ2VyID0gcmVxdWlyZShcIi4uL0xpYnJhcnkvQ29ycmVsYXRpb25JZE1hbmFnZXJcIik7XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gcmVhZCBkYXRhIGZyb20gdGhlIHJlcXVzdC9yZXNwb25zZSBvYmplY3RzIGFuZCBjb252ZXJ0IHRoZW0gaW50byB0aGUgdGVsZW1ldHJ5IGNvbnRyYWN0XHJcbiAqL1xyXG52YXIgSHR0cFJlcXVlc3RQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEh0dHBSZXF1ZXN0UGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSHR0cFJlcXVlc3RQYXJzZXIocmVxdWVzdCwgcmVxdWVzdElkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcclxuICAgICAgICAgICAgX3RoaXMudXJsID0gX3RoaXMuX2dldEFic29sdXRlVXJsKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgX3RoaXMuc29ja2V0UmVtb3RlQWRkcmVzcyA9IHJlcXVlc3Quc29ja2V0ICYmIHJlcXVlc3Quc29ja2V0LnJlbW90ZUFkZHJlc3M7XHJcbiAgICAgICAgICAgIF90aGlzLnBhcnNlSGVhZGVycyhyZXF1ZXN0LCByZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5jb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUmVtb3RlQWRkcmVzcyA9IHJlcXVlc3QuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubGVnYWN5U29ja2V0UmVtb3RlQWRkcmVzcyA9IHJlcXVlc3QuY29ubmVjdGlvbltcInNvY2tldFwiXSAmJiByZXF1ZXN0LmNvbm5lY3Rpb25bXCJzb2NrZXRcIl0ucmVtb3RlQWRkcmVzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBIdHRwUmVxdWVzdFBhcnNlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZWxsYXBzZWRNaWxsaXNlY29uZHMpIHtcclxuICAgICAgICB0aGlzLl9zZXRTdGF0dXModW5kZWZpbmVkLCBlcnJvcik7XHJcbiAgICAgICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgb25seSBmb3Igb3ZlcnJpZGVzLiBzZXRTdGF0dXMgaGFuZGxlcyB0aGlzIGludGVybmFsbHkgZm9yIHRoZSBhdXRvY29sbGVjdGVkIGNhc2VcclxuICAgICAgICBpZiAoZWxsYXBzZWRNaWxsaXNlY29uZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGVsbGFwc2VkTWlsbGlzZWNvbmRzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIdHRwUmVxdWVzdFBhcnNlci5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgZWxsYXBzZWRNaWxsaXNlY29uZHMpIHtcclxuICAgICAgICB0aGlzLl9zZXRTdGF0dXMocmVzcG9uc2Uuc3RhdHVzQ29kZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IGZvciBvdmVycmlkZXMuIHNldFN0YXR1cyBoYW5kbGVzIHRoaXMgaW50ZXJuYWxseSBmb3IgdGhlIGF1dG9jb2xsZWN0ZWQgY2FzZVxyXG4gICAgICAgIGlmIChlbGxhcHNlZE1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZWxsYXBzZWRNaWxsaXNlY29uZHM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5nZXRSZXF1ZXN0VGVsZW1ldHJ5ID0gZnVuY3Rpb24gKGJhc2VUZWxlbWV0cnkpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdFRlbGVtZXRyeSA9IHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMucmVxdWVzdElkLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm1ldGhvZCArIFwiIFwiICsgdXJsLnBhcnNlKHRoaXMudXJsKS5wYXRobmFtZSxcclxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvQXBwbGljYXRpb25JbnNpZ2h0cy1kb3RuZXQtc2VydmVyL2Jsb2IvMjVkNjk1ZTZhOTA2ZmJlOTc3ZjY3YmUzOTY2ZDI1ZGJmMWM1MGE3OS9TcmMvV2ViL1dlYi5TaGFyZWQuTmV0L1JlcXVlc3RUcmFja2luZ1RlbGVtZXRyeU1vZHVsZS5jcyNMMjUwXHJcbiAgICAgICAgICAgIGZvciByZWZlcmVuY2VcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZUNvcnJlbGF0aW9uSWQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICByZXN1bHRDb2RlOiB0aGlzLnN0YXR1c0NvZGUgPyB0aGlzLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IG51bGwsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRoaXMuX2lzU3VjY2VzcygpLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFdlIHNob3VsZCBrZWVwIGFueSBwYXJhbWV0ZXJzIHRoZSB1c2VyIHBhc3NlZCBpblxyXG4gICAgICAgIC8vIEV4Y2VwdCB0aGUgZmllbGRzIGRlZmluZWQgYWJvdmUgaW4gcmVxdWVzdFRlbGVtZXRyeSwgd2hpY2ggdGFrZSBwcmlvcml0eVxyXG4gICAgICAgIC8vIEV4Y2VwdCB0aGUgcHJvcGVydGllcyBmaWVsZCwgd2hlcmUgdGhleSdyZSBtZXJnZWQgaW5zdGVhZCwgd2l0aCBiYXNlVGVsZW1ldHJ5IHRha2luZyBwcmlvcml0eVxyXG4gICAgICAgIGlmIChiYXNlVGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIENvcHkgbWlzc2luZyBmaWVsZHNcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJhc2VUZWxlbWV0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdFRlbGVtZXRyeVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRlbGVtZXRyeVtrZXldID0gYmFzZVRlbGVtZXRyeVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgaWYgKGJhc2VUZWxlbWV0cnkucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJhc2VUZWxlbWV0cnkucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUZWxlbWV0cnkucHJvcGVydGllc1trZXldID0gYmFzZVRlbGVtZXRyeS5wcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RUZWxlbWV0cnk7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RQYXJzZXIucHJvdG90eXBlLmdldFJlcXVlc3RUYWdzID0gZnVuY3Rpb24gKHRhZ3MpIHtcclxuICAgICAgICAvLyBjcmVhdGUgYSBjb3B5IG9mIHRoZSBjb250ZXh0IGZvciByZXF1ZXN0cyBzaW5jZSBjbGllbnQgaW5mbyB3aWxsIGJlIHVzZWQgaGVyZVxyXG4gICAgICAgIHZhciBuZXdUYWdzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhZ3MpIHtcclxuICAgICAgICAgICAgbmV3VGFnc1trZXldID0gdGFnc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb24ndCBvdmVycmlkZSB0YWdzIGlmIHRoZXkgYXJlIGFscmVhZHkgc2V0XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLmxvY2F0aW9uSXBdID0gdGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLmxvY2F0aW9uSXBdIHx8IHRoaXMuX2dldElwKCk7XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLnNlc3Npb25JZF0gPSB0YWdzW0h0dHBSZXF1ZXN0UGFyc2VyLmtleXMuc2Vzc2lvbklkXSB8fCB0aGlzLl9nZXRJZChcImFpX3Nlc3Npb25cIik7XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLnVzZXJJZF0gPSB0YWdzW0h0dHBSZXF1ZXN0UGFyc2VyLmtleXMudXNlcklkXSB8fCB0aGlzLl9nZXRJZChcImFpX3VzZXJcIik7XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLnVzZXJBdXRoVXNlcklkXSA9IHRhZ3NbSHR0cFJlcXVlc3RQYXJzZXIua2V5cy51c2VyQXV0aFVzZXJJZF0gfHwgdGhpcy5fZ2V0SWQoXCJhaV9hdXRoVXNlclwiKTtcclxuICAgICAgICBuZXdUYWdzW0h0dHBSZXF1ZXN0UGFyc2VyLmtleXMub3BlcmF0aW9uTmFtZV0gPSB0aGlzLmdldE9wZXJhdGlvbk5hbWUodGFncyk7XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLm9wZXJhdGlvblBhcmVudElkXSA9IHRoaXMuZ2V0T3BlcmF0aW9uUGFyZW50SWQodGFncyk7XHJcbiAgICAgICAgbmV3VGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLm9wZXJhdGlvbklkXSA9IHRoaXMuZ2V0T3BlcmF0aW9uSWQodGFncyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1RhZ3M7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RQYXJzZXIucHJvdG90eXBlLmdldE9wZXJhdGlvbklkID0gZnVuY3Rpb24gKHRhZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLm9wZXJhdGlvbklkXSB8fCB0aGlzLm9wZXJhdGlvbklkO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5nZXRPcGVyYXRpb25QYXJlbnRJZCA9IGZ1bmN0aW9uICh0YWdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ3NbSHR0cFJlcXVlc3RQYXJzZXIua2V5cy5vcGVyYXRpb25QYXJlbnRJZF0gfHwgdGhpcy5wYXJlbnRJZCB8fCB0aGlzLmdldE9wZXJhdGlvbklkKHRhZ3MpO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5nZXRPcGVyYXRpb25OYW1lID0gZnVuY3Rpb24gKHRhZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGFnc1tIdHRwUmVxdWVzdFBhcnNlci5rZXlzLm9wZXJhdGlvbk5hbWVdIHx8IHRoaXMubWV0aG9kICsgXCIgXCIgKyB1cmwucGFyc2UodGhpcy51cmwpLnBhdGhuYW1lO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5nZXRSZXF1ZXN0SWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdElkO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5nZXRDb3JyZWxhdGlvbkNvbnRleHRIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ycmVsYXRpb25Db250ZXh0SGVhZGVyO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5fZ2V0QWJzb2x1dGVVcmwgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIGlmICghcmVxdWVzdC5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVuY3J5cHRlZCA9IHJlcXVlc3QuY29ubmVjdGlvbiA/IHJlcXVlc3QuY29ubmVjdGlvbi5lbmNyeXB0ZWQgOiBudWxsO1xyXG4gICAgICAgIHZhciByZXF1ZXN0VXJsID0gdXJsLnBhcnNlKHJlcXVlc3QudXJsKTtcclxuICAgICAgICB2YXIgcGF0aE5hbWUgPSByZXF1ZXN0VXJsLnBhdGhuYW1lO1xyXG4gICAgICAgIHZhciBzZWFyY2ggPSByZXF1ZXN0VXJsLnNlYXJjaDtcclxuICAgICAgICB2YXIgYWJzb2x1dGVVcmwgPSB1cmwuZm9ybWF0KHtcclxuICAgICAgICAgICAgcHJvdG9jb2w6IGVuY3J5cHRlZCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiLFxyXG4gICAgICAgICAgICBob3N0OiByZXF1ZXN0LmhlYWRlcnMuaG9zdCxcclxuICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGhOYW1lLFxyXG4gICAgICAgICAgICBzZWFyY2g6IHNlYXJjaFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcclxuICAgIH07XHJcbiAgICBIdHRwUmVxdWVzdFBhcnNlci5wcm90b3R5cGUuX2dldElwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHJlZ2V4IHRvIG1hdGNoIGlwdjQgd2l0aG91dCBwb3J0XHJcbiAgICAgICAgLy8gTm90ZTogaW5jbHVkaW5nIHRoZSBwb3J0IHdvdWxkIGNhdXNlIHRoZSBwYXlsb2FkIHRvIGJlIHJlamVjdGVkIGJ5IHRoZSBkYXRhIGNvbGxlY3RvclxyXG4gICAgICAgIHZhciBpcE1hdGNoID0gL1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM30vO1xyXG4gICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBpcE1hdGNoLmV4ZWMoc3RyKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaXAgPSBjaGVjayh0aGlzLnJhd0hlYWRlcnNbXCJ4LWZvcndhcmRlZC1mb3JcIl0pXHJcbiAgICAgICAgICAgIHx8IGNoZWNrKHRoaXMucmF3SGVhZGVyc1tcIngtY2xpZW50LWlwXCJdKVxyXG4gICAgICAgICAgICB8fCBjaGVjayh0aGlzLnJhd0hlYWRlcnNbXCJ4LXJlYWwtaXBcIl0pXHJcbiAgICAgICAgICAgIHx8IGNoZWNrKHRoaXMuY29ubmVjdGlvblJlbW90ZUFkZHJlc3MpXHJcbiAgICAgICAgICAgIHx8IGNoZWNrKHRoaXMuc29ja2V0UmVtb3RlQWRkcmVzcylcclxuICAgICAgICAgICAgfHwgY2hlY2sodGhpcy5sZWdhY3lTb2NrZXRSZW1vdGVBZGRyZXNzKTtcclxuICAgICAgICAvLyBub2RlIHYxMiByZXR1cm5zIHRoaXMgaWYgdGhlIGFkZHJlc3MgaXMgXCJsb2NhbGhvc3RcIlxyXG4gICAgICAgIGlmICghaXBcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0aW9uUmVtb3RlQWRkcmVzc1xyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rpb25SZW1vdGVBZGRyZXNzLnN1YnN0clxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rpb25SZW1vdGVBZGRyZXNzLnN1YnN0cigwLCAyKSA9PT0gXCI6OlwiKSB7XHJcbiAgICAgICAgICAgIGlwID0gXCIxMjcuMC4wLjFcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlwO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5fZ2V0SWQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBjb29raWUgPSAodGhpcy5yYXdIZWFkZXJzICYmIHRoaXMucmF3SGVhZGVyc1tcImNvb2tpZVwiXSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5yYXdIZWFkZXJzW1wiY29va2llXCJdID09PSAnc3RyaW5nJyAmJiB0aGlzLnJhd0hlYWRlcnNbXCJjb29raWVcIl0pIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gSHR0cFJlcXVlc3RQYXJzZXIucGFyc2VJZChVdGlsLmdldENvb2tpZShuYW1lLCBjb29raWUpKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RQYXJzZXIucHJvdG90eXBlLnBhcnNlSGVhZGVycyA9IGZ1bmN0aW9uIChyZXF1ZXN0LCByZXF1ZXN0SWQpIHtcclxuICAgICAgICB0aGlzLnJhd0hlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwgcmVxdWVzdC5yYXdIZWFkZXJzO1xyXG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gcmVxdWVzdC5oZWFkZXJzICYmIHJlcXVlc3QuaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XHJcbiAgICAgICAgdGhpcy5zb3VyY2VDb3JyZWxhdGlvbklkID0gVXRpbC5nZXRDb3JyZWxhdGlvbkNvbnRleHRUYXJnZXQocmVxdWVzdCwgUmVxdWVzdFJlc3BvbnNlSGVhZGVycy5yZXF1ZXN0Q29udGV4dFNvdXJjZUtleSk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVycykge1xyXG4gICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uQ29udGV4dEhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1tSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLmNvcnJlbGF0aW9uQ29udGV4dEhlYWRlcl07XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbUmVxdWVzdFJlc3BvbnNlSGVhZGVycy5yZXF1ZXN0SWRIZWFkZXJdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudElkID0gcmVxdWVzdC5oZWFkZXJzW1JlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdElkSGVhZGVyXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdElkID0gQ29ycmVsYXRpb25JZE1hbmFnZXIuZ2VuZXJhdGVSZXF1ZXN0SWQodGhpcy5wYXJlbnRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvcnJlbGF0aW9uQ29udGV4dEhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1tSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLmNvcnJlbGF0aW9uQ29udGV4dEhlYWRlcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZmFsbGJhY2tcclxuICAgICAgICAgICAgICAgIHZhciByb290SWQgPSByZXF1ZXN0LmhlYWRlcnNbUmVxdWVzdFJlc3BvbnNlSGVhZGVycy5yb290SWRIZWFkZXJdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRJZCA9IHJlcXVlc3QuaGVhZGVyc1tSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnBhcmVudElkSGVhZGVyXTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdElkID0gQ29ycmVsYXRpb25JZE1hbmFnZXIuZ2VuZXJhdGVSZXF1ZXN0SWQocm9vdElkIHx8IHRoaXMucGFyZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbkNvbnRleHRIZWFkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgc2NlbmFyaW9zIHRoYXQgZG9uJ3QgZ3VhcmFudGVlIGFuIEFJLWNyZWF0ZWQgY29udGV4dCxcclxuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHRoZSByZXF1ZXN0SWQgd2l0aCB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JZCA9IENvcnJlbGF0aW9uSWRNYW5hZ2VyLmdldFJvb3RJZCh0aGlzLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0UGFyc2VyLnBhcnNlSWQgPSBmdW5jdGlvbiAoY29va2llVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY29va2llVmFsdWUuc3Vic3RyKDAsIGNvb2tpZVZhbHVlLmluZGV4T2YoJ3wnKSk7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RQYXJzZXIua2V5cyA9IG5ldyBDb250cmFjdHMuQ29udGV4dFRhZ0tleXMoKTtcclxuICAgIHJldHVybiBIdHRwUmVxdWVzdFBhcnNlcjtcclxufShSZXF1ZXN0UGFyc2VyKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gSHR0cFJlcXVlc3RQYXJzZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh0dHBSZXF1ZXN0UGFyc2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/HttpRequests.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/HttpRequests.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar Logging = __webpack_require__(/*! ../Library/Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar Util = __webpack_require__(/*! ../Library/Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar RequestResponseHeaders = __webpack_require__(/*! ../Library/RequestResponseHeaders */ \"./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\");\r\nvar HttpRequestParser = __webpack_require__(/*! ./HttpRequestParser */ \"./node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js\");\r\nvar CorrelationContextManager_1 = __webpack_require__(/*! ./CorrelationContextManager */ \"./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\");\r\nvar AutoCollectPerformance = __webpack_require__(/*! ./Performance */ \"./node_modules/applicationinsights/out/AutoCollection/Performance.js\");\r\nvar AutoCollectHttpRequests = (function () {\r\n    function AutoCollectHttpRequests(client) {\r\n        if (!!AutoCollectHttpRequests.INSTANCE) {\r\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpRequests.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpRequests.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        // Autocorrelation requires automatic monitoring of incoming server requests\r\n        // Disabling autocollection but enabling autocorrelation will still enable\r\n        // request monitoring but will not produce request events\r\n        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {\r\n            this.useAutoCorrelation(this._isAutoCorrelating);\r\n            this._initialize();\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled) {\r\n        if (isEnabled && !this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.enable();\r\n        }\r\n        else if (!isEnabled && this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        }\r\n        this._isAutoCorrelating = isEnabled;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {\r\n        return this._isAutoCorrelating;\r\n    };\r\n    AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {\r\n        if (!this._isAutoCorrelating) {\r\n            return;\r\n        }\r\n        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader());\r\n    };\r\n    AutoCollectHttpRequests.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var wrapOnRequestHandler = function (onRequest) {\r\n            if (!onRequest) {\r\n                return undefined;\r\n            }\r\n            if (typeof onRequest !== 'function') {\r\n                throw new Error('onRequest handler must be a function');\r\n            }\r\n            return function (request, response) {\r\n                var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];\r\n                if (request && shouldCollect) {\r\n                    // Set up correlation context\r\n                    var requestParser_1 = new HttpRequestParser(request);\r\n                    var correlationContext = _this._generateCorrelationContext(requestParser_1);\r\n                    // Note: Check for if correlation is enabled happens within this method.\r\n                    // If not enabled, function will directly call the callback.\r\n                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {\r\n                        if (_this._isEnabled) {\r\n                            // Mark as auto collected\r\n                            request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;\r\n                            // Auto collect request\r\n                            AutoCollectHttpRequests.trackRequest(_this._client, { request: request, response: response }, requestParser_1);\r\n                        }\r\n                        // Add this request to the performance counter\r\n                        // Note: Check for if perf counters are enabled happens within this method.\r\n                        // TODO: Refactor common bits between trackRequest and countRequest so they can\r\n                        // be used together, even when perf counters are on, and request tracking is off\r\n                        AutoCollectPerformance.countRequest(request, response);\r\n                        if (typeof onRequest === \"function\") {\r\n                            onRequest(request, response);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    if (typeof onRequest === \"function\") {\r\n                        onRequest(request, response);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n        // The `http.createServer` function will instantiate a new http.Server object.\r\n        // Inside the Server's constructor, it is using addListener to register the\r\n        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:\r\n        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching\r\n        //    the http.createServer call. Or\r\n        // 2) Overwrite the http.createServer method and add a patched addListener to the\r\n        //    fresh server instance. This seems more stable for possible future changes as\r\n        //    it also covers the case where the Server might not use addListener to manage\r\n        //    the callback internally.\r\n        //    And also as long as the constructor uses addListener to add the handle, it is\r\n        //    ok to patch the addListener after construction only. Because if we would patch\r\n        //    the prototype one and the createServer method, we would wrap the handler twice\r\n        //    in case of the constructor call.\r\n        var wrapServerEventHandler = function (server) {\r\n            var originalAddListener = server.addListener.bind(server);\r\n            server.addListener = function (eventType, eventHandler) {\r\n                switch (eventType) {\r\n                    case 'request':\r\n                    case 'checkContinue':\r\n                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));\r\n                    default:\r\n                        return originalAddListener(eventType, eventHandler);\r\n                }\r\n            };\r\n            // on is an alias to addListener only\r\n            server.on = server.addListener;\r\n        };\r\n        var originalHttpServer = http.createServer;\r\n        http.createServer = function (onRequest) {\r\n            // todo: get a pointer to the server so the IP address can be read from server.address\r\n            var server = originalHttpServer(wrapOnRequestHandler(onRequest));\r\n            wrapServerEventHandler(server);\r\n            return server;\r\n        };\r\n        var originalHttpsServer = https.createServer;\r\n        https.createServer = function (options, onRequest) {\r\n            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));\r\n            wrapServerEventHandler(server);\r\n            return server;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\r\n     */\r\n    AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));\r\n        // Overwrite correlation context with request parser results\r\n        if (correlationContext) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);\r\n    };\r\n    /**\r\n     * Tracks a request by listening to the response 'finish' event\r\n     */\r\n    AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\r\n            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        }\r\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\r\n        if (correlationContext && !_requestParser) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        // response listeners\r\n        if (telemetry.response.once) {\r\n            telemetry.response.once(\"finish\", function () {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);\r\n            });\r\n        }\r\n        // track a failed request if an error is emitted\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on(\"error\", function (error) {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add the target correlationId to the response headers, if not already provided.\r\n     */\r\n    AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {\r\n        if (client.config && client.config.correlationId &&\r\n            response.getHeader && response.setHeader && !response.headersSent) {\r\n            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);\r\n            if (correlationHeader) {\r\n                var components = correlationHeader.split(\",\");\r\n                var key_1 = RequestResponseHeaders.requestContextSourceKey + \"=\";\r\n                if (!components.some(function (value) { return value.substring(0, key_1.length) === key_1; })) {\r\n                    response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + \",\" + RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n                }\r\n            }\r\n            else {\r\n                response.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n            }\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {\r\n        if (error) {\r\n            requestParser.onError(error, ellapsedMilliseconds);\r\n        }\r\n        else {\r\n            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);\r\n        }\r\n        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);\r\n        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);\r\n        if (telemetry.tagOverrides) {\r\n            for (var key in telemetry.tagOverrides) {\r\n                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];\r\n            }\r\n        }\r\n        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};\r\n        requestTelemetry.contextObjects[\"http.ServerRequest\"] = telemetry.request;\r\n        requestTelemetry.contextObjects[\"http.ServerResponse\"] = telemetry.response;\r\n        client.trackRequest(requestTelemetry);\r\n    };\r\n    AutoCollectHttpRequests.prototype.dispose = function () {\r\n        AutoCollectHttpRequests.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectHttpRequests.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpRequests;\r\n}());\r\nmodule.exports = AutoCollectHttpRequests;\r\n//# sourceMappingURL=HttpRequests.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vSHR0cFJlcXVlc3RzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9BdXRvQ29sbGVjdGlvbi9IdHRwUmVxdWVzdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XHJcbnZhciBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcclxudmFyIExvZ2dpbmcgPSByZXF1aXJlKFwiLi4vTGlicmFyeS9Mb2dnaW5nXCIpO1xyXG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi9MaWJyYXJ5L1V0aWxcIik7XHJcbnZhciBSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzID0gcmVxdWlyZShcIi4uL0xpYnJhcnkvUmVxdWVzdFJlc3BvbnNlSGVhZGVyc1wiKTtcclxudmFyIEh0dHBSZXF1ZXN0UGFyc2VyID0gcmVxdWlyZShcIi4vSHR0cFJlcXVlc3RQYXJzZXJcIik7XHJcbnZhciBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXCIpO1xyXG52YXIgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZSA9IHJlcXVpcmUoXCIuL1BlcmZvcm1hbmNlXCIpO1xyXG52YXIgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMoY2xpZW50KSB7XHJcbiAgICAgICAgaWYgKCEhQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyIHJlcXVlc3QgdHJhY2tpbmcgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgZnJvbSB0aGUgYXBwbGljYXRpb25JbnNpZ2h0cyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLklOU1RBTkNFID0gdGhpcztcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB9XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGlzRW5hYmxlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGlzRW5hYmxlZDtcclxuICAgICAgICAvLyBBdXRvY29ycmVsYXRpb24gcmVxdWlyZXMgYXV0b21hdGljIG1vbml0b3Jpbmcgb2YgaW5jb21pbmcgc2VydmVyIHJlcXVlc3RzXHJcbiAgICAgICAgLy8gRGlzYWJsaW5nIGF1dG9jb2xsZWN0aW9uIGJ1dCBlbmFibGluZyBhdXRvY29ycmVsYXRpb24gd2lsbCBzdGlsbCBlbmFibGVcclxuICAgICAgICAvLyByZXF1ZXN0IG1vbml0b3JpbmcgYnV0IHdpbGwgbm90IHByb2R1Y2UgcmVxdWVzdCBldmVudHNcclxuICAgICAgICBpZiAoKHRoaXMuX2lzQXV0b0NvcnJlbGF0aW5nIHx8IHRoaXMuX2lzRW5hYmxlZCB8fCBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLmlzRW5hYmxlZCgpKSAmJiAhdGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVzZUF1dG9Db3JyZWxhdGlvbih0aGlzLl9pc0F1dG9Db3JyZWxhdGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMucHJvdG90eXBlLnVzZUF1dG9Db3JyZWxhdGlvbiA9IGZ1bmN0aW9uIChpc0VuYWJsZWQpIHtcclxuICAgICAgICBpZiAoaXNFbmFibGVkICYmICF0aGlzLl9pc0F1dG9Db3JyZWxhdGluZykge1xyXG4gICAgICAgICAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXzEuQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5lbmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzRW5hYmxlZCAmJiB0aGlzLl9pc0F1dG9Db3JyZWxhdGluZykge1xyXG4gICAgICAgICAgICBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXzEuQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5kaXNhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzQXV0b0NvcnJlbGF0aW5nID0gaXNFbmFibGVkO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLnByb3RvdHlwZS5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLnByb3RvdHlwZS5pc0F1dG9Db3JyZWxhdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNBdXRvQ29ycmVsYXRpbmc7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMucHJvdG90eXBlLl9nZW5lcmF0ZUNvcnJlbGF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChyZXF1ZXN0UGFyc2VyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG9Db3JyZWxhdGluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXzEuQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5nZW5lcmF0ZUNvbnRleHRPYmplY3QocmVxdWVzdFBhcnNlci5nZXRPcGVyYXRpb25JZCh0aGlzLl9jbGllbnQuY29udGV4dC50YWdzKSwgcmVxdWVzdFBhcnNlci5nZXRSZXF1ZXN0SWQoKSwgcmVxdWVzdFBhcnNlci5nZXRPcGVyYXRpb25OYW1lKHRoaXMuX2NsaWVudC5jb250ZXh0LnRhZ3MpLCByZXF1ZXN0UGFyc2VyLmdldENvcnJlbGF0aW9uQ29udGV4dEhlYWRlcigpKTtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgd3JhcE9uUmVxdWVzdEhhbmRsZXIgPSBmdW5jdGlvbiAob25SZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICghb25SZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZXF1ZXN0ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uUmVxdWVzdCBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRDb2xsZWN0ID0gcmVxdWVzdCAmJiAhcmVxdWVzdFtBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5hbHJlYWR5QXV0b0NvbGxlY3RlZEZsYWddO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QgJiYgc2hvdWxkQ29sbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB1cCBjb3JyZWxhdGlvbiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJzZXJfMSA9IG5ldyBIdHRwUmVxdWVzdFBhcnNlcihyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29ycmVsYXRpb25Db250ZXh0ID0gX3RoaXMuX2dlbmVyYXRlQ29ycmVsYXRpb25Db250ZXh0KHJlcXVlc3RQYXJzZXJfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQ2hlY2sgZm9yIGlmIGNvcnJlbGF0aW9uIGlzIGVuYWJsZWQgaGFwcGVucyB3aXRoaW4gdGhpcyBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGVuYWJsZWQsIGZ1bmN0aW9uIHdpbGwgZGlyZWN0bHkgY2FsbCB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAgICAgICAgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlcl8xLkNvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIucnVuV2l0aENvbnRleHQoY29ycmVsYXRpb25Db250ZXh0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGFzIGF1dG8gY29sbGVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0W0F1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLmFscmVhZHlBdXRvQ29sbGVjdGVkRmxhZ10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXV0byBjb2xsZWN0IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLnRyYWNrUmVxdWVzdChfdGhpcy5fY2xpZW50LCB7IHJlcXVlc3Q6IHJlcXVlc3QsIHJlc3BvbnNlOiByZXNwb25zZSB9LCByZXF1ZXN0UGFyc2VyXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIHJlcXVlc3QgdG8gdGhlIHBlcmZvcm1hbmNlIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogQ2hlY2sgZm9yIGlmIHBlcmYgY291bnRlcnMgYXJlIGVuYWJsZWQgaGFwcGVucyB3aXRoaW4gdGhpcyBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIGNvbW1vbiBiaXRzIGJldHdlZW4gdHJhY2tSZXF1ZXN0IGFuZCBjb3VudFJlcXVlc3Qgc28gdGhleSBjYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgdXNlZCB0b2dldGhlciwgZXZlbiB3aGVuIHBlcmYgY291bnRlcnMgYXJlIG9uLCBhbmQgcmVxdWVzdCB0cmFja2luZyBpcyBvZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5jb3VudFJlcXVlc3QocmVxdWVzdCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlcXVlc3QocmVxdWVzdCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdChyZXF1ZXN0LCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVGhlIGBodHRwLmNyZWF0ZVNlcnZlcmAgZnVuY3Rpb24gd2lsbCBpbnN0YW50aWF0ZSBhIG5ldyBodHRwLlNlcnZlciBvYmplY3QuXHJcbiAgICAgICAgLy8gSW5zaWRlIHRoZSBTZXJ2ZXIncyBjb25zdHJ1Y3RvciwgaXQgaXMgdXNpbmcgYWRkTGlzdGVuZXIgdG8gcmVnaXN0ZXIgdGhlXHJcbiAgICAgICAgLy8gb25SZXF1ZXN0IGhhbmRsZXIuIFNvIHRoZXJlIGFyZSB0d28gd2F5cyB0byBpbmplY3QgdGhlIHdyYXBwZWQgb25SZXF1ZXN0IGhhbmRsZXI6XHJcbiAgICAgICAgLy8gMSkgT3ZlcndyaXRlIFNlcnZlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgKGFuZCAub24oKSkgZ2xvYmFsbHkgYW5kIG5vdCBwYXRjaGluZ1xyXG4gICAgICAgIC8vICAgIHRoZSBodHRwLmNyZWF0ZVNlcnZlciBjYWxsLiBPclxyXG4gICAgICAgIC8vIDIpIE92ZXJ3cml0ZSB0aGUgaHR0cC5jcmVhdGVTZXJ2ZXIgbWV0aG9kIGFuZCBhZGQgYSBwYXRjaGVkIGFkZExpc3RlbmVyIHRvIHRoZVxyXG4gICAgICAgIC8vICAgIGZyZXNoIHNlcnZlciBpbnN0YW5jZS4gVGhpcyBzZWVtcyBtb3JlIHN0YWJsZSBmb3IgcG9zc2libGUgZnV0dXJlIGNoYW5nZXMgYXNcclxuICAgICAgICAvLyAgICBpdCBhbHNvIGNvdmVycyB0aGUgY2FzZSB3aGVyZSB0aGUgU2VydmVyIG1pZ2h0IG5vdCB1c2UgYWRkTGlzdGVuZXIgdG8gbWFuYWdlXHJcbiAgICAgICAgLy8gICAgdGhlIGNhbGxiYWNrIGludGVybmFsbHkuXHJcbiAgICAgICAgLy8gICAgQW5kIGFsc28gYXMgbG9uZyBhcyB0aGUgY29uc3RydWN0b3IgdXNlcyBhZGRMaXN0ZW5lciB0byBhZGQgdGhlIGhhbmRsZSwgaXQgaXNcclxuICAgICAgICAvLyAgICBvayB0byBwYXRjaCB0aGUgYWRkTGlzdGVuZXIgYWZ0ZXIgY29uc3RydWN0aW9uIG9ubHkuIEJlY2F1c2UgaWYgd2Ugd291bGQgcGF0Y2hcclxuICAgICAgICAvLyAgICB0aGUgcHJvdG90eXBlIG9uZSBhbmQgdGhlIGNyZWF0ZVNlcnZlciBtZXRob2QsIHdlIHdvdWxkIHdyYXAgdGhlIGhhbmRsZXIgdHdpY2VcclxuICAgICAgICAvLyAgICBpbiBjYXNlIG9mIHRoZSBjb25zdHJ1Y3RvciBjYWxsLlxyXG4gICAgICAgIHZhciB3cmFwU2VydmVyRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKHNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxBZGRMaXN0ZW5lciA9IHNlcnZlci5hZGRMaXN0ZW5lci5iaW5kKHNlcnZlcik7XHJcbiAgICAgICAgICAgIHNlcnZlci5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50SGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGVja0NvbnRpbnVlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsQWRkTGlzdGVuZXIoZXZlbnRUeXBlLCB3cmFwT25SZXF1ZXN0SGFuZGxlcihldmVudEhhbmRsZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxBZGRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIG9uIGlzIGFuIGFsaWFzIHRvIGFkZExpc3RlbmVyIG9ubHlcclxuICAgICAgICAgICAgc2VydmVyLm9uID0gc2VydmVyLmFkZExpc3RlbmVyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSHR0cFNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyO1xyXG4gICAgICAgIGh0dHAuY3JlYXRlU2VydmVyID0gZnVuY3Rpb24gKG9uUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAvLyB0b2RvOiBnZXQgYSBwb2ludGVyIHRvIHRoZSBzZXJ2ZXIgc28gdGhlIElQIGFkZHJlc3MgY2FuIGJlIHJlYWQgZnJvbSBzZXJ2ZXIuYWRkcmVzc1xyXG4gICAgICAgICAgICB2YXIgc2VydmVyID0gb3JpZ2luYWxIdHRwU2VydmVyKHdyYXBPblJlcXVlc3RIYW5kbGVyKG9uUmVxdWVzdCkpO1xyXG4gICAgICAgICAgICB3cmFwU2VydmVyRXZlbnRIYW5kbGVyKHNlcnZlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb3JpZ2luYWxIdHRwc1NlcnZlciA9IGh0dHBzLmNyZWF0ZVNlcnZlcjtcclxuICAgICAgICBodHRwcy5jcmVhdGVTZXJ2ZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgb25SZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBvcmlnaW5hbEh0dHBzU2VydmVyKG9wdGlvbnMsIHdyYXBPblJlcXVlc3RIYW5kbGVyKG9uUmVxdWVzdCkpO1xyXG4gICAgICAgICAgICB3cmFwU2VydmVyRXZlbnRIYW5kbGVyKHNlcnZlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXI7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyBhIHJlcXVlc3Qgc3luY2hyb25vdXNseSAoZG9lc24ndCB3YWl0IGZvciByZXNwb25zZSAnZmluaXNoJyBldmVudClcclxuICAgICAqL1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMudHJhY2tSZXF1ZXN0U3luYyA9IGZ1bmN0aW9uIChjbGllbnQsIHRlbGVtZXRyeSkge1xyXG4gICAgICAgIGlmICghdGVsZW1ldHJ5LnJlcXVlc3QgfHwgIXRlbGVtZXRyeS5yZXNwb25zZSB8fCAhY2xpZW50KSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhcIkF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLnRyYWNrUmVxdWVzdFN5bmMgd2FzIGNhbGxlZCB3aXRoIGludmFsaWQgcGFyYW1ldGVyczogXCIsICF0ZWxlbWV0cnkucmVxdWVzdCwgIXRlbGVtZXRyeS5yZXNwb25zZSwgIWNsaWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuYWRkUmVzcG9uc2VDb3JyZWxhdGlvbklkSGVhZGVyKGNsaWVudCwgdGVsZW1ldHJ5LnJlc3BvbnNlKTtcclxuICAgICAgICAvLyBzdG9yZSBkYXRhIGFib3V0IHRoZSByZXF1ZXN0XHJcbiAgICAgICAgdmFyIGNvcnJlbGF0aW9uQ29udGV4dCA9IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMS5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RQYXJzZXIgPSBuZXcgSHR0cFJlcXVlc3RQYXJzZXIodGVsZW1ldHJ5LnJlcXVlc3QsIChjb3JyZWxhdGlvbkNvbnRleHQgJiYgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5wYXJlbnRJZCkpO1xyXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBjb3JyZWxhdGlvbiBjb250ZXh0IHdpdGggcmVxdWVzdCBwYXJzZXIgcmVzdWx0c1xyXG4gICAgICAgIGlmIChjb3JyZWxhdGlvbkNvbnRleHQpIHtcclxuICAgICAgICAgICAgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5pZCA9IHJlcXVlc3RQYXJzZXIuZ2V0T3BlcmF0aW9uSWQoY2xpZW50LmNvbnRleHQudGFncykgfHwgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5pZDtcclxuICAgICAgICAgICAgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5uYW1lID0gcmVxdWVzdFBhcnNlci5nZXRPcGVyYXRpb25OYW1lKGNsaWVudC5jb250ZXh0LnRhZ3MpIHx8IGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ubmFtZTtcclxuICAgICAgICAgICAgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5wYXJlbnRJZCA9IHJlcXVlc3RQYXJzZXIuZ2V0UmVxdWVzdElkKCkgfHwgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5wYXJlbnRJZDtcclxuICAgICAgICAgICAgY29ycmVsYXRpb25Db250ZXh0LmN1c3RvbVByb3BlcnRpZXMuYWRkSGVhZGVyRGF0YShyZXF1ZXN0UGFyc2VyLmdldENvcnJlbGF0aW9uQ29udGV4dEhlYWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuZW5kUmVxdWVzdChjbGllbnQsIHJlcXVlc3RQYXJzZXIsIHRlbGVtZXRyeSwgdGVsZW1ldHJ5LmR1cmF0aW9uLCB0ZWxlbWV0cnkuZXJyb3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVHJhY2tzIGEgcmVxdWVzdCBieSBsaXN0ZW5pbmcgdG8gdGhlIHJlc3BvbnNlICdmaW5pc2gnIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzLnRyYWNrUmVxdWVzdCA9IGZ1bmN0aW9uIChjbGllbnQsIHRlbGVtZXRyeSwgX3JlcXVlc3RQYXJzZXIpIHtcclxuICAgICAgICBpZiAoIXRlbGVtZXRyeS5yZXF1ZXN0IHx8ICF0ZWxlbWV0cnkucmVzcG9uc2UgfHwgIWNsaWVudCkge1xyXG4gICAgICAgICAgICBMb2dnaW5nLmluZm8oXCJBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy50cmFja1JlcXVlc3Qgd2FzIGNhbGxlZCB3aXRoIGludmFsaWQgcGFyYW1ldGVyczogXCIsICF0ZWxlbWV0cnkucmVxdWVzdCwgIXRlbGVtZXRyeS5yZXNwb25zZSwgIWNsaWVudCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RvcmUgZGF0YSBhYm91dCB0aGUgcmVxdWVzdFxyXG4gICAgICAgIHZhciBjb3JyZWxhdGlvbkNvbnRleHQgPSBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXzEuQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpO1xyXG4gICAgICAgIHZhciByZXF1ZXN0UGFyc2VyID0gX3JlcXVlc3RQYXJzZXIgfHwgbmV3IEh0dHBSZXF1ZXN0UGFyc2VyKHRlbGVtZXRyeS5yZXF1ZXN0LCBjb3JyZWxhdGlvbkNvbnRleHQgJiYgY29ycmVsYXRpb25Db250ZXh0Lm9wZXJhdGlvbi5wYXJlbnRJZCk7XHJcbiAgICAgICAgaWYgKFV0aWwuY2FuSW5jbHVkZUNvcnJlbGF0aW9uSGVhZGVyKGNsaWVudCwgcmVxdWVzdFBhcnNlci5nZXRVcmwoKSkpIHtcclxuICAgICAgICAgICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuYWRkUmVzcG9uc2VDb3JyZWxhdGlvbklkSGVhZGVyKGNsaWVudCwgdGVsZW1ldHJ5LnJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3ZlcndyaXRlIGNvcnJlbGF0aW9uIGNvbnRleHQgd2l0aCByZXF1ZXN0IHBhcnNlciByZXN1bHRzIChpZiBub3QgYW4gYXV0b21hdGljIHRyYWNrLiB3ZSd2ZSBhbHJlYWR5IHByZWNhbGN1bGF0ZWQgdGhlIGNvcnJlbGF0aW9uIGNvbnRleHQgaW4gdGhhdCBjYXNlKVxyXG4gICAgICAgIGlmIChjb3JyZWxhdGlvbkNvbnRleHQgJiYgIV9yZXF1ZXN0UGFyc2VyKSB7XHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24uaWQgPSByZXF1ZXN0UGFyc2VyLmdldE9wZXJhdGlvbklkKGNsaWVudC5jb250ZXh0LnRhZ3MpIHx8IGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24uaWQ7XHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ubmFtZSA9IHJlcXVlc3RQYXJzZXIuZ2V0T3BlcmF0aW9uTmFtZShjbGllbnQuY29udGV4dC50YWdzKSB8fCBjb3JyZWxhdGlvbkNvbnRleHQub3BlcmF0aW9uLm5hbWU7XHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ucGFyZW50SWQgPSByZXF1ZXN0UGFyc2VyLmdldE9wZXJhdGlvblBhcmVudElkKGNsaWVudC5jb250ZXh0LnRhZ3MpIHx8IGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ucGFyZW50SWQ7XHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uQ29udGV4dC5jdXN0b21Qcm9wZXJ0aWVzLmFkZEhlYWRlckRhdGEocmVxdWVzdFBhcnNlci5nZXRDb3JyZWxhdGlvbkNvbnRleHRIZWFkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc3BvbnNlIGxpc3RlbmVyc1xyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkucmVzcG9uc2Uub25jZSkge1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkucmVzcG9uc2Uub25jZShcImZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5lbmRSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdFBhcnNlciwgdGVsZW1ldHJ5LCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRyYWNrIGEgZmFpbGVkIHJlcXVlc3QgaWYgYW4gZXJyb3IgaXMgZW1pdHRlZFxyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkucmVxdWVzdC5vbikge1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkucmVxdWVzdC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuZW5kUmVxdWVzdChjbGllbnQsIHJlcXVlc3RQYXJzZXIsIHRlbGVtZXRyeSwgbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIHRhcmdldCBjb3JyZWxhdGlvbklkIHRvIHRoZSByZXNwb25zZSBoZWFkZXJzLCBpZiBub3QgYWxyZWFkeSBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuYWRkUmVzcG9uc2VDb3JyZWxhdGlvbklkSGVhZGVyID0gZnVuY3Rpb24gKGNsaWVudCwgcmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAoY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmNvcnJlbGF0aW9uSWQgJiZcclxuICAgICAgICAgICAgcmVzcG9uc2UuZ2V0SGVhZGVyICYmIHJlc3BvbnNlLnNldEhlYWRlciAmJiAhcmVzcG9uc2UuaGVhZGVyc1NlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGNvcnJlbGF0aW9uSGVhZGVyID0gcmVzcG9uc2UuZ2V0SGVhZGVyKFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRIZWFkZXIpO1xyXG4gICAgICAgICAgICBpZiAoY29ycmVsYXRpb25IZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gY29ycmVsYXRpb25IZWFkZXIuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleV8xID0gUmVxdWVzdFJlc3BvbnNlSGVhZGVycy5yZXF1ZXN0Q29udGV4dFNvdXJjZUtleSArIFwiPVwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwga2V5XzEubGVuZ3RoKSA9PT0ga2V5XzE7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRIZWFkZXIsIGNvcnJlbGF0aW9uSGVhZGVyICsgXCIsXCIgKyBSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLnJlcXVlc3RDb250ZXh0U291cmNlS2V5ICsgXCI9XCIgKyBjbGllbnQuY29uZmlnLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0SGVhZGVyKFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRIZWFkZXIsIFJlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRTb3VyY2VLZXkgKyBcIj1cIiArIGNsaWVudC5jb25maWcuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMuZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChjbGllbnQsIHJlcXVlc3RQYXJzZXIsIHRlbGVtZXRyeSwgZWxsYXBzZWRNaWxsaXNlY29uZHMsIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RQYXJzZXIub25FcnJvcihlcnJvciwgZWxsYXBzZWRNaWxsaXNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVxdWVzdFBhcnNlci5vblJlc3BvbnNlKHRlbGVtZXRyeS5yZXNwb25zZSwgZWxsYXBzZWRNaWxsaXNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVxdWVzdFRlbGVtZXRyeSA9IHJlcXVlc3RQYXJzZXIuZ2V0UmVxdWVzdFRlbGVtZXRyeSh0ZWxlbWV0cnkpO1xyXG4gICAgICAgIHJlcXVlc3RUZWxlbWV0cnkudGFnT3ZlcnJpZGVzID0gcmVxdWVzdFBhcnNlci5nZXRSZXF1ZXN0VGFncyhjbGllbnQuY29udGV4dC50YWdzKTtcclxuICAgICAgICBpZiAodGVsZW1ldHJ5LnRhZ092ZXJyaWRlcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGVsZW1ldHJ5LnRhZ092ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFRlbGVtZXRyeS50YWdPdmVycmlkZXNba2V5XSA9IHRlbGVtZXRyeS50YWdPdmVycmlkZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0VGVsZW1ldHJ5LmNvbnRleHRPYmplY3RzID0gcmVxdWVzdFRlbGVtZXRyeS5jb250ZXh0T2JqZWN0cyB8fCB7fTtcclxuICAgICAgICByZXF1ZXN0VGVsZW1ldHJ5LmNvbnRleHRPYmplY3RzW1wiaHR0cC5TZXJ2ZXJSZXF1ZXN0XCJdID0gdGVsZW1ldHJ5LnJlcXVlc3Q7XHJcbiAgICAgICAgcmVxdWVzdFRlbGVtZXRyeS5jb250ZXh0T2JqZWN0c1tcImh0dHAuU2VydmVyUmVzcG9uc2VcIl0gPSB0ZWxlbWV0cnkucmVzcG9uc2U7XHJcbiAgICAgICAgY2xpZW50LnRyYWNrUmVxdWVzdChyZXF1ZXN0VGVsZW1ldHJ5KTtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5JTlNUQU5DRSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGUoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdEh0dHBSZXF1ZXN0cy5hbHJlYWR5QXV0b0NvbGxlY3RlZEZsYWcgPSAnX2FwcEluc2lnaHRzQXV0b0NvbGxlY3RlZCc7XHJcbiAgICByZXR1cm4gQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHM7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh0dHBSZXF1ZXN0cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/HttpRequests.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/Performance.js":
/*!****************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/Performance.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar os = __webpack_require__(/*! os */ \"os\");\r\nvar Logging = __webpack_require__(/*! ../Library/Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar AutoCollectPerformance = (function () {\r\n    function AutoCollectPerformance(client) {\r\n        if (!!AutoCollectPerformance.INSTANCE) {\r\n            throw new Error(\"Performance tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectPerformance.INSTANCE = this;\r\n        this._isInitialized = false;\r\n        this._client = client;\r\n    }\r\n    AutoCollectPerformance.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._lastCpus = os.cpus();\r\n                this._lastRequests = {\r\n                    totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n                    time: +new Date\r\n                };\r\n                if (typeof process.cpuUsage === 'function') {\r\n                    this._lastAppCpuUsage = process.cpuUsage();\r\n                }\r\n                this._lastHrtime = process.hrtime();\r\n                this._handle = setInterval(function () { return _this.trackPerformance(); }, 60000);\r\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\r\n            }\r\n        }\r\n        else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectPerformance.countRequest = function (request, response) {\r\n        var _this = this;\r\n        if (!AutoCollectPerformance.isEnabled()) {\r\n            return;\r\n        }\r\n        var start = +new Date;\r\n        if (!request || !response) {\r\n            Logging.warn(\"AutoCollectPerformance.countRequest was called with invalid parameters: \", !!request, !!response);\r\n            return;\r\n        }\r\n        // response listeners\r\n        if (typeof response.once === \"function\") {\r\n            response.once(\"finish\", function () {\r\n                var end = +new Date;\r\n                _this._lastRequestExecutionTime = end - start;\r\n                AutoCollectPerformance._totalRequestCount++;\r\n                if (response.statusCode >= 400) {\r\n                    AutoCollectPerformance._totalFailedRequestCount++;\r\n                }\r\n            });\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectPerformance.isEnabled = function () {\r\n        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;\r\n    };\r\n    AutoCollectPerformance.prototype.trackPerformance = function () {\r\n        this._trackCpu();\r\n        this._trackMemory();\r\n        this._trackNetwork();\r\n    };\r\n    AutoCollectPerformance.prototype._trackCpu = function () {\r\n        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary\r\n        // to find the delta since the last measurement\r\n        var cpus = os.cpus();\r\n        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {\r\n            var totalUser = 0;\r\n            var totalSys = 0;\r\n            var totalNice = 0;\r\n            var totalIdle = 0;\r\n            var totalIrq = 0;\r\n            for (var i = 0; !!cpus && i < cpus.length; i++) {\r\n                var cpu = cpus[i];\r\n                var lastCpu = this._lastCpus[i];\r\n                var name = \"% cpu(\" + i + \") \";\r\n                var model = cpu.model;\r\n                var speed = cpu.speed;\r\n                var times = cpu.times;\r\n                var lastTimes = lastCpu.times;\r\n                // user cpu time (or) % CPU time spent in user space\r\n                var user = (times.user - lastTimes.user) || 0;\r\n                totalUser += user;\r\n                // system cpu time (or) % CPU time spent in kernel space\r\n                var sys = (times.sys - lastTimes.sys) || 0;\r\n                totalSys += sys;\r\n                // user nice cpu time (or) % CPU time spent on low priority processes\r\n                var nice = (times.nice - lastTimes.nice) || 0;\r\n                totalNice += nice;\r\n                // idle cpu time (or) % CPU time spent idle\r\n                var idle = (times.idle - lastTimes.idle) || 0;\r\n                totalIdle += idle;\r\n                // irq (or) % CPU time spent servicing/handling hardware interrupts\r\n                var irq = (times.irq - lastTimes.irq) || 0;\r\n                totalIrq += irq;\r\n            }\r\n            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)\r\n            var appCpuPercent = undefined;\r\n            if (typeof process.cpuUsage === 'function') {\r\n                var appCpuUsage = process.cpuUsage();\r\n                var hrtime = process.hrtime();\r\n                var totalApp = ((appCpuUsage.user - this._lastAppCpuUsage.user) + (appCpuUsage.system - this._lastAppCpuUsage.system)) || 0;\r\n                if (typeof this._lastHrtime !== 'undefined' && this._lastHrtime.length === 2) {\r\n                    var elapsedTime = ((hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3) || 0; // convert to microseconds\r\n                    appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);\r\n                }\r\n                // Set previous\r\n                this._lastAppCpuUsage = appCpuUsage;\r\n                this._lastHrtime = hrtime;\r\n            }\r\n            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;\r\n            this._client.trackMetric({ name: \"\\\\Processor(_Total)\\\\% Processor Time\", value: ((combinedTotal - totalIdle) / combinedTotal) * 100 });\r\n            this._client.trackMetric({ name: \"\\\\Process(??APP_WIN32_PROC??)\\\\% Processor Time\", value: appCpuPercent || ((totalUser / combinedTotal) * 100) });\r\n        }\r\n        this._lastCpus = cpus;\r\n    };\r\n    AutoCollectPerformance.prototype._trackMemory = function () {\r\n        var freeMem = os.freemem();\r\n        var usedMem = process.memoryUsage().rss;\r\n        this._client.trackMetric({ name: \"\\\\Process(??APP_WIN32_PROC??)\\\\Private Bytes\", value: usedMem });\r\n        this._client.trackMetric({ name: \"\\\\Memory\\\\Available Bytes\", value: freeMem });\r\n    };\r\n    AutoCollectPerformance.prototype._trackNetwork = function () {\r\n        // track total request counters\r\n        var lastRequests = this._lastRequests;\r\n        var requests = {\r\n            totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n            time: +new Date\r\n        };\r\n        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;\r\n        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;\r\n        var elapsedMs = requests.time - lastRequests.time;\r\n        var elapsedSeconds = elapsedMs / 1000;\r\n        if (elapsedMs > 0) {\r\n            var requestsPerSec = intervalRequests / elapsedSeconds;\r\n            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;\r\n            this._client.trackMetric({ name: \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Requests/Sec\", value: requestsPerSec });\r\n            this._client.trackMetric({ name: \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Request Execution Time\", value: AutoCollectPerformance._lastRequestExecutionTime });\r\n        }\r\n        this._lastRequests = requests;\r\n    };\r\n    AutoCollectPerformance.prototype.dispose = function () {\r\n        AutoCollectPerformance.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectPerformance._totalRequestCount = 0;\r\n    AutoCollectPerformance._totalFailedRequestCount = 0;\r\n    AutoCollectPerformance._lastRequestExecutionTime = 0;\r\n    return AutoCollectPerformance;\r\n}());\r\nmodule.exports = AutoCollectPerformance;\r\n//# sourceMappingURL=Performance.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vUGVyZm9ybWFuY2UuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0F1dG9Db2xsZWN0aW9uL1BlcmZvcm1hbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbnZhciBMb2dnaW5nID0gcmVxdWlyZShcIi4uL0xpYnJhcnkvTG9nZ2luZ1wiKTtcclxudmFyIEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXV0b0NvbGxlY3RQZXJmb3JtYW5jZShjbGllbnQpIHtcclxuICAgICAgICBpZiAoISFBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLklOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcmZvcm1hbmNlIHRyYWNraW5nIHNob3VsZCBiZSBjb25maWd1cmVkIGZyb20gdGhlIGFwcGxpY2F0aW9uSW5zaWdodHMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLklOU1RBTkNFID0gdGhpcztcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xyXG4gICAgfVxyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGlzRW5hYmxlZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5faXNFbmFibGVkID0gaXNFbmFibGVkO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQgJiYgIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RDcHVzID0gb3MuY3B1cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUmVxdWVzdENvdW50OiBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl90b3RhbFJlcXVlc3RDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbEZhaWxlZFJlcXVlc3RDb3VudDogQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5fdG90YWxGYWlsZWRSZXF1ZXN0Q291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogK25ldyBEYXRlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzLmNwdVVzYWdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEFwcENwdVVzYWdlID0gcHJvY2Vzcy5jcHVVc2FnZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhydGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50cmFja1BlcmZvcm1hbmNlKCk7IH0sIDYwMDAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZS51bnJlZigpOyAvLyBBbGxvdyB0aGUgYXBwIHRvIHRlcm1pbmF0ZSBldmVuIHdoaWxlIHRoaXMgbG9vcCBpcyBnb2luZyBvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2hhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5jb3VudFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5pc0VuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9ICtuZXcgRGF0ZTtcclxuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgIXJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcud2FybihcIkF1dG9Db2xsZWN0UGVyZm9ybWFuY2UuY291bnRSZXF1ZXN0IHdhcyBjYWxsZWQgd2l0aCBpbnZhbGlkIHBhcmFtZXRlcnM6IFwiLCAhIXJlcXVlc3QsICEhcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc3BvbnNlIGxpc3RlbmVyc1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2Uub25jZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9ICtuZXcgRGF0ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0UmVxdWVzdEV4ZWN1dGlvblRpbWUgPSBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgIEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UuX3RvdGFsUmVxdWVzdENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcclxuICAgICAgICAgICAgICAgICAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl90b3RhbEZhaWxlZFJlcXVlc3RDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5wcm90b3R5cGUuaXNJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5JTlNUQU5DRSAmJiBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLklOU1RBTkNFLl9pc0VuYWJsZWQ7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5wcm90b3R5cGUudHJhY2tQZXJmb3JtYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl90cmFja0NwdSgpO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrTWVtb3J5KCk7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tOZXR3b3JrKCk7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5wcm90b3R5cGUuX3RyYWNrQ3B1ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHRoaXMgcmVwb3J0cyB0b3RhbCBtcyBzcGVudCBpbiBlYWNoIGNhdGVnb3J5IHNpbmNlIHRoZSBPUyB3YXMgYm9vdGVkLCB0byBjYWxjdWxhdGUgcGVyY2VudCBpdCBpcyBuZWNlc3NhcnlcclxuICAgICAgICAvLyB0byBmaW5kIHRoZSBkZWx0YSBzaW5jZSB0aGUgbGFzdCBtZWFzdXJlbWVudFxyXG4gICAgICAgIHZhciBjcHVzID0gb3MuY3B1cygpO1xyXG4gICAgICAgIGlmIChjcHVzICYmIGNwdXMubGVuZ3RoICYmIHRoaXMuX2xhc3RDcHVzICYmIGNwdXMubGVuZ3RoID09PSB0aGlzLl9sYXN0Q3B1cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHRvdGFsVXNlciA9IDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbFN5cyA9IDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbE5pY2UgPSAwO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxJZGxlID0gMDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsSXJxID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7ICEhY3B1cyAmJiBpIDwgY3B1cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNwdSA9IGNwdXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENwdSA9IHRoaXMuX2xhc3RDcHVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBcIiUgY3B1KFwiICsgaSArIFwiKSBcIjtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGNwdS5tb2RlbDtcclxuICAgICAgICAgICAgICAgIHZhciBzcGVlZCA9IGNwdS5zcGVlZDtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lcyA9IGNwdS50aW1lcztcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0VGltZXMgPSBsYXN0Q3B1LnRpbWVzO1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlciBjcHUgdGltZSAob3IpICUgQ1BVIHRpbWUgc3BlbnQgaW4gdXNlciBzcGFjZVxyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSAodGltZXMudXNlciAtIGxhc3RUaW1lcy51c2VyKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdG90YWxVc2VyICs9IHVzZXI7XHJcbiAgICAgICAgICAgICAgICAvLyBzeXN0ZW0gY3B1IHRpbWUgKG9yKSAlIENQVSB0aW1lIHNwZW50IGluIGtlcm5lbCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgdmFyIHN5cyA9ICh0aW1lcy5zeXMgLSBsYXN0VGltZXMuc3lzKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdG90YWxTeXMgKz0gc3lzO1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlciBuaWNlIGNwdSB0aW1lIChvcikgJSBDUFUgdGltZSBzcGVudCBvbiBsb3cgcHJpb3JpdHkgcHJvY2Vzc2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgbmljZSA9ICh0aW1lcy5uaWNlIC0gbGFzdFRpbWVzLm5pY2UpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICB0b3RhbE5pY2UgKz0gbmljZTtcclxuICAgICAgICAgICAgICAgIC8vIGlkbGUgY3B1IHRpbWUgKG9yKSAlIENQVSB0aW1lIHNwZW50IGlkbGVcclxuICAgICAgICAgICAgICAgIHZhciBpZGxlID0gKHRpbWVzLmlkbGUgLSBsYXN0VGltZXMuaWRsZSkgfHwgMDtcclxuICAgICAgICAgICAgICAgIHRvdGFsSWRsZSArPSBpZGxlO1xyXG4gICAgICAgICAgICAgICAgLy8gaXJxIChvcikgJSBDUFUgdGltZSBzcGVudCBzZXJ2aWNpbmcvaGFuZGxpbmcgaGFyZHdhcmUgaW50ZXJydXB0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGlycSA9ICh0aW1lcy5pcnEgLSBsYXN0VGltZXMuaXJxKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdG90YWxJcnEgKz0gaXJxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSAlIG9mIHRvdGFsIGNwdSB0aW1lICh1c2VyICsgc3lzdGVtKSB0aGlzIEFwcCBQcm9jZXNzIHVzZWQgKE9ubHkgc3VwcG9ydGVkIGJ5IG5vZGUgdjYuMS4wKylcclxuICAgICAgICAgICAgdmFyIGFwcENwdVBlcmNlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzcy5jcHVVc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFwcENwdVVzYWdlID0gcHJvY2Vzcy5jcHVVc2FnZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxBcHAgPSAoKGFwcENwdVVzYWdlLnVzZXIgLSB0aGlzLl9sYXN0QXBwQ3B1VXNhZ2UudXNlcikgKyAoYXBwQ3B1VXNhZ2Uuc3lzdGVtIC0gdGhpcy5fbGFzdEFwcENwdVVzYWdlLnN5c3RlbSkpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2xhc3RIcnRpbWUgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuX2xhc3RIcnRpbWUubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gKChocnRpbWVbMF0gLSB0aGlzLl9sYXN0SHJ0aW1lWzBdKSAqIDFlNiArIChocnRpbWVbMV0gLSB0aGlzLl9sYXN0SHJ0aW1lWzFdKSAvIDFlMykgfHwgMDsgLy8gY29udmVydCB0byBtaWNyb3NlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICBhcHBDcHVQZXJjZW50ID0gMTAwICogdG90YWxBcHAgLyAoZWxhcHNlZFRpbWUgKiBjcHVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcHJldmlvdXNcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RBcHBDcHVVc2FnZSA9IGFwcENwdVVzYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhydGltZSA9IGhydGltZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29tYmluZWRUb3RhbCA9ICh0b3RhbFVzZXIgKyB0b3RhbFN5cyArIHRvdGFsTmljZSArIHRvdGFsSWRsZSArIHRvdGFsSXJxKSB8fCAxO1xyXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQudHJhY2tNZXRyaWMoeyBuYW1lOiBcIlxcXFxQcm9jZXNzb3IoX1RvdGFsKVxcXFwlIFByb2Nlc3NvciBUaW1lXCIsIHZhbHVlOiAoKGNvbWJpbmVkVG90YWwgLSB0b3RhbElkbGUpIC8gY29tYmluZWRUb3RhbCkgKiAxMDAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC50cmFja01ldHJpYyh7IG5hbWU6IFwiXFxcXFByb2Nlc3MoPz9BUFBfV0lOMzJfUFJPQz8/KVxcXFwlIFByb2Nlc3NvciBUaW1lXCIsIHZhbHVlOiBhcHBDcHVQZXJjZW50IHx8ICgodG90YWxVc2VyIC8gY29tYmluZWRUb3RhbCkgKiAxMDApIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXN0Q3B1cyA9IGNwdXM7XHJcbiAgICB9O1xyXG4gICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5wcm90b3R5cGUuX3RyYWNrTWVtb3J5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmcmVlTWVtID0gb3MuZnJlZW1lbSgpO1xyXG4gICAgICAgIHZhciB1c2VkTWVtID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLnJzcztcclxuICAgICAgICB0aGlzLl9jbGllbnQudHJhY2tNZXRyaWMoeyBuYW1lOiBcIlxcXFxQcm9jZXNzKD8/QVBQX1dJTjMyX1BST0M/PylcXFxcUHJpdmF0ZSBCeXRlc1wiLCB2YWx1ZTogdXNlZE1lbSB9KTtcclxuICAgICAgICB0aGlzLl9jbGllbnQudHJhY2tNZXRyaWMoeyBuYW1lOiBcIlxcXFxNZW1vcnlcXFxcQXZhaWxhYmxlIEJ5dGVzXCIsIHZhbHVlOiBmcmVlTWVtIH0pO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UucHJvdG90eXBlLl90cmFja05ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdHJhY2sgdG90YWwgcmVxdWVzdCBjb3VudGVyc1xyXG4gICAgICAgIHZhciBsYXN0UmVxdWVzdHMgPSB0aGlzLl9sYXN0UmVxdWVzdHM7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RzID0ge1xyXG4gICAgICAgICAgICB0b3RhbFJlcXVlc3RDb3VudDogQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5fdG90YWxSZXF1ZXN0Q291bnQsXHJcbiAgICAgICAgICAgIHRvdGFsRmFpbGVkUmVxdWVzdENvdW50OiBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl90b3RhbEZhaWxlZFJlcXVlc3RDb3VudCxcclxuICAgICAgICAgICAgdGltZTogK25ldyBEYXRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxSZXF1ZXN0cyA9IChyZXF1ZXN0cy50b3RhbFJlcXVlc3RDb3VudCAtIGxhc3RSZXF1ZXN0cy50b3RhbFJlcXVlc3RDb3VudCkgfHwgMDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWxGYWlsZWRSZXF1ZXN0cyA9IChyZXF1ZXN0cy50b3RhbEZhaWxlZFJlcXVlc3RDb3VudCAtIGxhc3RSZXF1ZXN0cy50b3RhbEZhaWxlZFJlcXVlc3RDb3VudCkgfHwgMDtcclxuICAgICAgICB2YXIgZWxhcHNlZE1zID0gcmVxdWVzdHMudGltZSAtIGxhc3RSZXF1ZXN0cy50aW1lO1xyXG4gICAgICAgIHZhciBlbGFwc2VkU2Vjb25kcyA9IGVsYXBzZWRNcyAvIDEwMDA7XHJcbiAgICAgICAgaWYgKGVsYXBzZWRNcyA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RzUGVyU2VjID0gaW50ZXJ2YWxSZXF1ZXN0cyAvIGVsYXBzZWRTZWNvbmRzO1xyXG4gICAgICAgICAgICB2YXIgZmFpbGVkUmVxdWVzdHNQZXJTZWMgPSBpbnRlcnZhbEZhaWxlZFJlcXVlc3RzIC8gZWxhcHNlZFNlY29uZHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC50cmFja01ldHJpYyh7IG5hbWU6IFwiXFxcXEFTUC5ORVQgQXBwbGljYXRpb25zKD8/QVBQX1czU1ZDX1BST0M/PylcXFxcUmVxdWVzdHMvU2VjXCIsIHZhbHVlOiByZXF1ZXN0c1BlclNlYyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnRyYWNrTWV0cmljKHsgbmFtZTogXCJcXFxcQVNQLk5FVCBBcHBsaWNhdGlvbnMoPz9BUFBfVzNTVkNfUFJPQz8/KVxcXFxSZXF1ZXN0IEV4ZWN1dGlvbiBUaW1lXCIsIHZhbHVlOiBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl9sYXN0UmVxdWVzdEV4ZWN1dGlvblRpbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0cyA9IHJlcXVlc3RzO1xyXG4gICAgfTtcclxuICAgIEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgQXV0b0NvbGxlY3RQZXJmb3JtYW5jZS5JTlNUQU5DRSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGUoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl90b3RhbFJlcXVlc3RDb3VudCA9IDA7XHJcbiAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl90b3RhbEZhaWxlZFJlcXVlc3RDb3VudCA9IDA7XHJcbiAgICBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlLl9sYXN0UmVxdWVzdEV4ZWN1dGlvblRpbWUgPSAwO1xyXG4gICAgcmV0dXJuIEF1dG9Db2xsZWN0UGVyZm9ybWFuY2U7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQXV0b0NvbGxlY3RQZXJmb3JtYW5jZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVyZm9ybWFuY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/Performance.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/RequestParser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/RequestParser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Base class for helpers that read data from HTTP requst/response objects and convert them\r\n * into the telemetry contract objects.\r\n */\r\nvar RequestParser = (function () {\r\n    function RequestParser() {\r\n    }\r\n    /**\r\n     * Gets a url parsed out from request options\r\n     */\r\n    RequestParser.prototype.getUrl = function () {\r\n        return this.url;\r\n    };\r\n    RequestParser.prototype.RequestParser = function () {\r\n        this.startTime = +new Date();\r\n    };\r\n    RequestParser.prototype._setStatus = function (status, error) {\r\n        var endTime = +new Date();\r\n        this.duration = endTime - this.startTime;\r\n        this.statusCode = status;\r\n        var properties = this.properties || {};\r\n        if (error) {\r\n            if (typeof error === \"string\") {\r\n                properties[\"error\"] = error;\r\n            }\r\n            else if (error instanceof Error) {\r\n                properties[\"error\"] = error.message;\r\n            }\r\n            else if (typeof error === \"object\") {\r\n                for (var key in error) {\r\n                    properties[key] = error[key] && error[key].toString && error[key].toString();\r\n                }\r\n            }\r\n        }\r\n        this.properties = properties;\r\n    };\r\n    RequestParser.prototype._isSuccess = function () {\r\n        return (0 < this.statusCode) && (this.statusCode < 400);\r\n    };\r\n    return RequestParser;\r\n}());\r\nmodule.exports = RequestParser;\r\n//# sourceMappingURL=RequestParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vUmVxdWVzdFBhcnNlci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vUmVxdWVzdFBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGhlbHBlcnMgdGhhdCByZWFkIGRhdGEgZnJvbSBIVFRQIHJlcXVzdC9yZXNwb25zZSBvYmplY3RzIGFuZCBjb252ZXJ0IHRoZW1cclxuICogaW50byB0aGUgdGVsZW1ldHJ5IGNvbnRyYWN0IG9iamVjdHMuXHJcbiAqL1xyXG52YXIgUmVxdWVzdFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXF1ZXN0UGFyc2VyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdXJsIHBhcnNlZCBvdXQgZnJvbSByZXF1ZXN0IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgUmVxdWVzdFBhcnNlci5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcclxuICAgIH07XHJcbiAgICBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5SZXF1ZXN0UGFyc2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgUmVxdWVzdFBhcnNlci5wcm90b3R5cGUuX3NldFN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGVuZFRpbWUgPSArbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcclxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcyB8fCB7fTtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tcImVycm9yXCJdID0gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tcImVycm9yXCJdID0gZXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGVycm9yW2tleV0gJiYgZXJyb3Jba2V5XS50b1N0cmluZyAmJiBlcnJvcltrZXldLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuICAgIH07XHJcbiAgICBSZXF1ZXN0UGFyc2VyLnByb3RvdHlwZS5faXNTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoMCA8IHRoaXMuc3RhdHVzQ29kZSkgJiYgKHRoaXMuc3RhdHVzQ29kZSA8IDQwMCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlcXVlc3RQYXJzZXI7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFBhcnNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVxdWVzdFBhcnNlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/RequestParser.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\n// Mapping from bunyan levels defined at https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L256\r\nvar bunyanToAILevelMap = {\r\n    10: Contracts_1.SeverityLevel.Verbose,\r\n    20: Contracts_1.SeverityLevel.Verbose,\r\n    30: Contracts_1.SeverityLevel.Information,\r\n    40: Contracts_1.SeverityLevel.Warning,\r\n    50: Contracts_1.SeverityLevel.Error,\r\n    60: Contracts_1.SeverityLevel.Critical,\r\n};\r\nvar subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var AIlevel = bunyanToAILevelMap[event.data.level];\r\n        client.trackTrace({ message: event.data.result, severity: AIlevel });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"bunyan\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"bunyan\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=bunyan.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL2J1bnlhbi5zdWIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0F1dG9Db2xsZWN0aW9uL2RpYWdub3N0aWMtY2hhbm5lbC9idW55YW4uc3ViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBDb250cmFjdHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9EZWNsYXJhdGlvbnMvQ29udHJhY3RzXCIpO1xyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgY2xpZW50cyA9IFtdO1xyXG4vLyBNYXBwaW5nIGZyb20gYnVueWFuIGxldmVscyBkZWZpbmVkIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS90cmVudG0vbm9kZS1idW55YW4vYmxvYi9tYXN0ZXIvbGliL2J1bnlhbi5qcyNMMjU2XHJcbnZhciBidW55YW5Ub0FJTGV2ZWxNYXAgPSB7XHJcbiAgICAxMDogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5WZXJib3NlLFxyXG4gICAgMjA6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuVmVyYm9zZSxcclxuICAgIDMwOiBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLkluZm9ybWF0aW9uLFxyXG4gICAgNDA6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuV2FybmluZyxcclxuICAgIDUwOiBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLkVycm9yLFxyXG4gICAgNjA6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuQ3JpdGljYWwsXHJcbn07XHJcbnZhciBzdWJzY3JpYmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xyXG4gICAgICAgIHZhciBBSWxldmVsID0gYnVueWFuVG9BSUxldmVsTWFwW2V2ZW50LmRhdGEubGV2ZWxdO1xyXG4gICAgICAgIGNsaWVudC50cmFja1RyYWNlKHsgbWVzc2FnZTogZXZlbnQuZGF0YS5yZXN1bHQsIHNldmVyaXR5OiBBSWxldmVsIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZShlbmFibGVkLCBjbGllbnQpIHtcclxuICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuc3Vic2NyaWJlKFwiYnVueWFuXCIsIHN1YnNjcmliZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgY2xpZW50cy5wdXNoKGNsaWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjbGllbnRzID0gY2xpZW50cy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT0gY2xpZW50OyB9KTtcclxuICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC51bnN1YnNjcmliZShcImJ1bnlhblwiLCBzdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bnlhbi5zdWIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nvar subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        // Message can have a trailing newline\r\n        var message = event.data.message;\r\n        if (message.lastIndexOf(\"\\n\") == message.length - 1) {\r\n            message = message.substring(0, message.length - 1);\r\n        }\r\n        client.trackTrace({ message: message, severity: (event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information) });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"console\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"console\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=console.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL2NvbnNvbGUuc3ViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9BdXRvQ29sbGVjdGlvbi9kaWFnbm9zdGljLWNoYW5uZWwvY29uc29sZS5zdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIENvbnRyYWN0c18xID0gcmVxdWlyZShcIi4uLy4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbnZhciBkaWFnbm9zdGljX2NoYW5uZWxfMSA9IHJlcXVpcmUoXCJkaWFnbm9zdGljLWNoYW5uZWxcIik7XHJcbnZhciBjbGllbnRzID0gW107XHJcbnZhciBzdWJzY3JpYmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xyXG4gICAgICAgIC8vIE1lc3NhZ2UgY2FuIGhhdmUgYSB0cmFpbGluZyBuZXdsaW5lXHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UubGFzdEluZGV4T2YoXCJcXG5cIikgPT0gbWVzc2FnZS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnN1YnN0cmluZygwLCBtZXNzYWdlLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGllbnQudHJhY2tUcmFjZSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIHNldmVyaXR5OiAoZXZlbnQuZGF0YS5zdGRlcnIgPyBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLldhcm5pbmcgOiBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLkluZm9ybWF0aW9uKSB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoZW5hYmxlZCwgY2xpZW50KSB7XHJcbiAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnN1YnNjcmliZShcImNvbnNvbGVcIiwgc3Vic2NyaWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNsaWVudHMgPSBjbGllbnRzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPSBjbGllbnQ7IH0pO1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnVuc3Vic2NyaWJlKFwiY29uc29sZVwiLCBzdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnNvbGUuc3ViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IsInitialized = !process.env[\"APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL\"];\r\nif (exports.IsInitialized) {\r\n    var publishers = __webpack_require__(/*! diagnostic-channel-publishers */ \"./node_modules/diagnostic-channel-publishers/dist/src/index.js\");\r\n    var individualOptOuts = process.env[\"APPLICATION_INSIGHTS_NO_PATCH_MODULES\"] || \"\";\r\n    var unpatchedModules = individualOptOuts.split(\",\");\r\n    var modules = {\r\n        bunyan: publishers.bunyan,\r\n        console: publishers.console,\r\n        mongodb: publishers.mongodb,\r\n        mongodbCore: publishers.mongodbCore,\r\n        mysql: publishers.mysql,\r\n        redis: publishers.redis,\r\n        pg: publishers.pg,\r\n        pgPool: publishers.pgPool,\r\n        winston: publishers.winston\r\n    };\r\n    for (var mod in modules) {\r\n        if (unpatchedModules.indexOf(mod) === -1) {\r\n            modules[mod].enable();\r\n        }\r\n    }\r\n}\r\nfunction registerContextPreservation(cb) {\r\n    if (!exports.IsInitialized) {\r\n        return;\r\n    }\r\n    __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\").channel.addContextPreservation(cb);\r\n}\r\nexports.registerContextPreservation = registerContextPreservation;\r\n//# sourceMappingURL=initialization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL2luaXRpYWxpemF0aW9uLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9BdXRvQ29sbGVjdGlvbi9kaWFnbm9zdGljLWNoYW5uZWwvaW5pdGlhbGl6YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLklzSW5pdGlhbGl6ZWQgPSAhcHJvY2Vzcy5lbnZbXCJBUFBMSUNBVElPTl9JTlNJR0hUU19OT19ESUFHTk9TVElDX0NIQU5ORUxcIl07XHJcbmlmIChleHBvcnRzLklzSW5pdGlhbGl6ZWQpIHtcclxuICAgIHZhciBwdWJsaXNoZXJzID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzXCIpO1xyXG4gICAgdmFyIGluZGl2aWR1YWxPcHRPdXRzID0gcHJvY2Vzcy5lbnZbXCJBUFBMSUNBVElPTl9JTlNJR0hUU19OT19QQVRDSF9NT0RVTEVTXCJdIHx8IFwiXCI7XHJcbiAgICB2YXIgdW5wYXRjaGVkTW9kdWxlcyA9IGluZGl2aWR1YWxPcHRPdXRzLnNwbGl0KFwiLFwiKTtcclxuICAgIHZhciBtb2R1bGVzID0ge1xyXG4gICAgICAgIGJ1bnlhbjogcHVibGlzaGVycy5idW55YW4sXHJcbiAgICAgICAgY29uc29sZTogcHVibGlzaGVycy5jb25zb2xlLFxyXG4gICAgICAgIG1vbmdvZGI6IHB1Ymxpc2hlcnMubW9uZ29kYixcclxuICAgICAgICBtb25nb2RiQ29yZTogcHVibGlzaGVycy5tb25nb2RiQ29yZSxcclxuICAgICAgICBteXNxbDogcHVibGlzaGVycy5teXNxbCxcclxuICAgICAgICByZWRpczogcHVibGlzaGVycy5yZWRpcyxcclxuICAgICAgICBwZzogcHVibGlzaGVycy5wZyxcclxuICAgICAgICBwZ1Bvb2w6IHB1Ymxpc2hlcnMucGdQb29sLFxyXG4gICAgICAgIHdpbnN0b246IHB1Ymxpc2hlcnMud2luc3RvblxyXG4gICAgfTtcclxuICAgIGZvciAodmFyIG1vZCBpbiBtb2R1bGVzKSB7XHJcbiAgICAgICAgaWYgKHVucGF0Y2hlZE1vZHVsZXMuaW5kZXhPZihtb2QpID09PSAtMSkge1xyXG4gICAgICAgICAgICBtb2R1bGVzW21vZF0uZW5hYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dFByZXNlcnZhdGlvbihjYikge1xyXG4gICAgaWYgKCFleHBvcnRzLklzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpLmNoYW5uZWwuYWRkQ29udGV4dFByZXNlcnZhdGlvbihjYik7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3RlckNvbnRleHRQcmVzZXJ2YXRpb24gPSByZWdpc3RlckNvbnRleHRQcmVzZXJ2YXRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRpYWxpemF0aW9uLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var dbName = (event.data.startedData && event.data.startedData.databaseName) || \"Unknown database\";\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: event.data.event.commandName,\r\n            name: event.data.event.commandName,\r\n            duration: event.data.event.duration,\r\n            success: event.data.succeeded,\r\n            /* TODO: transmit result code from mongo */\r\n            resultCode: event.data.succeeded ? \"0\" : \"1\",\r\n            dependencyTypeName: 'mongodb'\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL21vbmdvZGIuc3ViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9BdXRvQ29sbGVjdGlvbi9kaWFnbm9zdGljLWNoYW5uZWwvbW9uZ29kYi5zdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGRpYWdub3N0aWNfY2hhbm5lbF8xID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbFwiKTtcclxudmFyIGNsaWVudHMgPSBbXTtcclxuZXhwb3J0cy5zdWJzY3JpYmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xyXG4gICAgICAgIHZhciBkYk5hbWUgPSAoZXZlbnQuZGF0YS5zdGFydGVkRGF0YSAmJiBldmVudC5kYXRhLnN0YXJ0ZWREYXRhLmRhdGFiYXNlTmFtZSkgfHwgXCJVbmtub3duIGRhdGFiYXNlXCI7XHJcbiAgICAgICAgY2xpZW50LnRyYWNrRGVwZW5kZW5jeSh7XHJcbiAgICAgICAgICAgIHRhcmdldDogZGJOYW1lLFxyXG4gICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmV2ZW50LmNvbW1hbmROYW1lLFxyXG4gICAgICAgICAgICBuYW1lOiBldmVudC5kYXRhLmV2ZW50LmNvbW1hbmROYW1lLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogZXZlbnQuZGF0YS5ldmVudC5kdXJhdGlvbixcclxuICAgICAgICAgICAgc3VjY2VzczogZXZlbnQuZGF0YS5zdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIC8qIFRPRE86IHRyYW5zbWl0IHJlc3VsdCBjb2RlIGZyb20gbW9uZ28gKi9cclxuICAgICAgICAgICAgcmVzdWx0Q29kZTogZXZlbnQuZGF0YS5zdWNjZWVkZWQgPyBcIjBcIiA6IFwiMVwiLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmN5VHlwZU5hbWU6ICdtb25nb2RiJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZShlbmFibGVkLCBjbGllbnQpIHtcclxuICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuc3Vic2NyaWJlKFwibW9uZ29kYlwiLCBleHBvcnRzLnN1YnNjcmliZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgY2xpZW50cy5wdXNoKGNsaWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjbGllbnRzID0gY2xpZW50cy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT0gY2xpZW50OyB9KTtcclxuICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC51bnN1YnNjcmliZShcIm1vbmdvZGJcIiwgZXhwb3J0cy5zdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbmdvZGIuc3ViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var queryObj = event.data.query || {};\r\n        var sqlString = queryObj.sql || \"Unknown query\";\r\n        var success = !event.data.err;\r\n        var connection = queryObj._connection || {};\r\n        var connectionConfig = connection.config || {};\r\n        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || \"localhost\") + \":\" + connectionConfig.port;\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: sqlString,\r\n            name: sqlString,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            /* TODO: transmit result code from mysql */\r\n            resultCode: success ? \"0\" : \"1\",\r\n            dependencyTypeName: \"mysql\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mysql\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mysql\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mysql.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL215c3FsLnN1Yi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL215c3FsLnN1Yi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgY2xpZW50cyA9IFtdO1xyXG5leHBvcnRzLnN1YnNjcmliZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5T2JqID0gZXZlbnQuZGF0YS5xdWVyeSB8fCB7fTtcclxuICAgICAgICB2YXIgc3FsU3RyaW5nID0gcXVlcnlPYmouc3FsIHx8IFwiVW5rbm93biBxdWVyeVwiO1xyXG4gICAgICAgIHZhciBzdWNjZXNzID0gIWV2ZW50LmRhdGEuZXJyO1xyXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gcXVlcnlPYmouX2Nvbm5lY3Rpb24gfHwge307XHJcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uLmNvbmZpZyB8fCB7fTtcclxuICAgICAgICB2YXIgZGJOYW1lID0gY29ubmVjdGlvbkNvbmZpZy5zb2NrZXRQYXRoID8gY29ubmVjdGlvbkNvbmZpZy5zb2NrZXRQYXRoIDogKGNvbm5lY3Rpb25Db25maWcuaG9zdCB8fCBcImxvY2FsaG9zdFwiKSArIFwiOlwiICsgY29ubmVjdGlvbkNvbmZpZy5wb3J0O1xyXG4gICAgICAgIGNsaWVudC50cmFja0RlcGVuZGVuY3koe1xyXG4gICAgICAgICAgICB0YXJnZXQ6IGRiTmFtZSxcclxuICAgICAgICAgICAgZGF0YTogc3FsU3RyaW5nLFxyXG4gICAgICAgICAgICBuYW1lOiBzcWxTdHJpbmcsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBldmVudC5kYXRhLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAvKiBUT0RPOiB0cmFuc21pdCByZXN1bHQgY29kZSBmcm9tIG15c3FsICovXHJcbiAgICAgICAgICAgIHJlc3VsdENvZGU6IHN1Y2Nlc3MgPyBcIjBcIiA6IFwiMVwiLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmN5VHlwZU5hbWU6IFwibXlzcWxcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZShlbmFibGVkLCBjbGllbnQpIHtcclxuICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuc3Vic2NyaWJlKFwibXlzcWxcIiwgZXhwb3J0cy5zdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2xpZW50cyA9IGNsaWVudHMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9IGNsaWVudDsgfSk7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwudW5zdWJzY3JpYmUoXCJteXNxbFwiLCBleHBvcnRzLnN1YnNjcmliZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXlzcWwuc3ViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var q = event.data.query;\r\n        var sql = (q.preparable && q.preparable.text) || q.plan || q.text || \"unknown query\";\r\n        var success = !event.data.error;\r\n        var conn = event.data.database.host + \":\" + event.data.database.port;\r\n        client.trackDependency({\r\n            target: conn,\r\n            data: sql,\r\n            name: sql,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            resultCode: success ? \"0\" : \"1\",\r\n            dependencyTypeName: \"postgres\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"postgres\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"postgres\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=postgres.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL3Bvc3RncmVzLnN1Yi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL3Bvc3RncmVzLnN1Yi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgY2xpZW50cyA9IFtdO1xyXG5leHBvcnRzLnN1YnNjcmliZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XHJcbiAgICAgICAgdmFyIHEgPSBldmVudC5kYXRhLnF1ZXJ5O1xyXG4gICAgICAgIHZhciBzcWwgPSAocS5wcmVwYXJhYmxlICYmIHEucHJlcGFyYWJsZS50ZXh0KSB8fCBxLnBsYW4gfHwgcS50ZXh0IHx8IFwidW5rbm93biBxdWVyeVwiO1xyXG4gICAgICAgIHZhciBzdWNjZXNzID0gIWV2ZW50LmRhdGEuZXJyb3I7XHJcbiAgICAgICAgdmFyIGNvbm4gPSBldmVudC5kYXRhLmRhdGFiYXNlLmhvc3QgKyBcIjpcIiArIGV2ZW50LmRhdGEuZGF0YWJhc2UucG9ydDtcclxuICAgICAgICBjbGllbnQudHJhY2tEZXBlbmRlbmN5KHtcclxuICAgICAgICAgICAgdGFyZ2V0OiBjb25uLFxyXG4gICAgICAgICAgICBkYXRhOiBzcWwsXHJcbiAgICAgICAgICAgIG5hbWU6IHNxbCxcclxuICAgICAgICAgICAgZHVyYXRpb246IGV2ZW50LmRhdGEuZHVyYXRpb24sXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgIHJlc3VsdENvZGU6IHN1Y2Nlc3MgPyBcIjBcIiA6IFwiMVwiLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmN5VHlwZU5hbWU6IFwicG9zdGdyZXNcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZShlbmFibGVkLCBjbGllbnQpIHtcclxuICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuc3Vic2NyaWJlKFwicG9zdGdyZXNcIiwgZXhwb3J0cy5zdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2xpZW50cyA9IGNsaWVudHMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICE9IGNsaWVudDsgfSk7XHJcbiAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwudW5zdWJzY3JpYmUoXCJwb3N0Z3Jlc1wiLCBleHBvcnRzLnN1YnNjcmliZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zdGdyZXMuc3ViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        if (event.data.commandObj.command === \"info\") {\r\n            // We don't want to report 'info', it's irrelevant\r\n            return;\r\n        }\r\n        client.trackDependency({\r\n            target: event.data.address,\r\n            name: event.data.commandObj.command,\r\n            data: event.data.commandObj.command,\r\n            duration: event.data.duration,\r\n            success: !event.data.err,\r\n            /* TODO: transmit result code from redis */\r\n            resultCode: event.data.err ? \"1\" : \"0\",\r\n            dependencyTypeName: \"redis\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"redis\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"redis\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=redis.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL3JlZGlzLnN1Yi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL3JlZGlzLnN1Yi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgY2xpZW50cyA9IFtdO1xyXG5leHBvcnRzLnN1YnNjcmliZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2xpZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuY29tbWFuZE9iai5jb21tYW5kID09PSBcImluZm9cIikge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlcG9ydCAnaW5mbycsIGl0J3MgaXJyZWxldmFudFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsaWVudC50cmFja0RlcGVuZGVuY3koe1xyXG4gICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LmRhdGEuYWRkcmVzcyxcclxuICAgICAgICAgICAgbmFtZTogZXZlbnQuZGF0YS5jb21tYW5kT2JqLmNvbW1hbmQsXHJcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuY29tbWFuZE9iai5jb21tYW5kLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogZXZlbnQuZGF0YS5kdXJhdGlvbixcclxuICAgICAgICAgICAgc3VjY2VzczogIWV2ZW50LmRhdGEuZXJyLFxyXG4gICAgICAgICAgICAvKiBUT0RPOiB0cmFuc21pdCByZXN1bHQgY29kZSBmcm9tIHJlZGlzICovXHJcbiAgICAgICAgICAgIHJlc3VsdENvZGU6IGV2ZW50LmRhdGEuZXJyID8gXCIxXCIgOiBcIjBcIixcclxuICAgICAgICAgICAgZGVwZW5kZW5jeVR5cGVOYW1lOiBcInJlZGlzXCJcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoZW5hYmxlZCwgY2xpZW50KSB7XHJcbiAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnN1YnNjcmliZShcInJlZGlzXCIsIGV4cG9ydHMuc3Vic2NyaWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNsaWVudHMgPSBjbGllbnRzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPSBjbGllbnQ7IH0pO1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnVuc3Vic2NyaWJlKFwicmVkaXNcIiwgZXhwb3J0cy5zdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlzLnN1Yi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = __webpack_require__(/*! ../../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar clients = [];\r\nvar winstonToAILevelMap = {\r\n    syslog: function (og) {\r\n        var map = {\r\n            emerg: Contracts_1.SeverityLevel.Critical,\r\n            alert: Contracts_1.SeverityLevel.Critical,\r\n            crit: Contracts_1.SeverityLevel.Critical,\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warning: Contracts_1.SeverityLevel.Warning,\r\n            notice: Contracts_1.SeverityLevel.Information,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            debug: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    npm: function (og) {\r\n        var map = {\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warn: Contracts_1.SeverityLevel.Warning,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            verbose: Contracts_1.SeverityLevel.Verbose,\r\n            debug: Contracts_1.SeverityLevel.Verbose,\r\n            silly: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    unknown: function (og) {\r\n        return Contracts_1.SeverityLevel.Information;\r\n    }\r\n};\r\nvar subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);\r\n        client.trackTrace({\r\n            message: event.data.message,\r\n            severity: AIlevel,\r\n            properties: event.data.meta\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"winston\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"winston\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=winston.sub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvQXV0b0NvbGxlY3Rpb24vZGlhZ25vc3RpYy1jaGFubmVsL3dpbnN0b24uc3ViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9BdXRvQ29sbGVjdGlvbi9kaWFnbm9zdGljLWNoYW5uZWwvd2luc3Rvbi5zdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIENvbnRyYWN0c18xID0gcmVxdWlyZShcIi4uLy4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbnZhciBkaWFnbm9zdGljX2NoYW5uZWxfMSA9IHJlcXVpcmUoXCJkaWFnbm9zdGljLWNoYW5uZWxcIik7XHJcbnZhciBjbGllbnRzID0gW107XHJcbnZhciB3aW5zdG9uVG9BSUxldmVsTWFwID0ge1xyXG4gICAgc3lzbG9nOiBmdW5jdGlvbiAob2cpIHtcclxuICAgICAgICB2YXIgbWFwID0ge1xyXG4gICAgICAgICAgICBlbWVyZzogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5Dcml0aWNhbCxcclxuICAgICAgICAgICAgYWxlcnQ6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuQ3JpdGljYWwsXHJcbiAgICAgICAgICAgIGNyaXQ6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuQ3JpdGljYWwsXHJcbiAgICAgICAgICAgIGVycm9yOiBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLkVycm9yLFxyXG4gICAgICAgICAgICB3YXJuaW5nOiBDb250cmFjdHNfMS5TZXZlcml0eUxldmVsLldhcm5pbmcsXHJcbiAgICAgICAgICAgIG5vdGljZTogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5JbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgaW5mbzogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5JbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgZGVidWc6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuVmVyYm9zZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1hcFtvZ10gPT09IHVuZGVmaW5lZCA/IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuSW5mb3JtYXRpb24gOiBtYXBbb2ddO1xyXG4gICAgfSxcclxuICAgIG5wbTogZnVuY3Rpb24gKG9nKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuRXJyb3IsXHJcbiAgICAgICAgICAgIHdhcm46IENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuV2FybmluZyxcclxuICAgICAgICAgICAgaW5mbzogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5JbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgdmVyYm9zZTogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5WZXJib3NlLFxyXG4gICAgICAgICAgICBkZWJ1ZzogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5WZXJib3NlLFxyXG4gICAgICAgICAgICBzaWxseTogQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5WZXJib3NlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbWFwW29nXSA9PT0gdW5kZWZpbmVkID8gQ29udHJhY3RzXzEuU2V2ZXJpdHlMZXZlbC5JbmZvcm1hdGlvbiA6IG1hcFtvZ107XHJcbiAgICB9LFxyXG4gICAgdW5rbm93bjogZnVuY3Rpb24gKG9nKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbnRyYWN0c18xLlNldmVyaXR5TGV2ZWwuSW5mb3JtYXRpb247XHJcbiAgICB9XHJcbn07XHJcbnZhciBzdWJzY3JpYmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xyXG4gICAgICAgIHZhciBBSWxldmVsID0gd2luc3RvblRvQUlMZXZlbE1hcFtldmVudC5kYXRhLmxldmVsS2luZF0oZXZlbnQuZGF0YS5sZXZlbCk7XHJcbiAgICAgICAgY2xpZW50LnRyYWNrVHJhY2Uoe1xyXG4gICAgICAgICAgICBtZXNzYWdlOiBldmVudC5kYXRhLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiBBSWxldmVsLFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBldmVudC5kYXRhLm1ldGFcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoZW5hYmxlZCwgY2xpZW50KSB7XHJcbiAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnN1YnNjcmliZShcIndpbnN0b25cIiwgc3Vic2NyaWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNsaWVudHMgPSBjbGllbnRzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPSBjbGllbnQ7IH0pO1xyXG4gICAgICAgIGlmIChjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnVuc3Vic2NyaWJlKFwid2luc3RvblwiLCBzdWJzY3JpYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbnN0b24uc3ViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Constants.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Generated_1 = __webpack_require__(/*! ./Generated */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js\");\r\nvar RemoteDependencyDataConstants = (function () {\r\n    function RemoteDependencyDataConstants() {\r\n    }\r\n    RemoteDependencyDataConstants.TYPE_HTTP = \"Http\";\r\n    RemoteDependencyDataConstants.TYPE_AI = \"Http (tracked component)\";\r\n    return RemoteDependencyDataConstants;\r\n}());\r\nexports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\r\nfunction domainSupportsProperties(domain) {\r\n    return \"properties\" in domain ||\r\n        domain instanceof Generated_1.EventData ||\r\n        domain instanceof Generated_1.ExceptionData ||\r\n        domain instanceof Generated_1.MessageData ||\r\n        domain instanceof Generated_1.MetricData ||\r\n        domain instanceof Generated_1.PageViewData ||\r\n        domain instanceof Generated_1.RemoteDependencyData ||\r\n        domain instanceof Generated_1.RequestData;\r\n}\r\nexports.domainSupportsProperties = domainSupportsProperties;\r\n//# sourceMappingURL=Constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9Db25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvQ29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBHZW5lcmF0ZWRfMSA9IHJlcXVpcmUoXCIuL0dlbmVyYXRlZFwiKTtcclxudmFyIFJlbW90ZURlcGVuZGVuY3lEYXRhQ29uc3RhbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbW90ZURlcGVuZGVuY3lEYXRhQ29uc3RhbnRzKCkge1xyXG4gICAgfVxyXG4gICAgUmVtb3RlRGVwZW5kZW5jeURhdGFDb25zdGFudHMuVFlQRV9IVFRQID0gXCJIdHRwXCI7XHJcbiAgICBSZW1vdGVEZXBlbmRlbmN5RGF0YUNvbnN0YW50cy5UWVBFX0FJID0gXCJIdHRwICh0cmFja2VkIGNvbXBvbmVudClcIjtcclxuICAgIHJldHVybiBSZW1vdGVEZXBlbmRlbmN5RGF0YUNvbnN0YW50cztcclxufSgpKTtcclxuZXhwb3J0cy5SZW1vdGVEZXBlbmRlbmN5RGF0YUNvbnN0YW50cyA9IFJlbW90ZURlcGVuZGVuY3lEYXRhQ29uc3RhbnRzO1xyXG5mdW5jdGlvbiBkb21haW5TdXBwb3J0c1Byb3BlcnRpZXMoZG9tYWluKSB7XHJcbiAgICByZXR1cm4gXCJwcm9wZXJ0aWVzXCIgaW4gZG9tYWluIHx8XHJcbiAgICAgICAgZG9tYWluIGluc3RhbmNlb2YgR2VuZXJhdGVkXzEuRXZlbnREYXRhIHx8XHJcbiAgICAgICAgZG9tYWluIGluc3RhbmNlb2YgR2VuZXJhdGVkXzEuRXhjZXB0aW9uRGF0YSB8fFxyXG4gICAgICAgIGRvbWFpbiBpbnN0YW5jZW9mIEdlbmVyYXRlZF8xLk1lc3NhZ2VEYXRhIHx8XHJcbiAgICAgICAgZG9tYWluIGluc3RhbmNlb2YgR2VuZXJhdGVkXzEuTWV0cmljRGF0YSB8fFxyXG4gICAgICAgIGRvbWFpbiBpbnN0YW5jZW9mIEdlbmVyYXRlZF8xLlBhZ2VWaWV3RGF0YSB8fFxyXG4gICAgICAgIGRvbWFpbiBpbnN0YW5jZW9mIEdlbmVyYXRlZF8xLlJlbW90ZURlcGVuZGVuY3lEYXRhIHx8XHJcbiAgICAgICAgZG9tYWluIGluc3RhbmNlb2YgR2VuZXJhdGVkXzEuUmVxdWVzdERhdGE7XHJcbn1cclxuZXhwb3J0cy5kb21haW5TdXBwb3J0c1Byb3BlcnRpZXMgPSBkb21haW5TdXBwb3J0c1Byb3BlcnRpZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnN0YW50cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Constants.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * Instances of AvailabilityData represent the result of executing an availability test.\r\n */\r\nvar AvailabilityData = (function (_super) {\r\n    __extends(AvailabilityData, _super);\r\n    function AvailabilityData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return AvailabilityData;\r\n}(Domain));\r\nmodule.exports = AvailabilityData;\r\n//# sourceMappingURL=AvailabilityData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvQXZhaWxhYmlsaXR5RGF0YS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvQXZhaWxhYmlsaXR5RGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG52YXIgRG9tYWluID0gcmVxdWlyZShcIi4vRG9tYWluXCIpO1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEluc3RhbmNlcyBvZiBBdmFpbGFiaWxpdHlEYXRhIHJlcHJlc2VudCB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBhbiBhdmFpbGFiaWxpdHkgdGVzdC5cclxuICovXHJcbnZhciBBdmFpbGFiaWxpdHlEYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBdmFpbGFiaWxpdHlEYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXZhaWxhYmlsaXR5RGF0YSgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnZlciA9IDI7XHJcbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm1lYXN1cmVtZW50cyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBBdmFpbGFiaWxpdHlEYXRhO1xyXG59KERvbWFpbikpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEF2YWlsYWJpbGl0eURhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF2YWlsYWJpbGl0eURhdGEuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\n/**\r\n * Data struct to contain only C section with custom fields.\r\n */\r\nvar Base = (function () {\r\n    function Base() {\r\n    }\r\n    return Base;\r\n}());\r\nmodule.exports = Base;\r\n//# sourceMappingURL=Base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvQmFzZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvQmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBEYXRhIHN0cnVjdCB0byBjb250YWluIG9ubHkgQyBzZWN0aW9uIHdpdGggY3VzdG9tIGZpZWxkcy5cclxuICovXHJcbnZhciBCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2UoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmFzZTtcclxufSgpKTtcclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\nvar ContextTagKeys = (function () {\r\n    function ContextTagKeys() {\r\n        this.applicationVersion = \"ai.application.ver\";\r\n        this.deviceId = \"ai.device.id\";\r\n        this.deviceLocale = \"ai.device.locale\";\r\n        this.deviceModel = \"ai.device.model\";\r\n        this.deviceOEMName = \"ai.device.oemName\";\r\n        this.deviceOSVersion = \"ai.device.osVersion\";\r\n        this.deviceType = \"ai.device.type\";\r\n        this.locationIp = \"ai.location.ip\";\r\n        this.operationId = \"ai.operation.id\";\r\n        this.operationName = \"ai.operation.name\";\r\n        this.operationParentId = \"ai.operation.parentId\";\r\n        this.operationSyntheticSource = \"ai.operation.syntheticSource\";\r\n        this.operationCorrelationVector = \"ai.operation.correlationVector\";\r\n        this.sessionId = \"ai.session.id\";\r\n        this.sessionIsFirst = \"ai.session.isFirst\";\r\n        this.userAccountId = \"ai.user.accountId\";\r\n        this.userId = \"ai.user.id\";\r\n        this.userAuthUserId = \"ai.user.authUserId\";\r\n        this.cloudRole = \"ai.cloud.role\";\r\n        this.cloudRoleInstance = \"ai.cloud.roleInstance\";\r\n        this.internalSdkVersion = \"ai.internal.sdkVersion\";\r\n        this.internalAgentVersion = \"ai.internal.agentVersion\";\r\n        this.internalNodeName = \"ai.internal.nodeName\";\r\n    }\r\n    return ContextTagKeys;\r\n}());\r\nmodule.exports = ContextTagKeys;\r\n//# sourceMappingURL=ContextTagKeys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvQ29udGV4dFRhZ0tleXMuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL0NvbnRleHRUYWdLZXlzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG5cInVzZSBzdHJpY3RcIjtcclxudmFyIENvbnRleHRUYWdLZXlzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRleHRUYWdLZXlzKCkge1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZXJzaW9uID0gXCJhaS5hcHBsaWNhdGlvbi52ZXJcIjtcclxuICAgICAgICB0aGlzLmRldmljZUlkID0gXCJhaS5kZXZpY2UuaWRcIjtcclxuICAgICAgICB0aGlzLmRldmljZUxvY2FsZSA9IFwiYWkuZGV2aWNlLmxvY2FsZVwiO1xyXG4gICAgICAgIHRoaXMuZGV2aWNlTW9kZWwgPSBcImFpLmRldmljZS5tb2RlbFwiO1xyXG4gICAgICAgIHRoaXMuZGV2aWNlT0VNTmFtZSA9IFwiYWkuZGV2aWNlLm9lbU5hbWVcIjtcclxuICAgICAgICB0aGlzLmRldmljZU9TVmVyc2lvbiA9IFwiYWkuZGV2aWNlLm9zVmVyc2lvblwiO1xyXG4gICAgICAgIHRoaXMuZGV2aWNlVHlwZSA9IFwiYWkuZGV2aWNlLnR5cGVcIjtcclxuICAgICAgICB0aGlzLmxvY2F0aW9uSXAgPSBcImFpLmxvY2F0aW9uLmlwXCI7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25JZCA9IFwiYWkub3BlcmF0aW9uLmlkXCI7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25OYW1lID0gXCJhaS5vcGVyYXRpb24ubmFtZVwiO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uUGFyZW50SWQgPSBcImFpLm9wZXJhdGlvbi5wYXJlbnRJZFwiO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uU3ludGhldGljU291cmNlID0gXCJhaS5vcGVyYXRpb24uc3ludGhldGljU291cmNlXCI7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Db3JyZWxhdGlvblZlY3RvciA9IFwiYWkub3BlcmF0aW9uLmNvcnJlbGF0aW9uVmVjdG9yXCI7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBcImFpLnNlc3Npb24uaWRcIjtcclxuICAgICAgICB0aGlzLnNlc3Npb25Jc0ZpcnN0ID0gXCJhaS5zZXNzaW9uLmlzRmlyc3RcIjtcclxuICAgICAgICB0aGlzLnVzZXJBY2NvdW50SWQgPSBcImFpLnVzZXIuYWNjb3VudElkXCI7XHJcbiAgICAgICAgdGhpcy51c2VySWQgPSBcImFpLnVzZXIuaWRcIjtcclxuICAgICAgICB0aGlzLnVzZXJBdXRoVXNlcklkID0gXCJhaS51c2VyLmF1dGhVc2VySWRcIjtcclxuICAgICAgICB0aGlzLmNsb3VkUm9sZSA9IFwiYWkuY2xvdWQucm9sZVwiO1xyXG4gICAgICAgIHRoaXMuY2xvdWRSb2xlSW5zdGFuY2UgPSBcImFpLmNsb3VkLnJvbGVJbnN0YW5jZVwiO1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZGtWZXJzaW9uID0gXCJhaS5pbnRlcm5hbC5zZGtWZXJzaW9uXCI7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEFnZW50VmVyc2lvbiA9IFwiYWkuaW50ZXJuYWwuYWdlbnRWZXJzaW9uXCI7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbE5vZGVOYW1lID0gXCJhaS5pbnRlcm5hbC5ub2RlTmFtZVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbnRleHRUYWdLZXlzO1xyXG59KCkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHRUYWdLZXlzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250ZXh0VGFnS2V5cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Base = __webpack_require__(/*! ./Base */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js\");\r\n\"use strict\";\r\n/**\r\n * Data struct to contain both B and C sections.\r\n */\r\nvar Data = (function (_super) {\r\n    __extends(Data, _super);\r\n    function Data() {\r\n        return _super.call(this) || this;\r\n    }\r\n    return Data;\r\n}(Base));\r\nmodule.exports = Data;\r\n//# sourceMappingURL=Data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRGF0YS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuL0Jhc2VcIik7XHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogRGF0YSBzdHJ1Y3QgdG8gY29udGFpbiBib3RoIEIgYW5kIEMgc2VjdGlvbnMuXHJcbiAqL1xyXG52YXIgRGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRGF0YTtcclxufShCYXNlKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// THIS FILE WAS AUTOGENERATED\r\nvar DataPointType = __webpack_require__(/*! ./DataPointType */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js\");\r\n\"use strict\";\r\n/**\r\n * Metric data single measurement.\r\n */\r\nvar DataPoint = (function () {\r\n    function DataPoint() {\r\n        this.kind = DataPointType.Measurement;\r\n    }\r\n    return DataPoint;\r\n}());\r\nmodule.exports = DataPoint;\r\n//# sourceMappingURL=DataPoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRGF0YVBvaW50LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9EZWNsYXJhdGlvbnMvQ29udHJhY3RzL0dlbmVyYXRlZC9EYXRhUG9pbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG52YXIgRGF0YVBvaW50VHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFQb2ludFR5cGVcIik7XHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogTWV0cmljIGRhdGEgc2luZ2xlIG1lYXN1cmVtZW50LlxyXG4gKi9cclxudmFyIERhdGFQb2ludCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhUG9pbnQoKSB7XHJcbiAgICAgICAgdGhpcy5raW5kID0gRGF0YVBvaW50VHlwZS5NZWFzdXJlbWVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBEYXRhUG9pbnQ7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YVBvaW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhUG9pbnQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\n/**\r\n * Type of the metric data measurement.\r\n */\r\nvar DataPointType;\r\n(function (DataPointType) {\r\n    DataPointType[DataPointType[\"Measurement\"] = 0] = \"Measurement\";\r\n    DataPointType[DataPointType[\"Aggregation\"] = 1] = \"Aggregation\";\r\n})(DataPointType || (DataPointType = {}));\r\nmodule.exports = DataPointType;\r\n//# sourceMappingURL=DataPointType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRGF0YVBvaW50VHlwZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRGF0YVBvaW50VHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBUeXBlIG9mIHRoZSBtZXRyaWMgZGF0YSBtZWFzdXJlbWVudC5cclxuICovXHJcbnZhciBEYXRhUG9pbnRUeXBlO1xyXG4oZnVuY3Rpb24gKERhdGFQb2ludFR5cGUpIHtcclxuICAgIERhdGFQb2ludFR5cGVbRGF0YVBvaW50VHlwZVtcIk1lYXN1cmVtZW50XCJdID0gMF0gPSBcIk1lYXN1cmVtZW50XCI7XHJcbiAgICBEYXRhUG9pbnRUeXBlW0RhdGFQb2ludFR5cGVbXCJBZ2dyZWdhdGlvblwiXSA9IDFdID0gXCJBZ2dyZWdhdGlvblwiO1xyXG59KShEYXRhUG9pbnRUeXBlIHx8IChEYXRhUG9pbnRUeXBlID0ge30pKTtcclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUG9pbnRUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhUG9pbnRUeXBlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\n/**\r\n * The abstract common base of all domains.\r\n */\r\nvar Domain = (function () {\r\n    function Domain() {\r\n    }\r\n    return Domain;\r\n}());\r\nmodule.exports = Domain;\r\n//# sourceMappingURL=Domain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRG9tYWluLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9EZWNsYXJhdGlvbnMvQ29udHJhY3RzL0dlbmVyYXRlZC9Eb21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVEhJUyBGSUxFIFdBUyBBVVRPR0VORVJBVEVEXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogVGhlIGFic3RyYWN0IGNvbW1vbiBiYXNlIG9mIGFsbCBkb21haW5zLlxyXG4gKi9cclxudmFyIERvbWFpbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEb21haW4oKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRG9tYWluO1xyXG59KCkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IERvbWFpbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG9tYWluLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * System variables for a telemetry item.\r\n */\r\nvar Envelope = (function () {\r\n    function Envelope() {\r\n        this.ver = 1;\r\n        this.sampleRate = 100.0;\r\n        this.tags = {};\r\n    }\r\n    return Envelope;\r\n}());\r\nmodule.exports = Envelope;\r\n//# sourceMappingURL=Envelope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRW52ZWxvcGUuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL0VudmVsb3BlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogU3lzdGVtIHZhcmlhYmxlcyBmb3IgYSB0ZWxlbWV0cnkgaXRlbS5cclxuICovXHJcbnZhciBFbnZlbG9wZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnZlbG9wZSgpIHtcclxuICAgICAgICB0aGlzLnZlciA9IDE7XHJcbiAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gMTAwLjA7XHJcbiAgICAgICAgdGhpcy50YWdzID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW52ZWxvcGU7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gRW52ZWxvcGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVudmVsb3BlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.\r\n */\r\nvar EventData = (function (_super) {\r\n    __extends(EventData, _super);\r\n    function EventData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return EventData;\r\n}(Domain));\r\nmodule.exports = EventData;\r\n//# sourceMappingURL=EventData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRXZlbnREYXRhLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9EZWNsYXJhdGlvbnMvQ29udHJhY3RzL0dlbmVyYXRlZC9FdmVudERhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxudmFyIERvbWFpbiA9IHJlcXVpcmUoXCIuL0RvbWFpblwiKTtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBJbnN0YW5jZXMgb2YgRXZlbnQgcmVwcmVzZW50IHN0cnVjdHVyZWQgZXZlbnQgcmVjb3JkcyB0aGF0IGNhbiBiZSBncm91cGVkIGFuZCBzZWFyY2hlZCBieSB0aGVpciBwcm9wZXJ0aWVzLiBFdmVudCBkYXRhIGl0ZW0gYWxzbyBjcmVhdGVzIGEgbWV0cmljIG9mIGV2ZW50IGNvdW50IGJ5IG5hbWUuXHJcbiAqL1xyXG52YXIgRXZlbnREYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFdmVudERhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudERhdGEoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy52ZXIgPSAyO1xyXG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5tZWFzdXJlbWVudHMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRXZlbnREYXRhO1xyXG59KERvbWFpbikpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnREYXRhLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.\r\n */\r\nvar ExceptionData = (function (_super) {\r\n    __extends(ExceptionData, _super);\r\n    function ExceptionData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.exceptions = [];\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return ExceptionData;\r\n}(Domain));\r\nmodule.exports = ExceptionData;\r\n//# sourceMappingURL=ExceptionData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRXhjZXB0aW9uRGF0YS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRXhjZXB0aW9uRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG52YXIgRG9tYWluID0gcmVxdWlyZShcIi4vRG9tYWluXCIpO1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEFuIGluc3RhbmNlIG9mIEV4Y2VwdGlvbiByZXByZXNlbnRzIGEgaGFuZGxlZCBvciB1bmhhbmRsZWQgZXhjZXB0aW9uIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGUgbW9uaXRvcmVkIGFwcGxpY2F0aW9uLlxyXG4gKi9cclxudmFyIEV4Y2VwdGlvbkRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEV4Y2VwdGlvbkRhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFeGNlcHRpb25EYXRhKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudmVyID0gMjtcclxuICAgICAgICBfdGhpcy5leGNlcHRpb25zID0gW107XHJcbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm1lYXN1cmVtZW50cyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBFeGNlcHRpb25EYXRhO1xyXG59KERvbWFpbikpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2VwdGlvbkRhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4Y2VwdGlvbkRhdGEuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Exception details of the exception in a chain.\r\n */\r\nvar ExceptionDetails = (function () {\r\n    function ExceptionDetails() {\r\n        this.hasFullStack = true;\r\n        this.parsedStack = [];\r\n    }\r\n    return ExceptionDetails;\r\n}());\r\nmodule.exports = ExceptionDetails;\r\n//# sourceMappingURL=ExceptionDetails.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRXhjZXB0aW9uRGV0YWlscy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvRXhjZXB0aW9uRGV0YWlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEV4Y2VwdGlvbiBkZXRhaWxzIG9mIHRoZSBleGNlcHRpb24gaW4gYSBjaGFpbi5cclxuICovXHJcbnZhciBFeGNlcHRpb25EZXRhaWxzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4Y2VwdGlvbkRldGFpbHMoKSB7XHJcbiAgICAgICAgdGhpcy5oYXNGdWxsU3RhY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGFyc2VkU3RhY2sgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBFeGNlcHRpb25EZXRhaWxzO1xyXG59KCkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2VwdGlvbkRldGFpbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4Y2VwdGlvbkRldGFpbHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.\r\n */\r\nvar MessageData = (function (_super) {\r\n    __extends(MessageData, _super);\r\n    function MessageData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MessageData;\r\n}(Domain));\r\nmodule.exports = MessageData;\r\n//# sourceMappingURL=MessageData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvTWVzc2FnZURhdGEuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL01lc3NhZ2VEYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuLy8gVEhJUyBGSUxFIFdBUyBBVVRPR0VORVJBVEVEXHJcbnZhciBEb21haW4gPSByZXF1aXJlKFwiLi9Eb21haW5cIik7XHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogSW5zdGFuY2VzIG9mIE1lc3NhZ2UgcmVwcmVzZW50IHByaW50Zi1saWtlIHRyYWNlIHN0YXRlbWVudHMgdGhhdCBhcmUgdGV4dC1zZWFyY2hlZC4gTG9nNE5ldCwgTkxvZyBhbmQgb3RoZXIgdGV4dC1iYXNlZCBsb2cgZmlsZSBlbnRyaWVzIGFyZSB0cmFuc2xhdGVkIGludG8gaW50YW5jZXMgb2YgdGhpcyB0eXBlLiBUaGUgbWVzc2FnZSBkb2VzIG5vdCBoYXZlIG1lYXN1cmVtZW50cy5cclxuICovXHJcbnZhciBNZXNzYWdlRGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWVzc2FnZURhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlRGF0YSgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnZlciA9IDI7XHJcbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBNZXNzYWdlRGF0YTtcclxufShEb21haW4pKTtcclxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlRGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZURhdGEuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.\r\n */\r\nvar MetricData = (function (_super) {\r\n    __extends(MetricData, _super);\r\n    function MetricData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.metrics = [];\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MetricData;\r\n}(Domain));\r\nmodule.exports = MetricData;\r\n//# sourceMappingURL=MetricData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvTWV0cmljRGF0YS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvTWV0cmljRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG52YXIgRG9tYWluID0gcmVxdWlyZShcIi4vRG9tYWluXCIpO1xyXG5cInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBNZXRyaWMgaXRlbSBpcyBhIGxpc3Qgb2YgbWVhc3VyZW1lbnRzIChzaW5nbGUgZGF0YSBwb2ludHMpIGFuZC9vciBhZ2dyZWdhdGlvbnMuXHJcbiAqL1xyXG52YXIgTWV0cmljRGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWV0cmljRGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ldHJpY0RhdGEoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy52ZXIgPSAyO1xyXG4gICAgICAgIF90aGlzLm1ldHJpY3MgPSBbXTtcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1ldHJpY0RhdGE7XHJcbn0oRG9tYWluKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTWV0cmljRGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWV0cmljRGF0YS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar EventData = __webpack_require__(/*! ./EventData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js\");\r\n\"use strict\";\r\n/**\r\n * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.\r\n */\r\nvar PageViewData = (function (_super) {\r\n    __extends(PageViewData, _super);\r\n    function PageViewData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return PageViewData;\r\n}(EventData));\r\nmodule.exports = PageViewData;\r\n//# sourceMappingURL=PageViewData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvUGFnZVZpZXdEYXRhLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9EZWNsYXJhdGlvbnMvQ29udHJhY3RzL0dlbmVyYXRlZC9QYWdlVmlld0RhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxudmFyIEV2ZW50RGF0YSA9IHJlcXVpcmUoXCIuL0V2ZW50RGF0YVwiKTtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiBQYWdlVmlldyByZXByZXNlbnRzIGEgZ2VuZXJpYyBhY3Rpb24gb24gYSBwYWdlIGxpa2UgYSBidXR0b24gY2xpY2suIEl0IGlzIGFsc28gdGhlIGJhc2UgdHlwZSBmb3IgUGFnZVZpZXcuXHJcbiAqL1xyXG52YXIgUGFnZVZpZXdEYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYWdlVmlld0RhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYWdlVmlld0RhdGEoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy52ZXIgPSAyO1xyXG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5tZWFzdXJlbWVudHMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGFnZVZpZXdEYXRhO1xyXG59KEV2ZW50RGF0YSkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VWaWV3RGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFnZVZpZXdEYXRhLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.\r\n */\r\nvar RemoteDependencyData = (function (_super) {\r\n    __extends(RemoteDependencyData, _super);\r\n    function RemoteDependencyData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.success = true;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RemoteDependencyData;\r\n}(Domain));\r\nmodule.exports = RemoteDependencyData;\r\n//# sourceMappingURL=RemoteDependencyData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvUmVtb3RlRGVwZW5kZW5jeURhdGEuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL1JlbW90ZURlcGVuZGVuY3lEYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuLy8gVEhJUyBGSUxFIFdBUyBBVVRPR0VORVJBVEVEXHJcbnZhciBEb21haW4gPSByZXF1aXJlKFwiLi9Eb21haW5cIik7XHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgUmVtb3RlIERlcGVuZGVuY3kgcmVwcmVzZW50cyBhbiBpbnRlcmFjdGlvbiBvZiB0aGUgbW9uaXRvcmVkIGNvbXBvbmVudCB3aXRoIGEgcmVtb3RlIGNvbXBvbmVudC9zZXJ2aWNlIGxpa2UgU1FMIG9yIGFuIEhUVFAgZW5kcG9pbnQuXHJcbiAqL1xyXG52YXIgUmVtb3RlRGVwZW5kZW5jeURhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlbW90ZURlcGVuZGVuY3lEYXRhLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVtb3RlRGVwZW5kZW5jeURhdGEoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy52ZXIgPSAyO1xyXG4gICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5tZWFzdXJlbWVudHMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVtb3RlRGVwZW5kZW5jeURhdGE7XHJcbn0oRG9tYWluKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRGVwZW5kZW5jeURhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbW90ZURlcGVuZGVuY3lEYXRhLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\n\"use strict\";\r\n/**\r\n * An instance of Request represents completion of an external request to the application to do work and contains a summary of that request execution and the results.\r\n */\r\nvar RequestData = (function (_super) {\r\n    __extends(RequestData, _super);\r\n    function RequestData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RequestData;\r\n}(Domain));\r\nmodule.exports = RequestData;\r\n//# sourceMappingURL=RequestData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvUmVxdWVzdERhdGEuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL1JlcXVlc3REYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuLy8gVEhJUyBGSUxFIFdBUyBBVVRPR0VORVJBVEVEXHJcbnZhciBEb21haW4gPSByZXF1aXJlKFwiLi9Eb21haW5cIik7XHJcblwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgUmVxdWVzdCByZXByZXNlbnRzIGNvbXBsZXRpb24gb2YgYW4gZXh0ZXJuYWwgcmVxdWVzdCB0byB0aGUgYXBwbGljYXRpb24gdG8gZG8gd29yayBhbmQgY29udGFpbnMgYSBzdW1tYXJ5IG9mIHRoYXQgcmVxdWVzdCBleGVjdXRpb24gYW5kIHRoZSByZXN1bHRzLlxyXG4gKi9cclxudmFyIFJlcXVlc3REYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZXF1ZXN0RGF0YSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlcXVlc3REYXRhKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudmVyID0gMjtcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgX3RoaXMubWVhc3VyZW1lbnRzID0ge307XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlcXVlc3REYXRhO1xyXG59KERvbWFpbikpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3REYXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXF1ZXN0RGF0YS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\n/**\r\n * Defines the level of severity for the event.\r\n */\r\nvar SeverityLevel;\r\n(function (SeverityLevel) {\r\n    SeverityLevel[SeverityLevel[\"Verbose\"] = 0] = \"Verbose\";\r\n    SeverityLevel[SeverityLevel[\"Information\"] = 1] = \"Information\";\r\n    SeverityLevel[SeverityLevel[\"Warning\"] = 2] = \"Warning\";\r\n    SeverityLevel[SeverityLevel[\"Error\"] = 3] = \"Error\";\r\n    SeverityLevel[SeverityLevel[\"Critical\"] = 4] = \"Critical\";\r\n})(SeverityLevel || (SeverityLevel = {}));\r\nmodule.exports = SeverityLevel;\r\n//# sourceMappingURL=SeverityLevel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvU2V2ZXJpdHlMZXZlbC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvU2V2ZXJpdHlMZXZlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIHRoZSBsZXZlbCBvZiBzZXZlcml0eSBmb3IgdGhlIGV2ZW50LlxyXG4gKi9cclxudmFyIFNldmVyaXR5TGV2ZWw7XHJcbihmdW5jdGlvbiAoU2V2ZXJpdHlMZXZlbCkge1xyXG4gICAgU2V2ZXJpdHlMZXZlbFtTZXZlcml0eUxldmVsW1wiVmVyYm9zZVwiXSA9IDBdID0gXCJWZXJib3NlXCI7XHJcbiAgICBTZXZlcml0eUxldmVsW1NldmVyaXR5TGV2ZWxbXCJJbmZvcm1hdGlvblwiXSA9IDFdID0gXCJJbmZvcm1hdGlvblwiO1xyXG4gICAgU2V2ZXJpdHlMZXZlbFtTZXZlcml0eUxldmVsW1wiV2FybmluZ1wiXSA9IDJdID0gXCJXYXJuaW5nXCI7XHJcbiAgICBTZXZlcml0eUxldmVsW1NldmVyaXR5TGV2ZWxbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xyXG4gICAgU2V2ZXJpdHlMZXZlbFtTZXZlcml0eUxldmVsW1wiQ3JpdGljYWxcIl0gPSA0XSA9IFwiQ3JpdGljYWxcIjtcclxufSkoU2V2ZXJpdHlMZXZlbCB8fCAoU2V2ZXJpdHlMZXZlbCA9IHt9KSk7XHJcbm1vZHVsZS5leHBvcnRzID0gU2V2ZXJpdHlMZXZlbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2V2ZXJpdHlMZXZlbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\n/**\r\n * Stack frame information.\r\n */\r\nvar StackFrame = (function () {\r\n    function StackFrame() {\r\n    }\r\n    return StackFrame;\r\n}());\r\nmodule.exports = StackFrame;\r\n//# sourceMappingURL=StackFrame.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvU3RhY2tGcmFtZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvU3RhY2tGcmFtZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUSElTIEZJTEUgV0FTIEFVVE9HRU5FUkFURURcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBTdGFjayBmcmFtZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbnZhciBTdGFja0ZyYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcclxufSgpKTtcclxubW9kdWxlLmV4cG9ydHMgPSBTdGFja0ZyYW1lO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFja0ZyYW1lLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// THIS FILE WAS AUTOGENERATED\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AvailabilityData = __webpack_require__(/*! ./AvailabilityData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js\");\r\nexports.Base = __webpack_require__(/*! ./Base */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js\");\r\nexports.ContextTagKeys = __webpack_require__(/*! ./ContextTagKeys */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js\");\r\nexports.Data = __webpack_require__(/*! ./Data */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js\");\r\nexports.DataPoint = __webpack_require__(/*! ./DataPoint */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js\");\r\nexports.DataPointType = __webpack_require__(/*! ./DataPointType */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js\");\r\nexports.Domain = __webpack_require__(/*! ./Domain */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js\");\r\nexports.Envelope = __webpack_require__(/*! ./Envelope */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js\");\r\nexports.EventData = __webpack_require__(/*! ./EventData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js\");\r\nexports.ExceptionData = __webpack_require__(/*! ./ExceptionData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js\");\r\nexports.ExceptionDetails = __webpack_require__(/*! ./ExceptionDetails */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js\");\r\nexports.MessageData = __webpack_require__(/*! ./MessageData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js\");\r\nexports.MetricData = __webpack_require__(/*! ./MetricData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js\");\r\nexports.PageViewData = __webpack_require__(/*! ./PageViewData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js\");\r\nexports.RemoteDependencyData = __webpack_require__(/*! ./RemoteDependencyData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js\");\r\nexports.RequestData = __webpack_require__(/*! ./RequestData */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js\");\r\nexports.SeverityLevel = __webpack_require__(/*! ./SeverityLevel */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js\");\r\nexports.StackFrame = __webpack_require__(/*! ./StackFrame */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js\");\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9HZW5lcmF0ZWQvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0RlY2xhcmF0aW9ucy9Db250cmFjdHMvR2VuZXJhdGVkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRISVMgRklMRSBXQVMgQVVUT0dFTkVSQVRFRFxyXG5cInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkF2YWlsYWJpbGl0eURhdGEgPSByZXF1aXJlKFwiLi9BdmFpbGFiaWxpdHlEYXRhXCIpO1xyXG5leHBvcnRzLkJhc2UgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xyXG5leHBvcnRzLkNvbnRleHRUYWdLZXlzID0gcmVxdWlyZShcIi4vQ29udGV4dFRhZ0tleXNcIik7XHJcbmV4cG9ydHMuRGF0YSA9IHJlcXVpcmUoXCIuL0RhdGFcIik7XHJcbmV4cG9ydHMuRGF0YVBvaW50ID0gcmVxdWlyZShcIi4vRGF0YVBvaW50XCIpO1xyXG5leHBvcnRzLkRhdGFQb2ludFR5cGUgPSByZXF1aXJlKFwiLi9EYXRhUG9pbnRUeXBlXCIpO1xyXG5leHBvcnRzLkRvbWFpbiA9IHJlcXVpcmUoXCIuL0RvbWFpblwiKTtcclxuZXhwb3J0cy5FbnZlbG9wZSA9IHJlcXVpcmUoXCIuL0VudmVsb3BlXCIpO1xyXG5leHBvcnRzLkV2ZW50RGF0YSA9IHJlcXVpcmUoXCIuL0V2ZW50RGF0YVwiKTtcclxuZXhwb3J0cy5FeGNlcHRpb25EYXRhID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uRGF0YVwiKTtcclxuZXhwb3J0cy5FeGNlcHRpb25EZXRhaWxzID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uRGV0YWlsc1wiKTtcclxuZXhwb3J0cy5NZXNzYWdlRGF0YSA9IHJlcXVpcmUoXCIuL01lc3NhZ2VEYXRhXCIpO1xyXG5leHBvcnRzLk1ldHJpY0RhdGEgPSByZXF1aXJlKFwiLi9NZXRyaWNEYXRhXCIpO1xyXG5leHBvcnRzLlBhZ2VWaWV3RGF0YSA9IHJlcXVpcmUoXCIuL1BhZ2VWaWV3RGF0YVwiKTtcclxuZXhwb3J0cy5SZW1vdGVEZXBlbmRlbmN5RGF0YSA9IHJlcXVpcmUoXCIuL1JlbW90ZURlcGVuZGVuY3lEYXRhXCIpO1xyXG5leHBvcnRzLlJlcXVlc3REYXRhID0gcmVxdWlyZShcIi4vUmVxdWVzdERhdGFcIik7XHJcbmV4cG9ydHMuU2V2ZXJpdHlMZXZlbCA9IHJlcXVpcmUoXCIuL1NldmVyaXR5TGV2ZWxcIik7XHJcbmV4cG9ydHMuU3RhY2tGcmFtZSA9IHJlcXVpcmUoXCIuL1N0YWNrRnJhbWVcIik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Converts the user-friendly enumeration TelemetryType to the underlying schema baseType value\r\n * @param type Type to convert to BaseData string\r\n */\r\nfunction telemetryTypeToBaseType(type) {\r\n    switch (type) {\r\n        case TelemetryType.Event:\r\n            return \"EventData\";\r\n        case TelemetryType.Exception:\r\n            return \"ExceptionData\";\r\n        case TelemetryType.Trace:\r\n            return \"MessageData\";\r\n        case TelemetryType.Metric:\r\n            return \"MetricData\";\r\n        case TelemetryType.Request:\r\n            return \"RequestData\";\r\n        case TelemetryType.Dependency:\r\n            return \"RemoteDependencyData\";\r\n    }\r\n    return undefined;\r\n}\r\nexports.telemetryTypeToBaseType = telemetryTypeToBaseType;\r\n/**\r\n * Converts the schema baseType value to the user-friendly enumeration TelemetryType\r\n * @param baseType BaseData string to convert to TelemetryType\r\n */\r\nfunction baseTypeToTelemetryType(baseType) {\r\n    switch (baseType) {\r\n        case \"EventData\":\r\n            return TelemetryType.Event;\r\n        case \"ExceptionData\":\r\n            return TelemetryType.Exception;\r\n        case \"MessageData\":\r\n            return TelemetryType.Trace;\r\n        case \"MetricData\":\r\n            return TelemetryType.Metric;\r\n        case \"RequestData\":\r\n            return TelemetryType.Request;\r\n        case \"RemoteDependencyData\":\r\n            return TelemetryType.Dependency;\r\n    }\r\n    return undefined;\r\n}\r\nexports.baseTypeToTelemetryType = baseTypeToTelemetryType;\r\n/**\r\n * Telemetry types supported by this SDK\r\n */\r\nvar TelemetryType;\r\n(function (TelemetryType) {\r\n    TelemetryType[TelemetryType[\"Event\"] = 0] = \"Event\";\r\n    TelemetryType[TelemetryType[\"Exception\"] = 1] = \"Exception\";\r\n    TelemetryType[TelemetryType[\"Trace\"] = 2] = \"Trace\";\r\n    TelemetryType[TelemetryType[\"Metric\"] = 3] = \"Metric\";\r\n    TelemetryType[TelemetryType[\"Request\"] = 4] = \"Request\";\r\n    TelemetryType[TelemetryType[\"Dependency\"] = 5] = \"Dependency\";\r\n})(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));\r\n//# sourceMappingURL=TelemetryType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9UZWxlbWV0cnlUeXBlcy9UZWxlbWV0cnlUeXBlLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9EZWNsYXJhdGlvbnMvQ29udHJhY3RzL1RlbGVtZXRyeVR5cGVzL1RlbGVtZXRyeVR5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSB1c2VyLWZyaWVuZGx5IGVudW1lcmF0aW9uIFRlbGVtZXRyeVR5cGUgdG8gdGhlIHVuZGVybHlpbmcgc2NoZW1hIGJhc2VUeXBlIHZhbHVlXHJcbiAqIEBwYXJhbSB0eXBlIFR5cGUgdG8gY29udmVydCB0byBCYXNlRGF0YSBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHRlbGVtZXRyeVR5cGVUb0Jhc2VUeXBlKHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgVGVsZW1ldHJ5VHlwZS5FdmVudDpcclxuICAgICAgICAgICAgcmV0dXJuIFwiRXZlbnREYXRhXCI7XHJcbiAgICAgICAgY2FzZSBUZWxlbWV0cnlUeXBlLkV4Y2VwdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiRXhjZXB0aW9uRGF0YVwiO1xyXG4gICAgICAgIGNhc2UgVGVsZW1ldHJ5VHlwZS5UcmFjZTpcclxuICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZURhdGFcIjtcclxuICAgICAgICBjYXNlIFRlbGVtZXRyeVR5cGUuTWV0cmljOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJNZXRyaWNEYXRhXCI7XHJcbiAgICAgICAgY2FzZSBUZWxlbWV0cnlUeXBlLlJlcXVlc3Q6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlJlcXVlc3REYXRhXCI7XHJcbiAgICAgICAgY2FzZSBUZWxlbWV0cnlUeXBlLkRlcGVuZGVuY3k6XHJcbiAgICAgICAgICAgIHJldHVybiBcIlJlbW90ZURlcGVuZGVuY3lEYXRhXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydHMudGVsZW1ldHJ5VHlwZVRvQmFzZVR5cGUgPSB0ZWxlbWV0cnlUeXBlVG9CYXNlVHlwZTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzY2hlbWEgYmFzZVR5cGUgdmFsdWUgdG8gdGhlIHVzZXItZnJpZW5kbHkgZW51bWVyYXRpb24gVGVsZW1ldHJ5VHlwZVxyXG4gKiBAcGFyYW0gYmFzZVR5cGUgQmFzZURhdGEgc3RyaW5nIHRvIGNvbnZlcnQgdG8gVGVsZW1ldHJ5VHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVR5cGVUb1RlbGVtZXRyeVR5cGUoYmFzZVR5cGUpIHtcclxuICAgIHN3aXRjaCAoYmFzZVR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiRXZlbnREYXRhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUZWxlbWV0cnlUeXBlLkV2ZW50O1xyXG4gICAgICAgIGNhc2UgXCJFeGNlcHRpb25EYXRhXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBUZWxlbWV0cnlUeXBlLkV4Y2VwdGlvbjtcclxuICAgICAgICBjYXNlIFwiTWVzc2FnZURhdGFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFRlbGVtZXRyeVR5cGUuVHJhY2U7XHJcbiAgICAgICAgY2FzZSBcIk1ldHJpY0RhdGFcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFRlbGVtZXRyeVR5cGUuTWV0cmljO1xyXG4gICAgICAgIGNhc2UgXCJSZXF1ZXN0RGF0YVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gVGVsZW1ldHJ5VHlwZS5SZXF1ZXN0O1xyXG4gICAgICAgIGNhc2UgXCJSZW1vdGVEZXBlbmRlbmN5RGF0YVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gVGVsZW1ldHJ5VHlwZS5EZXBlbmRlbmN5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5leHBvcnRzLmJhc2VUeXBlVG9UZWxlbWV0cnlUeXBlID0gYmFzZVR5cGVUb1RlbGVtZXRyeVR5cGU7XHJcbi8qKlxyXG4gKiBUZWxlbWV0cnkgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoaXMgU0RLXHJcbiAqL1xyXG52YXIgVGVsZW1ldHJ5VHlwZTtcclxuKGZ1bmN0aW9uIChUZWxlbWV0cnlUeXBlKSB7XHJcbiAgICBUZWxlbWV0cnlUeXBlW1RlbGVtZXRyeVR5cGVbXCJFdmVudFwiXSA9IDBdID0gXCJFdmVudFwiO1xyXG4gICAgVGVsZW1ldHJ5VHlwZVtUZWxlbWV0cnlUeXBlW1wiRXhjZXB0aW9uXCJdID0gMV0gPSBcIkV4Y2VwdGlvblwiO1xyXG4gICAgVGVsZW1ldHJ5VHlwZVtUZWxlbWV0cnlUeXBlW1wiVHJhY2VcIl0gPSAyXSA9IFwiVHJhY2VcIjtcclxuICAgIFRlbGVtZXRyeVR5cGVbVGVsZW1ldHJ5VHlwZVtcIk1ldHJpY1wiXSA9IDNdID0gXCJNZXRyaWNcIjtcclxuICAgIFRlbGVtZXRyeVR5cGVbVGVsZW1ldHJ5VHlwZVtcIlJlcXVlc3RcIl0gPSA0XSA9IFwiUmVxdWVzdFwiO1xyXG4gICAgVGVsZW1ldHJ5VHlwZVtUZWxlbWV0cnlUeXBlW1wiRGVwZW5kZW5jeVwiXSA9IDVdID0gXCJEZXBlbmRlbmN5XCI7XHJcbn0pKFRlbGVtZXRyeVR5cGUgPSBleHBvcnRzLlRlbGVtZXRyeVR5cGUgfHwgKGV4cG9ydHMuVGVsZW1ldHJ5VHlwZSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRlbGVtZXRyeVR5cGUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(/*! ./TelemetryType */ \"./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js\"));\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9UZWxlbWV0cnlUeXBlcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9UZWxlbWV0cnlUeXBlcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vVGVsZW1ldHJ5VHlwZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Declarations/Contracts/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Declarations/Contracts/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(/*! ./Constants */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Constants.js\"));\r\n__export(__webpack_require__(/*! ./Generated */ \"./node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js\"));\r\n__export(__webpack_require__(/*! ./TelemetryTypes */ \"./node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js\"));\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvRGVjbGFyYXRpb25zL0NvbnRyYWN0cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vR2VuZXJhdGVkXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vVGVsZW1ldHJ5VHlwZXNcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Declarations/Contracts/index.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Channel.js":
/*!*****************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Channel.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar Channel = (function () {\r\n    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {\r\n        this._buffer = [];\r\n        this._lastSend = 0;\r\n        this._isDisabled = isDisabled;\r\n        this._getBatchSize = getBatchSize;\r\n        this._getBatchIntervalMs = getBatchIntervalMs;\r\n        this._sender = sender;\r\n    }\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occured while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);\r\n    };\r\n    /**\r\n     * Add a telemetry item to the send buffer\r\n     */\r\n    Channel.prototype.send = function (envelope) {\r\n        var _this = this;\r\n        // if master off switch is set, don't send any data\r\n        if (this._isDisabled()) {\r\n            // Do not send/save data\r\n            return;\r\n        }\r\n        // validate input\r\n        if (!envelope) {\r\n            Logging.warn(\"Cannot send null/undefined telemetry\");\r\n            return;\r\n        }\r\n        // check if the incoming payload is too large, truncate if necessary\r\n        var payload = this._stringify(envelope);\r\n        if (typeof payload !== \"string\") {\r\n            return;\r\n        }\r\n        // enqueue the payload\r\n        this._buffer.push(payload);\r\n        // flush if we would exceed the max-size limit by adding this item\r\n        if (this._buffer.length >= this._getBatchSize()) {\r\n            this.triggerSend(false);\r\n            return;\r\n        }\r\n        // ensure an invocation timeout is set if anything is in the buffer\r\n        if (!this._timeoutHandle && this._buffer.length > 0) {\r\n            this._timeoutHandle = setTimeout(function () {\r\n                _this._timeoutHandle = null;\r\n                _this.triggerSend(false);\r\n            }, this._getBatchIntervalMs());\r\n        }\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     */\r\n    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {\r\n        var bufferIsEmpty = this._buffer.length < 1;\r\n        if (!bufferIsEmpty) {\r\n            // compose an array of payloads\r\n            var batch = this._buffer.join(\"\\n\");\r\n            // invoke send\r\n            if (isNodeCrashing) {\r\n                this._sender.saveOnCrash(batch);\r\n                if (typeof callback === \"function\") {\r\n                    callback(\"data saved on crash\");\r\n                }\r\n            }\r\n            else {\r\n                this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);\r\n            }\r\n        }\r\n        // update lastSend time to enable throttling\r\n        this._lastSend = +new Date;\r\n        // clear buffer\r\n        this._buffer.length = 0;\r\n        clearTimeout(this._timeoutHandle);\r\n        this._timeoutHandle = null;\r\n        if (bufferIsEmpty && typeof callback === \"function\") {\r\n            callback(\"no data to send\");\r\n        }\r\n    };\r\n    Channel.prototype._stringify = function (envelope) {\r\n        try {\r\n            return JSON.stringify(envelope);\r\n        }\r\n        catch (error) {\r\n            Logging.warn(\"Failed to serialize payload\", error, envelope);\r\n        }\r\n    };\r\n    return Channel;\r\n}());\r\nmodule.exports = Channel;\r\n//# sourceMappingURL=Channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L0NoYW5uZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBMb2dnaW5nID0gcmVxdWlyZShcIi4vTG9nZ2luZ1wiKTtcclxudmFyIENoYW5uZWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhbm5lbChpc0Rpc2FibGVkLCBnZXRCYXRjaFNpemUsIGdldEJhdGNoSW50ZXJ2YWxNcywgc2VuZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gW107XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlbmQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgICAgIHRoaXMuX2dldEJhdGNoU2l6ZSA9IGdldEJhdGNoU2l6ZTtcclxuICAgICAgICB0aGlzLl9nZXRCYXRjaEludGVydmFsTXMgPSBnZXRCYXRjaEludGVydmFsTXM7XHJcbiAgICAgICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBkaXNrLWJhY2tlZCByZXRyeSBjYWNoaW5nIHRvIGNhY2hlIGV2ZW50cyB3aGVuIGNsaWVudCBpcyBvZmZsaW5lIChlbmFibGVkIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBUaGVzZSBjYWNoZWQgZXZlbnRzIGFyZSBzdG9yZWQgaW4geW91ciBzeXN0ZW0gb3IgdXNlcidzIHRlbXBvcmFyeSBkaXJlY3RvcnkgYW5kIGFjY2VzcyByZXN0cmljdGVkIHRvIHlvdXIgdXNlciB3aGVuIHBvc3NpYmxlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUgZXZlbnRzIHRoYXQgb2NjdXJlZCB3aGlsZSBjbGllbnQgaXMgb2ZmbGluZSB3aWxsIGJlIGNhY2hlZCBvbiBkaXNrXHJcbiAgICAgKiBAcGFyYW0gcmVzZW5kSW50ZXJ2YWwgVGhlIHdhaXQgaW50ZXJ2YWwgZm9yIHJlc2VuZGluZyBjYWNoZWQgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIG1heEJ5dGVzT25EaXNrIFRoZSBtYXhpbXVtIHNpemUgKGluIGJ5dGVzKSB0aGF0IHRoZSBjcmVhdGVkIHRlbXBvcmFyeSBkaXJlY3RvcnkgZm9yIGNhY2hlIGV2ZW50cyBjYW4gZ3JvdyB0bywgYmVmb3JlIGNhY2hpbmcgaXMgZGlzYWJsZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uZmlndXJhdGlvbn0gdGhpcyBjbGFzc1xyXG4gICAgICovXHJcbiAgICBDaGFubmVsLnByb3RvdHlwZS5zZXRVc2VEaXNrUmV0cnlDYWNoaW5nID0gZnVuY3Rpb24gKHZhbHVlLCByZXNlbmRJbnRlcnZhbCwgbWF4Qnl0ZXNPbkRpc2spIHtcclxuICAgICAgICB0aGlzLl9zZW5kZXIuc2V0RGlza1JldHJ5TW9kZSh2YWx1ZSwgcmVzZW5kSW50ZXJ2YWwsIG1heEJ5dGVzT25EaXNrKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRlbGVtZXRyeSBpdGVtIHRvIHRoZSBzZW5kIGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBDaGFubmVsLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGVudmVsb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBpZiBtYXN0ZXIgb2ZmIHN3aXRjaCBpcyBzZXQsIGRvbid0IHNlbmQgYW55IGRhdGFcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNhYmxlZCgpKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBzZW5kL3NhdmUgZGF0YVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhbGlkYXRlIGlucHV0XHJcbiAgICAgICAgaWYgKCFlbnZlbG9wZSkge1xyXG4gICAgICAgICAgICBMb2dnaW5nLndhcm4oXCJDYW5ub3Qgc2VuZCBudWxsL3VuZGVmaW5lZCB0ZWxlbWV0cnlcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGluY29taW5nIHBheWxvYWQgaXMgdG9vIGxhcmdlLCB0cnVuY2F0ZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICB2YXIgcGF5bG9hZCA9IHRoaXMuX3N0cmluZ2lmeShlbnZlbG9wZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZW5xdWV1ZSB0aGUgcGF5bG9hZFxyXG4gICAgICAgIHRoaXMuX2J1ZmZlci5wdXNoKHBheWxvYWQpO1xyXG4gICAgICAgIC8vIGZsdXNoIGlmIHdlIHdvdWxkIGV4Y2VlZCB0aGUgbWF4LXNpemUgbGltaXQgYnkgYWRkaW5nIHRoaXMgaXRlbVxyXG4gICAgICAgIGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID49IHRoaXMuX2dldEJhdGNoU2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNlbmQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSBhbiBpbnZvY2F0aW9uIHRpbWVvdXQgaXMgc2V0IGlmIGFueXRoaW5nIGlzIGluIHRoZSBidWZmZXJcclxuICAgICAgICBpZiAoIXRoaXMuX3RpbWVvdXRIYW5kbGUgJiYgdGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RpbWVvdXRIYW5kbGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlclNlbmQoZmFsc2UpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLl9nZXRCYXRjaEludGVydmFsTXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW1tZWRpYXRlbHkgc2VuZCBidWZmZXJlZCBkYXRhXHJcbiAgICAgKi9cclxuICAgIENoYW5uZWwucHJvdG90eXBlLnRyaWdnZXJTZW5kID0gZnVuY3Rpb24gKGlzTm9kZUNyYXNoaW5nLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBidWZmZXJJc0VtcHR5ID0gdGhpcy5fYnVmZmVyLmxlbmd0aCA8IDE7XHJcbiAgICAgICAgaWYgKCFidWZmZXJJc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBvc2UgYW4gYXJyYXkgb2YgcGF5bG9hZHNcclxuICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5fYnVmZmVyLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBzZW5kXHJcbiAgICAgICAgICAgIGlmIChpc05vZGVDcmFzaGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZGVyLnNhdmVPbkNyYXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiZGF0YSBzYXZlZCBvbiBjcmFzaFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRlci5zZW5kKEJ1ZmZlci5mcm9tID8gQnVmZmVyLmZyb20oYmF0Y2gpIDogbmV3IEJ1ZmZlcihiYXRjaCksIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGUgbGFzdFNlbmQgdGltZSB0byBlbmFibGUgdGhyb3R0bGluZ1xyXG4gICAgICAgIHRoaXMuX2xhc3RTZW5kID0gK25ldyBEYXRlO1xyXG4gICAgICAgIC8vIGNsZWFyIGJ1ZmZlclxyXG4gICAgICAgIHRoaXMuX2J1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SGFuZGxlKTtcclxuICAgICAgICB0aGlzLl90aW1lb3V0SGFuZGxlID0gbnVsbDtcclxuICAgICAgICBpZiAoYnVmZmVySXNFbXB0eSAmJiB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhcIm5vIGRhdGEgdG8gc2VuZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuX3N0cmluZ2lmeSA9IGZ1bmN0aW9uIChlbnZlbG9wZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShlbnZlbG9wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBMb2dnaW5nLndhcm4oXCJGYWlsZWQgdG8gc2VyaWFsaXplIHBheWxvYWRcIiwgZXJyb3IsIGVudmVsb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENoYW5uZWw7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ2hhbm5lbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hhbm5lbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Channel.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Config.js":
/*!****************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Config.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar CorrelationIdManager = __webpack_require__(/*! ./CorrelationIdManager */ \"./node_modules/applicationinsights/out/Library/CorrelationIdManager.js\");\r\nvar Config = (function () {\r\n    function Config(instrumentationKey) {\r\n        var _this = this;\r\n        this.endpointBase = \"https://dc.services.visualstudio.com\";\r\n        this.instrumentationKey = instrumentationKey || Config._getInstrumentationKey();\r\n        this.endpointUrl = this.endpointBase + \"/v2/track\";\r\n        this.maxBatchSize = 250;\r\n        this.maxBatchIntervalMs = 15000;\r\n        this.disableAppInsights = false;\r\n        this.samplingPercentage = 100;\r\n        this.correlationIdRetryIntervalMs = 30 * 1000;\r\n        this.correlationHeaderExcludedDomains = [\r\n            \"*.core.windows.net\",\r\n            \"*.core.chinacloudapi.cn\",\r\n            \"*.core.cloudapi.de\",\r\n            \"*.core.usgovcloudapi.net\"\r\n        ];\r\n        this.setCorrelationId = function (correlationId) { return _this.correlationId = correlationId; };\r\n        this.profileQueryEndpoint = process.env[Config.ENV_profileQueryEndpoint] || this.endpointBase;\r\n        this.proxyHttpUrl = process.env[Config.ENV_http_proxy] || undefined;\r\n        this.proxyHttpsUrl = process.env[Config.ENV_https_proxy] || undefined;\r\n        this.httpAgent = undefined;\r\n        this.httpsAgent = undefined;\r\n    }\r\n    Object.defineProperty(Config.prototype, \"profileQueryEndpoint\", {\r\n        get: function () {\r\n            return this._profileQueryEndpoint;\r\n        },\r\n        set: function (endpoint) {\r\n            CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);\r\n            this._profileQueryEndpoint = endpoint;\r\n            this.correlationId = CorrelationIdManager.correlationIdPrefix; // Reset the correlationId while we wait for the new query\r\n            CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Config._getInstrumentationKey = function () {\r\n        // check for both the documented env variable and the azure-prefixed variable\r\n        var iKey = process.env[Config.ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]\r\n            || process.env[Config.legacy_ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];\r\n        if (!iKey || iKey == \"\") {\r\n            throw new Error(\"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\");\r\n        }\r\n        return iKey;\r\n    };\r\n    // Azure adds this prefix to all environment variables\r\n    Config.ENV_azurePrefix = \"APPSETTING_\";\r\n    // This key is provided in the readme\r\n    Config.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\r\n    Config.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\r\n    Config.ENV_profileQueryEndpoint = \"APPINSIGHTS_PROFILE_QUERY_ENDPOINT\";\r\n    Config.ENV_http_proxy = \"http_proxy\";\r\n    Config.ENV_https_proxy = \"https_proxy\";\r\n    return Config;\r\n}());\r\nmodule.exports = Config;\r\n//# sourceMappingURL=Config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Db25maWcuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0xpYnJhcnkvQ29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQ29ycmVsYXRpb25JZE1hbmFnZXIgPSByZXF1aXJlKFwiLi9Db3JyZWxhdGlvbklkTWFuYWdlclwiKTtcclxudmFyIENvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25maWcoaW5zdHJ1bWVudGF0aW9uS2V5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmVuZHBvaW50QmFzZSA9IFwiaHR0cHM6Ly9kYy5zZXJ2aWNlcy52aXN1YWxzdHVkaW8uY29tXCI7XHJcbiAgICAgICAgdGhpcy5pbnN0cnVtZW50YXRpb25LZXkgPSBpbnN0cnVtZW50YXRpb25LZXkgfHwgQ29uZmlnLl9nZXRJbnN0cnVtZW50YXRpb25LZXkoKTtcclxuICAgICAgICB0aGlzLmVuZHBvaW50VXJsID0gdGhpcy5lbmRwb2ludEJhc2UgKyBcIi92Mi90cmFja1wiO1xyXG4gICAgICAgIHRoaXMubWF4QmF0Y2hTaXplID0gMjUwO1xyXG4gICAgICAgIHRoaXMubWF4QmF0Y2hJbnRlcnZhbE1zID0gMTUwMDA7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlQXBwSW5zaWdodHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNhbXBsaW5nUGVyY2VudGFnZSA9IDEwMDtcclxuICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWRSZXRyeUludGVydmFsTXMgPSAzMCAqIDEwMDA7XHJcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbkhlYWRlckV4Y2x1ZGVkRG9tYWlucyA9IFtcclxuICAgICAgICAgICAgXCIqLmNvcmUud2luZG93cy5uZXRcIixcclxuICAgICAgICAgICAgXCIqLmNvcmUuY2hpbmFjbG91ZGFwaS5jblwiLFxyXG4gICAgICAgICAgICBcIiouY29yZS5jbG91ZGFwaS5kZVwiLFxyXG4gICAgICAgICAgICBcIiouY29yZS51c2dvdmNsb3VkYXBpLm5ldFwiXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnNldENvcnJlbGF0aW9uSWQgPSBmdW5jdGlvbiAoY29ycmVsYXRpb25JZCkgeyByZXR1cm4gX3RoaXMuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWQ7IH07XHJcbiAgICAgICAgdGhpcy5wcm9maWxlUXVlcnlFbmRwb2ludCA9IHByb2Nlc3MuZW52W0NvbmZpZy5FTlZfcHJvZmlsZVF1ZXJ5RW5kcG9pbnRdIHx8IHRoaXMuZW5kcG9pbnRCYXNlO1xyXG4gICAgICAgIHRoaXMucHJveHlIdHRwVXJsID0gcHJvY2Vzcy5lbnZbQ29uZmlnLkVOVl9odHRwX3Byb3h5XSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wcm94eUh0dHBzVXJsID0gcHJvY2Vzcy5lbnZbQ29uZmlnLkVOVl9odHRwc19wcm94eV0gfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaHR0cEFnZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuaHR0cHNBZ2VudCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25maWcucHJvdG90eXBlLCBcInByb2ZpbGVRdWVyeUVuZHBvaW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2ZpbGVRdWVyeUVuZHBvaW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuY2FuY2VsQ29ycmVsYXRpb25JZFF1ZXJ5KHRoaXMsIHRoaXMuc2V0Q29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVRdWVyeUVuZHBvaW50ID0gZW5kcG9pbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IENvcnJlbGF0aW9uSWRNYW5hZ2VyLmNvcnJlbGF0aW9uSWRQcmVmaXg7IC8vIFJlc2V0IHRoZSBjb3JyZWxhdGlvbklkIHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXcgcXVlcnlcclxuICAgICAgICAgICAgQ29ycmVsYXRpb25JZE1hbmFnZXIucXVlcnlDb3JyZWxhdGlvbklkKHRoaXMsIHRoaXMuc2V0Q29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb25maWcuX2dldEluc3RydW1lbnRhdGlvbktleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aCB0aGUgZG9jdW1lbnRlZCBlbnYgdmFyaWFibGUgYW5kIHRoZSBhenVyZS1wcmVmaXhlZCB2YXJpYWJsZVxyXG4gICAgICAgIHZhciBpS2V5ID0gcHJvY2Vzcy5lbnZbQ29uZmlnLkVOVl9pS2V5XVxyXG4gICAgICAgICAgICB8fCBwcm9jZXNzLmVudltDb25maWcuRU5WX2F6dXJlUHJlZml4ICsgQ29uZmlnLkVOVl9pS2V5XVxyXG4gICAgICAgICAgICB8fCBwcm9jZXNzLmVudltDb25maWcubGVnYWN5X0VOVl9pS2V5XVxyXG4gICAgICAgICAgICB8fCBwcm9jZXNzLmVudltDb25maWcuRU5WX2F6dXJlUHJlZml4ICsgQ29uZmlnLmxlZ2FjeV9FTlZfaUtleV07XHJcbiAgICAgICAgaWYgKCFpS2V5IHx8IGlLZXkgPT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN0cnVtZW50YXRpb24ga2V5IG5vdCBmb3VuZCwgcGFzcyB0aGUga2V5IGluIHRoZSBjb25maWcgdG8gdGhpcyBtZXRob2Qgb3Igc2V0IHRoZSBrZXkgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIEFQUElOU0lHSFRTX0lOU1RSVU1FTlRBVElPTktFWSBiZWZvcmUgc3RhcnRpbmcgdGhlIHNlcnZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlLZXk7XHJcbiAgICB9O1xyXG4gICAgLy8gQXp1cmUgYWRkcyB0aGlzIHByZWZpeCB0byBhbGwgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbiAgICBDb25maWcuRU5WX2F6dXJlUHJlZml4ID0gXCJBUFBTRVRUSU5HX1wiO1xyXG4gICAgLy8gVGhpcyBrZXkgaXMgcHJvdmlkZWQgaW4gdGhlIHJlYWRtZVxyXG4gICAgQ29uZmlnLkVOVl9pS2V5ID0gXCJBUFBJTlNJR0hUU19JTlNUUlVNRU5UQVRJT05LRVlcIjtcclxuICAgIENvbmZpZy5sZWdhY3lfRU5WX2lLZXkgPSBcIkFQUElOU0lHSFRTX0lOU1RSVU1FTlRBVElPTl9LRVlcIjtcclxuICAgIENvbmZpZy5FTlZfcHJvZmlsZVF1ZXJ5RW5kcG9pbnQgPSBcIkFQUElOU0lHSFRTX1BST0ZJTEVfUVVFUllfRU5EUE9JTlRcIjtcclxuICAgIENvbmZpZy5FTlZfaHR0cF9wcm94eSA9IFwiaHR0cF9wcm94eVwiO1xyXG4gICAgQ29uZmlnLkVOVl9odHRwc19wcm94eSA9IFwiaHR0cHNfcHJveHlcIjtcclxuICAgIHJldHVybiBDb25maWc7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25maWcuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Config.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Context.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\r\nvar os = __webpack_require__(/*! os */ \"os\");\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar Context = (function () {\r\n    function Context(packageJsonPath) {\r\n        this.keys = new Contracts.ContextTagKeys();\r\n        this.tags = {};\r\n        this._loadApplicationContext();\r\n        this._loadDeviceContext();\r\n        this._loadInternalContext();\r\n    }\r\n    Context.prototype._loadApplicationContext = function (packageJsonPath) {\r\n        // note: this should return the host package.json\r\n        packageJsonPath = packageJsonPath || path.resolve(__dirname, \"../../../../package.json\");\r\n        if (!Context.appVersion[packageJsonPath]) {\r\n            Context.appVersion[packageJsonPath] = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.appVersion[packageJsonPath] = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];\r\n    };\r\n    Context.prototype._loadDeviceContext = function () {\r\n        this.tags[this.keys.deviceId] = \"\";\r\n        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();\r\n        this.tags[this.keys.deviceOSVersion] = os && (os.type() + \" \" + os.release());\r\n        this.tags[this.keys.cloudRole] = Context.DefaultRoleName;\r\n        // not yet supported tags\r\n        this.tags[\"ai.device.osArchitecture\"] = os && os.arch();\r\n        this.tags[\"ai.device.osPlatform\"] = os && os.platform();\r\n    };\r\n    Context.prototype._loadInternalContext = function () {\r\n        // note: this should return the sdk package.json\r\n        var packageJsonPath = path.resolve(__dirname, \"../../package.json\");\r\n        if (!Context.sdkVersion) {\r\n            Context.sdkVersion = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.sdkVersion = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.internalSdkVersion] = \"node:\" + Context.sdkVersion;\r\n    };\r\n    Context.DefaultRoleName = \"Web\";\r\n    Context.appVersion = {};\r\n    Context.sdkVersion = null;\r\n    return Context;\r\n}());\r\nmodule.exports = Context;\r\n//# sourceMappingURL=Context.js.map\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Db250ZXh0LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L0NvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG52YXIgQ29udHJhY3RzID0gcmVxdWlyZShcIi4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbnZhciBMb2dnaW5nID0gcmVxdWlyZShcIi4vTG9nZ2luZ1wiKTtcclxudmFyIENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29udGV4dChwYWNrYWdlSnNvblBhdGgpIHtcclxuICAgICAgICB0aGlzLmtleXMgPSBuZXcgQ29udHJhY3RzLkNvbnRleHRUYWdLZXlzKCk7XHJcbiAgICAgICAgdGhpcy50YWdzID0ge307XHJcbiAgICAgICAgdGhpcy5fbG9hZEFwcGxpY2F0aW9uQ29udGV4dCgpO1xyXG4gICAgICAgIHRoaXMuX2xvYWREZXZpY2VDb250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fbG9hZEludGVybmFsQ29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgQ29udGV4dC5wcm90b3R5cGUuX2xvYWRBcHBsaWNhdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAocGFja2FnZUpzb25QYXRoKSB7XHJcbiAgICAgICAgLy8gbm90ZTogdGhpcyBzaG91bGQgcmV0dXJuIHRoZSBob3N0IHBhY2thZ2UuanNvblxyXG4gICAgICAgIHBhY2thZ2VKc29uUGF0aCA9IHBhY2thZ2VKc29uUGF0aCB8fCBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uLy4uLy4uLy4uL3BhY2thZ2UuanNvblwiKTtcclxuICAgICAgICBpZiAoIUNvbnRleHQuYXBwVmVyc2lvbltwYWNrYWdlSnNvblBhdGhdKSB7XHJcbiAgICAgICAgICAgIENvbnRleHQuYXBwVmVyc2lvbltwYWNrYWdlSnNvblBhdGhdID0gXCJ1bmtub3duXCI7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYWNrYWdlSnNvblBhdGgsIFwidXRmOFwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFja2FnZUpzb24gJiYgdHlwZW9mIHBhY2thZ2VKc29uLnZlcnNpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250ZXh0LmFwcFZlcnNpb25bcGFja2FnZUpzb25QYXRoXSA9IHBhY2thZ2VKc29uLnZlcnNpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFwidW5hYmxlIHRvIHJlYWQgYXBwIHZlcnNpb246IFwiLCBleGNlcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGFnc1t0aGlzLmtleXMuYXBwbGljYXRpb25WZXJzaW9uXSA9IENvbnRleHQuYXBwVmVyc2lvbltwYWNrYWdlSnNvblBhdGhdO1xyXG4gICAgfTtcclxuICAgIENvbnRleHQucHJvdG90eXBlLl9sb2FkRGV2aWNlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRhZ3NbdGhpcy5rZXlzLmRldmljZUlkXSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy50YWdzW3RoaXMua2V5cy5jbG91ZFJvbGVJbnN0YW5jZV0gPSBvcyAmJiBvcy5ob3N0bmFtZSgpO1xyXG4gICAgICAgIHRoaXMudGFnc1t0aGlzLmtleXMuZGV2aWNlT1NWZXJzaW9uXSA9IG9zICYmIChvcy50eXBlKCkgKyBcIiBcIiArIG9zLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgdGhpcy50YWdzW3RoaXMua2V5cy5jbG91ZFJvbGVdID0gQ29udGV4dC5EZWZhdWx0Um9sZU5hbWU7XHJcbiAgICAgICAgLy8gbm90IHlldCBzdXBwb3J0ZWQgdGFnc1xyXG4gICAgICAgIHRoaXMudGFnc1tcImFpLmRldmljZS5vc0FyY2hpdGVjdHVyZVwiXSA9IG9zICYmIG9zLmFyY2goKTtcclxuICAgICAgICB0aGlzLnRhZ3NbXCJhaS5kZXZpY2Uub3NQbGF0Zm9ybVwiXSA9IG9zICYmIG9zLnBsYXRmb3JtKCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dC5wcm90b3R5cGUuX2xvYWRJbnRlcm5hbENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbm90ZTogdGhpcyBzaG91bGQgcmV0dXJuIHRoZSBzZGsgcGFja2FnZS5qc29uXHJcbiAgICAgICAgdmFyIHBhY2thZ2VKc29uUGF0aCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi4vLi4vcGFja2FnZS5qc29uXCIpO1xyXG4gICAgICAgIGlmICghQ29udGV4dC5zZGtWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIENvbnRleHQuc2RrVmVyc2lvbiA9IFwidW5rbm93blwiO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGFja2FnZUpzb25QYXRoLCBcInV0ZjhcIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhY2thZ2VKc29uICYmIHR5cGVvZiBwYWNrYWdlSnNvbi52ZXJzaW9uID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGV4dC5zZGtWZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnaW5nLmluZm8oXCJ1bmFibGUgdG8gcmVhZCBhcHAgdmVyc2lvbjogXCIsIGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YWdzW3RoaXMua2V5cy5pbnRlcm5hbFNka1ZlcnNpb25dID0gXCJub2RlOlwiICsgQ29udGV4dC5zZGtWZXJzaW9uO1xyXG4gICAgfTtcclxuICAgIENvbnRleHQuRGVmYXVsdFJvbGVOYW1lID0gXCJXZWJcIjtcclxuICAgIENvbnRleHQuYXBwVmVyc2lvbiA9IHt9O1xyXG4gICAgQ29udGV4dC5zZGtWZXJzaW9uID0gbnVsbDtcclxuICAgIHJldHVybiBDb250ZXh0O1xyXG59KCkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Context.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/CorrelationIdManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/CorrelationIdManager.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Util = __webpack_require__(/*! ./Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar CorrelationIdManager = (function () {\r\n    function CorrelationIdManager() {\r\n    }\r\n    CorrelationIdManager.queryCorrelationId = function (config, callback) {\r\n        // GET request to `${this.endpointBase}/api/profiles/${this.instrumentationKey}/appId`\r\n        // If it 404s, the iKey is bad and we should give up\r\n        // If it fails otherwise, try again later\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        if (CorrelationIdManager.completedLookups.hasOwnProperty(appIdUrlString)) {\r\n            callback(CorrelationIdManager.completedLookups[appIdUrlString]);\r\n            return;\r\n        }\r\n        else if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString].push(callback);\r\n            return;\r\n        }\r\n        CorrelationIdManager.pendingLookups[appIdUrlString] = [callback];\r\n        var fetchAppId = function () {\r\n            if (!CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                // This query has been cancelled.\r\n                return;\r\n            }\r\n            var requestOptions = {\r\n                method: 'GET',\r\n                // Ensure this request is not captured by auto-collection.\r\n                // Note: we don't refer to the property in HttpDependencyParser because that would cause a cyclical dependency\r\n                disableAppInsightsAutoCollection: true\r\n            };\r\n            Logging.info(CorrelationIdManager.TAG, requestOptions);\r\n            var req = Util.makeRequest(config, appIdUrlString, requestOptions, function (res) {\r\n                if (res.statusCode === 200) {\r\n                    // Success; extract the appId from the body\r\n                    var appId_1 = \"\";\r\n                    res.setEncoding(\"utf-8\");\r\n                    res.on('data', function (data) {\r\n                        appId_1 += data;\r\n                    });\r\n                    res.on('end', function () {\r\n                        Logging.info(CorrelationIdManager.TAG, appId_1);\r\n                        var result = CorrelationIdManager.correlationIdPrefix + appId_1;\r\n                        CorrelationIdManager.completedLookups[appIdUrlString] = result;\r\n                        if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                            CorrelationIdManager.pendingLookups[appIdUrlString].forEach(function (cb) { return cb(result); });\r\n                        }\r\n                        delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                    });\r\n                }\r\n                else if (res.statusCode >= 400 && res.statusCode < 500) {\r\n                    // Not found, probably a bad key. Do not try again.\r\n                    CorrelationIdManager.completedLookups[appIdUrlString] = undefined;\r\n                    delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                }\r\n                else {\r\n                    // Retry after timeout.\r\n                    setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);\r\n                }\r\n            });\r\n            if (req) {\r\n                req.on('error', function (error) {\r\n                    // Unable to contact endpoint.\r\n                    // Do nothing for now.\r\n                    Logging.warn(CorrelationIdManager.TAG, error);\r\n                });\r\n                req.end();\r\n            }\r\n        };\r\n        setTimeout(fetchAppId, 0);\r\n    };\r\n    CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        var pendingLookups = CorrelationIdManager.pendingLookups[appIdUrlString];\r\n        if (pendingLookups) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString] = pendingLookups.filter(function (cb) { return cb != callback; });\r\n            if (CorrelationIdManager.pendingLookups[appIdUrlString].length == 0) {\r\n                delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate a request Id according to https://github.com/lmolkova/correlation/blob/master/hierarchical_request_id.md\r\n     * @param parentId\r\n     */\r\n    CorrelationIdManager.generateRequestId = function (parentId) {\r\n        if (parentId) {\r\n            parentId = parentId[0] == '|' ? parentId : '|' + parentId;\r\n            if (parentId[parentId.length - 1] !== '.') {\r\n                parentId += '.';\r\n            }\r\n            var suffix = (CorrelationIdManager.currentRootId++).toString(16);\r\n            return CorrelationIdManager.appendSuffix(parentId, suffix, '_');\r\n        }\r\n        else {\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n    };\r\n    /**\r\n     * Given a hierarchical identifier of the form |X.*\r\n     * return the root identifier X\r\n     * @param id\r\n     */\r\n    CorrelationIdManager.getRootId = function (id) {\r\n        var endIndex = id.indexOf('.');\r\n        if (endIndex < 0) {\r\n            endIndex = id.length;\r\n        }\r\n        var startIndex = id[0] === '|' ? 1 : 0;\r\n        return id.substring(startIndex, endIndex);\r\n    };\r\n    CorrelationIdManager.generateRootId = function () {\r\n        return '|' + Util.w3cTraceId() + '.';\r\n    };\r\n    CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {\r\n        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) {\r\n            return parentId + suffix + delimiter;\r\n        }\r\n        // Combined identifier would be too long, so we must truncate it.\r\n        // We need 9 characters of space: 8 for the overflow ID, 1 for the\r\n        // overflow delimiter '#'\r\n        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;\r\n        if (parentId.length > trimPosition) {\r\n            for (; trimPosition > 1; --trimPosition) {\r\n                var c = parentId[trimPosition - 1];\r\n                if (c === '.' || c === '_') {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (trimPosition <= 1) {\r\n            // parentId is not a valid ID\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n        suffix = Util.randomu32().toString(16);\r\n        while (suffix.length < 8) {\r\n            suffix = '0' + suffix;\r\n        }\r\n        return parentId.substring(0, trimPosition) + suffix + '#';\r\n    };\r\n    CorrelationIdManager.TAG = \"CorrelationIdManager\";\r\n    CorrelationIdManager.correlationIdPrefix = \"cid-v1:\";\r\n    // To avoid extraneous HTTP requests, we maintain a queue of callbacks waiting on a particular appId lookup,\r\n    // as well as a cache of completed lookups so future requests can be resolved immediately.\r\n    CorrelationIdManager.pendingLookups = {};\r\n    CorrelationIdManager.completedLookups = {};\r\n    CorrelationIdManager.requestIdMaxLength = 1024;\r\n    CorrelationIdManager.currentRootId = Util.randomu32();\r\n    return CorrelationIdManager;\r\n}());\r\nmodule.exports = CorrelationIdManager;\r\n//# sourceMappingURL=CorrelationIdManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Db3JyZWxhdGlvbklkTWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Db3JyZWxhdGlvbklkTWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xyXG52YXIgTG9nZ2luZyA9IHJlcXVpcmUoXCIuL0xvZ2dpbmdcIik7XHJcbnZhciBDb3JyZWxhdGlvbklkTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb3JyZWxhdGlvbklkTWFuYWdlcigpIHtcclxuICAgIH1cclxuICAgIENvcnJlbGF0aW9uSWRNYW5hZ2VyLnF1ZXJ5Q29ycmVsYXRpb25JZCA9IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gR0VUIHJlcXVlc3QgdG8gYCR7dGhpcy5lbmRwb2ludEJhc2V9L2FwaS9wcm9maWxlcy8ke3RoaXMuaW5zdHJ1bWVudGF0aW9uS2V5fS9hcHBJZGBcclxuICAgICAgICAvLyBJZiBpdCA0MDRzLCB0aGUgaUtleSBpcyBiYWQgYW5kIHdlIHNob3VsZCBnaXZlIHVwXHJcbiAgICAgICAgLy8gSWYgaXQgZmFpbHMgb3RoZXJ3aXNlLCB0cnkgYWdhaW4gbGF0ZXJcclxuICAgICAgICB2YXIgYXBwSWRVcmxTdHJpbmcgPSBjb25maWcucHJvZmlsZVF1ZXJ5RW5kcG9pbnQgKyBcIi9hcGkvcHJvZmlsZXMvXCIgKyBjb25maWcuaW5zdHJ1bWVudGF0aW9uS2V5ICsgXCIvYXBwSWRcIjtcclxuICAgICAgICBpZiAoQ29ycmVsYXRpb25JZE1hbmFnZXIuY29tcGxldGVkTG9va3Vwcy5oYXNPd25Qcm9wZXJ0eShhcHBJZFVybFN0cmluZykpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soQ29ycmVsYXRpb25JZE1hbmFnZXIuY29tcGxldGVkTG9va3Vwc1thcHBJZFVybFN0cmluZ10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKENvcnJlbGF0aW9uSWRNYW5hZ2VyLnBlbmRpbmdMb29rdXBzW2FwcElkVXJsU3RyaW5nXSkge1xyXG4gICAgICAgICAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5wZW5kaW5nTG9va3Vwc1thcHBJZFVybFN0cmluZ10ucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ29ycmVsYXRpb25JZE1hbmFnZXIucGVuZGluZ0xvb2t1cHNbYXBwSWRVcmxTdHJpbmddID0gW2NhbGxiYWNrXTtcclxuICAgICAgICB2YXIgZmV0Y2hBcHBJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFDb3JyZWxhdGlvbklkTWFuYWdlci5wZW5kaW5nTG9va3Vwc1thcHBJZFVybFN0cmluZ10pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcXVlcnkgaGFzIGJlZW4gY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyByZXF1ZXN0IGlzIG5vdCBjYXB0dXJlZCBieSBhdXRvLWNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBkb24ndCByZWZlciB0byB0aGUgcHJvcGVydHkgaW4gSHR0cERlcGVuZGVuY3lQYXJzZXIgYmVjYXVzZSB0aGF0IHdvdWxkIGNhdXNlIGEgY3ljbGljYWwgZGVwZW5kZW5jeVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZUFwcEluc2lnaHRzQXV0b0NvbGxlY3Rpb246IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTG9nZ2luZy5pbmZvKENvcnJlbGF0aW9uSWRNYW5hZ2VyLlRBRywgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgcmVxID0gVXRpbC5tYWtlUmVxdWVzdChjb25maWcsIGFwcElkVXJsU3RyaW5nLCByZXF1ZXN0T3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzOyBleHRyYWN0IHRoZSBhcHBJZCBmcm9tIHRoZSBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcElkXzEgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZXRFbmNvZGluZyhcInV0Zi04XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcElkXzEgKz0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2luZy5pbmZvKENvcnJlbGF0aW9uSWRNYW5hZ2VyLlRBRywgYXBwSWRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBDb3JyZWxhdGlvbklkTWFuYWdlci5jb3JyZWxhdGlvbklkUHJlZml4ICsgYXBwSWRfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuY29tcGxldGVkTG9va3Vwc1thcHBJZFVybFN0cmluZ10gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb3JyZWxhdGlvbklkTWFuYWdlci5wZW5kaW5nTG9va3Vwc1thcHBJZFVybFN0cmluZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvcnJlbGF0aW9uSWRNYW5hZ2VyLnBlbmRpbmdMb29rdXBzW2FwcElkVXJsU3RyaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IocmVzdWx0KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIENvcnJlbGF0aW9uSWRNYW5hZ2VyLnBlbmRpbmdMb29rdXBzW2FwcElkVXJsU3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCAmJiByZXMuc3RhdHVzQ29kZSA8IDUwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBmb3VuZCwgcHJvYmFibHkgYSBiYWQga2V5LiBEbyBub3QgdHJ5IGFnYWluLlxyXG4gICAgICAgICAgICAgICAgICAgIENvcnJlbGF0aW9uSWRNYW5hZ2VyLmNvbXBsZXRlZExvb2t1cHNbYXBwSWRVcmxTdHJpbmddID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBDb3JyZWxhdGlvbklkTWFuYWdlci5wZW5kaW5nTG9va3Vwc1thcHBJZFVybFN0cmluZ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSBhZnRlciB0aW1lb3V0LlxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmV0Y2hBcHBJZCwgY29uZmlnLmNvcnJlbGF0aW9uSWRSZXRyeUludGVydmFsTXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHJlcSkge1xyXG4gICAgICAgICAgICAgICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuYWJsZSB0byBjb250YWN0IGVuZHBvaW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIG5vdy5cclxuICAgICAgICAgICAgICAgICAgICBMb2dnaW5nLndhcm4oQ29ycmVsYXRpb25JZE1hbmFnZXIuVEFHLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlcS5lbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0VGltZW91dChmZXRjaEFwcElkLCAwKTtcclxuICAgIH07XHJcbiAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5jYW5jZWxDb3JyZWxhdGlvbklkUXVlcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBhcHBJZFVybFN0cmluZyA9IGNvbmZpZy5wcm9maWxlUXVlcnlFbmRwb2ludCArIFwiL2FwaS9wcm9maWxlcy9cIiArIGNvbmZpZy5pbnN0cnVtZW50YXRpb25LZXkgKyBcIi9hcHBJZFwiO1xyXG4gICAgICAgIHZhciBwZW5kaW5nTG9va3VwcyA9IENvcnJlbGF0aW9uSWRNYW5hZ2VyLnBlbmRpbmdMb29rdXBzW2FwcElkVXJsU3RyaW5nXTtcclxuICAgICAgICBpZiAocGVuZGluZ0xvb2t1cHMpIHtcclxuICAgICAgICAgICAgQ29ycmVsYXRpb25JZE1hbmFnZXIucGVuZGluZ0xvb2t1cHNbYXBwSWRVcmxTdHJpbmddID0gcGVuZGluZ0xvb2t1cHMuZmlsdGVyKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IgIT0gY2FsbGJhY2s7IH0pO1xyXG4gICAgICAgICAgICBpZiAoQ29ycmVsYXRpb25JZE1hbmFnZXIucGVuZGluZ0xvb2t1cHNbYXBwSWRVcmxTdHJpbmddLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgQ29ycmVsYXRpb25JZE1hbmFnZXIucGVuZGluZ0xvb2t1cHNbYXBwSWRVcmxTdHJpbmddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSByZXF1ZXN0IElkIGFjY29yZGluZyB0byBodHRwczovL2dpdGh1Yi5jb20vbG1vbGtvdmEvY29ycmVsYXRpb24vYmxvYi9tYXN0ZXIvaGllcmFyY2hpY2FsX3JlcXVlc3RfaWQubWRcclxuICAgICAqIEBwYXJhbSBwYXJlbnRJZFxyXG4gICAgICovXHJcbiAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5nZW5lcmF0ZVJlcXVlc3RJZCA9IGZ1bmN0aW9uIChwYXJlbnRJZCkge1xyXG4gICAgICAgIGlmIChwYXJlbnRJZCkge1xyXG4gICAgICAgICAgICBwYXJlbnRJZCA9IHBhcmVudElkWzBdID09ICd8JyA/IHBhcmVudElkIDogJ3wnICsgcGFyZW50SWQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRJZFtwYXJlbnRJZC5sZW5ndGggLSAxXSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCArPSAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IChDb3JyZWxhdGlvbklkTWFuYWdlci5jdXJyZW50Um9vdElkKyspLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgcmV0dXJuIENvcnJlbGF0aW9uSWRNYW5hZ2VyLmFwcGVuZFN1ZmZpeChwYXJlbnRJZCwgc3VmZml4LCAnXycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvcnJlbGF0aW9uSWRNYW5hZ2VyLmdlbmVyYXRlUm9vdElkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBoaWVyYXJjaGljYWwgaWRlbnRpZmllciBvZiB0aGUgZm9ybSB8WC4qXHJcbiAgICAgKiByZXR1cm4gdGhlIHJvb3QgaWRlbnRpZmllciBYXHJcbiAgICAgKiBAcGFyYW0gaWRcclxuICAgICAqL1xyXG4gICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuZ2V0Um9vdElkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gaWQuaW5kZXhPZignLicpO1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpZC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gaWRbMF0gPT09ICd8JyA/IDEgOiAwO1xyXG4gICAgICAgIHJldHVybiBpZC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIENvcnJlbGF0aW9uSWRNYW5hZ2VyLmdlbmVyYXRlUm9vdElkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnfCcgKyBVdGlsLnczY1RyYWNlSWQoKSArICcuJztcclxuICAgIH07XHJcbiAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5hcHBlbmRTdWZmaXggPSBmdW5jdGlvbiAocGFyZW50SWQsIHN1ZmZpeCwgZGVsaW1pdGVyKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudElkLmxlbmd0aCArIHN1ZmZpeC5sZW5ndGggPCBDb3JyZWxhdGlvbklkTWFuYWdlci5yZXF1ZXN0SWRNYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudElkICsgc3VmZml4ICsgZGVsaW1pdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21iaW5lZCBpZGVudGlmaWVyIHdvdWxkIGJlIHRvbyBsb25nLCBzbyB3ZSBtdXN0IHRydW5jYXRlIGl0LlxyXG4gICAgICAgIC8vIFdlIG5lZWQgOSBjaGFyYWN0ZXJzIG9mIHNwYWNlOiA4IGZvciB0aGUgb3ZlcmZsb3cgSUQsIDEgZm9yIHRoZVxyXG4gICAgICAgIC8vIG92ZXJmbG93IGRlbGltaXRlciAnIydcclxuICAgICAgICB2YXIgdHJpbVBvc2l0aW9uID0gQ29ycmVsYXRpb25JZE1hbmFnZXIucmVxdWVzdElkTWF4TGVuZ3RoIC0gOTtcclxuICAgICAgICBpZiAocGFyZW50SWQubGVuZ3RoID4gdHJpbVBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGZvciAoOyB0cmltUG9zaXRpb24gPiAxOyAtLXRyaW1Qb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBwYXJlbnRJZFt0cmltUG9zaXRpb24gLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSAnLicgfHwgYyA9PT0gJ18nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyaW1Qb3NpdGlvbiA8PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHBhcmVudElkIGlzIG5vdCBhIHZhbGlkIElEXHJcbiAgICAgICAgICAgIHJldHVybiBDb3JyZWxhdGlvbklkTWFuYWdlci5nZW5lcmF0ZVJvb3RJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWZmaXggPSBVdGlsLnJhbmRvbXUzMigpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICB3aGlsZSAoc3VmZml4Lmxlbmd0aCA8IDgpIHtcclxuICAgICAgICAgICAgc3VmZml4ID0gJzAnICsgc3VmZml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyZW50SWQuc3Vic3RyaW5nKDAsIHRyaW1Qb3NpdGlvbikgKyBzdWZmaXggKyAnIyc7XHJcbiAgICB9O1xyXG4gICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuVEFHID0gXCJDb3JyZWxhdGlvbklkTWFuYWdlclwiO1xyXG4gICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuY29ycmVsYXRpb25JZFByZWZpeCA9IFwiY2lkLXYxOlwiO1xyXG4gICAgLy8gVG8gYXZvaWQgZXh0cmFuZW91cyBIVFRQIHJlcXVlc3RzLCB3ZSBtYWludGFpbiBhIHF1ZXVlIG9mIGNhbGxiYWNrcyB3YWl0aW5nIG9uIGEgcGFydGljdWxhciBhcHBJZCBsb29rdXAsXHJcbiAgICAvLyBhcyB3ZWxsIGFzIGEgY2FjaGUgb2YgY29tcGxldGVkIGxvb2t1cHMgc28gZnV0dXJlIHJlcXVlc3RzIGNhbiBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS5cclxuICAgIENvcnJlbGF0aW9uSWRNYW5hZ2VyLnBlbmRpbmdMb29rdXBzID0ge307XHJcbiAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5jb21wbGV0ZWRMb29rdXBzID0ge307XHJcbiAgICBDb3JyZWxhdGlvbklkTWFuYWdlci5yZXF1ZXN0SWRNYXhMZW5ndGggPSAxMDI0O1xyXG4gICAgQ29ycmVsYXRpb25JZE1hbmFnZXIuY3VycmVudFJvb3RJZCA9IFV0aWwucmFuZG9tdTMyKCk7XHJcbiAgICByZXR1cm4gQ29ycmVsYXRpb25JZE1hbmFnZXI7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gQ29ycmVsYXRpb25JZE1hbmFnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvcnJlbGF0aW9uSWRNYW5hZ2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/CorrelationIdManager.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/EnvelopeFactory.js":
/*!*************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/EnvelopeFactory.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar Util = __webpack_require__(/*! ./Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar CorrelationContextManager_1 = __webpack_require__(/*! ../AutoCollection/CorrelationContextManager */ \"./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\");\r\n/**\r\n * Manages the logic of creating envelopes from Telemetry objects\r\n */\r\nvar EnvelopeFactory = (function () {\r\n    function EnvelopeFactory() {\r\n    }\r\n    /**\r\n     * Creates envelope ready to be sent by Channel\r\n     * @param telemetry Telemetry data\r\n     * @param telemetryType Type of telemetry\r\n     * @param commonProperties Bag of custom common properties to be added to the envelope\r\n     * @param context Client context\r\n     * @param config Client configuration\r\n     */\r\n    EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {\r\n        var data = null;\r\n        switch (telemetryType) {\r\n            case Contracts.TelemetryType.Trace:\r\n                data = EnvelopeFactory.createTraceData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Dependency:\r\n                data = EnvelopeFactory.createDependencyData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Event:\r\n                data = EnvelopeFactory.createEventData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Exception:\r\n                data = EnvelopeFactory.createExceptionData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Request:\r\n                data = EnvelopeFactory.createRequestData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Metric:\r\n                data = EnvelopeFactory.createMetricData(telemetry);\r\n                break;\r\n        }\r\n        if (commonProperties && Contracts.domainSupportsProperties(data.baseData)) {\r\n            if (data && data.baseData) {\r\n                // if no properties are specified just add the common ones\r\n                if (!data.baseData.properties) {\r\n                    data.baseData.properties = commonProperties;\r\n                }\r\n                else {\r\n                    // otherwise, check each of the common ones\r\n                    for (var name in commonProperties) {\r\n                        // only override if the property `name` has not been set on this item\r\n                        if (!data.baseData.properties[name]) {\r\n                            data.baseData.properties[name] = commonProperties[name];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // sanitize properties\r\n            data.baseData.properties = Util.validateStringMap(data.baseData.properties);\r\n        }\r\n        var iKey = config ? config.instrumentationKey || \"\" : \"\";\r\n        var envelope = new Contracts.Envelope();\r\n        envelope.data = data;\r\n        envelope.iKey = iKey;\r\n        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars \"data\"\r\n        envelope.name =\r\n            \"Microsoft.ApplicationInsights.\" +\r\n                iKey.replace(/-/g, \"\") +\r\n                \".\" +\r\n                data.baseType.substr(0, data.baseType.length - 4);\r\n        envelope.tags = this.getTags(context, telemetry.tagOverrides);\r\n        envelope.time = (new Date()).toISOString();\r\n        envelope.ver = 1;\r\n        envelope.sampleRate = config ? config.samplingPercentage : 100;\r\n        // Exclude metrics from sampling by default\r\n        if (telemetryType === Contracts.TelemetryType.Metric) {\r\n            envelope.sampleRate = 100;\r\n        }\r\n        return envelope;\r\n    };\r\n    EnvelopeFactory.createTraceData = function (telemetry) {\r\n        var trace = new Contracts.MessageData();\r\n        trace.message = telemetry.message;\r\n        trace.properties = telemetry.properties;\r\n        if (!isNaN(telemetry.severity)) {\r\n            trace.severityLevel = telemetry.severity;\r\n        }\r\n        else {\r\n            trace.severityLevel = Contracts.SeverityLevel.Information;\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);\r\n        data.baseData = trace;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createDependencyData = function (telemetry) {\r\n        var remoteDependency = new Contracts.RemoteDependencyData();\r\n        remoteDependency.name = telemetry.name;\r\n        remoteDependency.data = telemetry.data;\r\n        remoteDependency.target = telemetry.target;\r\n        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);\r\n        remoteDependency.success = telemetry.success;\r\n        remoteDependency.type = telemetry.dependencyTypeName;\r\n        remoteDependency.properties = telemetry.properties;\r\n        remoteDependency.resultCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        if (telemetry.id) {\r\n            remoteDependency.id = telemetry.id;\r\n        }\r\n        else {\r\n            remoteDependency.id = Util.w3cTraceId();\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);\r\n        data.baseData = remoteDependency;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createEventData = function (telemetry) {\r\n        var event = new Contracts.EventData();\r\n        event.name = telemetry.name;\r\n        event.properties = telemetry.properties;\r\n        event.measurements = telemetry.measurements;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);\r\n        data.baseData = event;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createExceptionData = function (telemetry) {\r\n        var exception = new Contracts.ExceptionData();\r\n        exception.properties = telemetry.properties;\r\n        exception.severityLevel = Contracts.SeverityLevel.Error;\r\n        exception.measurements = telemetry.measurements;\r\n        exception.exceptions = [];\r\n        var stack = telemetry.exception[\"stack\"];\r\n        var exceptionDetails = new Contracts.ExceptionDetails();\r\n        exceptionDetails.message = telemetry.exception.message;\r\n        exceptionDetails.typeName = telemetry.exception.name;\r\n        exceptionDetails.parsedStack = this.parseStack(stack);\r\n        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;\r\n        exception.exceptions.push(exceptionDetails);\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);\r\n        data.baseData = exception;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createRequestData = function (telemetry) {\r\n        var requestData = new Contracts.RequestData();\r\n        if (telemetry.id) {\r\n            requestData.id = telemetry.id;\r\n        }\r\n        else {\r\n            requestData.id = Util.w3cTraceId();\r\n        }\r\n        requestData.name = telemetry.name;\r\n        requestData.url = telemetry.url;\r\n        requestData.source = telemetry.source;\r\n        requestData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        requestData.responseCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        requestData.success = telemetry.success;\r\n        requestData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);\r\n        data.baseData = requestData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createMetricData = function (telemetry) {\r\n        var metrics = new Contracts.MetricData(); // todo: enable client-batching of these\r\n        metrics.metrics = [];\r\n        var metric = new Contracts.DataPoint();\r\n        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;\r\n        metric.kind = Contracts.DataPointType.Aggregation;\r\n        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;\r\n        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;\r\n        metric.name = telemetry.name;\r\n        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;\r\n        metric.value = telemetry.value;\r\n        metrics.metrics.push(metric);\r\n        metrics.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);\r\n        data.baseData = metrics;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.getTags = function (context, tagOverrides) {\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        // Make a copy of context tags so we don't alter the actual object\r\n        // Also perform tag overriding\r\n        var newTags = {};\r\n        if (context && context.tags) {\r\n            for (var key in context.tags) {\r\n                newTags[key] = context.tags[key];\r\n            }\r\n        }\r\n        if (tagOverrides) {\r\n            for (var key in tagOverrides) {\r\n                newTags[key] = tagOverrides[key];\r\n            }\r\n        }\r\n        // Fill in internally-populated values if not already set\r\n        if (correlationContext) {\r\n            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;\r\n            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;\r\n            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;\r\n        }\r\n        return newTags;\r\n    };\r\n    EnvelopeFactory.parseStack = function (stack) {\r\n        var parsedStack = undefined;\r\n        if (typeof stack === \"string\") {\r\n            var frames = stack.split(\"\\n\");\r\n            parsedStack = [];\r\n            var level = 0;\r\n            var totalSizeInBytes = 0;\r\n            for (var i = 0; i <= frames.length; i++) {\r\n                var frame = frames[i];\r\n                if (_StackFrame.regex.test(frame)) {\r\n                    var parsedFrame = new _StackFrame(frames[i], level++);\r\n                    totalSizeInBytes += parsedFrame.sizeInBytes;\r\n                    parsedStack.push(parsedFrame);\r\n                }\r\n            }\r\n            // DP Constraint - exception parsed stack must be < 32KB\r\n            // remove frames from the middle to meet the threshold\r\n            var exceptionParsedStackThreshold = 32 * 1024;\r\n            if (totalSizeInBytes > exceptionParsedStackThreshold) {\r\n                var left = 0;\r\n                var right = parsedStack.length - 1;\r\n                var size = 0;\r\n                var acceptedLeft = left;\r\n                var acceptedRight = right;\r\n                while (left < right) {\r\n                    // check size\r\n                    var lSize = parsedStack[left].sizeInBytes;\r\n                    var rSize = parsedStack[right].sizeInBytes;\r\n                    size += lSize + rSize;\r\n                    if (size > exceptionParsedStackThreshold) {\r\n                        // remove extra frames from the middle\r\n                        var howMany = acceptedRight - acceptedLeft + 1;\r\n                        parsedStack.splice(acceptedLeft, howMany);\r\n                        break;\r\n                    }\r\n                    // update pointers\r\n                    acceptedLeft = left;\r\n                    acceptedRight = right;\r\n                    left++;\r\n                    right--;\r\n                }\r\n            }\r\n        }\r\n        return parsedStack;\r\n    };\r\n    return EnvelopeFactory;\r\n}());\r\nvar _StackFrame = (function () {\r\n    function _StackFrame(frame, level) {\r\n        this.sizeInBytes = 0;\r\n        this.level = level;\r\n        this.method = \"<no_method>\";\r\n        this.assembly = Util.trim(frame);\r\n        var matches = frame.match(_StackFrame.regex);\r\n        if (matches && matches.length >= 5) {\r\n            this.method = Util.trim(matches[2]) || this.method;\r\n            this.fileName = Util.trim(matches[4]) || \"<no_filename>\";\r\n            this.line = parseInt(matches[5]) || 0;\r\n        }\r\n        this.sizeInBytes += this.method.length;\r\n        this.sizeInBytes += this.fileName.length;\r\n        this.sizeInBytes += this.assembly.length;\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        this.sizeInBytes += _StackFrame.baseSize;\r\n        this.sizeInBytes += this.level.toString().length;\r\n        this.sizeInBytes += this.line.toString().length;\r\n    }\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^([\\s]+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\@\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; //'{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nmodule.exports = EnvelopeFactory;\r\n//# sourceMappingURL=EnvelopeFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9FbnZlbG9wZUZhY3RvcnkuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0xpYnJhcnkvRW52ZWxvcGVGYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQ29udHJhY3RzID0gcmVxdWlyZShcIi4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vVXRpbFwiKTtcclxudmFyIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9BdXRvQ29sbGVjdGlvbi9Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXCIpO1xyXG4vKipcclxuICogTWFuYWdlcyB0aGUgbG9naWMgb2YgY3JlYXRpbmcgZW52ZWxvcGVzIGZyb20gVGVsZW1ldHJ5IG9iamVjdHNcclxuICovXHJcbnZhciBFbnZlbG9wZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW52ZWxvcGVGYWN0b3J5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGVudmVsb3BlIHJlYWR5IHRvIGJlIHNlbnQgYnkgQ2hhbm5lbFxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeSBUZWxlbWV0cnkgZGF0YVxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeVR5cGUgVHlwZSBvZiB0ZWxlbWV0cnlcclxuICAgICAqIEBwYXJhbSBjb21tb25Qcm9wZXJ0aWVzIEJhZyBvZiBjdXN0b20gY29tbW9uIHByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGVudmVsb3BlXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBDbGllbnQgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGNvbmZpZyBDbGllbnQgY29uZmlndXJhdGlvblxyXG4gICAgICovXHJcbiAgICBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlRW52ZWxvcGUgPSBmdW5jdGlvbiAodGVsZW1ldHJ5LCB0ZWxlbWV0cnlUeXBlLCBjb21tb25Qcm9wZXJ0aWVzLCBjb250ZXh0LCBjb25maWcpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoICh0ZWxlbWV0cnlUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuVHJhY2U6XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gRW52ZWxvcGVGYWN0b3J5LmNyZWF0ZVRyYWNlRGF0YSh0ZWxlbWV0cnkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuRGVwZW5kZW5jeTpcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlRGVwZW5kZW5jeURhdGEodGVsZW1ldHJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLkV2ZW50OlxyXG4gICAgICAgICAgICAgICAgZGF0YSA9IEVudmVsb3BlRmFjdG9yeS5jcmVhdGVFdmVudERhdGEodGVsZW1ldHJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLkV4Y2VwdGlvbjpcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlRXhjZXB0aW9uRGF0YSh0ZWxlbWV0cnkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuUmVxdWVzdDpcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlUmVxdWVzdERhdGEodGVsZW1ldHJ5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLk1ldHJpYzpcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlTWV0cmljRGF0YSh0ZWxlbWV0cnkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21tb25Qcm9wZXJ0aWVzICYmIENvbnRyYWN0cy5kb21haW5TdXBwb3J0c1Byb3BlcnRpZXMoZGF0YS5iYXNlRGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIGp1c3QgYWRkIHRoZSBjb21tb24gb25lc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmJhc2VEYXRhLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmJhc2VEYXRhLnByb3BlcnRpZXMgPSBjb21tb25Qcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjaGVjayBlYWNoIG9mIHRoZSBjb21tb24gb25lc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29tbW9uUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG92ZXJyaWRlIGlmIHRoZSBwcm9wZXJ0eSBgbmFtZWAgaGFzIG5vdCBiZWVuIHNldCBvbiB0aGlzIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmJhc2VEYXRhLnByb3BlcnRpZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmFzZURhdGEucHJvcGVydGllc1tuYW1lXSA9IGNvbW1vblByb3BlcnRpZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2FuaXRpemUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBkYXRhLmJhc2VEYXRhLnByb3BlcnRpZXMgPSBVdGlsLnZhbGlkYXRlU3RyaW5nTWFwKGRhdGEuYmFzZURhdGEucHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpS2V5ID0gY29uZmlnID8gY29uZmlnLmluc3RydW1lbnRhdGlvbktleSB8fCBcIlwiIDogXCJcIjtcclxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBuZXcgQ29udHJhY3RzLkVudmVsb3BlKCk7XHJcbiAgICAgICAgZW52ZWxvcGUuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgZW52ZWxvcGUuaUtleSA9IGlLZXk7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBraW5kIG9mIGEgaGFjaywgYnV0IHRoZSBlbnZlbG9wZSBuYW1lIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyB0aGUgZGF0YSBuYW1lIHNhbnMgdGhlIGNoYXJzIFwiZGF0YVwiXHJcbiAgICAgICAgZW52ZWxvcGUubmFtZSA9XHJcbiAgICAgICAgICAgIFwiTWljcm9zb2Z0LkFwcGxpY2F0aW9uSW5zaWdodHMuXCIgK1xyXG4gICAgICAgICAgICAgICAgaUtleS5yZXBsYWNlKC8tL2csIFwiXCIpICtcclxuICAgICAgICAgICAgICAgIFwiLlwiICtcclxuICAgICAgICAgICAgICAgIGRhdGEuYmFzZVR5cGUuc3Vic3RyKDAsIGRhdGEuYmFzZVR5cGUubGVuZ3RoIC0gNCk7XHJcbiAgICAgICAgZW52ZWxvcGUudGFncyA9IHRoaXMuZ2V0VGFncyhjb250ZXh0LCB0ZWxlbWV0cnkudGFnT3ZlcnJpZGVzKTtcclxuICAgICAgICBlbnZlbG9wZS50aW1lID0gKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgICAgZW52ZWxvcGUudmVyID0gMTtcclxuICAgICAgICBlbnZlbG9wZS5zYW1wbGVSYXRlID0gY29uZmlnID8gY29uZmlnLnNhbXBsaW5nUGVyY2VudGFnZSA6IDEwMDtcclxuICAgICAgICAvLyBFeGNsdWRlIG1ldHJpY3MgZnJvbSBzYW1wbGluZyBieSBkZWZhdWx0XHJcbiAgICAgICAgaWYgKHRlbGVtZXRyeVR5cGUgPT09IENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLk1ldHJpYykge1xyXG4gICAgICAgICAgICBlbnZlbG9wZS5zYW1wbGVSYXRlID0gMTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW52ZWxvcGU7XHJcbiAgICB9O1xyXG4gICAgRW52ZWxvcGVGYWN0b3J5LmNyZWF0ZVRyYWNlRGF0YSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB2YXIgdHJhY2UgPSBuZXcgQ29udHJhY3RzLk1lc3NhZ2VEYXRhKCk7XHJcbiAgICAgICAgdHJhY2UubWVzc2FnZSA9IHRlbGVtZXRyeS5tZXNzYWdlO1xyXG4gICAgICAgIHRyYWNlLnByb3BlcnRpZXMgPSB0ZWxlbWV0cnkucHJvcGVydGllcztcclxuICAgICAgICBpZiAoIWlzTmFOKHRlbGVtZXRyeS5zZXZlcml0eSkpIHtcclxuICAgICAgICAgICAgdHJhY2Uuc2V2ZXJpdHlMZXZlbCA9IHRlbGVtZXRyeS5zZXZlcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYWNlLnNldmVyaXR5TGV2ZWwgPSBDb250cmFjdHMuU2V2ZXJpdHlMZXZlbC5JbmZvcm1hdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQ29udHJhY3RzLkRhdGEoKTtcclxuICAgICAgICBkYXRhLmJhc2VUeXBlID0gQ29udHJhY3RzLnRlbGVtZXRyeVR5cGVUb0Jhc2VUeXBlKENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLlRyYWNlKTtcclxuICAgICAgICBkYXRhLmJhc2VEYXRhID0gdHJhY2U7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgRW52ZWxvcGVGYWN0b3J5LmNyZWF0ZURlcGVuZGVuY3lEYXRhID0gZnVuY3Rpb24gKHRlbGVtZXRyeSkge1xyXG4gICAgICAgIHZhciByZW1vdGVEZXBlbmRlbmN5ID0gbmV3IENvbnRyYWN0cy5SZW1vdGVEZXBlbmRlbmN5RGF0YSgpO1xyXG4gICAgICAgIHJlbW90ZURlcGVuZGVuY3kubmFtZSA9IHRlbGVtZXRyeS5uYW1lO1xyXG4gICAgICAgIHJlbW90ZURlcGVuZGVuY3kuZGF0YSA9IHRlbGVtZXRyeS5kYXRhO1xyXG4gICAgICAgIHJlbW90ZURlcGVuZGVuY3kudGFyZ2V0ID0gdGVsZW1ldHJ5LnRhcmdldDtcclxuICAgICAgICByZW1vdGVEZXBlbmRlbmN5LmR1cmF0aW9uID0gVXRpbC5tc1RvVGltZVNwYW4odGVsZW1ldHJ5LmR1cmF0aW9uKTtcclxuICAgICAgICByZW1vdGVEZXBlbmRlbmN5LnN1Y2Nlc3MgPSB0ZWxlbWV0cnkuc3VjY2VzcztcclxuICAgICAgICByZW1vdGVEZXBlbmRlbmN5LnR5cGUgPSB0ZWxlbWV0cnkuZGVwZW5kZW5jeVR5cGVOYW1lO1xyXG4gICAgICAgIHJlbW90ZURlcGVuZGVuY3kucHJvcGVydGllcyA9IHRlbGVtZXRyeS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJlbW90ZURlcGVuZGVuY3kucmVzdWx0Q29kZSA9ICh0ZWxlbWV0cnkucmVzdWx0Q29kZSA/IHRlbGVtZXRyeS5yZXN1bHRDb2RlICsgJycgOiAnJyk7XHJcbiAgICAgICAgaWYgKHRlbGVtZXRyeS5pZCkge1xyXG4gICAgICAgICAgICByZW1vdGVEZXBlbmRlbmN5LmlkID0gdGVsZW1ldHJ5LmlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3RlRGVwZW5kZW5jeS5pZCA9IFV0aWwudzNjVHJhY2VJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBDb250cmFjdHMuRGF0YSgpO1xyXG4gICAgICAgIGRhdGEuYmFzZVR5cGUgPSBDb250cmFjdHMudGVsZW1ldHJ5VHlwZVRvQmFzZVR5cGUoQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuRGVwZW5kZW5jeSk7XHJcbiAgICAgICAgZGF0YS5iYXNlRGF0YSA9IHJlbW90ZURlcGVuZGVuY3k7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgRW52ZWxvcGVGYWN0b3J5LmNyZWF0ZUV2ZW50RGF0YSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ29udHJhY3RzLkV2ZW50RGF0YSgpO1xyXG4gICAgICAgIGV2ZW50Lm5hbWUgPSB0ZWxlbWV0cnkubmFtZTtcclxuICAgICAgICBldmVudC5wcm9wZXJ0aWVzID0gdGVsZW1ldHJ5LnByb3BlcnRpZXM7XHJcbiAgICAgICAgZXZlbnQubWVhc3VyZW1lbnRzID0gdGVsZW1ldHJ5Lm1lYXN1cmVtZW50cztcclxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBDb250cmFjdHMuRGF0YSgpO1xyXG4gICAgICAgIGRhdGEuYmFzZVR5cGUgPSBDb250cmFjdHMudGVsZW1ldHJ5VHlwZVRvQmFzZVR5cGUoQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuRXZlbnQpO1xyXG4gICAgICAgIGRhdGEuYmFzZURhdGEgPSBldmVudDtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlRXhjZXB0aW9uRGF0YSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB2YXIgZXhjZXB0aW9uID0gbmV3IENvbnRyYWN0cy5FeGNlcHRpb25EYXRhKCk7XHJcbiAgICAgICAgZXhjZXB0aW9uLnByb3BlcnRpZXMgPSB0ZWxlbWV0cnkucHJvcGVydGllcztcclxuICAgICAgICBleGNlcHRpb24uc2V2ZXJpdHlMZXZlbCA9IENvbnRyYWN0cy5TZXZlcml0eUxldmVsLkVycm9yO1xyXG4gICAgICAgIGV4Y2VwdGlvbi5tZWFzdXJlbWVudHMgPSB0ZWxlbWV0cnkubWVhc3VyZW1lbnRzO1xyXG4gICAgICAgIGV4Y2VwdGlvbi5leGNlcHRpb25zID0gW107XHJcbiAgICAgICAgdmFyIHN0YWNrID0gdGVsZW1ldHJ5LmV4Y2VwdGlvbltcInN0YWNrXCJdO1xyXG4gICAgICAgIHZhciBleGNlcHRpb25EZXRhaWxzID0gbmV3IENvbnRyYWN0cy5FeGNlcHRpb25EZXRhaWxzKCk7XHJcbiAgICAgICAgZXhjZXB0aW9uRGV0YWlscy5tZXNzYWdlID0gdGVsZW1ldHJ5LmV4Y2VwdGlvbi5tZXNzYWdlO1xyXG4gICAgICAgIGV4Y2VwdGlvbkRldGFpbHMudHlwZU5hbWUgPSB0ZWxlbWV0cnkuZXhjZXB0aW9uLm5hbWU7XHJcbiAgICAgICAgZXhjZXB0aW9uRGV0YWlscy5wYXJzZWRTdGFjayA9IHRoaXMucGFyc2VTdGFjayhzdGFjayk7XHJcbiAgICAgICAgZXhjZXB0aW9uRGV0YWlscy5oYXNGdWxsU3RhY2sgPSBVdGlsLmlzQXJyYXkoZXhjZXB0aW9uRGV0YWlscy5wYXJzZWRTdGFjaykgJiYgZXhjZXB0aW9uRGV0YWlscy5wYXJzZWRTdGFjay5sZW5ndGggPiAwO1xyXG4gICAgICAgIGV4Y2VwdGlvbi5leGNlcHRpb25zLnB1c2goZXhjZXB0aW9uRGV0YWlscyk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQ29udHJhY3RzLkRhdGEoKTtcclxuICAgICAgICBkYXRhLmJhc2VUeXBlID0gQ29udHJhY3RzLnRlbGVtZXRyeVR5cGVUb0Jhc2VUeXBlKENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLkV4Y2VwdGlvbik7XHJcbiAgICAgICAgZGF0YS5iYXNlRGF0YSA9IGV4Y2VwdGlvbjtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlUmVxdWVzdERhdGEgPSBmdW5jdGlvbiAodGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3REYXRhID0gbmV3IENvbnRyYWN0cy5SZXF1ZXN0RGF0YSgpO1xyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkuaWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdERhdGEuaWQgPSB0ZWxlbWV0cnkuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5pZCA9IFV0aWwudzNjVHJhY2VJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0RGF0YS5uYW1lID0gdGVsZW1ldHJ5Lm5hbWU7XHJcbiAgICAgICAgcmVxdWVzdERhdGEudXJsID0gdGVsZW1ldHJ5LnVybDtcclxuICAgICAgICByZXF1ZXN0RGF0YS5zb3VyY2UgPSB0ZWxlbWV0cnkuc291cmNlO1xyXG4gICAgICAgIHJlcXVlc3REYXRhLmR1cmF0aW9uID0gVXRpbC5tc1RvVGltZVNwYW4odGVsZW1ldHJ5LmR1cmF0aW9uKTtcclxuICAgICAgICByZXF1ZXN0RGF0YS5yZXNwb25zZUNvZGUgPSAodGVsZW1ldHJ5LnJlc3VsdENvZGUgPyB0ZWxlbWV0cnkucmVzdWx0Q29kZSArICcnIDogJycpO1xyXG4gICAgICAgIHJlcXVlc3REYXRhLnN1Y2Nlc3MgPSB0ZWxlbWV0cnkuc3VjY2VzcztcclxuICAgICAgICByZXF1ZXN0RGF0YS5wcm9wZXJ0aWVzID0gdGVsZW1ldHJ5LnByb3BlcnRpZXM7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQ29udHJhY3RzLkRhdGEoKTtcclxuICAgICAgICBkYXRhLmJhc2VUeXBlID0gQ29udHJhY3RzLnRlbGVtZXRyeVR5cGVUb0Jhc2VUeXBlKENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLlJlcXVlc3QpO1xyXG4gICAgICAgIGRhdGEuYmFzZURhdGEgPSByZXF1ZXN0RGF0YTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlTWV0cmljRGF0YSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB2YXIgbWV0cmljcyA9IG5ldyBDb250cmFjdHMuTWV0cmljRGF0YSgpOyAvLyB0b2RvOiBlbmFibGUgY2xpZW50LWJhdGNoaW5nIG9mIHRoZXNlXHJcbiAgICAgICAgbWV0cmljcy5tZXRyaWNzID0gW107XHJcbiAgICAgICAgdmFyIG1ldHJpYyA9IG5ldyBDb250cmFjdHMuRGF0YVBvaW50KCk7XHJcbiAgICAgICAgbWV0cmljLmNvdW50ID0gIWlzTmFOKHRlbGVtZXRyeS5jb3VudCkgPyB0ZWxlbWV0cnkuY291bnQgOiAxO1xyXG4gICAgICAgIG1ldHJpYy5raW5kID0gQ29udHJhY3RzLkRhdGFQb2ludFR5cGUuQWdncmVnYXRpb247XHJcbiAgICAgICAgbWV0cmljLm1heCA9ICFpc05hTih0ZWxlbWV0cnkubWF4KSA/IHRlbGVtZXRyeS5tYXggOiB0ZWxlbWV0cnkudmFsdWU7XHJcbiAgICAgICAgbWV0cmljLm1pbiA9ICFpc05hTih0ZWxlbWV0cnkubWluKSA/IHRlbGVtZXRyeS5taW4gOiB0ZWxlbWV0cnkudmFsdWU7XHJcbiAgICAgICAgbWV0cmljLm5hbWUgPSB0ZWxlbWV0cnkubmFtZTtcclxuICAgICAgICBtZXRyaWMuc3RkRGV2ID0gIWlzTmFOKHRlbGVtZXRyeS5zdGREZXYpID8gdGVsZW1ldHJ5LnN0ZERldiA6IDA7XHJcbiAgICAgICAgbWV0cmljLnZhbHVlID0gdGVsZW1ldHJ5LnZhbHVlO1xyXG4gICAgICAgIG1ldHJpY3MubWV0cmljcy5wdXNoKG1ldHJpYyk7XHJcbiAgICAgICAgbWV0cmljcy5wcm9wZXJ0aWVzID0gdGVsZW1ldHJ5LnByb3BlcnRpZXM7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQ29udHJhY3RzLkRhdGEoKTtcclxuICAgICAgICBkYXRhLmJhc2VUeXBlID0gQ29udHJhY3RzLnRlbGVtZXRyeVR5cGVUb0Jhc2VUeXBlKENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLk1ldHJpYyk7XHJcbiAgICAgICAgZGF0YS5iYXNlRGF0YSA9IG1ldHJpY3M7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgRW52ZWxvcGVGYWN0b3J5LmdldFRhZ3MgPSBmdW5jdGlvbiAoY29udGV4dCwgdGFnT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgdmFyIGNvcnJlbGF0aW9uQ29udGV4dCA9IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMS5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk7XHJcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgY29udGV4dCB0YWdzIHNvIHdlIGRvbid0IGFsdGVyIHRoZSBhY3R1YWwgb2JqZWN0XHJcbiAgICAgICAgLy8gQWxzbyBwZXJmb3JtIHRhZyBvdmVycmlkaW5nXHJcbiAgICAgICAgdmFyIG5ld1RhZ3MgPSB7fTtcclxuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnRhZ3MpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbnRleHQudGFncykge1xyXG4gICAgICAgICAgICAgICAgbmV3VGFnc1trZXldID0gY29udGV4dC50YWdzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhZ092ZXJyaWRlcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGFnT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUYWdzW2tleV0gPSB0YWdPdmVycmlkZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaWxsIGluIGludGVybmFsbHktcG9wdWxhdGVkIHZhbHVlcyBpZiBub3QgYWxyZWFkeSBzZXRcclxuICAgICAgICBpZiAoY29ycmVsYXRpb25Db250ZXh0KSB7XHJcbiAgICAgICAgICAgIG5ld1RhZ3NbY29udGV4dC5rZXlzLm9wZXJhdGlvbklkXSA9IG5ld1RhZ3NbY29udGV4dC5rZXlzLm9wZXJhdGlvbklkXSB8fCBjb3JyZWxhdGlvbkNvbnRleHQub3BlcmF0aW9uLmlkO1xyXG4gICAgICAgICAgICBuZXdUYWdzW2NvbnRleHQua2V5cy5vcGVyYXRpb25OYW1lXSA9IG5ld1RhZ3NbY29udGV4dC5rZXlzLm9wZXJhdGlvbk5hbWVdIHx8IGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ubmFtZTtcclxuICAgICAgICAgICAgbmV3VGFnc1tjb250ZXh0LmtleXMub3BlcmF0aW9uUGFyZW50SWRdID0gbmV3VGFnc1tjb250ZXh0LmtleXMub3BlcmF0aW9uUGFyZW50SWRdIHx8IGNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24ucGFyZW50SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdUYWdzO1xyXG4gICAgfTtcclxuICAgIEVudmVsb3BlRmFjdG9yeS5wYXJzZVN0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZFN0YWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHN0YWNrLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICBwYXJzZWRTdGFjayA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxTaXplSW5CeXRlcyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9TdGFja0ZyYW1lLnJlZ2V4LnRlc3QoZnJhbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZEZyYW1lID0gbmV3IF9TdGFja0ZyYW1lKGZyYW1lc1tpXSwgbGV2ZWwrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplSW5CeXRlcyArPSBwYXJzZWRGcmFtZS5zaXplSW5CeXRlcztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRTdGFjay5wdXNoKHBhcnNlZEZyYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEUCBDb25zdHJhaW50IC0gZXhjZXB0aW9uIHBhcnNlZCBzdGFjayBtdXN0IGJlIDwgMzJLQlxyXG4gICAgICAgICAgICAvLyByZW1vdmUgZnJhbWVzIGZyb20gdGhlIG1pZGRsZSB0byBtZWV0IHRoZSB0aHJlc2hvbGRcclxuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvblBhcnNlZFN0YWNrVGhyZXNob2xkID0gMzIgKiAxMDI0O1xyXG4gICAgICAgICAgICBpZiAodG90YWxTaXplSW5CeXRlcyA+IGV4Y2VwdGlvblBhcnNlZFN0YWNrVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBwYXJzZWRTdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjY2VwdGVkTGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWNjZXB0ZWRSaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNpemVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbFNpemUgPSBwYXJzZWRTdGFja1tsZWZ0XS5zaXplSW5CeXRlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgclNpemUgPSBwYXJzZWRTdGFja1tyaWdodF0uc2l6ZUluQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBsU2l6ZSArIHJTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gZXhjZXB0aW9uUGFyc2VkU3RhY2tUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGV4dHJhIGZyYW1lcyBmcm9tIHRoZSBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBhY2NlcHRlZFJpZ2h0IC0gYWNjZXB0ZWRMZWZ0ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkU3RhY2suc3BsaWNlKGFjY2VwdGVkTGVmdCwgaG93TWFueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9pbnRlcnNcclxuICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZExlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkUmlnaHQgPSByaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VkU3RhY2s7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVudmVsb3BlRmFjdG9yeTtcclxufSgpKTtcclxudmFyIF9TdGFja0ZyYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIF9TdGFja0ZyYW1lKGZyYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZUluQnl0ZXMgPSAwO1xyXG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IFwiPG5vX21ldGhvZD5cIjtcclxuICAgICAgICB0aGlzLmFzc2VtYmx5ID0gVXRpbC50cmltKGZyYW1lKTtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZyYW1lLm1hdGNoKF9TdGFja0ZyYW1lLnJlZ2V4KTtcclxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+PSA1KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gVXRpbC50cmltKG1hdGNoZXNbMl0pIHx8IHRoaXMubWV0aG9kO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gVXRpbC50cmltKG1hdGNoZXNbNF0pIHx8IFwiPG5vX2ZpbGVuYW1lPlwiO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSBwYXJzZUludChtYXRjaGVzWzVdKSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNpemVJbkJ5dGVzICs9IHRoaXMubWV0aG9kLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnNpemVJbkJ5dGVzICs9IHRoaXMuZmlsZU5hbWUubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc2l6ZUluQnl0ZXMgKz0gdGhpcy5hc3NlbWJseS5sZW5ndGg7XHJcbiAgICAgICAgLy8gdG9kbzogdGhlc2UgbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkIGRlcGVuZGluZyBvbiBob3cgdGhlIGJhY2stZW5kIHNldHRsZXMgb24gdGhlaXIgc2l6ZSBjYWxjdWxhdGlvblxyXG4gICAgICAgIHRoaXMuc2l6ZUluQnl0ZXMgKz0gX1N0YWNrRnJhbWUuYmFzZVNpemU7XHJcbiAgICAgICAgdGhpcy5zaXplSW5CeXRlcyArPSB0aGlzLmxldmVsLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc2l6ZUluQnl0ZXMgKz0gdGhpcy5saW5lLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLy8gcmVnZXggdG8gbWF0Y2ggc3RhY2sgZnJhbWVzIGZyb20gaWUvY2hyb21lL2ZmXHJcbiAgICAvLyBtZXRob2ROYW1lPSQyLCBmaWxlTmFtZT0kNCwgbGluZU5vPSQ1LCBjb2x1bW49JDZcclxuICAgIF9TdGFja0ZyYW1lLnJlZ2V4ID0gL14oW1xcc10rYXQpPyguKj8pKFxcQHxcXHNcXCh8XFxzKShbXlxcKFxcQFxcbl0rKTooWzAtOV0rKTooWzAtOV0rKShcXCk/KSQvO1xyXG4gICAgX1N0YWNrRnJhbWUuYmFzZVNpemUgPSA1ODsgLy8ne1wibWV0aG9kXCI6XCJcIixcImxldmVsXCI6LFwiYXNzZW1ibHlcIjpcIlwiLFwiZmlsZU5hbWVcIjpcIlwiLFwibGluZVwiOn0nLmxlbmd0aFxyXG4gICAgcmV0dXJuIF9TdGFja0ZyYW1lO1xyXG59KCkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEVudmVsb3BlRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW52ZWxvcGVGYWN0b3J5LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/EnvelopeFactory.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Logging.js":
/*!*****************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Logging.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar Logging = (function () {\r\n    function Logging() {\r\n    }\r\n    Logging.info = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (Logging.enableDebug) {\r\n            console.info(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.warn = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (!Logging.disableWarnings) {\r\n            console.warn(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.enableDebug = false;\r\n    Logging.disableWarnings = false;\r\n    Logging.TAG = \"ApplicationInsights:\";\r\n    return Logging;\r\n}());\r\nmodule.exports = Logging;\r\n//# sourceMappingURL=Logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Mb2dnaW5nLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L0xvZ2dpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBMb2dnaW5nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvZ2dpbmcoKSB7XHJcbiAgICB9XHJcbiAgICBMb2dnaW5nLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbmFsUGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTG9nZ2luZy5lbmFibGVEZWJ1Zykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oTG9nZ2luZy5UQUcgKyBtZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dpbmcud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbmFsUGFyYW1zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghTG9nZ2luZy5kaXNhYmxlV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKExvZ2dpbmcuVEFHICsgbWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnaW5nLmVuYWJsZURlYnVnID0gZmFsc2U7XHJcbiAgICBMb2dnaW5nLmRpc2FibGVXYXJuaW5ncyA9IGZhbHNlO1xyXG4gICAgTG9nZ2luZy5UQUcgPSBcIkFwcGxpY2F0aW9uSW5zaWdodHM6XCI7XHJcbiAgICByZXR1cm4gTG9nZ2luZztcclxufSgpKTtcclxubW9kdWxlLmV4cG9ydHMgPSBMb2dnaW5nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnaW5nLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Logging.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/NodeClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/NodeClient.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar TelemetryClient = __webpack_require__(/*! ./TelemetryClient */ \"./node_modules/applicationinsights/out/Library/TelemetryClient.js\");\r\nvar ServerRequestTracking = __webpack_require__(/*! ../AutoCollection/HttpRequests */ \"./node_modules/applicationinsights/out/AutoCollection/HttpRequests.js\");\r\nvar ClientRequestTracking = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ \"./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\n/**\r\n * Application Insights Telemetry Client for Node.JS. Provides the Application Insights TelemetryClient API\r\n * in addition to Node-specific helper functions.\r\n * Construct a new TelemetryClient to have an instance with a different configuration than the default client.\r\n * In most cases, `appInsights.defaultClient` should be used instead.\r\n */\r\nvar NodeClient = (function (_super) {\r\n    __extends(NodeClient, _super);\r\n    function NodeClient() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will log immediately without waitng for request completion\r\n     * and it requires duration parameter to be specified on NodeHttpRequestTelemetry object.\r\n     * Use trackNodeHttpRequest function to log the telemetry after request completion\r\n     * @param telemetry Object encapsulating incoming request, response and duration information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {\r\n        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {\r\n            ServerRequestTracking.trackRequestSync(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will `follow` the request to completion.\r\n     * Use trackNodeHttpRequestSync function to log telemetry immediately without waiting for request completion\r\n     * @param telemetry Object encapsulating incoming request and response information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {\r\n        if (telemetry.duration || telemetry.error) {\r\n            Logging.warn(\"trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.\");\r\n        }\r\n        if (telemetry && telemetry.request && telemetry.response) {\r\n            ServerRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log DependencyTelemetry from outgoing HTTP request. This method will instrument the outgoing request and append\r\n     * the specified headers and will log the telemetry when outgoing request is complete\r\n     * @param telemetry Object encapsulating outgoing request information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {\r\n        if (telemetry && telemetry.request) {\r\n            ClientRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.\");\r\n        }\r\n    };\r\n    return NodeClient;\r\n}(TelemetryClient));\r\nmodule.exports = NodeClient;\r\n//# sourceMappingURL=NodeClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9Ob2RlQ2xpZW50LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L05vZGVDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgVGVsZW1ldHJ5Q2xpZW50ID0gcmVxdWlyZShcIi4vVGVsZW1ldHJ5Q2xpZW50XCIpO1xyXG52YXIgU2VydmVyUmVxdWVzdFRyYWNraW5nID0gcmVxdWlyZShcIi4uL0F1dG9Db2xsZWN0aW9uL0h0dHBSZXF1ZXN0c1wiKTtcclxudmFyIENsaWVudFJlcXVlc3RUcmFja2luZyA9IHJlcXVpcmUoXCIuLi9BdXRvQ29sbGVjdGlvbi9IdHRwRGVwZW5kZW5jaWVzXCIpO1xyXG52YXIgTG9nZ2luZyA9IHJlcXVpcmUoXCIuL0xvZ2dpbmdcIik7XHJcbi8qKlxyXG4gKiBBcHBsaWNhdGlvbiBJbnNpZ2h0cyBUZWxlbWV0cnkgQ2xpZW50IGZvciBOb2RlLkpTLiBQcm92aWRlcyB0aGUgQXBwbGljYXRpb24gSW5zaWdodHMgVGVsZW1ldHJ5Q2xpZW50IEFQSVxyXG4gKiBpbiBhZGRpdGlvbiB0byBOb2RlLXNwZWNpZmljIGhlbHBlciBmdW5jdGlvbnMuXHJcbiAqIENvbnN0cnVjdCBhIG5ldyBUZWxlbWV0cnlDbGllbnQgdG8gaGF2ZSBhbiBpbnN0YW5jZSB3aXRoIGEgZGlmZmVyZW50IGNvbmZpZ3VyYXRpb24gdGhhbiB0aGUgZGVmYXVsdCBjbGllbnQuXHJcbiAqIEluIG1vc3QgY2FzZXMsIGBhcHBJbnNpZ2h0cy5kZWZhdWx0Q2xpZW50YCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gKi9cclxudmFyIE5vZGVDbGllbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5vZGVDbGllbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOb2RlQ2xpZW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9nIFJlcXVlc3RUZWxlbWV0cnkgZnJvbSBIVFRQIHJlcXVlc3QgYW5kIHJlc3BvbnNlLiBUaGlzIG1ldGhvZCB3aWxsIGxvZyBpbW1lZGlhdGVseSB3aXRob3V0IHdhaXRuZyBmb3IgcmVxdWVzdCBjb21wbGV0aW9uXHJcbiAgICAgKiBhbmQgaXQgcmVxdWlyZXMgZHVyYXRpb24gcGFyYW1ldGVyIHRvIGJlIHNwZWNpZmllZCBvbiBOb2RlSHR0cFJlcXVlc3RUZWxlbWV0cnkgb2JqZWN0LlxyXG4gICAgICogVXNlIHRyYWNrTm9kZUh0dHBSZXF1ZXN0IGZ1bmN0aW9uIHRvIGxvZyB0aGUgdGVsZW1ldHJ5IGFmdGVyIHJlcXVlc3QgY29tcGxldGlvblxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeSBPYmplY3QgZW5jYXBzdWxhdGluZyBpbmNvbWluZyByZXF1ZXN0LCByZXNwb25zZSBhbmQgZHVyYXRpb24gaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgTm9kZUNsaWVudC5wcm90b3R5cGUudHJhY2tOb2RlSHR0cFJlcXVlc3RTeW5jID0gZnVuY3Rpb24gKHRlbGVtZXRyeSkge1xyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkgJiYgdGVsZW1ldHJ5LnJlcXVlc3QgJiYgdGVsZW1ldHJ5LnJlc3BvbnNlICYmIHRlbGVtZXRyeS5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICBTZXJ2ZXJSZXF1ZXN0VHJhY2tpbmcudHJhY2tSZXF1ZXN0U3luYyh0aGlzLCB0ZWxlbWV0cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTG9nZ2luZy53YXJuKFwidHJhY2tOb2RlSHR0cFJlcXVlc3RTeW5jIHJlcXVpcmVzIE5vZGVIdHRwUmVxdWVzdFRlbGVtZXRyeSBvYmplY3Qgd2l0aCByZXF1ZXN0LCByZXNwb25zZSBhbmQgZHVyYXRpb24gc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgUmVxdWVzdFRlbGVtZXRyeSBmcm9tIEhUVFAgcmVxdWVzdCBhbmQgcmVzcG9uc2UuIFRoaXMgbWV0aG9kIHdpbGwgYGZvbGxvd2AgdGhlIHJlcXVlc3QgdG8gY29tcGxldGlvbi5cclxuICAgICAqIFVzZSB0cmFja05vZGVIdHRwUmVxdWVzdFN5bmMgZnVuY3Rpb24gdG8gbG9nIHRlbGVtZXRyeSBpbW1lZGlhdGVseSB3aXRob3V0IHdhaXRpbmcgZm9yIHJlcXVlc3QgY29tcGxldGlvblxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeSBPYmplY3QgZW5jYXBzdWxhdGluZyBpbmNvbWluZyByZXF1ZXN0IGFuZCByZXNwb25zZSBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBOb2RlQ2xpZW50LnByb3RvdHlwZS50cmFja05vZGVIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICBpZiAodGVsZW1ldHJ5LmR1cmF0aW9uIHx8IHRlbGVtZXRyeS5lcnJvcikge1xyXG4gICAgICAgICAgICBMb2dnaW5nLndhcm4oXCJ0cmFja05vZGVIdHRwUmVxdWVzdCB3aWxsIGlnbm9yZSBzdXBwbGllZCBkdXJhdGlvbiBhbmQgZXJyb3IgcGFyYW1ldGVycy4gVGhlc2UgdmFsdWVzIGFyZSBjb2xsZWN0ZWQgZnJvbSB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2Ugb2JqZWN0cy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkgJiYgdGVsZW1ldHJ5LnJlcXVlc3QgJiYgdGVsZW1ldHJ5LnJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIFNlcnZlclJlcXVlc3RUcmFja2luZy50cmFja1JlcXVlc3QodGhpcywgdGVsZW1ldHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcud2FybihcInRyYWNrTm9kZUh0dHBSZXF1ZXN0IHJlcXVpcmVzIE5vZGVIdHRwUmVxdWVzdFRlbGVtZXRyeSBvYmplY3Qgd2l0aCByZXF1ZXN0IGFuZCByZXNwb25zZSBzcGVjaWZpZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvZyBEZXBlbmRlbmN5VGVsZW1ldHJ5IGZyb20gb3V0Z29pbmcgSFRUUCByZXF1ZXN0LiBUaGlzIG1ldGhvZCB3aWxsIGluc3RydW1lbnQgdGhlIG91dGdvaW5nIHJlcXVlc3QgYW5kIGFwcGVuZFxyXG4gICAgICogdGhlIHNwZWNpZmllZCBoZWFkZXJzIGFuZCB3aWxsIGxvZyB0aGUgdGVsZW1ldHJ5IHdoZW4gb3V0Z29pbmcgcmVxdWVzdCBpcyBjb21wbGV0ZVxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeSBPYmplY3QgZW5jYXBzdWxhdGluZyBvdXRnb2luZyByZXF1ZXN0IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIE5vZGVDbGllbnQucHJvdG90eXBlLnRyYWNrTm9kZUh0dHBEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHRlbGVtZXRyeSkge1xyXG4gICAgICAgIGlmICh0ZWxlbWV0cnkgJiYgdGVsZW1ldHJ5LnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgQ2xpZW50UmVxdWVzdFRyYWNraW5nLnRyYWNrUmVxdWVzdCh0aGlzLCB0ZWxlbWV0cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTG9nZ2luZy53YXJuKFwidHJhY2tOb2RlSHR0cERlcGVuZGVuY3kgcmVxdWlyZXMgTm9kZUh0dHBEZXBlbmRlbmN5VGVsZW1ldHJ5IG9iamVjdCB3aXRoIHJlcXVlc3Qgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vZGVDbGllbnQ7XHJcbn0oVGVsZW1ldHJ5Q2xpZW50KSk7XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZUNsaWVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9kZUNsaWVudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/NodeClient.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js":
/*!********************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = {\r\n    /**\r\n     * Request-Context header\r\n     */\r\n    requestContextHeader: \"request-context\",\r\n    /**\r\n     * Source instrumentation header that is added by an application while making http\r\n     * requests and retrieved by the other application when processing incoming requests.\r\n     */\r\n    requestContextSourceKey: \"appId\",\r\n    /**\r\n     * Target instrumentation header that is added to the response and retrieved by the\r\n     * calling application when processing incoming responses.\r\n     */\r\n    requestContextTargetKey: \"appId\",\r\n    /**\r\n     * Request-Id header\r\n     */\r\n    requestIdHeader: \"request-id\",\r\n    /**\r\n     * Legacy Header containing the id of the immidiate caller\r\n     */\r\n    parentIdHeader: \"x-ms-request-id\",\r\n    /**\r\n     * Legacy Header containing the correlation id that kept the same for every telemetry item\r\n     * accross transactions\r\n     */\r\n    rootIdHeader: \"x-ms-request-root-id\",\r\n    /**\r\n     * Correlation-Context header\r\n     *\r\n     * Not currently actively used, but the contents should be passed from incoming to outgoing requests\r\n     */\r\n    correlationContextHeader: \"correlation-context\"\r\n};\r\n//# sourceMappingURL=RequestResponseHeaders.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9SZXF1ZXN0UmVzcG9uc2VIZWFkZXJzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L1JlcXVlc3RSZXNwb25zZUhlYWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0LUNvbnRleHQgaGVhZGVyXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3RDb250ZXh0SGVhZGVyOiBcInJlcXVlc3QtY29udGV4dFwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3VyY2UgaW5zdHJ1bWVudGF0aW9uIGhlYWRlciB0aGF0IGlzIGFkZGVkIGJ5IGFuIGFwcGxpY2F0aW9uIHdoaWxlIG1ha2luZyBodHRwXHJcbiAgICAgKiByZXF1ZXN0cyBhbmQgcmV0cmlldmVkIGJ5IHRoZSBvdGhlciBhcHBsaWNhdGlvbiB3aGVuIHByb2Nlc3NpbmcgaW5jb21pbmcgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3RDb250ZXh0U291cmNlS2V5OiBcImFwcElkXCIsXHJcbiAgICAvKipcclxuICAgICAqIFRhcmdldCBpbnN0cnVtZW50YXRpb24gaGVhZGVyIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHJlc3BvbnNlIGFuZCByZXRyaWV2ZWQgYnkgdGhlXHJcbiAgICAgKiBjYWxsaW5nIGFwcGxpY2F0aW9uIHdoZW4gcHJvY2Vzc2luZyBpbmNvbWluZyByZXNwb25zZXMuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3RDb250ZXh0VGFyZ2V0S2V5OiBcImFwcElkXCIsXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QtSWQgaGVhZGVyXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3RJZEhlYWRlcjogXCJyZXF1ZXN0LWlkXCIsXHJcbiAgICAvKipcclxuICAgICAqIExlZ2FjeSBIZWFkZXIgY29udGFpbmluZyB0aGUgaWQgb2YgdGhlIGltbWlkaWF0ZSBjYWxsZXJcclxuICAgICAqL1xyXG4gICAgcGFyZW50SWRIZWFkZXI6IFwieC1tcy1yZXF1ZXN0LWlkXCIsXHJcbiAgICAvKipcclxuICAgICAqIExlZ2FjeSBIZWFkZXIgY29udGFpbmluZyB0aGUgY29ycmVsYXRpb24gaWQgdGhhdCBrZXB0IHRoZSBzYW1lIGZvciBldmVyeSB0ZWxlbWV0cnkgaXRlbVxyXG4gICAgICogYWNjcm9zcyB0cmFuc2FjdGlvbnNcclxuICAgICAqL1xyXG4gICAgcm9vdElkSGVhZGVyOiBcIngtbXMtcmVxdWVzdC1yb290LWlkXCIsXHJcbiAgICAvKipcclxuICAgICAqIENvcnJlbGF0aW9uLUNvbnRleHQgaGVhZGVyXHJcbiAgICAgKlxyXG4gICAgICogTm90IGN1cnJlbnRseSBhY3RpdmVseSB1c2VkLCBidXQgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBwYXNzZWQgZnJvbSBpbmNvbWluZyB0byBvdXRnb2luZyByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBjb3JyZWxhdGlvbkNvbnRleHRIZWFkZXI6IFwiY29ycmVsYXRpb24tY29udGV4dFwiXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcXVlc3RSZXNwb25zZUhlYWRlcnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Sender.js":
/*!****************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Sender.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar os = __webpack_require__(/*! os */ \"os\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\nvar child_process = __webpack_require__(/*! child_process */ \"child_process\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar AutoCollectHttpDependencies = __webpack_require__(/*! ../AutoCollection/HttpDependencies */ \"./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js\");\r\nvar Util = __webpack_require__(/*! ./Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar Sender = (function () {\r\n    function Sender(config, onSuccess, onError) {\r\n        this._config = config;\r\n        this._onSuccess = onSuccess;\r\n        this._onError = onError;\r\n        this._enableDiskRetryMode = false;\r\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\r\n        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;\r\n        this._numConsecutiveFailures = 0;\r\n        if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            // Node's chmod levels do not appropriately restrict file access on Windows\r\n            // Use the built-in command line tool ICACLS on Windows to properly restrict\r\n            // access to the temporary directory used for disk retry mode.\r\n            if (Sender.USE_ICACLS) {\r\n                // This should be async - but it's currently safer to have this synchronous\r\n                // This guarantees we can immediately fail setDiskRetryMode if we need to\r\n                try {\r\n                    Sender.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(Sender.ICACLS_PATH);\r\n                }\r\n                catch (e) { }\r\n                if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n                    Logging.warn(Sender.TAG, \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\");\r\n                }\r\n            }\r\n            else {\r\n                // chmod works everywhere else\r\n                Sender.OS_PROVIDES_FILE_PROTECTION = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Enable or disable offline mode\r\n    */\r\n    Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._enableDiskRetryMode = Sender.OS_PROVIDES_FILE_PROTECTION && value;\r\n        if (typeof resendInterval === 'number' && resendInterval >= 0) {\r\n            this._resendInterval = Math.floor(resendInterval);\r\n        }\r\n        if (typeof maxBytesOnDisk === 'number' && maxBytesOnDisk >= 0) {\r\n            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);\r\n        }\r\n        if (value && !Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            this._enableDiskRetryMode = false;\r\n            Logging.warn(Sender.TAG, \"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\");\r\n        }\r\n    };\r\n    Sender.prototype.send = function (payload, callback) {\r\n        var _this = this;\r\n        var endpointUrl = this._config.endpointUrl;\r\n        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\r\n        var options = {\r\n            method: \"POST\",\r\n            withCredentials: false,\r\n            headers: {\r\n                \"Content-Type\": \"application/x-json-stream\"\r\n            }\r\n        };\r\n        zlib.gzip(payload, function (err, buffer) {\r\n            var dataToSend = buffer;\r\n            if (err) {\r\n                Logging.warn(err);\r\n                dataToSend = payload; // something went wrong so send without gzip\r\n                options.headers[\"Content-Length\"] = payload.length.toString();\r\n            }\r\n            else {\r\n                options.headers[\"Content-Encoding\"] = \"gzip\";\r\n                options.headers[\"Content-Length\"] = buffer.length;\r\n            }\r\n            Logging.info(Sender.TAG, options);\r\n            // Ensure this request is not captured by auto-collection.\r\n            options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;\r\n            var requestCallback = function (res) {\r\n                res.setEncoding(\"utf-8\");\r\n                //returns empty if the data is accepted\r\n                var responseString = \"\";\r\n                res.on(\"data\", function (data) {\r\n                    responseString += data;\r\n                });\r\n                res.on(\"end\", function () {\r\n                    _this._numConsecutiveFailures = 0;\r\n                    Logging.info(Sender.TAG, responseString);\r\n                    if (typeof _this._onSuccess === \"function\") {\r\n                        _this._onSuccess(responseString);\r\n                    }\r\n                    if (typeof callback === \"function\") {\r\n                        callback(responseString);\r\n                    }\r\n                    if (_this._enableDiskRetryMode) {\r\n                        // try to send any cached events if the user is back online\r\n                        if (res.statusCode === 200) {\r\n                            setTimeout(function () { return _this._sendFirstFileOnDisk(); }, _this._resendInterval);\r\n                            // store to disk in case of burst throttling\r\n                        }\r\n                        else if (res.statusCode === 408 ||\r\n                            res.statusCode === 429 ||\r\n                            res.statusCode === 439 ||\r\n                            res.statusCode === 500 ||\r\n                            res.statusCode === 503) {\r\n                            // TODO: Do not support partial success (206) until _sendFirstFileOnDisk checks payload age\r\n                            _this._storeToDisk(payload);\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);\r\n            req.on(\"error\", function (error) {\r\n                // todo: handle error codes better (group to recoverable/non-recoverable and persist)\r\n                _this._numConsecutiveFailures++;\r\n                // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data\r\n                // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors\r\n                // Continue informing on each failure if verbose logging is being used\r\n                if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {\r\n                    var notice = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\r\n                    if (_this._enableDiskRetryMode) {\r\n                        notice = \"Ingestion endpoint could not be reached \" + _this._numConsecutiveFailures + \" consecutive times. There may be resulting telemetry loss. Most recent error:\";\r\n                    }\r\n                    Logging.warn(Sender.TAG, notice, error);\r\n                }\r\n                else {\r\n                    var notice = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\";\r\n                    Logging.info(Sender.TAG, notice, error);\r\n                }\r\n                _this._onErrorHelper(error);\r\n                if (typeof callback === \"function\") {\r\n                    var errorMessage = \"error sending telemetry\";\r\n                    if (error && (typeof error.toString === \"function\")) {\r\n                        errorMessage = error.toString();\r\n                    }\r\n                    callback(errorMessage);\r\n                }\r\n                if (_this._enableDiskRetryMode) {\r\n                    _this._storeToDisk(payload);\r\n                }\r\n            });\r\n            req.write(dataToSend);\r\n            req.end();\r\n        });\r\n    };\r\n    Sender.prototype.saveOnCrash = function (payload) {\r\n        if (this._enableDiskRetryMode) {\r\n            this._storeToDiskSync(payload);\r\n        }\r\n    };\r\n    Sender.prototype._runICACLS = function (args, callback) {\r\n        var aclProc = child_process.spawn(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n        aclProc.on(\"error\", function (e) { return callback(e); });\r\n        aclProc.on(\"close\", function (code, signal) {\r\n            return callback(code === 0 ? null : new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + code + \")\"));\r\n        });\r\n    };\r\n    Sender.prototype._runICACLSSync = function (args) {\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var aclProc = child_process.spawnSync(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n            if (aclProc.error) {\r\n                throw aclProc.error;\r\n            }\r\n            else if (aclProc.status !== 0) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + aclProc.status + \")\");\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously call ICACLS under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLIdentity = function (callback) {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return callback(null, Sender.ACL_IDENTITY);\r\n        }\r\n        var psProc = child_process.spawn(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n            windowsHide: true,\r\n            stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n        });\r\n        var data = \"\";\r\n        psProc.stdout.on(\"data\", function (d) { return data += d; });\r\n        psProc.on(\"error\", function (e) { return callback(e, null); });\r\n        psProc.on(\"close\", function (code, signal) {\r\n            Sender.ACL_IDENTITY = data && data.trim();\r\n            return callback(code === 0 ? null : new Error(\"Getting ACL identity did not succeed (PS returned code \" + code + \")\"), Sender.ACL_IDENTITY);\r\n        });\r\n    };\r\n    Sender.prototype._getACLIdentitySync = function () {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var psProc = child_process.spawnSync(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n                windowsHide: true,\r\n                stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n            });\r\n            if (psProc.error) {\r\n                throw psProc.error;\r\n            }\r\n            else if (psProc.status !== 0) {\r\n                throw new Error(\"Getting ACL identity did not succeed (PS returned code \" + psProc.status + \")\");\r\n            }\r\n            Sender.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously get ACL identity under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLArguments = function (directory, identity) {\r\n        return [directory,\r\n            \"/grant\", \"*S-1-5-32-544:(OI)(CI)F\",\r\n            \"/grant\", identity + \":(OI)(CI)F\",\r\n            \"/inheritance:r\"]; // Remove all inherited permissions\r\n    };\r\n    Sender.prototype._applyACLRules = function (directory, callback) {\r\n        var _this = this;\r\n        if (!Sender.USE_ICACLS) {\r\n            return callback(null);\r\n        }\r\n        // For performance, only run ACL rules if we haven't already during this session\r\n        if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n            // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately\r\n            // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk\r\n            // This is better than the alternative of potentially infinitely spawned processes\r\n            Sender.ACLED_DIRECTORIES[directory] = false;\r\n            // Restrict this directory to only current user and administrator access\r\n            this._getACLIdentity(function (err, identity) {\r\n                if (err) {\r\n                    Sender.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is \"not yet tried\")\r\n                    return callback(err);\r\n                }\r\n                else {\r\n                    _this._runICACLS(_this._getACLArguments(directory, identity), function (err) {\r\n                        Sender.ACLED_DIRECTORIES[directory] = !err;\r\n                        return callback(err);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return callback(Sender.ACLED_DIRECTORIES[directory] ? null :\r\n                new Error(\"Setting ACL restrictions did not succeed (cached result)\"));\r\n        }\r\n    };\r\n    Sender.prototype._applyACLRulesSync = function (directory) {\r\n        if (Sender.USE_ICACLS) {\r\n            // For performance, only run ACL rules if we haven't already during this session\r\n            if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));\r\n                Sender.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures\r\n                return;\r\n            }\r\n            else if (!Sender.ACLED_DIRECTORIES[directory]) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\r\n            }\r\n        }\r\n    };\r\n    Sender.prototype._confirmDirExists = function (directory, callback) {\r\n        var _this = this;\r\n        fs.lstat(directory, function (err, stats) {\r\n            if (err && err.code === 'ENOENT') {\r\n                fs.mkdir(directory, function (err) {\r\n                    if (err && err.code !== 'EEXIST') {\r\n                        callback(err);\r\n                    }\r\n                    else {\r\n                        _this._applyACLRules(directory, callback);\r\n                    }\r\n                });\r\n            }\r\n            else if (!err && stats.isDirectory()) {\r\n                _this._applyACLRules(directory, callback);\r\n            }\r\n            else {\r\n                callback(err || new Error(\"Path existed but was not a directory\"));\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySize = function (directory, callback) {\r\n        // Get the directory listing\r\n        fs.readdir(directory, function (err, files) {\r\n            if (err) {\r\n                return callback(err, -1);\r\n            }\r\n            var error = null;\r\n            var totalSize = 0;\r\n            var count = 0;\r\n            if (files.length === 0) {\r\n                callback(null, 0);\r\n                return;\r\n            }\r\n            // Query all file sizes\r\n            for (var i = 0; i < files.length; i++) {\r\n                fs.stat(path.join(directory, files[i]), function (err, fileStats) {\r\n                    count++;\r\n                    if (err) {\r\n                        error = err;\r\n                    }\r\n                    else {\r\n                        if (fileStats.isFile()) {\r\n                            totalSize += fileStats.size;\r\n                        }\r\n                    }\r\n                    if (count === files.length) {\r\n                        // Did we get an error?\r\n                        if (error) {\r\n                            callback(error, -1);\r\n                        }\r\n                        else {\r\n                            callback(error, totalSize);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySizeSync = function (directory) {\r\n        var files = fs.readdirSync(directory);\r\n        var totalSize = 0;\r\n        for (var i = 0; i < files.length; i++) {\r\n            totalSize += fs.statSync(path.join(directory, files[i])).size;\r\n        }\r\n        return totalSize;\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk in the temp directory\r\n     */\r\n    Sender.prototype._storeToDisk = function (payload) {\r\n        var _this = this;\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        // This will create the dir if it does not exist\r\n        // Default permissions on *nix are directory listing from other users but no file creations\r\n        Logging.info(Sender.TAG, \"Checking existance of data storage directory: \" + directory);\r\n        this._confirmDirExists(directory, function (error) {\r\n            if (error) {\r\n                Logging.warn(Sender.TAG, \"Error while checking/creating directory: \" + (error && error.message));\r\n                _this._onErrorHelper(error);\r\n                return;\r\n            }\r\n            _this._getShallowDirectorySize(directory, function (err, size) {\r\n                if (err || size < 0) {\r\n                    Logging.warn(Sender.TAG, \"Error while checking directory size: \" + (err && err.message));\r\n                    _this._onErrorHelper(err);\r\n                    return;\r\n                }\r\n                else if (size > _this._maxBytesOnDisk) {\r\n                    Logging.warn(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + size);\r\n                    return;\r\n                }\r\n                //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n                //would require an external dependency\r\n                var fileName = new Date().getTime() + \".ai.json\";\r\n                var fileFullPath = path.join(directory, fileName);\r\n                // Mode 600 is w/r for creator and no read access for others (only applies on *nix)\r\n                // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)\r\n                Logging.info(Sender.TAG, \"saving data to disk at: \" + fileFullPath);\r\n                fs.writeFile(fileFullPath, payload, { mode: 384 }, function (error) { return _this._onErrorHelper(error); });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk using sync file operations\r\n     * this is used when storing data before crashes\r\n     */\r\n    Sender.prototype._storeToDiskSync = function (payload) {\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        try {\r\n            Logging.info(Sender.TAG, \"Checking existance of data storage directory: \" + directory);\r\n            if (!fs.existsSync(directory)) {\r\n                fs.mkdirSync(directory);\r\n            }\r\n            // Make sure permissions are valid\r\n            this._applyACLRulesSync(directory);\r\n            var dirSize = this._getShallowDirectorySizeSync(directory);\r\n            if (dirSize > this._maxBytesOnDisk) {\r\n                Logging.info(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + dirSize);\r\n                return;\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(directory, fileName);\r\n            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)\r\n            Logging.info(Sender.TAG, \"saving data before crash to disk at: \" + fileFullPath);\r\n            fs.writeFileSync(fileFullPath, payload, { mode: 384 });\r\n        }\r\n        catch (error) {\r\n            Logging.warn(Sender.TAG, \"Error while saving data to disk: \" + (error && error.message));\r\n            this._onErrorHelper(error);\r\n        }\r\n    };\r\n    /**\r\n     * Check for temp telemetry files\r\n     * reads the first file if exist, deletes it and tries to send its load\r\n     */\r\n    Sender.prototype._sendFirstFileOnDisk = function () {\r\n        var _this = this;\r\n        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        fs.exists(tempDir, function (exists) {\r\n            if (exists) {\r\n                fs.readdir(tempDir, function (error, files) {\r\n                    if (!error) {\r\n                        files = files.filter(function (f) { return path.basename(f).indexOf(\".ai.json\") > -1; });\r\n                        if (files.length > 0) {\r\n                            var firstFile = files[0];\r\n                            var filePath = path.join(tempDir, firstFile);\r\n                            fs.readFile(filePath, function (error, payload) {\r\n                                if (!error) {\r\n                                    // delete the file first to prevent double sending\r\n                                    fs.unlink(filePath, function (error) {\r\n                                        if (!error) {\r\n                                            _this.send(payload);\r\n                                        }\r\n                                        else {\r\n                                            _this._onErrorHelper(error);\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    _this._onErrorHelper(error);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _this._onErrorHelper(error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    Sender.prototype._onErrorHelper = function (error) {\r\n        if (typeof this._onError === \"function\") {\r\n            this._onError(error);\r\n        }\r\n    };\r\n    Sender.TAG = \"Sender\";\r\n    Sender.ICACLS_PATH = process.env.systemdrive + \"/windows/system32/icacls.exe\";\r\n    Sender.POWERSHELL_PATH = process.env.systemdrive + \"/windows/system32/windowspowershell/v1.0/powershell.exe\";\r\n    Sender.ACLED_DIRECTORIES = {};\r\n    Sender.ACL_IDENTITY = null;\r\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throtelling from the service side\r\n    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;\r\n    Sender.MAX_BYTES_ON_DISK = 50 * 1000 * 1000;\r\n    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\r\n    Sender.TEMPDIR_PREFIX = \"appInsights-node\";\r\n    Sender.OS_PROVIDES_FILE_PROTECTION = false;\r\n    Sender.USE_ICACLS = os.type() === \"Windows_NT\";\r\n    return Sender;\r\n}());\r\nmodule.exports = Sender;\r\n//# sourceMappingURL=Sender.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9TZW5kZXIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0xpYnJhcnkvU2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbnZhciBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxudmFyIHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcclxudmFyIGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcclxudmFyIExvZ2dpbmcgPSByZXF1aXJlKFwiLi9Mb2dnaW5nXCIpO1xyXG52YXIgQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzID0gcmVxdWlyZShcIi4uL0F1dG9Db2xsZWN0aW9uL0h0dHBEZXBlbmRlbmNpZXNcIik7XHJcbnZhciBVdGlsID0gcmVxdWlyZShcIi4vVXRpbFwiKTtcclxudmFyIFNlbmRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZW5kZXIoY29uZmlnLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5fb25TdWNjZXNzID0gb25TdWNjZXNzO1xyXG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZURpc2tSZXRyeU1vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNlbmRJbnRlcnZhbCA9IFNlbmRlci5XQUlUX0JFVFdFRU5fUkVTRU5EO1xyXG4gICAgICAgIHRoaXMuX21heEJ5dGVzT25EaXNrID0gU2VuZGVyLk1BWF9CWVRFU19PTl9ESVNLO1xyXG4gICAgICAgIHRoaXMuX251bUNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xyXG4gICAgICAgIGlmICghU2VuZGVyLk9TX1BST1ZJREVTX0ZJTEVfUFJPVEVDVElPTikge1xyXG4gICAgICAgICAgICAvLyBOb2RlJ3MgY2htb2QgbGV2ZWxzIGRvIG5vdCBhcHByb3ByaWF0ZWx5IHJlc3RyaWN0IGZpbGUgYWNjZXNzIG9uIFdpbmRvd3NcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBidWlsdC1pbiBjb21tYW5kIGxpbmUgdG9vbCBJQ0FDTFMgb24gV2luZG93cyB0byBwcm9wZXJseSByZXN0cmljdFxyXG4gICAgICAgICAgICAvLyBhY2Nlc3MgdG8gdGhlIHRlbXBvcmFyeSBkaXJlY3RvcnkgdXNlZCBmb3IgZGlzayByZXRyeSBtb2RlLlxyXG4gICAgICAgICAgICBpZiAoU2VuZGVyLlVTRV9JQ0FDTFMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFzeW5jIC0gYnV0IGl0J3MgY3VycmVudGx5IHNhZmVyIHRvIGhhdmUgdGhpcyBzeW5jaHJvbm91c1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHdlIGNhbiBpbW1lZGlhdGVseSBmYWlsIHNldERpc2tSZXRyeU1vZGUgaWYgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBTZW5kZXIuT1NfUFJPVklERVNfRklMRV9QUk9URUNUSU9OID0gZnMuZXhpc3RzU3luYyhTZW5kZXIuSUNBQ0xTX1BBVEgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFTZW5kZXIuT1NfUFJPVklERVNfRklMRV9QUk9URUNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2luZy53YXJuKFNlbmRlci5UQUcsIFwiQ291bGQgbm90IGZpbmQgSUNBQ0xTIGluIGV4cGVjdGVkIGxvY2F0aW9uISBUaGlzIGlzIG5lY2Vzc2FyeSB0byB1c2UgZGlzayByZXRyeSBtb2RlIG9uIFdpbmRvd3MuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2htb2Qgd29ya3MgZXZlcnl3aGVyZSBlbHNlXHJcbiAgICAgICAgICAgICAgICBTZW5kZXIuT1NfUFJPVklERVNfRklMRV9QUk9URUNUSU9OID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKiBFbmFibGUgb3IgZGlzYWJsZSBvZmZsaW5lIG1vZGVcclxuICAgICovXHJcbiAgICBTZW5kZXIucHJvdG90eXBlLnNldERpc2tSZXRyeU1vZGUgPSBmdW5jdGlvbiAodmFsdWUsIHJlc2VuZEludGVydmFsLCBtYXhCeXRlc09uRGlzaykge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZURpc2tSZXRyeU1vZGUgPSBTZW5kZXIuT1NfUFJPVklERVNfRklMRV9QUk9URUNUSU9OICYmIHZhbHVlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVzZW5kSW50ZXJ2YWwgPT09ICdudW1iZXInICYmIHJlc2VuZEludGVydmFsID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzZW5kSW50ZXJ2YWwgPSBNYXRoLmZsb29yKHJlc2VuZEludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhCeXRlc09uRGlzayA9PT0gJ251bWJlcicgJiYgbWF4Qnl0ZXNPbkRpc2sgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXhCeXRlc09uRGlzayA9IE1hdGguZmxvb3IobWF4Qnl0ZXNPbkRpc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgJiYgIVNlbmRlci5PU19QUk9WSURFU19GSUxFX1BST1RFQ1RJT04pIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlRGlza1JldHJ5TW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBMb2dnaW5nLndhcm4oU2VuZGVyLlRBRywgXCJJZ25vcmluZyByZXF1ZXN0IHRvIGVuYWJsZSBkaXNrIHJldHJ5IG1vZGUuIFN1ZmZpY2llbnQgZmlsZSBwcm90ZWN0aW9uIGNhcGFiaWxpdGllcyB3ZXJlIG5vdCBkZXRlY3RlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50VXJsID0gdGhpcy5fY29uZmlnLmVuZHBvaW50VXJsO1xyXG4gICAgICAgIC8vIHRvZG86IGludmVzdGlnYXRlIHNwZWNpZnlpbmcgYW4gYWdlbnQgaGVyZTogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9jbGFzc19odHRwX2FnZW50XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC1qc29uLXN0cmVhbVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHpsaWIuZ3ppcChwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFUb1NlbmQgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcud2FybihlcnIpO1xyXG4gICAgICAgICAgICAgICAgZGF0YVRvU2VuZCA9IHBheWxvYWQ7IC8vIHNvbWV0aGluZyB3ZW50IHdyb25nIHNvIHNlbmQgd2l0aG91dCBnemlwXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IHBheWxvYWQubGVuZ3RoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gXCJnemlwXCI7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFNlbmRlci5UQUcsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyByZXF1ZXN0IGlzIG5vdCBjYXB0dXJlZCBieSBhdXRvLWNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgIG9wdGlvbnNbQXV0b0NvbGxlY3RIdHRwRGVwZW5kZW5jaWVzLmRpc2FibGVDb2xsZWN0aW9uUmVxdWVzdE9wdGlvbl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKFwidXRmLThcIik7XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybnMgZW1wdHkgaWYgdGhlIGRhdGEgaXMgYWNjZXB0ZWRcclxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICByZXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VTdHJpbmcgKz0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbnVtQ29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFNlbmRlci5UQUcsIHJlc3BvbnNlU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLl9vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25TdWNjZXNzKHJlc3BvbnNlU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmFibGVEaXNrUmV0cnlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzZW5kIGFueSBjYWNoZWQgZXZlbnRzIGlmIHRoZSB1c2VyIGlzIGJhY2sgb25saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZW5kRmlyc3RGaWxlT25EaXNrKCk7IH0sIF90aGlzLl9yZXNlbmRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0byBkaXNrIGluIGNhc2Ugb2YgYnVyc3QgdGhyb3R0bGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlID09PSA0MDggfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID09PSA0MjkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID09PSA0MzkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID09PSA1MDAgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID09PSA1MDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvIG5vdCBzdXBwb3J0IHBhcnRpYWwgc3VjY2VzcyAoMjA2KSB1bnRpbCBfc2VuZEZpcnN0RmlsZU9uRGlzayBjaGVja3MgcGF5bG9hZCBhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdG9yZVRvRGlzayhwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcmVxID0gVXRpbC5tYWtlUmVxdWVzdChfdGhpcy5fY29uZmlnLCBlbmRwb2ludFVybCwgb3B0aW9ucywgcmVxdWVzdENhbGxiYWNrKTtcclxuICAgICAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBoYW5kbGUgZXJyb3IgY29kZXMgYmV0dGVyIChncm91cCB0byByZWNvdmVyYWJsZS9ub24tcmVjb3ZlcmFibGUgYW5kIHBlcnNpc3QpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbnVtQ29uc2VjdXRpdmVGYWlsdXJlcysrO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSB1c2Ugd2FybiBsZXZlbCBpZiByZXRyaWVzIGFyZSBkaXNhYmxlZCBvciB3ZSd2ZSBoYWQgc29tZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgZmFpbHVyZXMgc2VuZGluZyBkYXRhXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2FybiBsZXZlbCBpcyBwcmludGVkIGluIHRoZSBjb25zb2xlIGJ5IGRlZmF1bHQsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGJlIG5vaXN5IGZvciB0cmFuc2llbnQgYW5kIHNlbGYtcmVjb3ZlcmluZyBlcnJvcnNcclxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluZm9ybWluZyBvbiBlYWNoIGZhaWx1cmUgaWYgdmVyYm9zZSBsb2dnaW5nIGlzIGJlaW5nIHVzZWRcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2VuYWJsZURpc2tSZXRyeU1vZGUgfHwgX3RoaXMuX251bUNvbnNlY3V0aXZlRmFpbHVyZXMgPiAwICYmIF90aGlzLl9udW1Db25zZWN1dGl2ZUZhaWx1cmVzICUgU2VuZGVyLk1BWF9DT05ORUNUSU9OX0ZBSUxVUkVTX0JFRk9SRV9XQVJOID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGljZSA9IFwiSW5nZXN0aW9uIGVuZHBvaW50IGNvdWxkIG5vdCBiZSByZWFjaGVkLiBUaGlzIGJhdGNoIG9mIHRlbGVtZXRyeSBpdGVtcyBoYXMgYmVlbiBsb3N0LiBVc2UgRGlzayBSZXRyeSBDYWNoaW5nIHRvIGVuYWJsZSByZXNlbmRpbmcgb2YgZmFpbGVkIHRlbGVtZXRyeS4gRXJyb3I6XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmFibGVEaXNrUmV0cnlNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGljZSA9IFwiSW5nZXN0aW9uIGVuZHBvaW50IGNvdWxkIG5vdCBiZSByZWFjaGVkIFwiICsgX3RoaXMuX251bUNvbnNlY3V0aXZlRmFpbHVyZXMgKyBcIiBjb25zZWN1dGl2ZSB0aW1lcy4gVGhlcmUgbWF5IGJlIHJlc3VsdGluZyB0ZWxlbWV0cnkgbG9zcy4gTW9zdCByZWNlbnQgZXJyb3I6XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIExvZ2dpbmcud2FybihTZW5kZXIuVEFHLCBub3RpY2UsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3RpY2UgPSBcIlRyYW5zaWVudCBmYWlsdXJlIHRvIHJlYWNoIGluZ2VzdGlvbiBlbmRwb2ludC4gVGhpcyBiYXRjaCBvZiB0ZWxlbWV0cnkgaXRlbXMgd2lsbCBiZSByZXRyaWVkLiBFcnJvcjpcIjtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnaW5nLmluZm8oU2VuZGVyLlRBRywgbm90aWNlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fb25FcnJvckhlbHBlcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJlcnJvciBzZW5kaW5nIHRlbGVtZXRyeVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiAodHlwZW9mIGVycm9yLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuYWJsZURpc2tSZXRyeU1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RvcmVUb0Rpc2socGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXEud3JpdGUoZGF0YVRvU2VuZCk7XHJcbiAgICAgICAgICAgIHJlcS5lbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLnNhdmVPbkNyYXNoID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlRGlza1JldHJ5TW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9yZVRvRGlza1N5bmMocGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlbmRlci5wcm90b3R5cGUuX3J1bklDQUNMUyA9IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBhY2xQcm9jID0gY2hpbGRfcHJvY2Vzcy5zcGF3bihTZW5kZXIuSUNBQ0xTX1BBVEgsIGFyZ3MsIHsgd2luZG93c0hpZGU6IHRydWUgfSk7XHJcbiAgICAgICAgYWNsUHJvYy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYWxsYmFjayhlKTsgfSk7XHJcbiAgICAgICAgYWNsUHJvYy5vbihcImNsb3NlXCIsIGZ1bmN0aW9uIChjb2RlLCBzaWduYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNvZGUgPT09IDAgPyBudWxsIDogbmV3IEVycm9yKFwiU2V0dGluZyBBQ0wgcmVzdHJpY3Rpb25zIGRpZCBub3Qgc3VjY2VlZCAoSUNBQ0xTIHJldHVybmVkIGNvZGUgXCIgKyBjb2RlICsgXCIpXCIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9ydW5JQ0FDTFNTeW5jID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAvLyBTb21lIHZlcnkgb2xkIHZlcnNpb25zIG9mIE5vZGUgKDwgMC4xMSkgZG9uJ3QgaGF2ZSB0aGlzXHJcbiAgICAgICAgaWYgKGNoaWxkX3Byb2Nlc3Muc3Bhd25TeW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBhY2xQcm9jID0gY2hpbGRfcHJvY2Vzcy5zcGF3blN5bmMoU2VuZGVyLklDQUNMU19QQVRILCBhcmdzLCB7IHdpbmRvd3NIaWRlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBpZiAoYWNsUHJvYy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYWNsUHJvYy5lcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY2xQcm9jLnN0YXR1cyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZyBBQ0wgcmVzdHJpY3Rpb25zIGRpZCBub3Qgc3VjY2VlZCAoSUNBQ0xTIHJldHVybmVkIGNvZGUgXCIgKyBhY2xQcm9jLnN0YXR1cyArIFwiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHN5bmNocm9ub3VzbHkgY2FsbCBJQ0FDTFMgdW5kZXIgY3VycmVudCB2ZXJzaW9uIG9mIE5vZGUuanNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlbmRlci5wcm90b3R5cGUuX2dldEFDTElkZW50aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKFNlbmRlci5BQ0xfSURFTlRJVFkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFNlbmRlci5BQ0xfSURFTlRJVFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHNQcm9jID0gY2hpbGRfcHJvY2Vzcy5zcGF3bihTZW5kZXIuUE9XRVJTSEVMTF9QQVRILCBbXCItQ29tbWFuZFwiLCBcIltTeXN0ZW0uU2VjdXJpdHkuUHJpbmNpcGFsLldpbmRvd3NJZGVudGl0eV06OkdldEN1cnJlbnQoKS5OYW1lXCJdLCB7XHJcbiAgICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdwaXBlJ10gLy8gTmVlZGVkIHRvIHByZXZlbnQgaGFuZ2luZyBvbiBXaW4gN1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBkYXRhID0gXCJcIjtcclxuICAgICAgICBwc1Byb2Muc3Rkb3V0Lm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGF0YSArPSBkOyB9KTtcclxuICAgICAgICBwc1Byb2Mub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY2FsbGJhY2soZSwgbnVsbCk7IH0pO1xyXG4gICAgICAgIHBzUHJvYy5vbihcImNsb3NlXCIsIGZ1bmN0aW9uIChjb2RlLCBzaWduYWwpIHtcclxuICAgICAgICAgICAgU2VuZGVyLkFDTF9JREVOVElUWSA9IGRhdGEgJiYgZGF0YS50cmltKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2RlID09PSAwID8gbnVsbCA6IG5ldyBFcnJvcihcIkdldHRpbmcgQUNMIGlkZW50aXR5IGRpZCBub3Qgc3VjY2VlZCAoUFMgcmV0dXJuZWQgY29kZSBcIiArIGNvZGUgKyBcIilcIiksIFNlbmRlci5BQ0xfSURFTlRJVFkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNlbmRlci5wcm90b3R5cGUuX2dldEFDTElkZW50aXR5U3luYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoU2VuZGVyLkFDTF9JREVOVElUWSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2VuZGVyLkFDTF9JREVOVElUWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29tZSB2ZXJ5IG9sZCB2ZXJzaW9ucyBvZiBOb2RlICg8IDAuMTEpIGRvbid0IGhhdmUgdGhpc1xyXG4gICAgICAgIGlmIChjaGlsZF9wcm9jZXNzLnNwYXduU3luYykge1xyXG4gICAgICAgICAgICB2YXIgcHNQcm9jID0gY2hpbGRfcHJvY2Vzcy5zcGF3blN5bmMoU2VuZGVyLlBPV0VSU0hFTExfUEFUSCwgW1wiLUNvbW1hbmRcIiwgXCJbU3lzdGVtLlNlY3VyaXR5LlByaW5jaXBhbC5XaW5kb3dzSWRlbnRpdHldOjpHZXRDdXJyZW50KCkuTmFtZVwiXSwge1xyXG4gICAgICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdwaXBlJ10gLy8gTmVlZGVkIHRvIHByZXZlbnQgaGFuZ2luZyBvbiBXaW4gN1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHBzUHJvYy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgcHNQcm9jLmVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBzUHJvYy5zdGF0dXMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdldHRpbmcgQUNMIGlkZW50aXR5IGRpZCBub3Qgc3VjY2VlZCAoUFMgcmV0dXJuZWQgY29kZSBcIiArIHBzUHJvYy5zdGF0dXMgKyBcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2VuZGVyLkFDTF9JREVOVElUWSA9IHBzUHJvYy5zdGRvdXQgJiYgcHNQcm9jLnN0ZG91dC50b1N0cmluZygpLnRyaW0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNlbmRlci5BQ0xfSURFTlRJVFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc3luY2hyb25vdXNseSBnZXQgQUNMIGlkZW50aXR5IHVuZGVyIGN1cnJlbnQgdmVyc2lvbiBvZiBOb2RlLmpzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9nZXRBQ0xBcmd1bWVudHMgPSBmdW5jdGlvbiAoZGlyZWN0b3J5LCBpZGVudGl0eSkge1xyXG4gICAgICAgIHJldHVybiBbZGlyZWN0b3J5LFxyXG4gICAgICAgICAgICBcIi9ncmFudFwiLCBcIipTLTEtNS0zMi01NDQ6KE9JKShDSSlGXCIsXHJcbiAgICAgICAgICAgIFwiL2dyYW50XCIsIGlkZW50aXR5ICsgXCI6KE9JKShDSSlGXCIsXHJcbiAgICAgICAgICAgIFwiL2luaGVyaXRhbmNlOnJcIl07IC8vIFJlbW92ZSBhbGwgaW5oZXJpdGVkIHBlcm1pc3Npb25zXHJcbiAgICB9O1xyXG4gICAgU2VuZGVyLnByb3RvdHlwZS5fYXBwbHlBQ0xSdWxlcyA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIVNlbmRlci5VU0VfSUNBQ0xTKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlLCBvbmx5IHJ1biBBQ0wgcnVsZXMgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGR1cmluZyB0aGlzIHNlc3Npb25cclxuICAgICAgICBpZiAoU2VuZGVyLkFDTEVEX0RJUkVDVE9SSUVTW2RpcmVjdG9yeV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBBdm9pZCBtdWx0aXBsZSBjYWxscyByYWNlIGNvbmRpdGlvbiBieSBzZXR0aW5nIEFDTEVEX0RJUkVDVE9SSUVTIHRvIGZhbHNlIGZvciB0aGlzIGRpcmVjdG9yeSBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAvLyBJZiBiYXRjaGVzIGFyZSBiZWluZyBmYWlsZWQgZmFzdGVyIHRoYW4gdGhlIHByb2Nlc3NlcyBzcGF3bmVkIGJlbG93IHJldHVybiwgc29tZSBkYXRhIHdvbid0IGJlIHN0b3JlZCB0byBkaXNrXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYmV0dGVyIHRoYW4gdGhlIGFsdGVybmF0aXZlIG9mIHBvdGVudGlhbGx5IGluZmluaXRlbHkgc3Bhd25lZCBwcm9jZXNzZXNcclxuICAgICAgICAgICAgU2VuZGVyLkFDTEVEX0RJUkVDVE9SSUVTW2RpcmVjdG9yeV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gUmVzdHJpY3QgdGhpcyBkaXJlY3RvcnkgdG8gb25seSBjdXJyZW50IHVzZXIgYW5kIGFkbWluaXN0cmF0b3IgYWNjZXNzXHJcbiAgICAgICAgICAgIHRoaXMuX2dldEFDTElkZW50aXR5KGZ1bmN0aW9uIChlcnIsIGlkZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2VuZGVyLkFDTEVEX0RJUkVDVE9SSUVTW2RpcmVjdG9yeV0gPSBmYWxzZTsgLy8gZmFsc2UgaXMgdXNlZCB0byBjYWNoZSBmYWlsZWQgKHZzIHVuZGVmaW5lZCB3aGljaCBpcyBcIm5vdCB5ZXQgdHJpZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9ydW5JQ0FDTFMoX3RoaXMuX2dldEFDTEFyZ3VtZW50cyhkaXJlY3RvcnksIGlkZW50aXR5KSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTZW5kZXIuQUNMRURfRElSRUNUT1JJRVNbZGlyZWN0b3J5XSA9ICFlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhTZW5kZXIuQUNMRURfRElSRUNUT1JJRVNbZGlyZWN0b3J5XSA/IG51bGwgOlxyXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiU2V0dGluZyBBQ0wgcmVzdHJpY3Rpb25zIGRpZCBub3Qgc3VjY2VlZCAoY2FjaGVkIHJlc3VsdClcIikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9hcHBseUFDTFJ1bGVzU3luYyA9IGZ1bmN0aW9uIChkaXJlY3RvcnkpIHtcclxuICAgICAgICBpZiAoU2VuZGVyLlVTRV9JQ0FDTFMpIHtcclxuICAgICAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlLCBvbmx5IHJ1biBBQ0wgcnVsZXMgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGR1cmluZyB0aGlzIHNlc3Npb25cclxuICAgICAgICAgICAgaWYgKFNlbmRlci5BQ0xFRF9ESVJFQ1RPUklFU1tkaXJlY3RvcnldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3J1bklDQUNMU1N5bmModGhpcy5fZ2V0QUNMQXJndW1lbnRzKGRpcmVjdG9yeSwgdGhpcy5fZ2V0QUNMSWRlbnRpdHlTeW5jKCkpKTtcclxuICAgICAgICAgICAgICAgIFNlbmRlci5BQ0xFRF9ESVJFQ1RPUklFU1tkaXJlY3RvcnldID0gdHJ1ZTsgLy8gSWYgd2UgZ2V0IGhlcmUsIGl0IHN1Y2NlZWRlZC4gX3J1bklBQ0xTU3luYyB3aWxsIHRocm93IG9uIGZhaWx1cmVzXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIVNlbmRlci5BQ0xFRF9ESVJFQ1RPUklFU1tkaXJlY3RvcnldKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIEFDTCByZXN0cmljdGlvbnMgZGlkIG5vdCBzdWNjZWVkIChjYWNoZWQgcmVzdWx0KVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9jb25maXJtRGlyRXhpc3RzID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGZzLmxzdGF0KGRpcmVjdG9yeSwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcclxuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcclxuICAgICAgICAgICAgICAgIGZzLm1rZGlyKGRpcmVjdG9yeSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFRVhJU1QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlBQ0xSdWxlcyhkaXJlY3RvcnksIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghZXJyICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hcHBseUFDTFJ1bGVzKGRpcmVjdG9yeSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFcnJvcihcIlBhdGggZXhpc3RlZCBidXQgd2FzIG5vdCBhIGRpcmVjdG9yeVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBzaXplIChpbiBieXRlcykgb2YgYWxsIGZpbGVzIGluIGEgZGlyZWN0b3J5IGF0IHRoZSByb290IGxldmVsLiBBc3luY2hyb25vdXNseS5cclxuICAgICAqL1xyXG4gICAgU2VuZGVyLnByb3RvdHlwZS5fZ2V0U2hhbGxvd0RpcmVjdG9yeVNpemUgPSBmdW5jdGlvbiAoZGlyZWN0b3J5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIEdldCB0aGUgZGlyZWN0b3J5IGxpc3RpbmdcclxuICAgICAgICBmcy5yZWFkZGlyKGRpcmVjdG9yeSwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbFNpemUgPSAwO1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBRdWVyeSBhbGwgZmlsZSBzaXplc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmcy5zdGF0KHBhdGguam9pbihkaXJlY3RvcnksIGZpbGVzW2ldKSwgZnVuY3Rpb24gKGVyciwgZmlsZVN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVTdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplICs9IGZpbGVTdGF0cy5zaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gZmlsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpZCB3ZSBnZXQgYW4gZXJyb3I/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBzaXplIChpbiBieXRlcykgb2YgYWxsIGZpbGVzIGluIGEgZGlyZWN0b3J5IGF0IHRoZSByb290IGxldmVsLiBTeW5jaHJvbm91c2x5LlxyXG4gICAgICovXHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9nZXRTaGFsbG93RGlyZWN0b3J5U2l6ZVN5bmMgPSBmdW5jdGlvbiAoZGlyZWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyZWN0b3J5KTtcclxuICAgICAgICB2YXIgdG90YWxTaXplID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBmcy5zdGF0U3luYyhwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlc1tpXSkpLnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3RhbFNpemU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIHBheWxvYWQgYXMgYSBqc29uIGZpbGUgb24gZGlzayBpbiB0aGUgdGVtcCBkaXJlY3RvcnlcclxuICAgICAqL1xyXG4gICAgU2VuZGVyLnByb3RvdHlwZS5fc3RvcmVUb0Rpc2sgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gdG1wZGlyIGlzIC90bXAgZm9yICpuaXggYW5kIFVTRVJESVIvQXBwRGF0YS9Mb2NhbC9UZW1wIGZvciBXaW5kb3dzXHJcbiAgICAgICAgdmFyIGRpcmVjdG9yeSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgU2VuZGVyLlRFTVBESVJfUFJFRklYICsgdGhpcy5fY29uZmlnLmluc3RydW1lbnRhdGlvbktleSk7XHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSB0aGUgZGlyIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgLy8gRGVmYXVsdCBwZXJtaXNzaW9ucyBvbiAqbml4IGFyZSBkaXJlY3RvcnkgbGlzdGluZyBmcm9tIG90aGVyIHVzZXJzIGJ1dCBubyBmaWxlIGNyZWF0aW9uc1xyXG4gICAgICAgIExvZ2dpbmcuaW5mbyhTZW5kZXIuVEFHLCBcIkNoZWNraW5nIGV4aXN0YW5jZSBvZiBkYXRhIHN0b3JhZ2UgZGlyZWN0b3J5OiBcIiArIGRpcmVjdG9yeSk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlybURpckV4aXN0cyhkaXJlY3RvcnksIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcud2FybihTZW5kZXIuVEFHLCBcIkVycm9yIHdoaWxlIGNoZWNraW5nL2NyZWF0aW5nIGRpcmVjdG9yeTogXCIgKyAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX29uRXJyb3JIZWxwZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9nZXRTaGFsbG93RGlyZWN0b3J5U2l6ZShkaXJlY3RvcnksIGZ1bmN0aW9uIChlcnIsIHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgc2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnaW5nLndhcm4oU2VuZGVyLlRBRywgXCJFcnJvciB3aGlsZSBjaGVja2luZyBkaXJlY3Rvcnkgc2l6ZTogXCIgKyAoZXJyICYmIGVyci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRXJyb3JIZWxwZXIoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplID4gX3RoaXMuX21heEJ5dGVzT25EaXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2luZy53YXJuKFNlbmRlci5UQUcsIFwiTm90IHNhdmluZyBkYXRhIGR1ZSB0byBtYXggc2l6ZSBsaW1pdCBiZWluZyBtZXQuIERpcmVjdG9yeSBzaXplIGluIGJ5dGVzIGlzOiBcIiArIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY3JlYXRlIGZpbGUgLSBmaWxlIG5hbWUgZm9yIG5vdyBpcyB0aGUgdGltZXN0YW1wLCBhIGJldHRlciBhcHByb2FjaCB3b3VsZCBiZSBhIFVVSUQgYnV0IHRoYXRcclxuICAgICAgICAgICAgICAgIC8vd291bGQgcmVxdWlyZSBhbiBleHRlcm5hbCBkZXBlbmRlbmN5XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIFwiLmFpLmpzb25cIjtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlRnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBNb2RlIDYwMCBpcyB3L3IgZm9yIGNyZWF0b3IgYW5kIG5vIHJlYWQgYWNjZXNzIGZvciBvdGhlcnMgKG9ubHkgYXBwbGllcyBvbiAqbml4KVxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIFdpbmRvd3MsIEFDTCBydWxlcyBhcmUgYXBwbGllZCB0byB0aGUgZW50aXJlIGRpcmVjdG9yeSAoc2VlIGxvZ2ljIGluIF9jb25maXJtRGlyRXhpc3RzIGFuZCBfYXBwbHlBQ0xSdWxlcylcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhTZW5kZXIuVEFHLCBcInNhdmluZyBkYXRhIHRvIGRpc2sgYXQ6IFwiICsgZmlsZUZ1bGxQYXRoKTtcclxuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZShmaWxlRnVsbFBhdGgsIHBheWxvYWQsIHsgbW9kZTogMzg0IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX29uRXJyb3JIZWxwZXIoZXJyb3IpOyB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIHBheWxvYWQgYXMgYSBqc29uIGZpbGUgb24gZGlzayB1c2luZyBzeW5jIGZpbGUgb3BlcmF0aW9uc1xyXG4gICAgICogdGhpcyBpcyB1c2VkIHdoZW4gc3RvcmluZyBkYXRhIGJlZm9yZSBjcmFzaGVzXHJcbiAgICAgKi9cclxuICAgIFNlbmRlci5wcm90b3R5cGUuX3N0b3JlVG9EaXNrU3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICAgICAgLy8gdG1wZGlyIGlzIC90bXAgZm9yICpuaXggYW5kIFVTRVJESVIvQXBwRGF0YS9Mb2NhbC9UZW1wIGZvciBXaW5kb3dzXHJcbiAgICAgICAgdmFyIGRpcmVjdG9yeSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgU2VuZGVyLlRFTVBESVJfUFJFRklYICsgdGhpcy5fY29uZmlnLmluc3RydW1lbnRhdGlvbktleSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFNlbmRlci5UQUcsIFwiQ2hlY2tpbmcgZXhpc3RhbmNlIG9mIGRhdGEgc3RvcmFnZSBkaXJlY3Rvcnk6IFwiICsgZGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcmVjdG9yeSkpIHtcclxuICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhkaXJlY3RvcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBwZXJtaXNzaW9ucyBhcmUgdmFsaWRcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlBQ0xSdWxlc1N5bmMoZGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgdmFyIGRpclNpemUgPSB0aGlzLl9nZXRTaGFsbG93RGlyZWN0b3J5U2l6ZVN5bmMoZGlyZWN0b3J5KTtcclxuICAgICAgICAgICAgaWYgKGRpclNpemUgPiB0aGlzLl9tYXhCeXRlc09uRGlzaykge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFNlbmRlci5UQUcsIFwiTm90IHNhdmluZyBkYXRhIGR1ZSB0byBtYXggc2l6ZSBsaW1pdCBiZWluZyBtZXQuIERpcmVjdG9yeSBzaXplIGluIGJ5dGVzIGlzOiBcIiArIGRpclNpemUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGZpbGUgLSBmaWxlIG5hbWUgZm9yIG5vdyBpcyB0aGUgdGltZXN0YW1wLCBhIGJldHRlciBhcHByb2FjaCB3b3VsZCBiZSBhIFVVSUQgYnV0IHRoYXRcclxuICAgICAgICAgICAgLy93b3VsZCByZXF1aXJlIGFuIGV4dGVybmFsIGRlcGVuZGVuY3lcclxuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIi5haS5qc29uXCI7XHJcbiAgICAgICAgICAgIHZhciBmaWxlRnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgIC8vIE1vZGUgNjAwIGlzIHcvciBmb3IgY3JlYXRvciBhbmQgbm8gYWNjZXNzIGZvciBhbnlvbmUgZWxzZSAob25seSBhcHBsaWVzIG9uICpuaXgpXHJcbiAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhTZW5kZXIuVEFHLCBcInNhdmluZyBkYXRhIGJlZm9yZSBjcmFzaCB0byBkaXNrIGF0OiBcIiArIGZpbGVGdWxsUGF0aCk7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZUZ1bGxQYXRoLCBwYXlsb2FkLCB7IG1vZGU6IDM4NCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcud2FybihTZW5kZXIuVEFHLCBcIkVycm9yIHdoaWxlIHNhdmluZyBkYXRhIHRvIGRpc2s6IFwiICsgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgdGhpcy5fb25FcnJvckhlbHBlcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgZm9yIHRlbXAgdGVsZW1ldHJ5IGZpbGVzXHJcbiAgICAgKiByZWFkcyB0aGUgZmlyc3QgZmlsZSBpZiBleGlzdCwgZGVsZXRlcyBpdCBhbmQgdHJpZXMgdG8gc2VuZCBpdHMgbG9hZFxyXG4gICAgICovXHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9zZW5kRmlyc3RGaWxlT25EaXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRlbXBEaXIgPSBwYXRoLmpvaW4ob3MudG1wZGlyKCksIFNlbmRlci5URU1QRElSX1BSRUZJWCArIHRoaXMuX2NvbmZpZy5pbnN0cnVtZW50YXRpb25LZXkpO1xyXG4gICAgICAgIGZzLmV4aXN0cyh0ZW1wRGlyLCBmdW5jdGlvbiAoZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgIGZzLnJlYWRkaXIodGVtcERpciwgZnVuY3Rpb24gKGVycm9yLCBmaWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHBhdGguYmFzZW5hbWUoZikuaW5kZXhPZihcIi5haS5qc29uXCIpID4gLTE7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0RmlsZSA9IGZpbGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVQYXRoID0gcGF0aC5qb2luKHRlbXBEaXIsIGZpcnN0RmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShmaWxlUGF0aCwgZnVuY3Rpb24gKGVycm9yLCBwYXlsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIGZpbGUgZmlyc3QgdG8gcHJldmVudCBkb3VibGUgc2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmsoZmlsZVBhdGgsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmQocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25FcnJvckhlbHBlcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRXJyb3JIZWxwZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25FcnJvckhlbHBlcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTZW5kZXIucHJvdG90eXBlLl9vbkVycm9ySGVscGVyID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlbmRlci5UQUcgPSBcIlNlbmRlclwiO1xyXG4gICAgU2VuZGVyLklDQUNMU19QQVRIID0gcHJvY2Vzcy5lbnYuc3lzdGVtZHJpdmUgKyBcIi93aW5kb3dzL3N5c3RlbTMyL2ljYWNscy5leGVcIjtcclxuICAgIFNlbmRlci5QT1dFUlNIRUxMX1BBVEggPSBwcm9jZXNzLmVudi5zeXN0ZW1kcml2ZSArIFwiL3dpbmRvd3Mvc3lzdGVtMzIvd2luZG93c3Bvd2Vyc2hlbGwvdjEuMC9wb3dlcnNoZWxsLmV4ZVwiO1xyXG4gICAgU2VuZGVyLkFDTEVEX0RJUkVDVE9SSUVTID0ge307XHJcbiAgICBTZW5kZXIuQUNMX0lERU5USVRZID0gbnVsbDtcclxuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSB0aGUgU0RLIHdpbGwgd2FpdCBiZXR3ZWVuIHJlc2VuZGluZyBjYWNoZWQgZGF0YSwgdGhpcyBidWZmZXIgaXMgdG8gYXZvaWQgYW55IHRocm90ZWxsaW5nIGZyb20gdGhlIHNlcnZpY2Ugc2lkZVxyXG4gICAgU2VuZGVyLldBSVRfQkVUV0VFTl9SRVNFTkQgPSA2MCAqIDEwMDA7XHJcbiAgICBTZW5kZXIuTUFYX0JZVEVTX09OX0RJU0sgPSA1MCAqIDEwMDAgKiAxMDAwO1xyXG4gICAgU2VuZGVyLk1BWF9DT05ORUNUSU9OX0ZBSUxVUkVTX0JFRk9SRV9XQVJOID0gNTtcclxuICAgIFNlbmRlci5URU1QRElSX1BSRUZJWCA9IFwiYXBwSW5zaWdodHMtbm9kZVwiO1xyXG4gICAgU2VuZGVyLk9TX1BST1ZJREVTX0ZJTEVfUFJPVEVDVElPTiA9IGZhbHNlO1xyXG4gICAgU2VuZGVyLlVTRV9JQ0FDTFMgPSBvcy50eXBlKCkgPT09IFwiV2luZG93c19OVFwiO1xyXG4gICAgcmV0dXJuIFNlbmRlcjtcclxufSgpKTtcclxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbmRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Sender.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/TelemetryClient.js":
/*!*************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/TelemetryClient.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar url = __webpack_require__(/*! url */ \"url\");\r\nvar Config = __webpack_require__(/*! ./Config */ \"./node_modules/applicationinsights/out/Library/Config.js\");\r\nvar Context = __webpack_require__(/*! ./Context */ \"./node_modules/applicationinsights/out/Library/Context.js\");\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\nvar Channel = __webpack_require__(/*! ./Channel */ \"./node_modules/applicationinsights/out/Library/Channel.js\");\r\nvar TelemetryProcessors = __webpack_require__(/*! ../TelemetryProcessors */ \"./node_modules/applicationinsights/out/TelemetryProcessors/index.js\");\r\nvar CorrelationContextManager_1 = __webpack_require__(/*! ../AutoCollection/CorrelationContextManager */ \"./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\");\r\nvar Sender = __webpack_require__(/*! ./Sender */ \"./node_modules/applicationinsights/out/Library/Sender.js\");\r\nvar Util = __webpack_require__(/*! ./Util */ \"./node_modules/applicationinsights/out/Library/Util.js\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar EnvelopeFactory = __webpack_require__(/*! ./EnvelopeFactory */ \"./node_modules/applicationinsights/out/Library/EnvelopeFactory.js\");\r\n/**\r\n * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and\r\n * and manually trigger immediate sending (flushing)\r\n */\r\nvar TelemetryClient = (function () {\r\n    /**\r\n     * Constructs a new client of the client\r\n     * @param iKey the instrumentation key to use (read from environment variable if not specified)\r\n     */\r\n    function TelemetryClient(iKey) {\r\n        this._telemetryProcessors = [];\r\n        var config = new Config(iKey);\r\n        this.config = config;\r\n        this.context = new Context();\r\n        this.commonProperties = {};\r\n        var sender = new Sender(this.config);\r\n        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);\r\n    }\r\n    /**\r\n     * Log a trace message\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackTrace = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Trace);\r\n    };\r\n    /**\r\n     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\r\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\r\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackMetric = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Metric);\r\n    };\r\n    /**\r\n     * Log an exception\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackException = function (telemetry) {\r\n        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {\r\n            telemetry.exception = new Error(telemetry.exception.toString());\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Exception);\r\n    };\r\n    /**\r\n     * Log a user action or other occurrence.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackEvent = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Event);\r\n    };\r\n    /**\r\n     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests\r\n     * that aren't automatically captured or if you've disabled automatic request collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackRequest = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Request);\r\n    };\r\n    /**\r\n     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies\r\n     * that aren't automatically captured or if you've disabled automatic dependency collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking option\r\n     * */\r\n    TelemetryClient.prototype.trackDependency = function (telemetry) {\r\n        if (telemetry && !telemetry.target && telemetry.data) {\r\n            // url.parse().host returns null for non-urls,\r\n            // making this essentially a no-op in those cases\r\n            // If this logic is moved, update jsdoc in DependencyTelemetry.target\r\n            telemetry.target = url.parse(telemetry.data).host;\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Dependency);\r\n    };\r\n    /**\r\n     * Immediately send all queued telemetry.\r\n     * @param options Flush options, including indicator whether app is crashing and callback\r\n     */\r\n    TelemetryClient.prototype.flush = function (options) {\r\n        this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : undefined);\r\n    };\r\n    /**\r\n     * Generic track method for all telemetry types\r\n     * @param data the telemetry to send\r\n     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes\r\n     */\r\n    TelemetryClient.prototype.track = function (telemetry, telemetryType) {\r\n        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {\r\n            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);\r\n            // Set time on the envelope if it was set on the telemetry item\r\n            if (telemetry.time) {\r\n                envelope.time = telemetry.time.toISOString();\r\n            }\r\n            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);\r\n            // Ideally we would have a central place for \"internal\" telemetry processors and users can configure which ones are in use.\r\n            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.\r\n            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });\r\n            if (accepted) {\r\n                this.channel.send(envelope);\r\n            }\r\n        }\r\n        else {\r\n            Logging.warn(\"track() requires telemetry object and telemetryType to be specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\r\n     * before telemetry item is pushed for sending and in the order they were added.\r\n     *\r\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\r\n     */\r\n    TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {\r\n        this._telemetryProcessors.push(telemetryProcessor);\r\n    };\r\n    /*\r\n     * Removes all telemetry processors\r\n     */\r\n    TelemetryClient.prototype.clearTelemetryProcessors = function () {\r\n        this._telemetryProcessors = [];\r\n    };\r\n    TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {\r\n        var accepted = true;\r\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\r\n        if (telemetryProcessorsCount === 0) {\r\n            return accepted;\r\n        }\r\n        contextObjects = contextObjects || {};\r\n        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\r\n            try {\r\n                var processor = this._telemetryProcessors[i];\r\n                if (processor) {\r\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\r\n                        accepted = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                accepted = true;\r\n                Logging.warn(\"One of telemetry processors failed, telemetry item will be sent.\", error, envelope);\r\n            }\r\n        }\r\n        return accepted;\r\n    };\r\n    return TelemetryClient;\r\n}());\r\nmodule.exports = TelemetryClient;\r\n//# sourceMappingURL=TelemetryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9UZWxlbWV0cnlDbGllbnQuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2FwcGxpY2F0aW9uaW5zaWdodHMvb3V0L0xpYnJhcnkvVGVsZW1ldHJ5Q2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXJsID0gcmVxdWlyZShcInVybFwiKTtcclxudmFyIENvbmZpZyA9IHJlcXVpcmUoXCIuL0NvbmZpZ1wiKTtcclxudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi9Db250ZXh0XCIpO1xyXG52YXIgQ29udHJhY3RzID0gcmVxdWlyZShcIi4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbnZhciBDaGFubmVsID0gcmVxdWlyZShcIi4vQ2hhbm5lbFwiKTtcclxudmFyIFRlbGVtZXRyeVByb2Nlc3NvcnMgPSByZXF1aXJlKFwiLi4vVGVsZW1ldHJ5UHJvY2Vzc29yc1wiKTtcclxudmFyIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9BdXRvQ29sbGVjdGlvbi9Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyXCIpO1xyXG52YXIgU2VuZGVyID0gcmVxdWlyZShcIi4vU2VuZGVyXCIpO1xyXG52YXIgVXRpbCA9IHJlcXVpcmUoXCIuL1V0aWxcIik7XHJcbnZhciBMb2dnaW5nID0gcmVxdWlyZShcIi4vTG9nZ2luZ1wiKTtcclxudmFyIEVudmVsb3BlRmFjdG9yeSA9IHJlcXVpcmUoXCIuL0VudmVsb3BlRmFjdG9yeVwiKTtcclxuLyoqXHJcbiAqIEFwcGxpY2F0aW9uIEluc2lnaHRzIHRlbGVtZXRyeSBjbGllbnQgcHJvdmlkZXMgaW50ZXJmYWNlIHRvIHRyYWNrIHRlbGVtZXRyeSBpdGVtcywgcmVnaXN0ZXIgdGVsZW1ldHJ5IGluaXRpYWxpemVycyBhbmRcclxuICogYW5kIG1hbnVhbGx5IHRyaWdnZXIgaW1tZWRpYXRlIHNlbmRpbmcgKGZsdXNoaW5nKVxyXG4gKi9cclxudmFyIFRlbGVtZXRyeUNsaWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgY2xpZW50IG9mIHRoZSBjbGllbnRcclxuICAgICAqIEBwYXJhbSBpS2V5IHRoZSBpbnN0cnVtZW50YXRpb24ga2V5IHRvIHVzZSAocmVhZCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIG5vdCBzcGVjaWZpZWQpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRlbGVtZXRyeUNsaWVudChpS2V5KSB7XHJcbiAgICAgICAgdGhpcy5fdGVsZW1ldHJ5UHJvY2Vzc29ycyA9IFtdO1xyXG4gICAgICAgIHZhciBjb25maWcgPSBuZXcgQ29uZmlnKGlLZXkpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5jb21tb25Qcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgdmFyIHNlbmRlciA9IG5ldyBTZW5kZXIodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IG5ldyBDaGFubmVsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5kaXNhYmxlQXBwSW5zaWdodHM7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5tYXhCYXRjaFNpemU7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5tYXhCYXRjaEludGVydmFsTXM7IH0sIHNlbmRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhIHRyYWNlIG1lc3NhZ2VcclxuICAgICAqIEBwYXJhbSB0ZWxlbWV0cnkgICAgICBPYmplY3QgZW5jYXBzdWxhdGluZyB0cmFja2luZyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIFRlbGVtZXRyeUNsaWVudC5wcm90b3R5cGUudHJhY2tUcmFjZSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB0aGlzLnRyYWNrKHRlbGVtZXRyeSwgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuVHJhY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTG9nIGEgbnVtZXJpYyB2YWx1ZSB0aGF0IGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBldmVudC4gVHlwaWNhbGx5IHVzZWQgdG8gc2VuZCByZWd1bGFyIHJlcG9ydHMgb2YgcGVyZm9ybWFuY2UgaW5kaWNhdG9ycy5cclxuICAgICAqIFRvIHNlbmQgYSBzaW5nbGUgbWVhc3VyZW1lbnQsIHVzZSBqdXN0IHRoZSBmaXJzdCB0d28gcGFyYW1ldGVycy4gSWYgeW91IHRha2UgbWVhc3VyZW1lbnRzIHZlcnkgZnJlcXVlbnRseSwgeW91IGNhbiByZWR1Y2UgdGhlXHJcbiAgICAgKiB0ZWxlbWV0cnkgYmFuZHdpZHRoIGJ5IGFnZ3JlZ2F0aW5nIG11bHRpcGxlIG1lYXN1cmVtZW50cyBhbmQgc2VuZGluZyB0aGUgcmVzdWx0aW5nIGF2ZXJhZ2UgYXQgaW50ZXJ2YWxzLlxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeSAgICAgIE9iamVjdCBlbmNhcHN1bGF0aW5nIHRyYWNraW5nIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgVGVsZW1ldHJ5Q2xpZW50LnByb3RvdHlwZS50cmFja01ldHJpYyA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICB0aGlzLnRyYWNrKHRlbGVtZXRyeSwgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuTWV0cmljKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhbiBleGNlcHRpb25cclxuICAgICAqIEBwYXJhbSB0ZWxlbWV0cnkgICAgICBPYmplY3QgZW5jYXBzdWxhdGluZyB0cmFja2luZyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIFRlbGVtZXRyeUNsaWVudC5wcm90b3R5cGUudHJhY2tFeGNlcHRpb24gPSBmdW5jdGlvbiAodGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgaWYgKHRlbGVtZXRyeSAmJiB0ZWxlbWV0cnkuZXhjZXB0aW9uICYmICFVdGlsLmlzRXJyb3IodGVsZW1ldHJ5LmV4Y2VwdGlvbikpIHtcclxuICAgICAgICAgICAgdGVsZW1ldHJ5LmV4Y2VwdGlvbiA9IG5ldyBFcnJvcih0ZWxlbWV0cnkuZXhjZXB0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYWNrKHRlbGVtZXRyeSwgQ29udHJhY3RzLlRlbGVtZXRyeVR5cGUuRXhjZXB0aW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhIHVzZXIgYWN0aW9uIG9yIG90aGVyIG9jY3VycmVuY2UuXHJcbiAgICAgKiBAcGFyYW0gdGVsZW1ldHJ5ICAgICAgT2JqZWN0IGVuY2Fwc3VsYXRpbmcgdHJhY2tpbmcgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBUZWxlbWV0cnlDbGllbnQucHJvdG90eXBlLnRyYWNrRXZlbnQgPSBmdW5jdGlvbiAodGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgdGhpcy50cmFjayh0ZWxlbWV0cnksIENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLkV2ZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhIHJlcXVlc3QuIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBjbGllbnQgd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3QgSFRUUCByZXF1ZXN0cyBhdXRvbWF0aWNhbGx5IHNvIG9ubHkgdXNlIHRoaXMgZm9yIHJlcXVlc3RzXHJcbiAgICAgKiB0aGF0IGFyZW4ndCBhdXRvbWF0aWNhbGx5IGNhcHR1cmVkIG9yIGlmIHlvdSd2ZSBkaXNhYmxlZCBhdXRvbWF0aWMgcmVxdWVzdCBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0ZWxlbWV0cnkgICAgICBPYmplY3QgZW5jYXBzdWxhdGluZyB0cmFja2luZyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIFRlbGVtZXRyeUNsaWVudC5wcm90b3R5cGUudHJhY2tSZXF1ZXN0ID0gZnVuY3Rpb24gKHRlbGVtZXRyeSkge1xyXG4gICAgICAgIHRoaXMudHJhY2sodGVsZW1ldHJ5LCBDb250cmFjdHMuVGVsZW1ldHJ5VHlwZS5SZXF1ZXN0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhIGRlcGVuZGVuY3kuIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBjbGllbnQgd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkgc28gb25seSB1c2UgdGhpcyBmb3IgZGVwZW5kZW5jaWVzXHJcbiAgICAgKiB0aGF0IGFyZW4ndCBhdXRvbWF0aWNhbGx5IGNhcHR1cmVkIG9yIGlmIHlvdSd2ZSBkaXNhYmxlZCBhdXRvbWF0aWMgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0ZWxlbWV0cnkgICAgICBPYmplY3QgZW5jYXBzdWxhdGluZyB0cmFja2luZyBvcHRpb25cclxuICAgICAqICovXHJcbiAgICBUZWxlbWV0cnlDbGllbnQucHJvdG90eXBlLnRyYWNrRGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0ZWxlbWV0cnkpIHtcclxuICAgICAgICBpZiAodGVsZW1ldHJ5ICYmICF0ZWxlbWV0cnkudGFyZ2V0ICYmIHRlbGVtZXRyeS5kYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIHVybC5wYXJzZSgpLmhvc3QgcmV0dXJucyBudWxsIGZvciBub24tdXJscyxcclxuICAgICAgICAgICAgLy8gbWFraW5nIHRoaXMgZXNzZW50aWFsbHkgYSBuby1vcCBpbiB0aG9zZSBjYXNlc1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGxvZ2ljIGlzIG1vdmVkLCB1cGRhdGUganNkb2MgaW4gRGVwZW5kZW5jeVRlbGVtZXRyeS50YXJnZXRcclxuICAgICAgICAgICAgdGVsZW1ldHJ5LnRhcmdldCA9IHVybC5wYXJzZSh0ZWxlbWV0cnkuZGF0YSkuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjayh0ZWxlbWV0cnksIENvbnRyYWN0cy5UZWxlbWV0cnlUeXBlLkRlcGVuZGVuY3kpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW1tZWRpYXRlbHkgc2VuZCBhbGwgcXVldWVkIHRlbGVtZXRyeS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEZsdXNoIG9wdGlvbnMsIGluY2x1ZGluZyBpbmRpY2F0b3Igd2hldGhlciBhcHAgaXMgY3Jhc2hpbmcgYW5kIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIFRlbGVtZXRyeUNsaWVudC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyU2VuZChvcHRpb25zID8gISFvcHRpb25zLmlzQXBwQ3Jhc2hpbmcgOiBmYWxzZSwgb3B0aW9ucyA/IG9wdGlvbnMuY2FsbGJhY2sgOiB1bmRlZmluZWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJpYyB0cmFjayBtZXRob2QgZm9yIGFsbCB0ZWxlbWV0cnkgdHlwZXNcclxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSB0ZWxlbWV0cnkgdG8gc2VuZFxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeVR5cGUgc3BlY2lmeSB0aGUgdHlwZSBvZiB0ZWxlbWV0cnkgeW91IGFyZSB0cmFja2luZyBmcm9tIHRoZSBsaXN0IG9mIENvbnRyYWN0cy5EYXRhVHlwZXNcclxuICAgICAqL1xyXG4gICAgVGVsZW1ldHJ5Q2xpZW50LnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uICh0ZWxlbWV0cnksIHRlbGVtZXRyeVR5cGUpIHtcclxuICAgICAgICBpZiAodGVsZW1ldHJ5ICYmIENvbnRyYWN0cy50ZWxlbWV0cnlUeXBlVG9CYXNlVHlwZSh0ZWxlbWV0cnlUeXBlKSkge1xyXG4gICAgICAgICAgICB2YXIgZW52ZWxvcGUgPSBFbnZlbG9wZUZhY3RvcnkuY3JlYXRlRW52ZWxvcGUodGVsZW1ldHJ5LCB0ZWxlbWV0cnlUeXBlLCB0aGlzLmNvbW1vblByb3BlcnRpZXMsIHRoaXMuY29udGV4dCwgdGhpcy5jb25maWcpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdGltZSBvbiB0aGUgZW52ZWxvcGUgaWYgaXQgd2FzIHNldCBvbiB0aGUgdGVsZW1ldHJ5IGl0ZW1cclxuICAgICAgICAgICAgaWYgKHRlbGVtZXRyeS50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlbnZlbG9wZS50aW1lID0gdGVsZW1ldHJ5LnRpbWUudG9JU09TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWNjZXB0ZWQgPSB0aGlzLnJ1blRlbGVtZXRyeVByb2Nlc3NvcnMoZW52ZWxvcGUsIHRlbGVtZXRyeS5jb250ZXh0T2JqZWN0cyk7XHJcbiAgICAgICAgICAgIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIGNlbnRyYWwgcGxhY2UgZm9yIFwiaW50ZXJuYWxcIiB0ZWxlbWV0cnkgcHJvY2Vzc29ycyBhbmQgdXNlcnMgY2FuIGNvbmZpZ3VyZSB3aGljaCBvbmVzIGFyZSBpbiB1c2UuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBkbyBmb3Igbm93LiBPdGhlcndpc2UgY2xlYXJUZWxlbWV0cnlQcm9jZXNzb3JzKCkgd291bGQgYmUgcHJvYmxlbWF0aWMuXHJcbiAgICAgICAgICAgIGFjY2VwdGVkID0gYWNjZXB0ZWQgJiYgVGVsZW1ldHJ5UHJvY2Vzc29ycy5zYW1wbGluZ1RlbGVtZXRyeVByb2Nlc3NvcihlbnZlbG9wZSwgeyBjb3JyZWxhdGlvbkNvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMS5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCkgfSk7XHJcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnNlbmQoZW52ZWxvcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBMb2dnaW5nLndhcm4oXCJ0cmFjaygpIHJlcXVpcmVzIHRlbGVtZXRyeSBvYmplY3QgYW5kIHRlbGVtZXRyeVR5cGUgdG8gYmUgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRlbGVtZXRyeSBwcm9jZXNzb3IgdG8gdGhlIGNvbGxlY3Rpb24uIFRlbGVtZXRyeSBwcm9jZXNzb3JzIHdpbGwgYmUgY2FsbGVkIG9uZSBieSBvbmVcclxuICAgICAqIGJlZm9yZSB0ZWxlbWV0cnkgaXRlbSBpcyBwdXNoZWQgZm9yIHNlbmRpbmcgYW5kIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRlbGVtZXRyeVByb2Nlc3NvciBmdW5jdGlvbiwgdGFrZXMgRW52ZWxvcGUsIGFuZCBvcHRpb25hbCBjb250ZXh0IG9iamVjdCBhbmQgcmV0dXJucyBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIFRlbGVtZXRyeUNsaWVudC5wcm90b3R5cGUuYWRkVGVsZW1ldHJ5UHJvY2Vzc29yID0gZnVuY3Rpb24gKHRlbGVtZXRyeVByb2Nlc3Nvcikge1xyXG4gICAgICAgIHRoaXMuX3RlbGVtZXRyeVByb2Nlc3NvcnMucHVzaCh0ZWxlbWV0cnlQcm9jZXNzb3IpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBSZW1vdmVzIGFsbCB0ZWxlbWV0cnkgcHJvY2Vzc29yc1xyXG4gICAgICovXHJcbiAgICBUZWxlbWV0cnlDbGllbnQucHJvdG90eXBlLmNsZWFyVGVsZW1ldHJ5UHJvY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl90ZWxlbWV0cnlQcm9jZXNzb3JzID0gW107XHJcbiAgICB9O1xyXG4gICAgVGVsZW1ldHJ5Q2xpZW50LnByb3RvdHlwZS5ydW5UZWxlbWV0cnlQcm9jZXNzb3JzID0gZnVuY3Rpb24gKGVudmVsb3BlLCBjb250ZXh0T2JqZWN0cykge1xyXG4gICAgICAgIHZhciBhY2NlcHRlZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHRlbGVtZXRyeVByb2Nlc3NvcnNDb3VudCA9IHRoaXMuX3RlbGVtZXRyeVByb2Nlc3NvcnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0ZWxlbWV0cnlQcm9jZXNzb3JzQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2VwdGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0T2JqZWN0cyA9IGNvbnRleHRPYmplY3RzIHx8IHt9O1xyXG4gICAgICAgIGNvbnRleHRPYmplY3RzWydjb3JyZWxhdGlvbkNvbnRleHQnXSA9IENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJfMS5Db3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWxlbWV0cnlQcm9jZXNzb3JzQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IHRoaXMuX3RlbGVtZXRyeVByb2Nlc3NvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nvci5hcHBseShudWxsLCBbZW52ZWxvcGUsIGNvbnRleHRPYmplY3RzXSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcud2FybihcIk9uZSBvZiB0ZWxlbWV0cnkgcHJvY2Vzc29ycyBmYWlsZWQsIHRlbGVtZXRyeSBpdGVtIHdpbGwgYmUgc2VudC5cIiwgZXJyb3IsIGVudmVsb3BlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjZXB0ZWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRlbGVtZXRyeUNsaWVudDtcclxufSgpKTtcclxubW9kdWxlLmV4cG9ydHMgPSBUZWxlbWV0cnlDbGllbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRlbGVtZXRyeUNsaWVudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/TelemetryClient.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/Library/Util.js":
/*!**************************************************************!*\
  !*** ./node_modules/applicationinsights/out/Library/Util.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar url = __webpack_require__(/*! url */ \"url\");\r\nvar constants = __webpack_require__(/*! constants */ \"constants\");\r\nvar Logging = __webpack_require__(/*! ./Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\nvar RequestResponseHeaders = __webpack_require__(/*! ./RequestResponseHeaders */ \"./node_modules/applicationinsights/out/Library/RequestResponseHeaders.js\");\r\nvar Util = (function () {\r\n    function Util() {\r\n    }\r\n    /**\r\n     * helper method to access userId and sessionId cookie\r\n     */\r\n    Util.getCookie = function (name, cookie) {\r\n        var value = \"\";\r\n        if (name && name.length && typeof cookie === \"string\") {\r\n            var cookieName = name + \"=\";\r\n            var cookies = cookie.split(\";\");\r\n            for (var i = 0; i < cookies.length; i++) {\r\n                var cookie = cookies[i];\r\n                cookie = Util.trim(cookie);\r\n                if (cookie && cookie.indexOf(cookieName) === 0) {\r\n                    value = cookie.substring(cookieName.length, cookies[i].length);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * helper method to trim strings (IE8 does not implement String.prototype.trim)\r\n     */\r\n    Util.trim = function (str) {\r\n        if (typeof str === \"string\") {\r\n            return str.replace(/^\\s+|\\s+$/g, \"\");\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    };\r\n    /**\r\n     * Convert an array of int32 to Base64 (no '==' at the end).\r\n     * MSB first.\r\n     */\r\n    Util.int32ArrayToBase64 = function (array) {\r\n        var toChar = function (v, i) {\r\n            return String.fromCharCode((v >> i) & 0xFF);\r\n        };\r\n        var int32AsString = function (v) {\r\n            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);\r\n        };\r\n        var x = array.map(int32AsString).join(\"\");\r\n        var b = Buffer.from ? Buffer.from(x, \"binary\") : new Buffer(x, \"binary\");\r\n        var s = b.toString(\"base64\");\r\n        return s.substr(0, s.indexOf(\"=\"));\r\n    };\r\n    /**\r\n     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).\r\n     */\r\n    Util.random32 = function () {\r\n        return (0x100000000 * Math.random()) | 0;\r\n    };\r\n    /**\r\n     * generate a random 32bit number (0x00000000..0xFFFFFFFF).\r\n     */\r\n    Util.randomu32 = function () {\r\n        return Util.random32() + 0x80000000;\r\n    };\r\n    /**\r\n     * generate W3C-compatible trace id\r\n     * https://github.com/w3c/distributed-tracing/blob/master/trace_context/HTTP_HEADER_FORMAT.md#trace-id\r\n     */\r\n    Util.w3cTraceId = function () {\r\n        var hexValues = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n        // rfc4122 version 4 UUID without dashes and with lowercase letters\r\n        var oct = \"\", tmp;\r\n        for (var a = 0; a < 4; a++) {\r\n            tmp = Util.random32();\r\n            oct +=\r\n                hexValues[tmp & 0xF] +\r\n                    hexValues[tmp >> 4 & 0xF] +\r\n                    hexValues[tmp >> 8 & 0xF] +\r\n                    hexValues[tmp >> 12 & 0xF] +\r\n                    hexValues[tmp >> 16 & 0xF] +\r\n                    hexValues[tmp >> 20 & 0xF] +\r\n                    hexValues[tmp >> 24 & 0xF] +\r\n                    hexValues[tmp >> 28 & 0xF];\r\n        }\r\n        // \"Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively\"\r\n        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];\r\n        return oct.substr(0, 8) + oct.substr(9, 4) + \"4\" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);\r\n    };\r\n    /**\r\n     * Check if an object is of type Array\r\n     */\r\n    Util.isArray = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Error\r\n     */\r\n    Util.isError = function (obj) {\r\n        return obj instanceof Error;\r\n    };\r\n    Util.isPrimitive = function (input) {\r\n        var propType = typeof input;\r\n        return propType === \"string\" || propType === \"number\" || propType === \"boolean\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Date\r\n     */\r\n    Util.isDate = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Date]\";\r\n    };\r\n    /**\r\n     * Convert ms to c# time span format\r\n     */\r\n    Util.msToTimeSpan = function (totalms) {\r\n        if (isNaN(totalms) || totalms < 0) {\r\n            totalms = 0;\r\n        }\r\n        var sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, \"\");\r\n        var min = \"\" + Math.floor(totalms / (1000 * 60)) % 60;\r\n        var hour = \"\" + Math.floor(totalms / (1000 * 60 * 60)) % 24;\r\n        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));\r\n        sec = sec.indexOf(\".\") < 2 ? \"0\" + sec : sec;\r\n        min = min.length < 2 ? \"0\" + min : min;\r\n        hour = hour.length < 2 ? \"0\" + hour : hour;\r\n        var daysText = days > 0 ? days + \".\" : \"\";\r\n        return daysText + hour + \":\" + min + \":\" + sec;\r\n    };\r\n    /**\r\n     * Using JSON.stringify, by default Errors do not serialize to something useful:\r\n     * Simplify a generic Node Error into a simpler map for customDimensions\r\n     * Custom errors can still implement toJSON to override this functionality\r\n     */\r\n    Util.extractError = function (err) {\r\n        // Error is often subclassed so may have code OR id properties:\r\n        // https://nodejs.org/api/errors.html#errors_error_code\r\n        var looseError = err;\r\n        return {\r\n            message: err.message,\r\n            code: looseError.code || looseError.id || \"\",\r\n        };\r\n    };\r\n    /**\r\n     * Manually call toJSON if available to pre-convert the value.\r\n     * If a primitive is returned, then the consumer of this function can skip JSON.stringify.\r\n     * This avoids double escaping of quotes for Date objects, for example.\r\n     */\r\n    Util.extractObject = function (origProperty) {\r\n        if (origProperty instanceof Error) {\r\n            return Util.extractError(origProperty);\r\n        }\r\n        if (typeof origProperty.toJSON === \"function\") {\r\n            return origProperty.toJSON();\r\n        }\r\n        return origProperty;\r\n    };\r\n    /**\r\n     * Validate that an object is of type { [key: string]: string }\r\n     */\r\n    Util.validateStringMap = function (obj) {\r\n        if (typeof obj !== \"object\") {\r\n            Logging.info(\"Invalid properties dropped from payload\");\r\n            return;\r\n        }\r\n        var map = {};\r\n        for (var field in obj) {\r\n            var property = '';\r\n            var origProperty = obj[field];\r\n            var propType = typeof origProperty;\r\n            if (Util.isPrimitive(origProperty)) {\r\n                property = origProperty.toString();\r\n            }\r\n            else if (origProperty === null || propType === \"undefined\") {\r\n                property = \"\";\r\n            }\r\n            else if (propType === \"function\") {\r\n                Logging.info(\"key: \" + field + \" was function; will not serialize\");\r\n                continue;\r\n            }\r\n            else {\r\n                var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);\r\n                try {\r\n                    if (Util.isPrimitive(stringTarget)) {\r\n                        property = stringTarget;\r\n                    }\r\n                    else {\r\n                        property = JSON.stringify(stringTarget);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    property = origProperty.constructor.name.toString() + \" (Error: \" + e.message + \")\";\r\n                    Logging.info(\"key: \" + field + \", could not be serialized\");\r\n                }\r\n            }\r\n            map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);\r\n        }\r\n        return map;\r\n    };\r\n    /**\r\n     * Checks if a request url is not on a excluded domain list\r\n     * and if it is safe to add correlation headers\r\n     */\r\n    Util.canIncludeCorrelationHeader = function (client, requestUrl) {\r\n        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;\r\n        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < excludedDomains.length; i++) {\r\n            var regex = new RegExp(excludedDomains[i].replace(/\\./g, \"\\.\").replace(/\\*/g, \".*\"));\r\n            if (regex.test(url.parse(requestUrl).hostname)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Util.getCorrelationContextTarget = function (response, key) {\r\n        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];\r\n        if (contextHeaders) {\r\n            var keyValues = contextHeaders.split(\",\");\r\n            for (var i = 0; i < keyValues.length; ++i) {\r\n                var keyValue = keyValues[i].split(\"=\");\r\n                if (keyValue.length == 2 && keyValue[0] == key) {\r\n                    return keyValue[1];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate request\r\n     *\r\n     * Proxify the request creation to handle proxy http\r\n     *\r\n     * @param {string} requestUrl url endpoint\r\n     * @param {Object} requestOptions Request option\r\n     * @param {Function} requestCallback callback on request\r\n     * @returns {http.ClientRequest} request object\r\n     */\r\n    Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback) {\r\n        if (requestUrl && requestUrl.indexOf('//') === 0) {\r\n            requestUrl = 'https:' + requestUrl;\r\n        }\r\n        var requestUrlParsed = url.parse(requestUrl);\r\n        var options = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });\r\n        var proxyUrl = undefined;\r\n        if (requestUrlParsed.protocol === 'https:') {\r\n            proxyUrl = config.proxyHttpsUrl || undefined;\r\n        }\r\n        if (requestUrlParsed.protocol === 'http:') {\r\n            proxyUrl = config.proxyHttpUrl || undefined;\r\n        }\r\n        if (proxyUrl) {\r\n            if (proxyUrl.indexOf('//') === 0) {\r\n                proxyUrl = 'http:' + proxyUrl;\r\n            }\r\n            var proxyUrlParsed = url.parse(proxyUrl);\r\n            // https is not supported at the moment\r\n            if (proxyUrlParsed.protocol === 'https:') {\r\n                Logging.info(\"Proxies that use HTTPS are not supported\");\r\n                proxyUrl = undefined;\r\n            }\r\n            else {\r\n                options = __assign({}, options, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || \"80\", path: requestUrl, headers: __assign({}, options.headers, { Host: requestUrlParsed.hostname }) });\r\n            }\r\n        }\r\n        var isHttps = requestUrlParsed.protocol === 'https:' && !proxyUrl;\r\n        if (isHttps && config.httpsAgent !== undefined) {\r\n            options.agent = config.httpsAgent;\r\n        }\r\n        else if (!isHttps && config.httpAgent !== undefined) {\r\n            options.agent = config.httpAgent;\r\n        }\r\n        else if (isHttps) {\r\n            // HTTPS without a passed in agent. Use one that enforces our TLS rules\r\n            options.agent = Util.tlsRestrictedAgent;\r\n        }\r\n        if (isHttps) {\r\n            return https.request(options, requestCallback);\r\n        }\r\n        else {\r\n            return http.request(options, requestCallback);\r\n        }\r\n    };\r\n    ;\r\n    Util.MAX_PROPERTY_LENGTH = 8192;\r\n    Util.tlsRestrictedAgent = new https.Agent({\r\n        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 |\r\n            constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1\r\n    });\r\n    return Util;\r\n}());\r\nmodule.exports = Util;\r\n//# sourceMappingURL=Util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvTGlicmFyeS9VdGlsLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9hcHBsaWNhdGlvbmluc2lnaHRzL291dC9MaWJyYXJ5L1V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcbnZhciBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XHJcbnZhciBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcclxudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiY29uc3RhbnRzXCIpO1xyXG52YXIgTG9nZ2luZyA9IHJlcXVpcmUoXCIuL0xvZ2dpbmdcIik7XHJcbnZhciBSZXF1ZXN0UmVzcG9uc2VIZWFkZXJzID0gcmVxdWlyZShcIi4vUmVxdWVzdFJlc3BvbnNlSGVhZGVyc1wiKTtcclxudmFyIFV0aWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXRpbCgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogaGVscGVyIG1ldGhvZCB0byBhY2Nlc3MgdXNlcklkIGFuZCBzZXNzaW9uSWQgY29va2llXHJcbiAgICAgKi9cclxuICAgIFV0aWwuZ2V0Q29va2llID0gZnVuY3Rpb24gKG5hbWUsIGNvb2tpZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5sZW5ndGggJiYgdHlwZW9mIGNvb2tpZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB2YXIgY29va2llTmFtZSA9IG5hbWUgKyBcIj1cIjtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZXMgPSBjb29raWUuc3BsaXQoXCI7XCIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSBjb29raWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29va2llID0gVXRpbC50cmltKGNvb2tpZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29va2llICYmIGNvb2tpZS5pbmRleE9mKGNvb2tpZU5hbWUpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb29raWUuc3Vic3RyaW5nKGNvb2tpZU5hbWUubGVuZ3RoLCBjb29raWVzW2ldLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogaGVscGVyIG1ldGhvZCB0byB0cmltIHN0cmluZ3MgKElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgU3RyaW5nLnByb3RvdHlwZS50cmltKVxyXG4gICAgICovXHJcbiAgICBVdGlsLnRyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYW4gYXJyYXkgb2YgaW50MzIgdG8gQmFzZTY0IChubyAnPT0nIGF0IHRoZSBlbmQpLlxyXG4gICAgICogTVNCIGZpcnN0LlxyXG4gICAgICovXHJcbiAgICBVdGlsLmludDMyQXJyYXlUb0Jhc2U2NCA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHZhciB0b0NoYXIgPSBmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgodiA+PiBpKSAmIDB4RkYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGludDMyQXNTdHJpbmcgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9DaGFyKHYsIDI0KSArIHRvQ2hhcih2LCAxNikgKyB0b0NoYXIodiwgOCkgKyB0b0NoYXIodiwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgeCA9IGFycmF5Lm1hcChpbnQzMkFzU3RyaW5nKS5qb2luKFwiXCIpO1xyXG4gICAgICAgIHZhciBiID0gQnVmZmVyLmZyb20gPyBCdWZmZXIuZnJvbSh4LCBcImJpbmFyeVwiKSA6IG5ldyBCdWZmZXIoeCwgXCJiaW5hcnlcIik7XHJcbiAgICAgICAgdmFyIHMgPSBiLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xyXG4gICAgICAgIHJldHVybiBzLnN1YnN0cigwLCBzLmluZGV4T2YoXCI9XCIpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIGdlbmVyYXRlIGEgcmFuZG9tIDMyYml0IG51bWJlciAoLTB4ODAwMDAwMDAuLjB4N0ZGRkZGRkYpLlxyXG4gICAgICovXHJcbiAgICBVdGlsLnJhbmRvbTMyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoMHgxMDAwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKSB8IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZW5lcmF0ZSBhIHJhbmRvbSAzMmJpdCBudW1iZXIgKDB4MDAwMDAwMDAuLjB4RkZGRkZGRkYpLlxyXG4gICAgICovXHJcbiAgICBVdGlsLnJhbmRvbXUzMiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gVXRpbC5yYW5kb20zMigpICsgMHg4MDAwMDAwMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIGdlbmVyYXRlIFczQy1jb21wYXRpYmxlIHRyYWNlIGlkXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Rpc3RyaWJ1dGVkLXRyYWNpbmcvYmxvYi9tYXN0ZXIvdHJhY2VfY29udGV4dC9IVFRQX0hFQURFUl9GT1JNQVQubWQjdHJhY2UtaWRcclxuICAgICAqL1xyXG4gICAgVXRpbC53M2NUcmFjZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZXhWYWx1ZXMgPSBbXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCJdO1xyXG4gICAgICAgIC8vIHJmYzQxMjIgdmVyc2lvbiA0IFVVSUQgd2l0aG91dCBkYXNoZXMgYW5kIHdpdGggbG93ZXJjYXNlIGxldHRlcnNcclxuICAgICAgICB2YXIgb2N0ID0gXCJcIiwgdG1wO1xyXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgNDsgYSsrKSB7XHJcbiAgICAgICAgICAgIHRtcCA9IFV0aWwucmFuZG9tMzIoKTtcclxuICAgICAgICAgICAgb2N0ICs9XHJcbiAgICAgICAgICAgICAgICBoZXhWYWx1ZXNbdG1wICYgMHhGXSArXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWVzW3RtcCA+PiA0ICYgMHhGXSArXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWVzW3RtcCA+PiA4ICYgMHhGXSArXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWVzW3RtcCA+PiAxMiAmIDB4Rl0gK1xyXG4gICAgICAgICAgICAgICAgICAgIGhleFZhbHVlc1t0bXAgPj4gMTYgJiAweEZdICtcclxuICAgICAgICAgICAgICAgICAgICBoZXhWYWx1ZXNbdG1wID4+IDIwICYgMHhGXSArXHJcbiAgICAgICAgICAgICAgICAgICAgaGV4VmFsdWVzW3RtcCA+PiAyNCAmIDB4Rl0gK1xyXG4gICAgICAgICAgICAgICAgICAgIGhleFZhbHVlc1t0bXAgPj4gMjggJiAweEZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBcIlNldCB0aGUgdHdvIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyAoYml0cyA2IGFuZCA3KSBvZiB0aGUgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZCB0byB6ZXJvIGFuZCBvbmUsIHJlc3BlY3RpdmVseVwiXHJcbiAgICAgICAgdmFyIGNsb2NrU2VxdWVuY2VIaSA9IGhleFZhbHVlc1s4ICsgKE1hdGgucmFuZG9tKCkgKiA0KSB8IDBdO1xyXG4gICAgICAgIHJldHVybiBvY3Quc3Vic3RyKDAsIDgpICsgb2N0LnN1YnN0cig5LCA0KSArIFwiNFwiICsgb2N0LnN1YnN0cigxMywgMykgKyBjbG9ja1NlcXVlbmNlSGkgKyBvY3Quc3Vic3RyKDE2LCAzKSArIG9jdC5zdWJzdHIoMTksIDEyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBvZiB0eXBlIEFycmF5XHJcbiAgICAgKi9cclxuICAgIFV0aWwuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBvZiB0eXBlIEVycm9yXHJcbiAgICAgKi9cclxuICAgIFV0aWwuaXNFcnJvciA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3I7XHJcbiAgICB9O1xyXG4gICAgVXRpbC5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBpbnB1dDtcclxuICAgICAgICByZXR1cm4gcHJvcFR5cGUgPT09IFwic3RyaW5nXCIgfHwgcHJvcFR5cGUgPT09IFwibnVtYmVyXCIgfHwgcHJvcFR5cGUgPT09IFwiYm9vbGVhblwiO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIG9mIHR5cGUgRGF0ZVxyXG4gICAgICovXHJcbiAgICBVdGlsLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBEYXRlXVwiO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBtcyB0byBjIyB0aW1lIHNwYW4gZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIFV0aWwubXNUb1RpbWVTcGFuID0gZnVuY3Rpb24gKHRvdGFsbXMpIHtcclxuICAgICAgICBpZiAoaXNOYU4odG90YWxtcykgfHwgdG90YWxtcyA8IDApIHtcclxuICAgICAgICAgICAgdG90YWxtcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWMgPSAoKHRvdGFsbXMgLyAxMDAwKSAlIDYwKS50b0ZpeGVkKDcpLnJlcGxhY2UoLzB7MCw0fSQvLCBcIlwiKTtcclxuICAgICAgICB2YXIgbWluID0gXCJcIiArIE1hdGguZmxvb3IodG90YWxtcyAvICgxMDAwICogNjApKSAlIDYwO1xyXG4gICAgICAgIHZhciBob3VyID0gXCJcIiArIE1hdGguZmxvb3IodG90YWxtcyAvICgxMDAwICogNjAgKiA2MCkpICUgMjQ7XHJcbiAgICAgICAgdmFyIGRheXMgPSBNYXRoLmZsb29yKHRvdGFsbXMgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xyXG4gICAgICAgIHNlYyA9IHNlYy5pbmRleE9mKFwiLlwiKSA8IDIgPyBcIjBcIiArIHNlYyA6IHNlYztcclxuICAgICAgICBtaW4gPSBtaW4ubGVuZ3RoIDwgMiA/IFwiMFwiICsgbWluIDogbWluO1xyXG4gICAgICAgIGhvdXIgPSBob3VyLmxlbmd0aCA8IDIgPyBcIjBcIiArIGhvdXIgOiBob3VyO1xyXG4gICAgICAgIHZhciBkYXlzVGV4dCA9IGRheXMgPiAwID8gZGF5cyArIFwiLlwiIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gZGF5c1RleHQgKyBob3VyICsgXCI6XCIgKyBtaW4gKyBcIjpcIiArIHNlYztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVzaW5nIEpTT04uc3RyaW5naWZ5LCBieSBkZWZhdWx0IEVycm9ycyBkbyBub3Qgc2VyaWFsaXplIHRvIHNvbWV0aGluZyB1c2VmdWw6XHJcbiAgICAgKiBTaW1wbGlmeSBhIGdlbmVyaWMgTm9kZSBFcnJvciBpbnRvIGEgc2ltcGxlciBtYXAgZm9yIGN1c3RvbURpbWVuc2lvbnNcclxuICAgICAqIEN1c3RvbSBlcnJvcnMgY2FuIHN0aWxsIGltcGxlbWVudCB0b0pTT04gdG8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbmFsaXR5XHJcbiAgICAgKi9cclxuICAgIFV0aWwuZXh0cmFjdEVycm9yID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIC8vIEVycm9yIGlzIG9mdGVuIHN1YmNsYXNzZWQgc28gbWF5IGhhdmUgY29kZSBPUiBpZCBwcm9wZXJ0aWVzOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2Vycm9yX2NvZGVcclxuICAgICAgICB2YXIgbG9vc2VFcnJvciA9IGVycjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcclxuICAgICAgICAgICAgY29kZTogbG9vc2VFcnJvci5jb2RlIHx8IGxvb3NlRXJyb3IuaWQgfHwgXCJcIixcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTWFudWFsbHkgY2FsbCB0b0pTT04gaWYgYXZhaWxhYmxlIHRvIHByZS1jb252ZXJ0IHRoZSB2YWx1ZS5cclxuICAgICAqIElmIGEgcHJpbWl0aXZlIGlzIHJldHVybmVkLCB0aGVuIHRoZSBjb25zdW1lciBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBza2lwIEpTT04uc3RyaW5naWZ5LlxyXG4gICAgICogVGhpcyBhdm9pZHMgZG91YmxlIGVzY2FwaW5nIG9mIHF1b3RlcyBmb3IgRGF0ZSBvYmplY3RzLCBmb3IgZXhhbXBsZS5cclxuICAgICAqL1xyXG4gICAgVXRpbC5leHRyYWN0T2JqZWN0ID0gZnVuY3Rpb24gKG9yaWdQcm9wZXJ0eSkge1xyXG4gICAgICAgIGlmIChvcmlnUHJvcGVydHkgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gVXRpbC5leHRyYWN0RXJyb3Iob3JpZ1Byb3BlcnR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnUHJvcGVydHkudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdQcm9wZXJ0eS50b0pTT04oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9yaWdQcm9wZXJ0eTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxyXG4gICAgICovXHJcbiAgICBVdGlsLnZhbGlkYXRlU3RyaW5nTWFwID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhcIkludmFsaWQgcHJvcGVydGllcyBkcm9wcGVkIGZyb20gcGF5bG9hZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWFwID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgb3JpZ1Byb3BlcnR5ID0gb2JqW2ZpZWxkXTtcclxuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIG9yaWdQcm9wZXJ0eTtcclxuICAgICAgICAgICAgaWYgKFV0aWwuaXNQcmltaXRpdmUob3JpZ1Byb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBvcmlnUHJvcGVydHkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnUHJvcGVydHkgPT09IG51bGwgfHwgcHJvcFR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnaW5nLmluZm8oXCJrZXk6IFwiICsgZmllbGQgKyBcIiB3YXMgZnVuY3Rpb247IHdpbGwgbm90IHNlcmlhbGl6ZVwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1RhcmdldCA9IFV0aWwuaXNBcnJheShvcmlnUHJvcGVydHkpID8gb3JpZ1Byb3BlcnR5IDogVXRpbC5leHRyYWN0T2JqZWN0KG9yaWdQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzUHJpbWl0aXZlKHN0cmluZ1RhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBzdHJpbmdUYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IEpTT04uc3RyaW5naWZ5KHN0cmluZ1RhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG9yaWdQcm9wZXJ0eS5jb25zdHJ1Y3Rvci5uYW1lLnRvU3RyaW5nKCkgKyBcIiAoRXJyb3I6IFwiICsgZS5tZXNzYWdlICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2luZy5pbmZvKFwia2V5OiBcIiArIGZpZWxkICsgXCIsIGNvdWxkIG5vdCBiZSBzZXJpYWxpemVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hcFtmaWVsZF0gPSBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgVXRpbC5NQVhfUFJPUEVSVFlfTEVOR1RIKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHJlcXVlc3QgdXJsIGlzIG5vdCBvbiBhIGV4Y2x1ZGVkIGRvbWFpbiBsaXN0XHJcbiAgICAgKiBhbmQgaWYgaXQgaXMgc2FmZSB0byBhZGQgY29ycmVsYXRpb24gaGVhZGVyc1xyXG4gICAgICovXHJcbiAgICBVdGlsLmNhbkluY2x1ZGVDb3JyZWxhdGlvbkhlYWRlciA9IGZ1bmN0aW9uIChjbGllbnQsIHJlcXVlc3RVcmwpIHtcclxuICAgICAgICB2YXIgZXhjbHVkZWREb21haW5zID0gY2xpZW50ICYmIGNsaWVudC5jb25maWcgJiYgY2xpZW50LmNvbmZpZy5jb3JyZWxhdGlvbkhlYWRlckV4Y2x1ZGVkRG9tYWlucztcclxuICAgICAgICBpZiAoIWV4Y2x1ZGVkRG9tYWlucyB8fCBleGNsdWRlZERvbWFpbnMubGVuZ3RoID09IDAgfHwgIXJlcXVlc3RVcmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWREb21haW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoZXhjbHVkZWREb21haW5zW2ldLnJlcGxhY2UoL1xcLi9nLCBcIlxcLlwiKS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKSk7XHJcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHVybC5wYXJzZShyZXF1ZXN0VXJsKS5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBVdGlsLmdldENvcnJlbGF0aW9uQ29udGV4dFRhcmdldCA9IGZ1bmN0aW9uIChyZXNwb25zZSwga2V5KSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHRIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzW1JlcXVlc3RSZXNwb25zZUhlYWRlcnMucmVxdWVzdENvbnRleHRIZWFkZXJdO1xyXG4gICAgICAgIGlmIChjb250ZXh0SGVhZGVycykge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWVzID0gY29udGV4dEhlYWRlcnMuc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0ga2V5VmFsdWVzW2ldLnNwbGl0KFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZS5sZW5ndGggPT0gMiAmJiBrZXlWYWx1ZVswXSA9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5VmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSByZXF1ZXN0XHJcbiAgICAgKlxyXG4gICAgICogUHJveGlmeSB0aGUgcmVxdWVzdCBjcmVhdGlvbiB0byBoYW5kbGUgcHJveHkgaHR0cFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsIHVybCBlbmRwb2ludFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zIFJlcXVlc3Qgb3B0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXF1ZXN0Q2FsbGJhY2sgY2FsbGJhY2sgb24gcmVxdWVzdFxyXG4gICAgICogQHJldHVybnMge2h0dHAuQ2xpZW50UmVxdWVzdH0gcmVxdWVzdCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgVXRpbC5tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uIChjb25maWcsIHJlcXVlc3RVcmwsIHJlcXVlc3RPcHRpb25zLCByZXF1ZXN0Q2FsbGJhY2spIHtcclxuICAgICAgICBpZiAocmVxdWVzdFVybCAmJiByZXF1ZXN0VXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVybCA9ICdodHRwczonICsgcmVxdWVzdFVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcXVlc3RVcmxQYXJzZWQgPSB1cmwucGFyc2UocmVxdWVzdFVybCk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMsIHsgaG9zdDogcmVxdWVzdFVybFBhcnNlZC5ob3N0bmFtZSwgcG9ydDogcmVxdWVzdFVybFBhcnNlZC5wb3J0LCBwYXRoOiByZXF1ZXN0VXJsUGFyc2VkLnBhdGhuYW1lIH0pO1xyXG4gICAgICAgIHZhciBwcm94eVVybCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAocmVxdWVzdFVybFBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcclxuICAgICAgICAgICAgcHJveHlVcmwgPSBjb25maWcucHJveHlIdHRwc1VybCB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0VXJsUGFyc2VkLnByb3RvY29sID09PSAnaHR0cDonKSB7XHJcbiAgICAgICAgICAgIHByb3h5VXJsID0gY29uZmlnLnByb3h5SHR0cFVybCB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm94eVVybCkge1xyXG4gICAgICAgICAgICBpZiAocHJveHlVcmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcHJveHlVcmwgPSAnaHR0cDonICsgcHJveHlVcmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb3h5VXJsUGFyc2VkID0gdXJsLnBhcnNlKHByb3h5VXJsKTtcclxuICAgICAgICAgICAgLy8gaHR0cHMgaXMgbm90IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50XHJcbiAgICAgICAgICAgIGlmIChwcm94eVVybFBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dpbmcuaW5mbyhcIlByb3hpZXMgdGhhdCB1c2UgSFRUUFMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICBwcm94eVVybCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucywgeyBob3N0OiBwcm94eVVybFBhcnNlZC5ob3N0bmFtZSwgcG9ydDogcHJveHlVcmxQYXJzZWQucG9ydCB8fCBcIjgwXCIsIHBhdGg6IHJlcXVlc3RVcmwsIGhlYWRlcnM6IF9fYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHsgSG9zdDogcmVxdWVzdFVybFBhcnNlZC5ob3N0bmFtZSB9KSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNIdHRwcyA9IHJlcXVlc3RVcmxQYXJzZWQucHJvdG9jb2wgPT09ICdodHRwczonICYmICFwcm94eVVybDtcclxuICAgICAgICBpZiAoaXNIdHRwcyAmJiBjb25maWcuaHR0cHNBZ2VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYWdlbnQgPSBjb25maWcuaHR0cHNBZ2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzSHR0cHMgJiYgY29uZmlnLmh0dHBBZ2VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYWdlbnQgPSBjb25maWcuaHR0cEFnZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0h0dHBzKSB7XHJcbiAgICAgICAgICAgIC8vIEhUVFBTIHdpdGhvdXQgYSBwYXNzZWQgaW4gYWdlbnQuIFVzZSBvbmUgdGhhdCBlbmZvcmNlcyBvdXIgVExTIHJ1bGVzXHJcbiAgICAgICAgICAgIG9wdGlvbnMuYWdlbnQgPSBVdGlsLnRsc1Jlc3RyaWN0ZWRBZ2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzSHR0cHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgcmVxdWVzdENhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBodHRwLnJlcXVlc3Qob3B0aW9ucywgcmVxdWVzdENhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVXRpbC5NQVhfUFJPUEVSVFlfTEVOR1RIID0gODE5MjtcclxuICAgIFV0aWwudGxzUmVzdHJpY3RlZEFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcclxuICAgICAgICBzZWN1cmVPcHRpb25zOiBjb25zdGFudHMuU1NMX09QX05PX1NTTHYyIHwgY29uc3RhbnRzLlNTTF9PUF9OT19TU0x2MyB8XHJcbiAgICAgICAgICAgIGNvbnN0YW50cy5TU0xfT1BfTk9fVExTdjEgfCBjb25zdGFudHMuU1NMX09QX05PX1RMU3YxXzFcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFV0aWw7XHJcbn0oKSk7XHJcbm1vZHVsZS5leHBvcnRzID0gVXRpbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/Library/Util.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts = __webpack_require__(/*! ../Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\n/**\r\n *  A telemetry processor that handles sampling.\r\n */\r\nfunction samplingTelemetryProcessor(envelope, contextObjects) {\r\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\r\n    var isSampledIn = false;\r\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\r\n        return true;\r\n    }\r\n    else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {\r\n        // Exclude MetricData telemetry from sampling\r\n        return true;\r\n    }\r\n    else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\r\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request \r\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\r\n    }\r\n    else {\r\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\r\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\r\n    }\r\n    return isSampledIn;\r\n}\r\nexports.samplingTelemetryProcessor = samplingTelemetryProcessor;\r\n/** Ported from AI .NET SDK */\r\nfunction getSamplingHashCode(input) {\r\n    var csharpMin = -2147483648;\r\n    var csharpMax = 2147483647;\r\n    var hash = 5381;\r\n    if (!input) {\r\n        return 0;\r\n    }\r\n    while (input.length < 8) {\r\n        input = input + input;\r\n    }\r\n    for (var i = 0; i < input.length; i++) {\r\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\r\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\r\n    }\r\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\r\n    return (hash / csharpMax) * 100;\r\n}\r\nexports.getSamplingHashCode = getSamplingHashCode;\r\n//# sourceMappingURL=SamplingTelemetryProcessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvVGVsZW1ldHJ5UHJvY2Vzc29ycy9TYW1wbGluZ1RlbGVtZXRyeVByb2Nlc3Nvci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvVGVsZW1ldHJ5UHJvY2Vzc29ycy9TYW1wbGluZ1RlbGVtZXRyeVByb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQ29udHJhY3RzID0gcmVxdWlyZShcIi4uL0RlY2xhcmF0aW9ucy9Db250cmFjdHNcIik7XHJcbi8qKlxyXG4gKiAgQSB0ZWxlbWV0cnkgcHJvY2Vzc29yIHRoYXQgaGFuZGxlcyBzYW1wbGluZy5cclxuICovXHJcbmZ1bmN0aW9uIHNhbXBsaW5nVGVsZW1ldHJ5UHJvY2Vzc29yKGVudmVsb3BlLCBjb250ZXh0T2JqZWN0cykge1xyXG4gICAgdmFyIHNhbXBsaW5nUGVyY2VudGFnZSA9IGVudmVsb3BlLnNhbXBsZVJhdGU7IC8vIFNldCBmb3IgdXMgaW4gQ2xpZW50LmdldEVudmVsb3BlXHJcbiAgICB2YXIgaXNTYW1wbGVkSW4gPSBmYWxzZTtcclxuICAgIGlmIChzYW1wbGluZ1BlcmNlbnRhZ2UgPT09IG51bGwgfHwgc2FtcGxpbmdQZXJjZW50YWdlID09PSB1bmRlZmluZWQgfHwgc2FtcGxpbmdQZXJjZW50YWdlID49IDEwMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZW52ZWxvcGUuZGF0YSAmJiBDb250cmFjdHMuVGVsZW1ldHJ5VHlwZS5NZXRyaWMgPT09IENvbnRyYWN0cy5iYXNlVHlwZVRvVGVsZW1ldHJ5VHlwZShlbnZlbG9wZS5kYXRhLmJhc2VUeXBlKSkge1xyXG4gICAgICAgIC8vIEV4Y2x1ZGUgTWV0cmljRGF0YSB0ZWxlbWV0cnkgZnJvbSBzYW1wbGluZ1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29udGV4dE9iamVjdHMuY29ycmVsYXRpb25Db250ZXh0ICYmIGNvbnRleHRPYmplY3RzLmNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24pIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyBkZXBlbmRlbmN5IGNvcnJlbGF0aW9uLCBzYW1wbGluZyBzaG91bGQgcmV0YWluIGFsbCB0ZWxlbWV0cnkgZnJvbSBhIGdpdmVuIHJlcXVlc3QgXHJcbiAgICAgICAgaXNTYW1wbGVkSW4gPSBnZXRTYW1wbGluZ0hhc2hDb2RlKGNvbnRleHRPYmplY3RzLmNvcnJlbGF0aW9uQ29udGV4dC5vcGVyYXRpb24uaWQpIDwgc2FtcGxpbmdQZXJjZW50YWdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IHVzaW5nIGRlcGVuZGVuY3kgY29ycmVsYXRpb24sIHNhbXBsaW5nIHNob3VsZCB1c2UgYSByYW5kb20gZGlzdHJpYnV0aW9uIG9uIGVhY2ggaXRlbVxyXG4gICAgICAgIGlzU2FtcGxlZEluID0gKE1hdGgucmFuZG9tKCkgKiAxMDApIDwgc2FtcGxpbmdQZXJjZW50YWdlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzU2FtcGxlZEluO1xyXG59XHJcbmV4cG9ydHMuc2FtcGxpbmdUZWxlbWV0cnlQcm9jZXNzb3IgPSBzYW1wbGluZ1RlbGVtZXRyeVByb2Nlc3NvcjtcclxuLyoqIFBvcnRlZCBmcm9tIEFJIC5ORVQgU0RLICovXHJcbmZ1bmN0aW9uIGdldFNhbXBsaW5nSGFzaENvZGUoaW5wdXQpIHtcclxuICAgIHZhciBjc2hhcnBNaW4gPSAtMjE0NzQ4MzY0ODtcclxuICAgIHZhciBjc2hhcnBNYXggPSAyMTQ3NDgzNjQ3O1xyXG4gICAgdmFyIGhhc2ggPSA1MzgxO1xyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCA8IDgpIHtcclxuICAgICAgICBpbnB1dCA9IGlucHV0ICsgaW5wdXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gSlMgZG9lc24ndCByZXNwb25kIHRvIGludGVnZXIgb3ZlcmZsb3cgYnkgd3JhcHBpbmcgYXJvdW5kLiBTaW11bGF0ZSBpdCB3aXRoIGJpdHdpc2Ugb3BlcmF0b3JzICggfCAwKVxyXG4gICAgICAgIGhhc2ggPSAoKCgoaGFzaCA8PCA1KSArIGhhc2gpIHwgMCkgKyBpbnB1dC5jaGFyQ29kZUF0KGkpIHwgMCk7XHJcbiAgICB9XHJcbiAgICBoYXNoID0gaGFzaCA8PSBjc2hhcnBNaW4gPyBjc2hhcnBNYXggOiBNYXRoLmFicyhoYXNoKTtcclxuICAgIHJldHVybiAoaGFzaCAvIGNzaGFycE1heCkgKiAxMDA7XHJcbn1cclxuZXhwb3J0cy5nZXRTYW1wbGluZ0hhc2hDb2RlID0gZ2V0U2FtcGxpbmdIYXNoQ29kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2FtcGxpbmdUZWxlbWV0cnlQcm9jZXNzb3IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/TelemetryProcessors/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/applicationinsights/out/TelemetryProcessors/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(/*! ./SamplingTelemetryProcessor */ \"./node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js\"));\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvVGVsZW1ldHJ5UHJvY2Vzc29ycy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvVGVsZW1ldHJ5UHJvY2Vzc29ycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vU2FtcGxpbmdUZWxlbWV0cnlQcm9jZXNzb3JcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/TelemetryProcessors/index.js\n");

/***/ }),

/***/ "./node_modules/applicationinsights/out/applicationinsights.js":
/*!*********************************************************************!*\
  !*** ./node_modules/applicationinsights/out/applicationinsights.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CorrelationContextManager = __webpack_require__(/*! ./AutoCollection/CorrelationContextManager */ \"./node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js\"); // Keep this first\r\nvar AutoCollectConsole = __webpack_require__(/*! ./AutoCollection/Console */ \"./node_modules/applicationinsights/out/AutoCollection/Console.js\");\r\nvar AutoCollectExceptions = __webpack_require__(/*! ./AutoCollection/Exceptions */ \"./node_modules/applicationinsights/out/AutoCollection/Exceptions.js\");\r\nvar AutoCollectPerformance = __webpack_require__(/*! ./AutoCollection/Performance */ \"./node_modules/applicationinsights/out/AutoCollection/Performance.js\");\r\nvar AutoCollectHttpDependencies = __webpack_require__(/*! ./AutoCollection/HttpDependencies */ \"./node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js\");\r\nvar AutoCollectHttpRequests = __webpack_require__(/*! ./AutoCollection/HttpRequests */ \"./node_modules/applicationinsights/out/AutoCollection/HttpRequests.js\");\r\nvar Logging = __webpack_require__(/*! ./Library/Logging */ \"./node_modules/applicationinsights/out/Library/Logging.js\");\r\n// We export these imports so that SDK users may use these classes directly.\r\n// They're exposed using \"export import\" so that types are passed along as expected\r\nexports.TelemetryClient = __webpack_require__(/*! ./Library/NodeClient */ \"./node_modules/applicationinsights/out/Library/NodeClient.js\");\r\nexports.Contracts = __webpack_require__(/*! ./Declarations/Contracts */ \"./node_modules/applicationinsights/out/Declarations/Contracts/index.js\");\r\n// Default autocollection configuration\r\nvar _isConsole = true;\r\nvar _isConsoleLog = false;\r\nvar _isExceptions = true;\r\nvar _isPerformance = true;\r\nvar _isRequests = true;\r\nvar _isDependencies = true;\r\nvar _isDiskRetry = true;\r\nvar _isCorrelating = true;\r\nvar _diskRetryInterval = undefined;\r\nvar _diskRetryMaxBytes = undefined;\r\nvar _console;\r\nvar _exceptions;\r\nvar _performance;\r\nvar _serverRequests;\r\nvar _clientRequests;\r\nvar _isStarted = false;\r\n/**\r\n * Initializes the default client. Should be called after setting\r\n * configuration options.\r\n *\r\n * @param instrumentationKey the instrumentation key to use. Optional, if\r\n * this is not specified, the value will be read from the environment\r\n * variable APPINSIGHTS_INSTRUMENTATIONKEY.\r\n * @returns {Configuration} the configuration class to initialize\r\n * and start the SDK.\r\n */\r\nfunction setup(instrumentationKey) {\r\n    if (!exports.defaultClient) {\r\n        exports.defaultClient = new exports.TelemetryClient(instrumentationKey);\r\n        _console = new AutoCollectConsole(exports.defaultClient);\r\n        _exceptions = new AutoCollectExceptions(exports.defaultClient);\r\n        _performance = new AutoCollectPerformance(exports.defaultClient);\r\n        _serverRequests = new AutoCollectHttpRequests(exports.defaultClient);\r\n        _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient);\r\n    }\r\n    else {\r\n        Logging.info(\"The default client is already setup\");\r\n    }\r\n    if (exports.defaultClient && exports.defaultClient.channel) {\r\n        exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);\r\n    }\r\n    return Configuration;\r\n}\r\nexports.setup = setup;\r\n/**\r\n * Starts automatic collection of telemetry. Prior to calling start no\r\n * telemetry will be *automatically* collected, though manual collection\r\n * is enabled.\r\n * @returns {ApplicationInsights} this class\r\n */\r\nfunction start() {\r\n    if (!!exports.defaultClient) {\r\n        _isStarted = true;\r\n        _console.enable(_isConsole, _isConsoleLog);\r\n        _exceptions.enable(_isExceptions);\r\n        _performance.enable(_isPerformance);\r\n        _serverRequests.useAutoCorrelation(_isCorrelating);\r\n        _serverRequests.enable(_isRequests);\r\n        _clientRequests.enable(_isDependencies);\r\n    }\r\n    else {\r\n        Logging.warn(\"Start cannot be called before setup\");\r\n    }\r\n    return Configuration;\r\n}\r\nexports.start = start;\r\n/**\r\n * Returns an object that is shared across all code handling a given request.\r\n * This can be used similarly to thread-local storage in other languages.\r\n * Properties set on this object will be available to telemetry processors.\r\n *\r\n * Do not store sensitive information here.\r\n * Custom properties set on this object can be exposed in a future SDK\r\n * release via outgoing HTTP headers.\r\n * This is to allow for correlating data cross-component.\r\n *\r\n * This method will return null if automatic dependency correlation is disabled.\r\n * @returns A plain object for request storage or null if automatic dependency correlation is disabled.\r\n */\r\nfunction getCorrelationContext() {\r\n    if (_isCorrelating) {\r\n        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();\r\n    }\r\n    return null;\r\n}\r\nexports.getCorrelationContext = getCorrelationContext;\r\n/**\r\n * Returns a function that will get the same correlation context within its\r\n * function body as the code executing this function.\r\n * Use this method if automatic dependency correlation is not propagating\r\n * correctly to an asynchronous callback.\r\n */\r\nfunction wrapWithCorrelationContext(fn) {\r\n    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn);\r\n}\r\nexports.wrapWithCorrelationContext = wrapWithCorrelationContext;\r\n/**\r\n * The active configuration for global SDK behaviors, such as autocollection.\r\n */\r\nvar Configuration = (function () {\r\n    function Configuration() {\r\n    }\r\n    /**\r\n     * Sets the state of console and logger tracking (enabled by default for third-party loggers only)\r\n     * @param value if true logger activity will be sent to Application Insights\r\n     * @param collectConsoleLog if true, logger autocollection will include console.log calls (default false)\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {\r\n        if (collectConsoleLog === void 0) { collectConsoleLog = false; }\r\n        _isConsole = value;\r\n        _isConsoleLog = collectConsoleLog;\r\n        if (_isStarted) {\r\n            _console.enable(value, collectConsoleLog);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of exception tracking (enabled by default)\r\n     * @param value if true uncaught exceptions will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectExceptions = function (value) {\r\n        _isExceptions = value;\r\n        if (_isStarted) {\r\n            _exceptions.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of performance tracking (enabled by default)\r\n     * @param value if true performance counters will be collected every second and sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectPerformance = function (value) {\r\n        _isPerformance = value;\r\n        if (_isStarted) {\r\n            _performance.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of request tracking (enabled by default)\r\n     * @param value if true requests will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectRequests = function (value) {\r\n        _isRequests = value;\r\n        if (_isStarted) {\r\n            _serverRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of dependency tracking (enabled by default)\r\n     * @param value if true dependencies will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectDependencies = function (value) {\r\n        _isDependencies = value;\r\n        if (_isStarted) {\r\n            _clientRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of automatic dependency correlation (enabled by default)\r\n     * @param value if true dependencies will be correlated with requests\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoDependencyCorrelation = function (value) {\r\n        _isCorrelating = value;\r\n        if (_isStarted) {\r\n            _serverRequests.useAutoCorrelation(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * Note that this method only applies to the default client. Disk-backed retry caching is disabled by default for additional clients.\r\n     * For enable for additional clients, use client.channel.setUseDiskRetryCaching(true).\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occured while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        _isDiskRetry = value;\r\n        _diskRetryInterval = resendInterval;\r\n        _diskRetryMaxBytes = maxBytesOnDisk;\r\n        if (exports.defaultClient && exports.defaultClient.channel) {\r\n            exports.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enables debug and warning logging for AppInsights itself.\r\n     * @param enableDebugLogging if true, enables debug logging\r\n     * @param enableWarningLogging if true, enables warning logging\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {\r\n        if (enableDebugLogging === void 0) { enableDebugLogging = false; }\r\n        if (enableWarningLogging === void 0) { enableWarningLogging = true; }\r\n        Logging.enableDebug = enableDebugLogging;\r\n        Logging.disableWarnings = !enableWarningLogging;\r\n        return Configuration;\r\n    };\r\n    // Convenience shortcut to ApplicationInsights.start\r\n    Configuration.start = start;\r\n    return Configuration;\r\n}());\r\nexports.Configuration = Configuration;\r\n/**\r\n * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration\r\n*/\r\nfunction dispose() {\r\n    exports.defaultClient = null;\r\n    _isStarted = false;\r\n    if (_console) {\r\n        _console.dispose();\r\n    }\r\n    if (_exceptions) {\r\n        _exceptions.dispose();\r\n    }\r\n    if (_performance) {\r\n        _performance.dispose();\r\n    }\r\n    if (_serverRequests) {\r\n        _serverRequests.dispose();\r\n    }\r\n    if (_clientRequests) {\r\n        _clientRequests.dispose();\r\n    }\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=applicationinsights.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvYXBwbGljYXRpb25pbnNpZ2h0cy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvYXBwbGljYXRpb25pbnNpZ2h0cy9vdXQvYXBwbGljYXRpb25pbnNpZ2h0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlciA9IHJlcXVpcmUoXCIuL0F1dG9Db2xsZWN0aW9uL0NvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXJcIik7IC8vIEtlZXAgdGhpcyBmaXJzdFxyXG52YXIgQXV0b0NvbGxlY3RDb25zb2xlID0gcmVxdWlyZShcIi4vQXV0b0NvbGxlY3Rpb24vQ29uc29sZVwiKTtcclxudmFyIEF1dG9Db2xsZWN0RXhjZXB0aW9ucyA9IHJlcXVpcmUoXCIuL0F1dG9Db2xsZWN0aW9uL0V4Y2VwdGlvbnNcIik7XHJcbnZhciBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlID0gcmVxdWlyZShcIi4vQXV0b0NvbGxlY3Rpb24vUGVyZm9ybWFuY2VcIik7XHJcbnZhciBBdXRvQ29sbGVjdEh0dHBEZXBlbmRlbmNpZXMgPSByZXF1aXJlKFwiLi9BdXRvQ29sbGVjdGlvbi9IdHRwRGVwZW5kZW5jaWVzXCIpO1xyXG52YXIgQXV0b0NvbGxlY3RIdHRwUmVxdWVzdHMgPSByZXF1aXJlKFwiLi9BdXRvQ29sbGVjdGlvbi9IdHRwUmVxdWVzdHNcIik7XHJcbnZhciBMb2dnaW5nID0gcmVxdWlyZShcIi4vTGlicmFyeS9Mb2dnaW5nXCIpO1xyXG4vLyBXZSBleHBvcnQgdGhlc2UgaW1wb3J0cyBzbyB0aGF0IFNESyB1c2VycyBtYXkgdXNlIHRoZXNlIGNsYXNzZXMgZGlyZWN0bHkuXHJcbi8vIFRoZXkncmUgZXhwb3NlZCB1c2luZyBcImV4cG9ydCBpbXBvcnRcIiBzbyB0aGF0IHR5cGVzIGFyZSBwYXNzZWQgYWxvbmcgYXMgZXhwZWN0ZWRcclxuZXhwb3J0cy5UZWxlbWV0cnlDbGllbnQgPSByZXF1aXJlKFwiLi9MaWJyYXJ5L05vZGVDbGllbnRcIik7XHJcbmV4cG9ydHMuQ29udHJhY3RzID0gcmVxdWlyZShcIi4vRGVjbGFyYXRpb25zL0NvbnRyYWN0c1wiKTtcclxuLy8gRGVmYXVsdCBhdXRvY29sbGVjdGlvbiBjb25maWd1cmF0aW9uXHJcbnZhciBfaXNDb25zb2xlID0gdHJ1ZTtcclxudmFyIF9pc0NvbnNvbGVMb2cgPSBmYWxzZTtcclxudmFyIF9pc0V4Y2VwdGlvbnMgPSB0cnVlO1xyXG52YXIgX2lzUGVyZm9ybWFuY2UgPSB0cnVlO1xyXG52YXIgX2lzUmVxdWVzdHMgPSB0cnVlO1xyXG52YXIgX2lzRGVwZW5kZW5jaWVzID0gdHJ1ZTtcclxudmFyIF9pc0Rpc2tSZXRyeSA9IHRydWU7XHJcbnZhciBfaXNDb3JyZWxhdGluZyA9IHRydWU7XHJcbnZhciBfZGlza1JldHJ5SW50ZXJ2YWwgPSB1bmRlZmluZWQ7XHJcbnZhciBfZGlza1JldHJ5TWF4Qnl0ZXMgPSB1bmRlZmluZWQ7XHJcbnZhciBfY29uc29sZTtcclxudmFyIF9leGNlcHRpb25zO1xyXG52YXIgX3BlcmZvcm1hbmNlO1xyXG52YXIgX3NlcnZlclJlcXVlc3RzO1xyXG52YXIgX2NsaWVudFJlcXVlc3RzO1xyXG52YXIgX2lzU3RhcnRlZCA9IGZhbHNlO1xyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIGRlZmF1bHQgY2xpZW50LiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNldHRpbmdcclxuICogY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5zdHJ1bWVudGF0aW9uS2V5IHRoZSBpbnN0cnVtZW50YXRpb24ga2V5IHRvIHVzZS4gT3B0aW9uYWwsIGlmXHJcbiAqIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHZhbHVlIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBlbnZpcm9ubWVudFxyXG4gKiB2YXJpYWJsZSBBUFBJTlNJR0hUU19JTlNUUlVNRU5UQVRJT05LRVkuXHJcbiAqIEByZXR1cm5zIHtDb25maWd1cmF0aW9ufSB0aGUgY29uZmlndXJhdGlvbiBjbGFzcyB0byBpbml0aWFsaXplXHJcbiAqIGFuZCBzdGFydCB0aGUgU0RLLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0dXAoaW5zdHJ1bWVudGF0aW9uS2V5KSB7XHJcbiAgICBpZiAoIWV4cG9ydHMuZGVmYXVsdENsaWVudCkge1xyXG4gICAgICAgIGV4cG9ydHMuZGVmYXVsdENsaWVudCA9IG5ldyBleHBvcnRzLlRlbGVtZXRyeUNsaWVudChpbnN0cnVtZW50YXRpb25LZXkpO1xyXG4gICAgICAgIF9jb25zb2xlID0gbmV3IEF1dG9Db2xsZWN0Q29uc29sZShleHBvcnRzLmRlZmF1bHRDbGllbnQpO1xyXG4gICAgICAgIF9leGNlcHRpb25zID0gbmV3IEF1dG9Db2xsZWN0RXhjZXB0aW9ucyhleHBvcnRzLmRlZmF1bHRDbGllbnQpO1xyXG4gICAgICAgIF9wZXJmb3JtYW5jZSA9IG5ldyBBdXRvQ29sbGVjdFBlcmZvcm1hbmNlKGV4cG9ydHMuZGVmYXVsdENsaWVudCk7XHJcbiAgICAgICAgX3NlcnZlclJlcXVlc3RzID0gbmV3IEF1dG9Db2xsZWN0SHR0cFJlcXVlc3RzKGV4cG9ydHMuZGVmYXVsdENsaWVudCk7XHJcbiAgICAgICAgX2NsaWVudFJlcXVlc3RzID0gbmV3IEF1dG9Db2xsZWN0SHR0cERlcGVuZGVuY2llcyhleHBvcnRzLmRlZmF1bHRDbGllbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgTG9nZ2luZy5pbmZvKFwiVGhlIGRlZmF1bHQgY2xpZW50IGlzIGFscmVhZHkgc2V0dXBcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwb3J0cy5kZWZhdWx0Q2xpZW50ICYmIGV4cG9ydHMuZGVmYXVsdENsaWVudC5jaGFubmVsKSB7XHJcbiAgICAgICAgZXhwb3J0cy5kZWZhdWx0Q2xpZW50LmNoYW5uZWwuc2V0VXNlRGlza1JldHJ5Q2FjaGluZyhfaXNEaXNrUmV0cnksIF9kaXNrUmV0cnlJbnRlcnZhbCwgX2Rpc2tSZXRyeU1heEJ5dGVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG59XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuLyoqXHJcbiAqIFN0YXJ0cyBhdXRvbWF0aWMgY29sbGVjdGlvbiBvZiB0ZWxlbWV0cnkuIFByaW9yIHRvIGNhbGxpbmcgc3RhcnQgbm9cclxuICogdGVsZW1ldHJ5IHdpbGwgYmUgKmF1dG9tYXRpY2FsbHkqIGNvbGxlY3RlZCwgdGhvdWdoIG1hbnVhbCBjb2xsZWN0aW9uXHJcbiAqIGlzIGVuYWJsZWQuXHJcbiAqIEByZXR1cm5zIHtBcHBsaWNhdGlvbkluc2lnaHRzfSB0aGlzIGNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydCgpIHtcclxuICAgIGlmICghIWV4cG9ydHMuZGVmYXVsdENsaWVudCkge1xyXG4gICAgICAgIF9pc1N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIF9jb25zb2xlLmVuYWJsZShfaXNDb25zb2xlLCBfaXNDb25zb2xlTG9nKTtcclxuICAgICAgICBfZXhjZXB0aW9ucy5lbmFibGUoX2lzRXhjZXB0aW9ucyk7XHJcbiAgICAgICAgX3BlcmZvcm1hbmNlLmVuYWJsZShfaXNQZXJmb3JtYW5jZSk7XHJcbiAgICAgICAgX3NlcnZlclJlcXVlc3RzLnVzZUF1dG9Db3JyZWxhdGlvbihfaXNDb3JyZWxhdGluZyk7XHJcbiAgICAgICAgX3NlcnZlclJlcXVlc3RzLmVuYWJsZShfaXNSZXF1ZXN0cyk7XHJcbiAgICAgICAgX2NsaWVudFJlcXVlc3RzLmVuYWJsZShfaXNEZXBlbmRlbmNpZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgTG9nZ2luZy53YXJuKFwiU3RhcnQgY2Fubm90IGJlIGNhbGxlZCBiZWZvcmUgc2V0dXBcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29uZmlndXJhdGlvbjtcclxufVxyXG5leHBvcnRzLnN0YXJ0ID0gc3RhcnQ7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGlzIHNoYXJlZCBhY3Jvc3MgYWxsIGNvZGUgaGFuZGxpbmcgYSBnaXZlbiByZXF1ZXN0LlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHNpbWlsYXJseSB0byB0aHJlYWQtbG9jYWwgc3RvcmFnZSBpbiBvdGhlciBsYW5ndWFnZXMuXHJcbiAqIFByb3BlcnRpZXMgc2V0IG9uIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIHRlbGVtZXRyeSBwcm9jZXNzb3JzLlxyXG4gKlxyXG4gKiBEbyBub3Qgc3RvcmUgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGhlcmUuXHJcbiAqIEN1c3RvbSBwcm9wZXJ0aWVzIHNldCBvbiB0aGlzIG9iamVjdCBjYW4gYmUgZXhwb3NlZCBpbiBhIGZ1dHVyZSBTREtcclxuICogcmVsZWFzZSB2aWEgb3V0Z29pbmcgSFRUUCBoZWFkZXJzLlxyXG4gKiBUaGlzIGlzIHRvIGFsbG93IGZvciBjb3JyZWxhdGluZyBkYXRhIGNyb3NzLWNvbXBvbmVudC5cclxuICpcclxuICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gbnVsbCBpZiBhdXRvbWF0aWMgZGVwZW5kZW5jeSBjb3JyZWxhdGlvbiBpcyBkaXNhYmxlZC5cclxuICogQHJldHVybnMgQSBwbGFpbiBvYmplY3QgZm9yIHJlcXVlc3Qgc3RvcmFnZSBvciBudWxsIGlmIGF1dG9tYXRpYyBkZXBlbmRlbmN5IGNvcnJlbGF0aW9uIGlzIGRpc2FibGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29ycmVsYXRpb25Db250ZXh0KCkge1xyXG4gICAgaWYgKF9pc0NvcnJlbGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIENvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIuQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5nZXRDb3JyZWxhdGlvbkNvbnRleHQgPSBnZXRDb3JyZWxhdGlvbkNvbnRleHQ7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGdldCB0aGUgc2FtZSBjb3JyZWxhdGlvbiBjb250ZXh0IHdpdGhpbiBpdHNcclxuICogZnVuY3Rpb24gYm9keSBhcyB0aGUgY29kZSBleGVjdXRpbmcgdGhpcyBmdW5jdGlvbi5cclxuICogVXNlIHRoaXMgbWV0aG9kIGlmIGF1dG9tYXRpYyBkZXBlbmRlbmN5IGNvcnJlbGF0aW9uIGlzIG5vdCBwcm9wYWdhdGluZ1xyXG4gKiBjb3JyZWN0bHkgdG8gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JhcFdpdGhDb3JyZWxhdGlvbkNvbnRleHQoZm4pIHtcclxuICAgIHJldHVybiBDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyLkNvcnJlbGF0aW9uQ29udGV4dE1hbmFnZXIud3JhcENhbGxiYWNrKGZuKTtcclxufVxyXG5leHBvcnRzLndyYXBXaXRoQ29ycmVsYXRpb25Db250ZXh0ID0gd3JhcFdpdGhDb3JyZWxhdGlvbkNvbnRleHQ7XHJcbi8qKlxyXG4gKiBUaGUgYWN0aXZlIGNvbmZpZ3VyYXRpb24gZm9yIGdsb2JhbCBTREsgYmVoYXZpb3JzLCBzdWNoIGFzIGF1dG9jb2xsZWN0aW9uLlxyXG4gKi9cclxudmFyIENvbmZpZ3VyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgY29uc29sZSBhbmQgbG9nZ2VyIHRyYWNraW5nIChlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIHRoaXJkLXBhcnR5IGxvZ2dlcnMgb25seSlcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlIGxvZ2dlciBhY3Rpdml0eSB3aWxsIGJlIHNlbnQgdG8gQXBwbGljYXRpb24gSW5zaWdodHNcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0Q29uc29sZUxvZyBpZiB0cnVlLCBsb2dnZXIgYXV0b2NvbGxlY3Rpb24gd2lsbCBpbmNsdWRlIGNvbnNvbGUubG9nIGNhbGxzIChkZWZhdWx0IGZhbHNlKVxyXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259IHRoaXMgY2xhc3NcclxuICAgICAqL1xyXG4gICAgQ29uZmlndXJhdGlvbi5zZXRBdXRvQ29sbGVjdENvbnNvbGUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbGxlY3RDb25zb2xlTG9nKSB7XHJcbiAgICAgICAgaWYgKGNvbGxlY3RDb25zb2xlTG9nID09PSB2b2lkIDApIHsgY29sbGVjdENvbnNvbGVMb2cgPSBmYWxzZTsgfVxyXG4gICAgICAgIF9pc0NvbnNvbGUgPSB2YWx1ZTtcclxuICAgICAgICBfaXNDb25zb2xlTG9nID0gY29sbGVjdENvbnNvbGVMb2c7XHJcbiAgICAgICAgaWYgKF9pc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgX2NvbnNvbGUuZW5hYmxlKHZhbHVlLCBjb2xsZWN0Q29uc29sZUxvZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgZXhjZXB0aW9uIHRyYWNraW5nIChlbmFibGVkIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgaWYgdHJ1ZSB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgc2VudCB0byBBcHBsaWNhdGlvbiBJbnNpZ2h0c1xyXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259IHRoaXMgY2xhc3NcclxuICAgICAqL1xyXG4gICAgQ29uZmlndXJhdGlvbi5zZXRBdXRvQ29sbGVjdEV4Y2VwdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfaXNFeGNlcHRpb25zID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKF9pc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgX2V4Y2VwdGlvbnMuZW5hYmxlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbmZpZ3VyYXRpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBwZXJmb3JtYW5jZSB0cmFja2luZyAoZW5hYmxlZCBieSBkZWZhdWx0KVxyXG4gICAgICogQHBhcmFtIHZhbHVlIGlmIHRydWUgcGVyZm9ybWFuY2UgY291bnRlcnMgd2lsbCBiZSBjb2xsZWN0ZWQgZXZlcnkgc2Vjb25kIGFuZCBzZW50IHRvIEFwcGxpY2F0aW9uIEluc2lnaHRzXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uZmlndXJhdGlvbn0gdGhpcyBjbGFzc1xyXG4gICAgICovXHJcbiAgICBDb25maWd1cmF0aW9uLnNldEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfaXNQZXJmb3JtYW5jZSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChfaXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIF9wZXJmb3JtYW5jZS5lbmFibGUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29uZmlndXJhdGlvbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHJlcXVlc3QgdHJhY2tpbmcgKGVuYWJsZWQgYnkgZGVmYXVsdClcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlIHJlcXVlc3RzIHdpbGwgYmUgc2VudCB0byBBcHBsaWNhdGlvbiBJbnNpZ2h0c1xyXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259IHRoaXMgY2xhc3NcclxuICAgICAqL1xyXG4gICAgQ29uZmlndXJhdGlvbi5zZXRBdXRvQ29sbGVjdFJlcXVlc3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX2lzUmVxdWVzdHMgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoX2lzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICBfc2VydmVyUmVxdWVzdHMuZW5hYmxlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbmZpZ3VyYXRpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBkZXBlbmRlbmN5IHRyYWNraW5nIChlbmFibGVkIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgaWYgdHJ1ZSBkZXBlbmRlbmNpZXMgd2lsbCBiZSBzZW50IHRvIEFwcGxpY2F0aW9uIEluc2lnaHRzXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uZmlndXJhdGlvbn0gdGhpcyBjbGFzc1xyXG4gICAgICovXHJcbiAgICBDb25maWd1cmF0aW9uLnNldEF1dG9Db2xsZWN0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX2lzRGVwZW5kZW5jaWVzID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKF9pc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgX2NsaWVudFJlcXVlc3RzLmVuYWJsZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgYXV0b21hdGljIGRlcGVuZGVuY3kgY29ycmVsYXRpb24gKGVuYWJsZWQgYnkgZGVmYXVsdClcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlIGRlcGVuZGVuY2llcyB3aWxsIGJlIGNvcnJlbGF0ZWQgd2l0aCByZXF1ZXN0c1xyXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259IHRoaXMgY2xhc3NcclxuICAgICAqL1xyXG4gICAgQ29uZmlndXJhdGlvbi5zZXRBdXRvRGVwZW5kZW5jeUNvcnJlbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgX2lzQ29ycmVsYXRpbmcgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoX2lzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICBfc2VydmVyUmVxdWVzdHMudXNlQXV0b0NvcnJlbGF0aW9uKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbmZpZ3VyYXRpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBkaXNrLWJhY2tlZCByZXRyeSBjYWNoaW5nIHRvIGNhY2hlIGV2ZW50cyB3aGVuIGNsaWVudCBpcyBvZmZsaW5lIChlbmFibGVkIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSBhcHBsaWVzIHRvIHRoZSBkZWZhdWx0IGNsaWVudC4gRGlzay1iYWNrZWQgcmV0cnkgY2FjaGluZyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IGZvciBhZGRpdGlvbmFsIGNsaWVudHMuXHJcbiAgICAgKiBGb3IgZW5hYmxlIGZvciBhZGRpdGlvbmFsIGNsaWVudHMsIHVzZSBjbGllbnQuY2hhbm5lbC5zZXRVc2VEaXNrUmV0cnlDYWNoaW5nKHRydWUpLlxyXG4gICAgICogVGhlc2UgY2FjaGVkIGV2ZW50cyBhcmUgc3RvcmVkIGluIHlvdXIgc3lzdGVtIG9yIHVzZXIncyB0ZW1wb3JhcnkgZGlyZWN0b3J5IGFuZCBhY2Nlc3MgcmVzdHJpY3RlZCB0byB5b3VyIHVzZXIgd2hlbiBwb3NzaWJsZS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlIGV2ZW50cyB0aGF0IG9jY3VyZWQgd2hpbGUgY2xpZW50IGlzIG9mZmxpbmUgd2lsbCBiZSBjYWNoZWQgb24gZGlza1xyXG4gICAgICogQHBhcmFtIHJlc2VuZEludGVydmFsIFRoZSB3YWl0IGludGVydmFsIGZvciByZXNlbmRpbmcgY2FjaGVkIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBtYXhCeXRlc09uRGlzayBUaGUgbWF4aW11bSBzaXplIChpbiBieXRlcykgdGhhdCB0aGUgY3JlYXRlZCB0ZW1wb3JhcnkgZGlyZWN0b3J5IGZvciBjYWNoZSBldmVudHMgY2FuIGdyb3cgdG8sIGJlZm9yZSBjYWNoaW5nIGlzIGRpc2FibGVkLlxyXG4gICAgICogQHJldHVybnMge0NvbmZpZ3VyYXRpb259IHRoaXMgY2xhc3NcclxuICAgICAqL1xyXG4gICAgQ29uZmlndXJhdGlvbi5zZXRVc2VEaXNrUmV0cnlDYWNoaW5nID0gZnVuY3Rpb24gKHZhbHVlLCByZXNlbmRJbnRlcnZhbCwgbWF4Qnl0ZXNPbkRpc2spIHtcclxuICAgICAgICBfaXNEaXNrUmV0cnkgPSB2YWx1ZTtcclxuICAgICAgICBfZGlza1JldHJ5SW50ZXJ2YWwgPSByZXNlbmRJbnRlcnZhbDtcclxuICAgICAgICBfZGlza1JldHJ5TWF4Qnl0ZXMgPSBtYXhCeXRlc09uRGlzaztcclxuICAgICAgICBpZiAoZXhwb3J0cy5kZWZhdWx0Q2xpZW50ICYmIGV4cG9ydHMuZGVmYXVsdENsaWVudC5jaGFubmVsKSB7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdENsaWVudC5jaGFubmVsLnNldFVzZURpc2tSZXRyeUNhY2hpbmcodmFsdWUsIHJlc2VuZEludGVydmFsLCBtYXhCeXRlc09uRGlzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBkZWJ1ZyBhbmQgd2FybmluZyBsb2dnaW5nIGZvciBBcHBJbnNpZ2h0cyBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0gZW5hYmxlRGVidWdMb2dnaW5nIGlmIHRydWUsIGVuYWJsZXMgZGVidWcgbG9nZ2luZ1xyXG4gICAgICogQHBhcmFtIGVuYWJsZVdhcm5pbmdMb2dnaW5nIGlmIHRydWUsIGVuYWJsZXMgd2FybmluZyBsb2dnaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uZmlndXJhdGlvbn0gdGhpcyBjbGFzc1xyXG4gICAgICovXHJcbiAgICBDb25maWd1cmF0aW9uLnNldEludGVybmFsTG9nZ2luZyA9IGZ1bmN0aW9uIChlbmFibGVEZWJ1Z0xvZ2dpbmcsIGVuYWJsZVdhcm5pbmdMb2dnaW5nKSB7XHJcbiAgICAgICAgaWYgKGVuYWJsZURlYnVnTG9nZ2luZyA9PT0gdm9pZCAwKSB7IGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGVuYWJsZVdhcm5pbmdMb2dnaW5nID09PSB2b2lkIDApIHsgZW5hYmxlV2FybmluZ0xvZ2dpbmcgPSB0cnVlOyB9XHJcbiAgICAgICAgTG9nZ2luZy5lbmFibGVEZWJ1ZyA9IGVuYWJsZURlYnVnTG9nZ2luZztcclxuICAgICAgICBMb2dnaW5nLmRpc2FibGVXYXJuaW5ncyA9ICFlbmFibGVXYXJuaW5nTG9nZ2luZztcclxuICAgICAgICByZXR1cm4gQ29uZmlndXJhdGlvbjtcclxuICAgIH07XHJcbiAgICAvLyBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBBcHBsaWNhdGlvbkluc2lnaHRzLnN0YXJ0XHJcbiAgICBDb25maWd1cmF0aW9uLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICByZXR1cm4gQ29uZmlndXJhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbjtcclxuLyoqXHJcbiAqIERpc3Bvc2VzIHRoZSBkZWZhdWx0IGNsaWVudCBhbmQgYWxsIHRoZSBhdXRvIGNvbGxlY3RvcnMgc28gdGhleSBjYW4gYmUgcmVpbml0aWFsaXplZCB3aXRoIGRpZmZlcmVudCBjb25maWd1cmF0aW9uXHJcbiovXHJcbmZ1bmN0aW9uIGRpc3Bvc2UoKSB7XHJcbiAgICBleHBvcnRzLmRlZmF1bHRDbGllbnQgPSBudWxsO1xyXG4gICAgX2lzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgaWYgKF9jb25zb2xlKSB7XHJcbiAgICAgICAgX2NvbnNvbGUuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKF9leGNlcHRpb25zKSB7XHJcbiAgICAgICAgX2V4Y2VwdGlvbnMuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKF9wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIF9wZXJmb3JtYW5jZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoX3NlcnZlclJlcXVlc3RzKSB7XHJcbiAgICAgICAgX3NlcnZlclJlcXVlc3RzLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIGlmIChfY2xpZW50UmVxdWVzdHMpIHtcclxuICAgICAgICBfY2xpZW50UmVxdWVzdHMuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGlzcG9zZSA9IGRpc3Bvc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGxpY2F0aW9uaW5zaWdodHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/applicationinsights/out/applicationinsights.js\n");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFsYW5jZWQtbWF0Y2gvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2JhbGFuY2VkLW1hdGNoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gYmFsYW5jZWQ7XG5mdW5jdGlvbiBiYWxhbmNlZChhLCBiLCBzdHIpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIGEgPSBtYXliZU1hdGNoKGEsIHN0cik7XG4gIGlmIChiIGluc3RhbmNlb2YgUmVnRXhwKSBiID0gbWF5YmVNYXRjaChiLCBzdHIpO1xuXG4gIHZhciByID0gcmFuZ2UoYSwgYiwgc3RyKTtcblxuICByZXR1cm4gciAmJiB7XG4gICAgc3RhcnQ6IHJbMF0sXG4gICAgZW5kOiByWzFdLFxuICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgIGJvZHk6IHN0ci5zbGljZShyWzBdICsgYS5sZW5ndGgsIHJbMV0pLFxuICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgYi5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1heWJlTWF0Y2gocmVnLCBzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cblxuYmFsYW5jZWQucmFuZ2UgPSByYW5nZTtcbmZ1bmN0aW9uIHJhbmdlKGEsIGIsIHN0cikge1xuICB2YXIgYmVncywgYmVnLCBsZWZ0LCByaWdodCwgcmVzdWx0O1xuICB2YXIgYWkgPSBzdHIuaW5kZXhPZihhKTtcbiAgdmFyIGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgdmFyIGkgPSBhaTtcblxuICBpZiAoYWkgPj0gMCAmJiBiaSA+IDApIHtcbiAgICBiZWdzID0gW107XG4gICAgbGVmdCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA+PSAwICYmICFyZXN1bHQpIHtcbiAgICAgIGlmIChpID09IGFpKSB7XG4gICAgICAgIGJlZ3MucHVzaChpKTtcbiAgICAgICAgYWkgPSBzdHIuaW5kZXhPZihhLCBpICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGJlZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gWyBiZWdzLnBvcCgpLCBiaSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgaWYgKGJlZyA8IGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgIHJpZ2h0ID0gYmk7XG4gICAgICAgIH1cblxuICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgIH1cblxuICAgICAgaSA9IGFpIDwgYmkgJiYgYWkgPj0gMCA/IGFpIDogYmk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBbIGxlZnQsIHJpZ2h0IF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/balanced-match/index.js\n");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbmNhdE1hcCA9IHJlcXVpcmUoJ2NvbmNhdC1tYXAnKTtcbnZhciBiYWxhbmNlZCA9IHJlcXVpcmUoJ2JhbGFuY2VkLW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kVG9wO1xuXG52YXIgZXNjU2xhc2ggPSAnXFwwU0xBU0gnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjT3BlbiA9ICdcXDBPUEVOJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0Nsb3NlID0gJ1xcMENMT1NFJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0NvbW1hID0gJ1xcMENPTU1BJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY1BlcmlvZCA9ICdcXDBQRVJJT0QnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG5cbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKSA9PSBzdHJcbiAgICA/IHBhcnNlSW50KHN0ciwgMTApXG4gICAgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcXFxcXCcpLmpvaW4oZXNjU2xhc2gpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx7Jykuam9pbihlc2NPcGVuKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcfScpLmpvaW4oZXNjQ2xvc2UpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwsJykuam9pbihlc2NDb21tYSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXC4nKS5qb2luKGVzY1BlcmlvZCk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KGVzY1NsYXNoKS5qb2luKCdcXFxcJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NPcGVuKS5qb2luKCd7JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDbG9zZSkuam9pbignfScpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ29tbWEpLmpvaW4oJywnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY1BlcmlvZCkuam9pbignLicpO1xufVxuXG5cbi8vIEJhc2ljYWxseSBqdXN0IHN0ci5zcGxpdChcIixcIiksIGJ1dCBoYW5kbGluZyBjYXNlc1xuLy8gd2hlcmUgd2UgaGF2ZSBuZXN0ZWQgYnJhY2VkIHNlY3Rpb25zLCB3aGljaCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgYXMgaW5kaXZpZHVhbCBtZW1iZXJzLCBsaWtlIHthLHtiLGN9LGR9XG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbJyddO1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuXG4gIGlmICghbSlcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG5cbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgYm9keSA9IG0uYm9keTtcbiAgdmFyIHBvc3QgPSBtLnBvc3Q7XG4gIHZhciBwID0gcHJlLnNwbGl0KCcsJyk7XG5cbiAgcFtwLmxlbmd0aC0xXSArPSAneycgKyBib2R5ICsgJ30nO1xuICB2YXIgcG9zdFBhcnRzID0gcGFyc2VDb21tYVBhcnRzKHBvc3QpO1xuICBpZiAocG9zdC5sZW5ndGgpIHtcbiAgICBwW3AubGVuZ3RoLTFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgIHAucHVzaC5hcHBseShwLCBwb3N0UGFydHMpO1xuICB9XG5cbiAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb3Aoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbXTtcblxuICAvLyBJIGRvbid0IGtub3cgd2h5IEJhc2ggNC4zIGRvZXMgdGhpcywgYnV0IGl0IGRvZXMuXG4gIC8vIEFueXRoaW5nIHN0YXJ0aW5nIHdpdGgge30gd2lsbCBoYXZlIHRoZSBmaXJzdCB0d28gYnl0ZXMgcHJlc2VydmVkXG4gIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgLy8gYnV0IGF7fSxifWMgd2lsbCBiZSBleHBhbmRlZCB0byBbYX1jLGFiY10uXG4gIC8vIE9uZSBjb3VsZCBhcmd1ZSB0aGF0IHRoaXMgaXMgYSBidWcgaW4gQmFzaCwgYnV0IHNpbmNlIHRoZSBnb2FsIG9mXG4gIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJ3t9Jykge1xuICAgIHN0ciA9ICdcXFxce1xcXFx9JyArIHN0ci5zdWJzdHIoMik7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kKGVzY2FwZUJyYWNlcyhzdHIpLCB0cnVlKS5tYXAodW5lc2NhcGVCcmFjZXMpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShlKSB7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBlbWJyYWNlKHN0cikge1xuICByZXR1cm4gJ3snICsgc3RyICsgJ30nO1xufVxuZnVuY3Rpb24gaXNQYWRkZWQoZWwpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cblxuZnVuY3Rpb24gbHRlKGksIHkpIHtcbiAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gIHJldHVybiBpID49IHk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdHIsIGlzVG9wKSB7XG4gIHZhciBleHBhbnNpb25zID0gW107XG5cbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgaWYgKCFtIHx8IC9cXCQkLy50ZXN0KG0ucHJlKSkgcmV0dXJuIFtzdHJdO1xuXG4gIHZhciBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gIHZhciBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgLy8ge2F9LGJ9XG4gICAgaWYgKG0ucG9zdC5tYXRjaCgvLC4qXFx9LykpIHtcbiAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICByZXR1cm4gZXhwYW5kKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyXTtcbiAgfVxuXG4gIHZhciBuO1xuICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgIG4gPSBtLmJvZHkuc3BsaXQoL1xcLlxcLi8pO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICAgICAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgICAgICAgIDogWycnXTtcbiAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbS5wcmUgKyBuWzBdICsgcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gIC8vIHdpdGggYSBzaW5nbGUgZW50cnkuXG5cbiAgLy8gbm8gbmVlZCB0byBleHBhbmQgcHJlLCBzaW5jZSBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGZyZWUgb2YgYnJhY2Utc2V0c1xuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgOiBbJyddO1xuXG4gIHZhciBOO1xuXG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgdmFyIHggPSBudW1lcmljKG5bMF0pO1xuICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgdmFyIGluY3IgPSBuLmxlbmd0aCA9PSAzXG4gICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICA6IDE7XG4gICAgdmFyIHRlc3QgPSBsdGU7XG4gICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgaW5jciAqPSAtMTtcbiAgICAgIHRlc3QgPSBndGU7XG4gICAgfVxuICAgIHZhciBwYWQgPSBuLnNvbWUoaXNQYWRkZWQpO1xuXG4gICAgTiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKVxuICAgICAgICAgIGMgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBTdHJpbmcoaSk7XG4gICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgaWYgKG5lZWQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICBjID0gJy0nICsgeiArIGMuc2xpY2UoMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE4ucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTiA9IGNvbmNhdE1hcChuLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZXhwYW5kKGVsLCBmYWxzZSkgfSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUgKyBOW2pdICsgcG9zdFtrXTtcbiAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "./node_modules/buffer-crc32/index.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-crc32/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\nvar CRC_TABLE = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n  0x2d02ef8d\n];\n\nif (typeof Int32Array !== 'undefined') {\n  CRC_TABLE = new Int32Array(CRC_TABLE);\n}\n\nfunction ensureBuffer(input) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  var hasNewBufferAPI =\n      typeof Buffer.alloc === \"function\" &&\n      typeof Buffer.from === \"function\";\n\n  if (typeof input === \"number\") {\n    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);\n  }\n  else if (typeof input === \"string\") {\n    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);\n  }\n  else {\n    throw new Error(\"input must be buffer, number, or string, received \" +\n                    typeof input);\n  }\n}\n\nfunction bufferizeInt(num) {\n  var tmp = ensureBuffer(4);\n  tmp.writeInt32BE(num, 0);\n  return tmp;\n}\n\nfunction _crc32(buf, previous) {\n  buf = ensureBuffer(buf);\n  if (Buffer.isBuffer(previous)) {\n    previous = previous.readUInt32BE(0);\n  }\n  var crc = ~~previous ^ -1;\n  for (var n = 0; n < buf.length; n++) {\n    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);\n  }\n  return (crc ^ -1);\n}\n\nfunction crc32() {\n  return bufferizeInt(_crc32.apply(null, arguments));\n}\ncrc32.signed = function () {\n  return _crc32.apply(null, arguments);\n};\ncrc32.unsigned = function () {\n  return _crc32.apply(null, arguments) >>> 0;\n};\n\nmodule.exports = crc32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyLWNyYzMyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9idWZmZXItY3JjMzIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIENSQ19UQUJMRSA9IFtcbiAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhlZTBlNjEyYywgMHg5OTA5NTFiYSwgMHgwNzZkYzQxOSxcbiAgMHg3MDZhZjQ4ZiwgMHhlOTYzYTUzNSwgMHg5ZTY0OTVhMywgMHgwZWRiODgzMiwgMHg3OWRjYjhhNCxcbiAgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCwgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNyxcbiAgMHg5MGJmMWQ5MSwgMHgxZGI3MTA2NCwgMHg2YWIwMjBmMiwgMHhmM2I5NzE0OCwgMHg4NGJlNDFkZSxcbiAgMHgxYWRhZDQ3ZCwgMHg2ZGRkZTRlYiwgMHhmNGQ0YjU1MSwgMHg4M2QzODVjNywgMHgxMzZjOTg1NixcbiAgMHg2NDZiYThjMCwgMHhmZDYyZjk3YSwgMHg4YTY1YzllYywgMHgxNDAxNWM0ZiwgMHg2MzA2NmNkOSxcbiAgMHhmYTBmM2Q2MywgMHg4ZDA4MGRmNSwgMHgzYjZlMjBjOCwgMHg0YzY5MTA1ZSwgMHhkNTYwNDFlNCxcbiAgMHhhMjY3NzE3MiwgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YixcbiAgMHgzNWI1YThmYSwgMHg0MmIyOTg2YywgMHhkYmJiYzlkNiwgMHhhY2JjZjk0MCwgMHgzMmQ4NmNlMyxcbiAgMHg0NWRmNWM3NSwgMHhkY2Q2MGRjZiwgMHhhYmQxM2Q1OSwgMHgyNmQ5MzBhYywgMHg1MWRlMDAzYSxcbiAgMHhjOGQ3NTE4MCwgMHhiZmQwNjExNiwgMHgyMWI0ZjRiNSwgMHg1NmIzYzQyMywgMHhjZmJhOTU5OSxcbiAgMHhiOGJkYTUwZiwgMHgyODAyYjg5ZSwgMHg1ZjA1ODgwOCwgMHhjNjBjZDliMiwgMHhiMTBiZTkyNCxcbiAgMHgyZjZmN2M4NywgMHg1ODY4NGMxMSwgMHhjMTYxMWRhYiwgMHhiNjY2MmQzZCwgMHg3NmRjNDE5MCxcbiAgMHgwMWRiNzEwNiwgMHg5OGQyMjBiYywgMHhlZmQ1MTAyYSwgMHg3MWIxODU4OSwgMHgwNmI2YjUxZixcbiAgMHg5ZmJmZTRhNSwgMHhlOGI4ZDQzMywgMHg3ODA3YzlhMiwgMHgwZjAwZjkzNCwgMHg5NjA5YTg4ZSxcbiAgMHhlMTBlOTgxOCwgMHg3ZjZhMGRiYiwgMHgwODZkM2QyZCwgMHg5MTY0NmM5NywgMHhlNjYzNWMwMSxcbiAgMHg2YjZiNTFmNCwgMHgxYzZjNjE2MiwgMHg4NTY1MzBkOCwgMHhmMjYyMDA0ZSwgMHg2YzA2OTVlZCxcbiAgMHgxYjAxYTU3YiwgMHg4MjA4ZjRjMSwgMHhmNTBmYzQ1NywgMHg2NWIwZDljNiwgMHgxMmI3ZTk1MCxcbiAgMHg4YmJlYjhlYSwgMHhmY2I5ODg3YywgMHg2MmRkMWRkZiwgMHgxNWRhMmQ0OSwgMHg4Y2QzN2NmMyxcbiAgMHhmYmQ0NGM2NSwgMHg0ZGIyNjE1OCwgMHgzYWI1NTFjZSwgMHhhM2JjMDA3NCwgMHhkNGJiMzBlMixcbiAgMHg0YWRmYTU0MSwgMHgzZGQ4OTVkNywgMHhhNGQxYzQ2ZCwgMHhkM2Q2ZjRmYiwgMHg0MzY5ZTk2YSxcbiAgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCwgMHg0NDA0MmQ3MywgMHgzMzAzMWRlNSxcbiAgMHhhYTBhNGM1ZiwgMHhkZDBkN2NjOSwgMHg1MDA1NzEzYywgMHgyNzAyNDFhYSwgMHhiZTBiMTAxMCxcbiAgMHhjOTBjMjA4NiwgMHg1NzY4YjUyNSwgMHgyMDZmODViMywgMHhiOTY2ZDQwOSwgMHhjZTYxZTQ5ZixcbiAgMHg1ZWRlZjkwZSwgMHgyOWQ5Yzk5OCwgMHhiMGQwOTgyMiwgMHhjN2Q3YThiNCwgMHg1OWIzM2QxNyxcbiAgMHgyZWI0MGQ4MSwgMHhiN2JkNWMzYiwgMHhjMGJhNmNhZCwgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNixcbiAgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSwgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSxcbiAgMHg3M2RjMTY4MywgMHhlMzYzMGIxMiwgMHg5NDY0M2I4NCwgMHgwZDZkNmEzZSwgMHg3YTZhNWFhOCxcbiAgMHhlNDBlY2YwYiwgMHg5MzA5ZmY5ZCwgMHgwYTAwYWUyNywgMHg3ZDA3OWViMSwgMHhmMDBmOTM0NCxcbiAgMHg4NzA4YTNkMiwgMHgxZTAxZjI2OCwgMHg2OTA2YzJmZSwgMHhmNzYyNTc1ZCwgMHg4MDY1NjdjYixcbiAgMHgxOTZjMzY3MSwgMHg2ZTZiMDZlNywgMHhmZWQ0MWI3NiwgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSxcbiAgMHg2N2RkNGFjYywgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSxcbiAgMHhkNmQ2YTNlOCwgMHhhMWQxOTM3ZSwgMHgzOGQ4YzJjNCwgMHg0ZmRmZjI1MiwgMHhkMWJiNjdmMSxcbiAgMHhhNmJjNTc2NywgMHgzZmI1MDZkZCwgMHg0OGIyMzY0YiwgMHhkODBkMmJkYSwgMHhhZjBhMWI0YyxcbiAgMHgzNjAzNGFmNiwgMHg0MTA0N2E2MCwgMHhkZjYwZWZjMywgMHhhODY3ZGY1NSwgMHgzMTZlOGVlZixcbiAgMHg0NjY5YmU3OSwgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNixcbiAgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZiwgMHhjNWJhM2JiZSxcbiAgMHhiMmJkMGIyOCwgMHgyYmI0NWE5MiwgMHg1Y2IzNmEwNCwgMHhjMmQ3ZmZhNywgMHhiNWQwY2YzMSxcbiAgMHgyY2Q5OWU4YiwgMHg1YmRlYWUxZCwgMHg5YjY0YzJiMCwgMHhlYzYzZjIyNiwgMHg3NTZhYTM5YyxcbiAgMHgwMjZkOTMwYSwgMHg5YzA5MDZhOSwgMHhlYjBlMzYzZiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMyxcbiAgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCwgMHg5MmQyOGU5YixcbiAgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNywgMHgwYmRiZGYyMSwgMHg4NmQzZDJkNCwgMHhmMWQ0ZTI0MixcbiAgMHg2OGRkYjNmOCwgMHgxZmRhODM2ZSwgMHg4MWJlMTZjZCwgMHhmNmI5MjY1YiwgMHg2ZmIwNzdlMSxcbiAgMHgxOGI3NDc3NywgMHg4ODA4NWFlNiwgMHhmZjBmNmE3MCwgMHg2NjA2M2JjYSwgMHgxMTAxMGI1YyxcbiAgMHg4ZjY1OWVmZiwgMHhmODYyYWU2OSwgMHg2MTZiZmZkMywgMHgxNjZjY2Y0NSwgMHhhMDBhZTI3OCxcbiAgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMiwgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNyxcbiAgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYiwgMHhhZWQxNmE0YSwgMHhkOWQ2NWFkYywgMHg0MGRmMGI2NixcbiAgMHgzN2Q4M2JmMCwgMHhhOWJjYWU1MywgMHhkZWJiOWVjNSwgMHg0N2IyY2Y3ZiwgMHgzMGI1ZmZlOSxcbiAgMHhiZGJkZjIxYywgMHhjYWJhYzI4YSwgMHg1M2IzOTMzMCwgMHgyNGI0YTNhNiwgMHhiYWQwMzYwNSxcbiAgMHhjZGQ3MDY5MywgMHg1NGRlNTcyOSwgMHgyM2Q5NjdiZiwgMHhiMzY2N2EyZSwgMHhjNDYxNGFiOCxcbiAgMHg1ZDY4MWIwMiwgMHgyYTZmMmI5NCwgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYixcbiAgMHgyZDAyZWY4ZFxuXTtcblxuaWYgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICBDUkNfVEFCTEUgPSBuZXcgSW50MzJBcnJheShDUkNfVEFCTEUpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVCdWZmZXIoaW5wdXQpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICB2YXIgaGFzTmV3QnVmZmVyQVBJID1cbiAgICAgIHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5mcm9tID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBoYXNOZXdCdWZmZXJBUEkgPyBCdWZmZXIuYWxsb2MoaW5wdXQpIDogbmV3IEJ1ZmZlcihpbnB1dCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGhhc05ld0J1ZmZlckFQSSA/IEJ1ZmZlci5mcm9tKGlucHV0KSA6IG5ldyBCdWZmZXIoaW5wdXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IG11c3QgYmUgYnVmZmVyLCBudW1iZXIsIG9yIHN0cmluZywgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5wdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlcml6ZUludChudW0pIHtcbiAgdmFyIHRtcCA9IGVuc3VyZUJ1ZmZlcig0KTtcbiAgdG1wLndyaXRlSW50MzJCRShudW0sIDApO1xuICByZXR1cm4gdG1wO1xufVxuXG5mdW5jdGlvbiBfY3JjMzIoYnVmLCBwcmV2aW91cykge1xuICBidWYgPSBlbnN1cmVCdWZmZXIoYnVmKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwcmV2aW91cykpIHtcbiAgICBwcmV2aW91cyA9IHByZXZpb3VzLnJlYWRVSW50MzJCRSgwKTtcbiAgfVxuICB2YXIgY3JjID0gfn5wcmV2aW91cyBeIC0xO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IGJ1Zi5sZW5ndGg7IG4rKykge1xuICAgIGNyYyA9IENSQ19UQUJMRVsoY3JjIF4gYnVmW25dKSAmIDB4ZmZdIF4gKGNyYyA+Pj4gOCk7XG4gIH1cbiAgcmV0dXJuIChjcmMgXiAtMSk7XG59XG5cbmZ1bmN0aW9uIGNyYzMyKCkge1xuICByZXR1cm4gYnVmZmVyaXplSW50KF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbn1cbmNyYzMyLnNpZ25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmMzMi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbmNyYzMyLnVuc2lnbmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyYzMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgPj4+IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/buffer-crc32/index.js\n");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uY2F0LW1hcC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvY29uY2F0LW1hcC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGZuKHhzW2ldLCBpKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoeCkpIHJlcy5wdXNoLmFwcGx5KHJlcywgeCk7XG4gICAgICAgIGVsc2UgcmVzLnB1c2goeCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/concat-map/index.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Connection$":
/*!****************************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src sync ^.*\/lib\/Connection$ ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Connection$";

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Pool$":
/*!**********************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src sync ^.*\/lib\/Pool$ ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\/lib\\/Pool$";

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js":
/*!***************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar bunyanPatchFunction = function (originalBunyan) {\r\n    var originalEmit = originalBunyan.prototype._emit;\r\n    originalBunyan.prototype._emit = function (rec, noemit) {\r\n        var ret = originalEmit.apply(this, arguments);\r\n        if (!noemit) {\r\n            var str = ret;\r\n            if (!str) {\r\n                str = originalEmit.call(this, rec, true);\r\n            }\r\n            diagnostic_channel_1.channel.publish(\"bunyan\", { level: rec.level, result: str });\r\n        }\r\n        return ret;\r\n    };\r\n    return originalBunyan;\r\n};\r\nexports.bunyan = {\r\n    versionSpecifier: \">= 1.0.0 < 2.0.0\",\r\n    patch: bunyanPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"bunyan\", exports.bunyan);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=bunyan.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvYnVueWFuLnB1Yi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvYnVueWFuLnB1Yi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXHJcbnZhciBkaWFnbm9zdGljX2NoYW5uZWxfMSA9IHJlcXVpcmUoXCJkaWFnbm9zdGljLWNoYW5uZWxcIik7XHJcbnZhciBidW55YW5QYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKG9yaWdpbmFsQnVueWFuKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxFbWl0ID0gb3JpZ2luYWxCdW55YW4ucHJvdG90eXBlLl9lbWl0O1xyXG4gICAgb3JpZ2luYWxCdW55YW4ucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHJlYywgbm9lbWl0KSB7XHJcbiAgICAgICAgdmFyIHJldCA9IG9yaWdpbmFsRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICghbm9lbWl0KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSByZXQ7XHJcbiAgICAgICAgICAgIGlmICghc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBvcmlnaW5hbEVtaXQuY2FsbCh0aGlzLCByZWMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwucHVibGlzaChcImJ1bnlhblwiLCB7IGxldmVsOiByZWMubGV2ZWwsIHJlc3VsdDogc3RyIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBvcmlnaW5hbEJ1bnlhbjtcclxufTtcclxuZXhwb3J0cy5idW55YW4gPSB7XHJcbiAgICB2ZXJzaW9uU3BlY2lmaWVyOiBcIj49IDEuMC4wIDwgMi4wLjBcIixcclxuICAgIHBhdGNoOiBidW55YW5QYXRjaEZ1bmN0aW9uLFxyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnJlZ2lzdGVyTW9ua2V5UGF0Y2goXCJidW55YW5cIiwgZXhwb3J0cy5idW55YW4pO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW55YW4ucHViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/console.pub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/console.pub.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nvar consolePatchFunction = function (originalConsole) {\r\n    var aiLoggingOutStream = new stream_1.Writable();\r\n    var aiLoggingErrStream = new stream_1.Writable();\r\n    // Default console is roughly equivalent to `new Console(process.stdout, process.stderr)`\r\n    // We create a version which publishes to the channel and also to stdout/stderr\r\n    aiLoggingOutStream.write = function (chunk) {\r\n        if (!chunk) {\r\n            return true;\r\n        }\r\n        var message = chunk.toString();\r\n        diagnostic_channel_1.channel.publish(\"console\", { message: message });\r\n        return true;\r\n    };\r\n    aiLoggingErrStream.write = function (chunk) {\r\n        if (!chunk) {\r\n            return true;\r\n        }\r\n        var message = chunk.toString();\r\n        diagnostic_channel_1.channel.publish(\"console\", { message: message, stderr: true });\r\n        return true;\r\n    };\r\n    var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);\r\n    var consoleMethods = [\"log\", \"info\", \"warn\", \"error\", \"dir\", \"time\", \"timeEnd\", \"trace\", \"assert\"];\r\n    var _loop_1 = function (method) {\r\n        var originalMethod = originalConsole[method];\r\n        if (originalMethod) {\r\n            originalConsole[method] = function () {\r\n                if (aiLoggingConsole[method]) {\r\n                    try {\r\n                        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);\r\n                    }\r\n                    catch (e) {\r\n                        // Ignore errors; allow the original method to throw if necessary\r\n                    }\r\n                }\r\n                return originalMethod.apply(originalConsole, arguments);\r\n            };\r\n        }\r\n    };\r\n    for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {\r\n        var method = consoleMethods_1[_i];\r\n        _loop_1(method);\r\n    }\r\n    return originalConsole;\r\n};\r\nexports.console = {\r\n    versionSpecifier: \">= 4.0.0\",\r\n    patch: consolePatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"console\", exports.console);\r\n    // Force patching of console\r\n    /* tslint:disable-next-line:no-var-requires */\r\n    __webpack_require__(/*! console */ \"console\");\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=console.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvY29uc29sZS5wdWIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzL2Rpc3Qvc3JjL2NvbnNvbGUucHViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cclxudmFyIGRpYWdub3N0aWNfY2hhbm5lbF8xID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbFwiKTtcclxudmFyIHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcclxudmFyIGNvbnNvbGVQYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKG9yaWdpbmFsQ29uc29sZSkge1xyXG4gICAgdmFyIGFpTG9nZ2luZ091dFN0cmVhbSA9IG5ldyBzdHJlYW1fMS5Xcml0YWJsZSgpO1xyXG4gICAgdmFyIGFpTG9nZ2luZ0VyclN0cmVhbSA9IG5ldyBzdHJlYW1fMS5Xcml0YWJsZSgpO1xyXG4gICAgLy8gRGVmYXVsdCBjb25zb2xlIGlzIHJvdWdobHkgZXF1aXZhbGVudCB0byBgbmV3IENvbnNvbGUocHJvY2Vzcy5zdGRvdXQsIHByb2Nlc3Muc3RkZXJyKWBcclxuICAgIC8vIFdlIGNyZWF0ZSBhIHZlcnNpb24gd2hpY2ggcHVibGlzaGVzIHRvIHRoZSBjaGFubmVsIGFuZCBhbHNvIHRvIHN0ZG91dC9zdGRlcnJcclxuICAgIGFpTG9nZ2luZ091dFN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xyXG4gICAgICAgIGlmICghY2h1bmspIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZXNzYWdlID0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnB1Ymxpc2goXCJjb25zb2xlXCIsIHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBhaUxvZ2dpbmdFcnJTdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcclxuICAgICAgICBpZiAoIWNodW5rKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWVzc2FnZSA9IGNodW5rLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5wdWJsaXNoKFwiY29uc29sZVwiLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIHN0ZGVycjogdHJ1ZSB9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICB2YXIgYWlMb2dnaW5nQ29uc29sZSA9IG5ldyBvcmlnaW5hbENvbnNvbGUuQ29uc29sZShhaUxvZ2dpbmdPdXRTdHJlYW0sIGFpTG9nZ2luZ0VyclN0cmVhbSk7XHJcbiAgICB2YXIgY29uc29sZU1ldGhvZHMgPSBbXCJsb2dcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiZGlyXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIiwgXCJ0cmFjZVwiLCBcImFzc2VydFwiXTtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9yaWdpbmFsQ29uc29sZVttZXRob2RdO1xyXG4gICAgICAgIGlmIChvcmlnaW5hbE1ldGhvZCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhaUxvZ2dpbmdDb25zb2xlW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhaUxvZ2dpbmdDb25zb2xlW21ldGhvZF0uYXBwbHkoYWlMb2dnaW5nQ29uc29sZSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yczsgYWxsb3cgdGhlIG9yaWdpbmFsIG1ldGhvZCB0byB0aHJvdyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkob3JpZ2luYWxDb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnNvbGVNZXRob2RzXzEgPSBjb25zb2xlTWV0aG9kczsgX2kgPCBjb25zb2xlTWV0aG9kc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBjb25zb2xlTWV0aG9kc18xW19pXTtcclxuICAgICAgICBfbG9vcF8xKG1ldGhvZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ2luYWxDb25zb2xlO1xyXG59O1xyXG5leHBvcnRzLmNvbnNvbGUgPSB7XHJcbiAgICB2ZXJzaW9uU3BlY2lmaWVyOiBcIj49IDQuMC4wXCIsXHJcbiAgICBwYXRjaDogY29uc29sZVBhdGNoRnVuY3Rpb24sXHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwucmVnaXN0ZXJNb25rZXlQYXRjaChcImNvbnNvbGVcIiwgZXhwb3J0cy5jb25zb2xlKTtcclxuICAgIC8vIEZvcmNlIHBhdGNoaW5nIG9mIGNvbnNvbGVcclxuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby12YXItcmVxdWlyZXMgKi9cclxuICAgIHJlcXVpcmUoXCJjb25zb2xlXCIpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zb2xlLnB1Yi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/console.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bunyan = __webpack_require__(/*! ./bunyan.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js\");\r\nexports.bunyan = bunyan;\r\nvar consolePub = __webpack_require__(/*! ./console.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/console.pub.js\");\r\nexports.console = consolePub;\r\nvar mongodbCore = __webpack_require__(/*! ./mongodb-core.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js\");\r\nexports.mongodbCore = mongodbCore;\r\nvar mongodb = __webpack_require__(/*! ./mongodb.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js\");\r\nexports.mongodb = mongodb;\r\nvar mysql = __webpack_require__(/*! ./mysql.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js\");\r\nexports.mysql = mysql;\r\nvar pgPool = __webpack_require__(/*! ./pg-pool.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js\");\r\nexports.pgPool = pgPool;\r\nvar pg = __webpack_require__(/*! ./pg.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js\");\r\nexports.pg = pg;\r\nvar redis = __webpack_require__(/*! ./redis.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js\");\r\nexports.redis = redis;\r\nvar winston = __webpack_require__(/*! ./winston.pub */ \"./node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js\");\r\nexports.winston = winston;\r\nfunction enable() {\r\n    bunyan.enable();\r\n    consolePub.enable();\r\n    mongodbCore.enable();\r\n    mongodb.enable();\r\n    mysql.enable();\r\n    pg.enable();\r\n    pgPool.enable();\r\n    redis.enable();\r\n    winston.enable();\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzL2Rpc3Qvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGJ1bnlhbiA9IHJlcXVpcmUoXCIuL2J1bnlhbi5wdWJcIik7XHJcbmV4cG9ydHMuYnVueWFuID0gYnVueWFuO1xyXG52YXIgY29uc29sZVB1YiA9IHJlcXVpcmUoXCIuL2NvbnNvbGUucHViXCIpO1xyXG5leHBvcnRzLmNvbnNvbGUgPSBjb25zb2xlUHViO1xyXG52YXIgbW9uZ29kYkNvcmUgPSByZXF1aXJlKFwiLi9tb25nb2RiLWNvcmUucHViXCIpO1xyXG5leHBvcnRzLm1vbmdvZGJDb3JlID0gbW9uZ29kYkNvcmU7XHJcbnZhciBtb25nb2RiID0gcmVxdWlyZShcIi4vbW9uZ29kYi5wdWJcIik7XHJcbmV4cG9ydHMubW9uZ29kYiA9IG1vbmdvZGI7XHJcbnZhciBteXNxbCA9IHJlcXVpcmUoXCIuL215c3FsLnB1YlwiKTtcclxuZXhwb3J0cy5teXNxbCA9IG15c3FsO1xyXG52YXIgcGdQb29sID0gcmVxdWlyZShcIi4vcGctcG9vbC5wdWJcIik7XHJcbmV4cG9ydHMucGdQb29sID0gcGdQb29sO1xyXG52YXIgcGcgPSByZXF1aXJlKFwiLi9wZy5wdWJcIik7XHJcbmV4cG9ydHMucGcgPSBwZztcclxudmFyIHJlZGlzID0gcmVxdWlyZShcIi4vcmVkaXMucHViXCIpO1xyXG5leHBvcnRzLnJlZGlzID0gcmVkaXM7XHJcbnZhciB3aW5zdG9uID0gcmVxdWlyZShcIi4vd2luc3Rvbi5wdWJcIik7XHJcbmV4cG9ydHMud2luc3RvbiA9IHdpbnN0b247XHJcbmZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgIGJ1bnlhbi5lbmFibGUoKTtcclxuICAgIGNvbnNvbGVQdWIuZW5hYmxlKCk7XHJcbiAgICBtb25nb2RiQ29yZS5lbmFibGUoKTtcclxuICAgIG1vbmdvZGIuZW5hYmxlKCk7XHJcbiAgICBteXNxbC5lbmFibGUoKTtcclxuICAgIHBnLmVuYWJsZSgpO1xyXG4gICAgcGdQb29sLmVuYWJsZSgpO1xyXG4gICAgcmVkaXMuZW5hYmxlKCk7XHJcbiAgICB3aW5zdG9uLmVuYWJsZSgpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/index.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar mongodbcorePatchFunction = function (originalMongoCore) {\r\n    var originalConnect = originalMongoCore.Server.prototype.connect;\r\n    originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {\r\n        var ret = originalConnect.apply(this, arguments);\r\n        // Messages sent to mongo progress through a pool\r\n        // This can result in context getting mixed between different responses\r\n        // so we wrap the callbacks to restore appropriate state\r\n        var originalWrite = this.s.pool.write;\r\n        this.s.pool.write = function contextPreservingWrite() {\r\n            var cbidx = typeof arguments[1] === \"function\" ? 1 : 2;\r\n            if (typeof arguments[cbidx] === \"function\") {\r\n                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);\r\n            }\r\n            return originalWrite.apply(this, arguments);\r\n        };\r\n        // Logout is a special case, it doesn't call the write function but instead\r\n        // directly calls into connection.write\r\n        var originalLogout = this.s.pool.logout;\r\n        this.s.pool.logout = function contextPreservingLogout() {\r\n            if (typeof arguments[1] === \"function\") {\r\n                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);\r\n            }\r\n            return originalLogout.apply(this, arguments);\r\n        };\r\n        return ret;\r\n    };\r\n    return originalMongoCore;\r\n};\r\nexports.mongoCore2 = {\r\n    versionSpecifier: \">= 2.0.0 < 2.2.0\",\r\n    patch: mongodbcorePatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb-core\", exports.mongoCore2);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb-core.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvbW9uZ29kYi1jb3JlLnB1Yi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvbW9uZ29kYi1jb3JlLnB1Yi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXHJcbnZhciBkaWFnbm9zdGljX2NoYW5uZWxfMSA9IHJlcXVpcmUoXCJkaWFnbm9zdGljLWNoYW5uZWxcIik7XHJcbnZhciBtb25nb2RiY29yZVBhdGNoRnVuY3Rpb24gPSBmdW5jdGlvbiAob3JpZ2luYWxNb25nb0NvcmUpIHtcclxuICAgIHZhciBvcmlnaW5hbENvbm5lY3QgPSBvcmlnaW5hbE1vbmdvQ29yZS5TZXJ2ZXIucHJvdG90eXBlLmNvbm5lY3Q7XHJcbiAgICBvcmlnaW5hbE1vbmdvQ29yZS5TZXJ2ZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiBjb250ZXh0UHJlc2VydmluZ0Nvbm5lY3QoKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IG9yaWdpbmFsQ29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIE1lc3NhZ2VzIHNlbnQgdG8gbW9uZ28gcHJvZ3Jlc3MgdGhyb3VnaCBhIHBvb2xcclxuICAgICAgICAvLyBUaGlzIGNhbiByZXN1bHQgaW4gY29udGV4dCBnZXR0aW5nIG1peGVkIGJldHdlZW4gZGlmZmVyZW50IHJlc3BvbnNlc1xyXG4gICAgICAgIC8vIHNvIHdlIHdyYXAgdGhlIGNhbGxiYWNrcyB0byByZXN0b3JlIGFwcHJvcHJpYXRlIHN0YXRlXHJcbiAgICAgICAgdmFyIG9yaWdpbmFsV3JpdGUgPSB0aGlzLnMucG9vbC53cml0ZTtcclxuICAgICAgICB0aGlzLnMucG9vbC53cml0ZSA9IGZ1bmN0aW9uIGNvbnRleHRQcmVzZXJ2aW5nV3JpdGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYmlkeCA9IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09IFwiZnVuY3Rpb25cIiA/IDEgOiAyO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tjYmlkeF0gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzW2NiaWR4XSA9IGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuYmluZFRvQ29udGV4dChhcmd1bWVudHNbY2JpZHhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxXcml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gTG9nb3V0IGlzIGEgc3BlY2lhbCBjYXNlLCBpdCBkb2Vzbid0IGNhbGwgdGhlIHdyaXRlIGZ1bmN0aW9uIGJ1dCBpbnN0ZWFkXHJcbiAgICAgICAgLy8gZGlyZWN0bHkgY2FsbHMgaW50byBjb25uZWN0aW9uLndyaXRlXHJcbiAgICAgICAgdmFyIG9yaWdpbmFsTG9nb3V0ID0gdGhpcy5zLnBvb2wubG9nb3V0O1xyXG4gICAgICAgIHRoaXMucy5wb29sLmxvZ291dCA9IGZ1bmN0aW9uIGNvbnRleHRQcmVzZXJ2aW5nTG9nb3V0KCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMV0gPSBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLmJpbmRUb0NvbnRleHQoYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxMb2dvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsTW9uZ29Db3JlO1xyXG59O1xyXG5leHBvcnRzLm1vbmdvQ29yZTIgPSB7XHJcbiAgICB2ZXJzaW9uU3BlY2lmaWVyOiBcIj49IDIuMC4wIDwgMi4yLjBcIixcclxuICAgIHBhdGNoOiBtb25nb2RiY29yZVBhdGNoRnVuY3Rpb24sXHJcbn07XHJcbmZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwucmVnaXN0ZXJNb25rZXlQYXRjaChcIm1vbmdvZGItY29yZVwiLCBleHBvcnRzLm1vbmdvQ29yZTIpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb25nb2RiLWNvcmUucHViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar mongodbPatchFunction = function (originalMongo) {\r\n    var listener = originalMongo.instrument({\r\n        operationIdGenerator: {\r\n            next: function () {\r\n                return diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\r\n            },\r\n        },\r\n    });\r\n    var eventMap = {};\r\n    listener.on(\"started\", function (event) {\r\n        if (eventMap[event.requestId]) {\r\n            // Note: Mongo can generate 2 completely separate requests\r\n            // which share the same requestId, if a certain race condition is triggered.\r\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\r\n            return;\r\n        }\r\n        eventMap[event.requestId] = event;\r\n    });\r\n    listener.on(\"succeeded\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\r\n    });\r\n    listener.on(\"failed\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\r\n    });\r\n    return originalMongo;\r\n};\r\nexports.mongo2 = {\r\n    versionSpecifier: \">= 2.0.0 <= 2.2.x\",\r\n    patch: mongodbPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo2);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvbW9uZ29kYi5wdWIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzL2Rpc3Qvc3JjL21vbmdvZGIucHViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cclxudmFyIGRpYWdub3N0aWNfY2hhbm5lbF8xID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbFwiKTtcclxudmFyIG1vbmdvZGJQYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKG9yaWdpbmFsTW9uZ28pIHtcclxuICAgIHZhciBsaXN0ZW5lciA9IG9yaWdpbmFsTW9uZ28uaW5zdHJ1bWVudCh7XHJcbiAgICAgICAgb3BlcmF0aW9uSWRHZW5lcmF0b3I6IHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuYmluZFRvQ29udGV4dChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiKCk7IH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHZhciBldmVudE1hcCA9IHt9O1xyXG4gICAgbGlzdGVuZXIub24oXCJzdGFydGVkXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudE1hcFtldmVudC5yZXF1ZXN0SWRdKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IE1vbmdvIGNhbiBnZW5lcmF0ZSAyIGNvbXBsZXRlbHkgc2VwYXJhdGUgcmVxdWVzdHNcclxuICAgICAgICAgICAgLy8gd2hpY2ggc2hhcmUgdGhlIHNhbWUgcmVxdWVzdElkLCBpZiBhIGNlcnRhaW4gcmFjZSBjb25kaXRpb24gaXMgdHJpZ2dlcmVkLlxyXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBhY2NlcHQgdGhhdCB0aGlzIGNhbiBoYXBwZW4gYW5kIHBvdGVudGlhbGx5IG1pc3Mgb3IgbWlzbGFiZWwgc29tZSBldmVudHMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYXBbZXZlbnQucmVxdWVzdElkXSA9IGV2ZW50O1xyXG4gICAgfSk7XHJcbiAgICBsaXN0ZW5lci5vbihcInN1Y2NlZWRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgc3RhcnRlZERhdGEgPSBldmVudE1hcFtldmVudC5yZXF1ZXN0SWRdO1xyXG4gICAgICAgIGlmIChzdGFydGVkRGF0YSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRNYXBbZXZlbnQucmVxdWVzdElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQub3BlcmF0aW9uSWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5wdWJsaXNoKFwibW9uZ29kYlwiLCB7IHN0YXJ0ZWREYXRhOiBzdGFydGVkRGF0YSwgZXZlbnQ6IGV2ZW50LCBzdWNjZWVkZWQ6IHRydWUgfSk7IH0pO1xyXG4gICAgfSk7XHJcbiAgICBsaXN0ZW5lci5vbihcImZhaWxlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgc3RhcnRlZERhdGEgPSBldmVudE1hcFtldmVudC5yZXF1ZXN0SWRdO1xyXG4gICAgICAgIGlmIChzdGFydGVkRGF0YSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRNYXBbZXZlbnQucmVxdWVzdElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQub3BlcmF0aW9uSWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5wdWJsaXNoKFwibW9uZ29kYlwiLCB7IHN0YXJ0ZWREYXRhOiBzdGFydGVkRGF0YSwgZXZlbnQ6IGV2ZW50LCBzdWNjZWVkZWQ6IGZhbHNlIH0pOyB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsTW9uZ287XHJcbn07XHJcbmV4cG9ydHMubW9uZ28yID0ge1xyXG4gICAgdmVyc2lvblNwZWNpZmllcjogXCI+PSAyLjAuMCA8PSAyLjIueFwiLFxyXG4gICAgcGF0Y2g6IG1vbmdvZGJQYXRjaEZ1bmN0aW9uLFxyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnJlZ2lzdGVyTW9ua2V5UGF0Y2goXCJtb25nb2RiXCIsIGV4cG9ydHMubW9uZ28yKTtcclxufVxyXG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9uZ29kYi5wdWIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar mysqlPatchFunction = function (originalMysql, originalMysqlPath) {\r\n    // The `name` passed in here is for debugging purposes,\r\n    // to help distinguish which object is being patched.\r\n    var patchObjectFunction = function (obj, name) {\r\n        return function (func, cbWrapper) {\r\n            var originalFunc = obj[func];\r\n            if (originalFunc) {\r\n                obj[func] = function mysqlContextPreserver() {\r\n                    // Find the callback, if there is one\r\n                    var cbidx = arguments.length - 1;\r\n                    for (var i = arguments.length - 1; i >= 0; --i) {\r\n                        if (typeof arguments[i] === \"function\") {\r\n                            cbidx = i;\r\n                            break;\r\n                        }\r\n                        else if (typeof arguments[i] !== \"undefined\") {\r\n                            break;\r\n                        }\r\n                    }\r\n                    var cb = arguments[cbidx];\r\n                    var resultContainer = { result: null, startTime: null };\r\n                    if (typeof cb === \"function\") {\r\n                        // Preserve context on the callback.\r\n                        // If this is one of the functions that we want to track,\r\n                        // then wrap the callback with the tracking wrapper\r\n                        if (cbWrapper) {\r\n                            resultContainer.startTime = process.hrtime();\r\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));\r\n                        }\r\n                        else {\r\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);\r\n                        }\r\n                    }\r\n                    var result = originalFunc.apply(this, arguments);\r\n                    resultContainer.result = result;\r\n                    return result;\r\n                };\r\n            }\r\n        };\r\n    };\r\n    var patchClassMemberFunction = function (classObject, name) {\r\n        return patchObjectFunction(classObject.prototype, name + \".prototype\");\r\n    };\r\n    var connectionCallbackFunctions = [\r\n        \"connect\", \"changeUser\",\r\n        \"ping\", \"statistics\", \"end\",\r\n    ];\r\n    var connectionClass = __webpack_require__(\"./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Connection$\")(path.dirname(originalMysqlPath) + \"/lib/Connection\");\r\n    connectionCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(connectionClass, \"Connection\")(value); });\r\n    // Connection.createQuery is a static method\r\n    patchObjectFunction(connectionClass, \"Connection\")(\"createQuery\", function (resultContainer, cb) {\r\n        return function (err) {\r\n            var hrDuration = process.hrtime(resultContainer.startTime);\r\n            /* tslint:disable-next-line:no-bitwise */\r\n            var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\r\n            diagnostic_channel_1.channel.publish(\"mysql\", { query: resultContainer.result, callbackArgs: arguments, err: err, duration: duration });\r\n            cb.apply(this, arguments);\r\n        };\r\n    });\r\n    var poolCallbackFunctions = [\r\n        \"_enqueueCallback\",\r\n    ];\r\n    var poolClass = __webpack_require__(\"./node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Pool$\")(path.dirname(originalMysqlPath) + \"/lib/Pool\");\r\n    poolCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(poolClass, \"Pool\")(value); });\r\n    return originalMysql;\r\n};\r\nexports.mysql = {\r\n    versionSpecifier: \">= 2.0.0 <= 2.14.x\",\r\n    patch: mysqlPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mysql\", exports.mysql);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mysql.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvbXlzcWwucHViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9kaWFnbm9zdGljLWNoYW5uZWwtcHVibGlzaGVycy9kaXN0L3NyYy9teXNxbC5wdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG52YXIgbXlzcWxQYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKG9yaWdpbmFsTXlzcWwsIG9yaWdpbmFsTXlzcWxQYXRoKSB7XHJcbiAgICAvLyBUaGUgYG5hbWVgIHBhc3NlZCBpbiBoZXJlIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsXHJcbiAgICAvLyB0byBoZWxwIGRpc3Rpbmd1aXNoIHdoaWNoIG9iamVjdCBpcyBiZWluZyBwYXRjaGVkLlxyXG4gICAgdmFyIHBhdGNoT2JqZWN0RnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqLCBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmdW5jLCBjYldyYXBwZXIpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRnVuYyA9IG9ialtmdW5jXTtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRnVuYykge1xyXG4gICAgICAgICAgICAgICAgb2JqW2Z1bmNdID0gZnVuY3Rpb24gbXlzcWxDb250ZXh0UHJlc2VydmVyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNhbGxiYWNrLCBpZiB0aGVyZSBpcyBvbmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2JpZHggPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IGFyZ3VtZW50c1tjYmlkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdENvbnRhaW5lciA9IHsgcmVzdWx0OiBudWxsLCBzdGFydFRpbWU6IG51bGwgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgY29udGV4dCBvbiB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb25lIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCB3ZSB3YW50IHRvIHRyYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdyYXAgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHRyYWNraW5nIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNiV3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q29udGFpbmVyLnN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbY2JpZHhdID0gZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5iaW5kVG9Db250ZXh0KGNiV3JhcHBlcihyZXN1bHRDb250YWluZXIsIGNiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbY2JpZHhdID0gZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5iaW5kVG9Db250ZXh0KGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWxGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q29udGFpbmVyLnJlc3VsdCA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIHBhdGNoQ2xhc3NNZW1iZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChjbGFzc09iamVjdCwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwYXRjaE9iamVjdEZ1bmN0aW9uKGNsYXNzT2JqZWN0LnByb3RvdHlwZSwgbmFtZSArIFwiLnByb3RvdHlwZVwiKTtcclxuICAgIH07XHJcbiAgICB2YXIgY29ubmVjdGlvbkNhbGxiYWNrRnVuY3Rpb25zID0gW1xyXG4gICAgICAgIFwiY29ubmVjdFwiLCBcImNoYW5nZVVzZXJcIixcclxuICAgICAgICBcInBpbmdcIiwgXCJzdGF0aXN0aWNzXCIsIFwiZW5kXCIsXHJcbiAgICBdO1xyXG4gICAgdmFyIGNvbm5lY3Rpb25DbGFzcyA9IHJlcXVpcmUocGF0aC5kaXJuYW1lKG9yaWdpbmFsTXlzcWxQYXRoKSArIFwiL2xpYi9Db25uZWN0aW9uXCIpO1xyXG4gICAgY29ubmVjdGlvbkNhbGxiYWNrRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBwYXRjaENsYXNzTWVtYmVyRnVuY3Rpb24oY29ubmVjdGlvbkNsYXNzLCBcIkNvbm5lY3Rpb25cIikodmFsdWUpOyB9KTtcclxuICAgIC8vIENvbm5lY3Rpb24uY3JlYXRlUXVlcnkgaXMgYSBzdGF0aWMgbWV0aG9kXHJcbiAgICBwYXRjaE9iamVjdEZ1bmN0aW9uKGNvbm5lY3Rpb25DbGFzcywgXCJDb25uZWN0aW9uXCIpKFwiY3JlYXRlUXVlcnlcIiwgZnVuY3Rpb24gKHJlc3VsdENvbnRhaW5lciwgY2IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICB2YXIgaHJEdXJhdGlvbiA9IHByb2Nlc3MuaHJ0aW1lKHJlc3VsdENvbnRhaW5lci5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZSAqL1xyXG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoaHJEdXJhdGlvblswXSAqIDFlMyArIGhyRHVyYXRpb25bMV0gLyAxZTYpIHwgMDtcclxuICAgICAgICAgICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5wdWJsaXNoKFwibXlzcWxcIiwgeyBxdWVyeTogcmVzdWx0Q29udGFpbmVyLnJlc3VsdCwgY2FsbGJhY2tBcmdzOiBhcmd1bWVudHMsIGVycjogZXJyLCBkdXJhdGlvbjogZHVyYXRpb24gfSk7XHJcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgdmFyIHBvb2xDYWxsYmFja0Z1bmN0aW9ucyA9IFtcclxuICAgICAgICBcIl9lbnF1ZXVlQ2FsbGJhY2tcIixcclxuICAgIF07XHJcbiAgICB2YXIgcG9vbENsYXNzID0gcmVxdWlyZShwYXRoLmRpcm5hbWUob3JpZ2luYWxNeXNxbFBhdGgpICsgXCIvbGliL1Bvb2xcIik7XHJcbiAgICBwb29sQ2FsbGJhY2tGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHBhdGNoQ2xhc3NNZW1iZXJGdW5jdGlvbihwb29sQ2xhc3MsIFwiUG9vbFwiKSh2YWx1ZSk7IH0pO1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsTXlzcWw7XHJcbn07XHJcbmV4cG9ydHMubXlzcWwgPSB7XHJcbiAgICB2ZXJzaW9uU3BlY2lmaWVyOiBcIj49IDIuMC4wIDw9IDIuMTQueFwiLFxyXG4gICAgcGF0Y2g6IG15c3FsUGF0Y2hGdW5jdGlvbixcclxufTtcclxuZnVuY3Rpb24gZW5hYmxlKCkge1xyXG4gICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5yZWdpc3Rlck1vbmtleVBhdGNoKFwibXlzcWxcIiwgZXhwb3J0cy5teXNxbCk7XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW15c3FsLnB1Yi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nfunction postgresPool1PatchFunction(originalPgPool) {\r\n    var originalConnect = originalPgPool.prototype.connect;\r\n    originalPgPool.prototype.connect = function connect(callback) {\r\n        if (callback) {\r\n            arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);\r\n        }\r\n        originalConnect.apply(this, arguments);\r\n    };\r\n    return originalPgPool;\r\n}\r\nexports.postgresPool1 = {\r\n    versionSpecifier: \"1.x\",\r\n    patch: postgresPool1PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg-pool\", exports.postgresPool1);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=pg-pool.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvcGctcG9vbC5wdWIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzL2Rpc3Qvc3JjL3BnLXBvb2wucHViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cclxudmFyIGRpYWdub3N0aWNfY2hhbm5lbF8xID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbFwiKTtcclxuZnVuY3Rpb24gcG9zdGdyZXNQb29sMVBhdGNoRnVuY3Rpb24ob3JpZ2luYWxQZ1Bvb2wpIHtcclxuICAgIHZhciBvcmlnaW5hbENvbm5lY3QgPSBvcmlnaW5hbFBnUG9vbC5wcm90b3R5cGUuY29ubmVjdDtcclxuICAgIG9yaWdpbmFsUGdQb29sLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gY29ubmVjdChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLmJpbmRUb0NvbnRleHQoY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcmlnaW5hbENvbm5lY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gb3JpZ2luYWxQZ1Bvb2w7XHJcbn1cclxuZXhwb3J0cy5wb3N0Z3Jlc1Bvb2wxID0ge1xyXG4gICAgdmVyc2lvblNwZWNpZmllcjogXCIxLnhcIixcclxuICAgIHBhdGNoOiBwb3N0Z3Jlc1Bvb2wxUGF0Y2hGdW5jdGlvbixcclxufTtcclxuZnVuY3Rpb24gZW5hYmxlKCkge1xyXG4gICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5yZWdpc3Rlck1vbmtleVBhdGNoKFwicGctcG9vbFwiLCBleHBvcnRzLnBvc3RncmVzUG9vbDEpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZy1wb29sLnB1Yi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js":
/*!***********************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar events_1 = __webpack_require__(/*! events */ \"events\");\r\nfunction postgres6PatchFunction(originalPg, originalPgPath) {\r\n    var originalClientQuery = originalPg.Client.prototype.query;\r\n    var diagnosticOriginalFunc = \"__diagnosticOriginalFunc\";\r\n    // wherever the callback is passed, find it, save it, and remove it from the call\r\n    // to the the original .query() function\r\n    originalPg.Client.prototype.query = function query(config, values, callback) {\r\n        var data = {\r\n            query: {},\r\n            database: {\r\n                host: this.connectionParameters.host,\r\n                port: this.connectionParameters.port,\r\n            },\r\n            result: null,\r\n            error: null,\r\n            duration: 0,\r\n        };\r\n        var start = process.hrtime();\r\n        var queryResult;\r\n        function patchCallback(cb) {\r\n            if (cb && cb[diagnosticOriginalFunc]) {\r\n                cb = cb[diagnosticOriginalFunc];\r\n            }\r\n            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {\r\n                var end = process.hrtime(start);\r\n                data.result = res && { rowCount: res.rowCount, command: res.command };\r\n                data.error = err;\r\n                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));\r\n                diagnostic_channel_1.channel.publish(\"postgres\", data);\r\n                // emulate weird internal behavior in pg@6\r\n                // on success, the callback is called *before* query events are emitted\r\n                // on failure, the callback is called *instead of* the query emitting events\r\n                // with no events, that means no promises (since the promise is resolved/rejected in an event handler)\r\n                // since we are always inserting ourselves as a callback, we have to restore the original\r\n                // behavior if the user didn't provide one themselves\r\n                if (err) {\r\n                    if (cb) {\r\n                        return cb.apply(this, arguments);\r\n                    }\r\n                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {\r\n                        queryResult.emit(\"error\", err);\r\n                    }\r\n                }\r\n                else if (cb) {\r\n                    cb.apply(this, arguments);\r\n                }\r\n            });\r\n            try {\r\n                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });\r\n                return trackingCallback;\r\n            }\r\n            catch (e) {\r\n                // this should never happen, but bailout in case it does\r\n                return cb;\r\n            }\r\n        }\r\n        // this function takes too many variations of arguments.\r\n        // this patches any provided callback or creates a new callback if one wasn't provided.\r\n        // since the callback is always called (if provided) in addition to always having a Promisified\r\n        // EventEmitter returned (well, sometimes -- see above), its safe to insert a callback if none was given\r\n        try {\r\n            if (typeof config === \"string\") {\r\n                if (values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config,\r\n                        args: values,\r\n                    };\r\n                    callback = patchCallback(callback);\r\n                }\r\n                else {\r\n                    data.query.text = config;\r\n                    // pg v6 will, for some reason, accept both\r\n                    // client.query(\"...\", undefined, () => {...})\r\n                    // **and**\r\n                    // client.query(\"...\", () => {...});\r\n                    // Internally, precedence is given to the callback argument\r\n                    if (callback) {\r\n                        callback = patchCallback(callback);\r\n                    }\r\n                    else {\r\n                        values = patchCallback(values);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (typeof config.name === \"string\") {\r\n                    data.query.plan = config.name;\r\n                }\r\n                else if (config.values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config.text,\r\n                        args: config.values,\r\n                    };\r\n                }\r\n                else {\r\n                    data.query.text = config.text;\r\n                }\r\n                if (callback) {\r\n                    callback = patchCallback(callback);\r\n                }\r\n                else if (values) {\r\n                    values = patchCallback(values);\r\n                }\r\n                else {\r\n                    config.callback = patchCallback(config.callback);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // if our logic here throws, bail out and just let pg do its thing\r\n            return originalClientQuery.apply(this, arguments);\r\n        }\r\n        arguments[0] = config;\r\n        arguments[1] = values;\r\n        arguments[2] = callback;\r\n        arguments.length = (arguments.length > 3) ? arguments.length : 3;\r\n        queryResult = originalClientQuery.apply(this, arguments);\r\n        return queryResult;\r\n    };\r\n    return originalPg;\r\n}\r\nexports.postgres6 = {\r\n    versionSpecifier: \"6.x\",\r\n    patch: postgres6PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg\", exports.postgres6);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=pg.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvcGcucHViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9kaWFnbm9zdGljLWNoYW5uZWwtcHVibGlzaGVycy9kaXN0L3NyYy9wZy5wdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5mdW5jdGlvbiBwb3N0Z3JlczZQYXRjaEZ1bmN0aW9uKG9yaWdpbmFsUGcsIG9yaWdpbmFsUGdQYXRoKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxDbGllbnRRdWVyeSA9IG9yaWdpbmFsUGcuQ2xpZW50LnByb3RvdHlwZS5xdWVyeTtcclxuICAgIHZhciBkaWFnbm9zdGljT3JpZ2luYWxGdW5jID0gXCJfX2RpYWdub3N0aWNPcmlnaW5hbEZ1bmNcIjtcclxuICAgIC8vIHdoZXJldmVyIHRoZSBjYWxsYmFjayBpcyBwYXNzZWQsIGZpbmQgaXQsIHNhdmUgaXQsIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgY2FsbFxyXG4gICAgLy8gdG8gdGhlIHRoZSBvcmlnaW5hbCAucXVlcnkoKSBmdW5jdGlvblxyXG4gICAgb3JpZ2luYWxQZy5DbGllbnQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoY29uZmlnLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcclxuICAgICAgICAgICAgZGF0YWJhc2U6IHtcclxuICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMuaG9zdCxcclxuICAgICAgICAgICAgICAgIHBvcnQ6IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMucG9ydCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdWx0OiBudWxsLFxyXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RhcnQgPSBwcm9jZXNzLmhydGltZSgpO1xyXG4gICAgICAgIHZhciBxdWVyeVJlc3VsdDtcclxuICAgICAgICBmdW5jdGlvbiBwYXRjaENhbGxiYWNrKGNiKSB7XHJcbiAgICAgICAgICAgIGlmIChjYiAmJiBjYltkaWFnbm9zdGljT3JpZ2luYWxGdW5jXSkge1xyXG4gICAgICAgICAgICAgICAgY2IgPSBjYltkaWFnbm9zdGljT3JpZ2luYWxGdW5jXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdDYWxsYmFjayA9IGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwuYmluZFRvQ29udGV4dChmdW5jdGlvbiAoZXJyLCByZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwcm9jZXNzLmhydGltZShzdGFydCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnJlc3VsdCA9IHJlcyAmJiB7IHJvd0NvdW50OiByZXMucm93Q291bnQsIGNvbW1hbmQ6IHJlcy5jb21tYW5kIH07XHJcbiAgICAgICAgICAgICAgICBkYXRhLmVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5kdXJhdGlvbiA9IE1hdGguY2VpbCgoZW5kWzBdICogMWUzKSArIChlbmRbMV0gLyAxZTYpKTtcclxuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNfY2hhbm5lbF8xLmNoYW5uZWwucHVibGlzaChcInBvc3RncmVzXCIsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gZW11bGF0ZSB3ZWlyZCBpbnRlcm5hbCBiZWhhdmlvciBpbiBwZ0A2XHJcbiAgICAgICAgICAgICAgICAvLyBvbiBzdWNjZXNzLCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkICpiZWZvcmUqIHF1ZXJ5IGV2ZW50cyBhcmUgZW1pdHRlZFxyXG4gICAgICAgICAgICAgICAgLy8gb24gZmFpbHVyZSwgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCAqaW5zdGVhZCBvZiogdGhlIHF1ZXJ5IGVtaXR0aW5nIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBubyBldmVudHMsIHRoYXQgbWVhbnMgbm8gcHJvbWlzZXMgKHNpbmNlIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkL3JlamVjdGVkIGluIGFuIGV2ZW50IGhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgYWx3YXlzIGluc2VydGluZyBvdXJzZWx2ZXMgYXMgYSBjYWxsYmFjaywgd2UgaGF2ZSB0byByZXN0b3JlIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaWYgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUgb25lIHRoZW1zZWx2ZXNcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5UmVzdWx0ICYmIHF1ZXJ5UmVzdWx0IGluc3RhbmNlb2YgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0LmVtaXQoXCJlcnJvclwiLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tpbmdDYWxsYmFjaywgZGlhZ25vc3RpY09yaWdpbmFsRnVuYywgeyB2YWx1ZTogY2IgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tpbmdDYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgYmFpbG91dCBpbiBjYXNlIGl0IGRvZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHRha2VzIHRvbyBtYW55IHZhcmlhdGlvbnMgb2YgYXJndW1lbnRzLlxyXG4gICAgICAgIC8vIHRoaXMgcGF0Y2hlcyBhbnkgcHJvdmlkZWQgY2FsbGJhY2sgb3IgY3JlYXRlcyBhIG5ldyBjYWxsYmFjayBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkLlxyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBjYWxsYmFjayBpcyBhbHdheXMgY2FsbGVkIChpZiBwcm92aWRlZCkgaW4gYWRkaXRpb24gdG8gYWx3YXlzIGhhdmluZyBhIFByb21pc2lmaWVkXHJcbiAgICAgICAgLy8gRXZlbnRFbWl0dGVyIHJldHVybmVkICh3ZWxsLCBzb21ldGltZXMgLS0gc2VlIGFib3ZlKSwgaXRzIHNhZmUgdG8gaW5zZXJ0IGEgY2FsbGJhY2sgaWYgbm9uZSB3YXMgZ2l2ZW5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5xdWVyeS5wcmVwYXJhYmxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHZhbHVlcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGF0Y2hDYWxsYmFjayhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnF1ZXJ5LnRleHQgPSBjb25maWc7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGcgdjYgd2lsbCwgZm9yIHNvbWUgcmVhc29uLCBhY2NlcHQgYm90aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC5xdWVyeShcIi4uLlwiLCB1bmRlZmluZWQsICgpID0+IHsuLi59KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICoqYW5kKipcclxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQucXVlcnkoXCIuLi5cIiwgKCkgPT4gey4uLn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVybmFsbHksIHByZWNlZGVuY2UgaXMgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIGFyZ3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGF0Y2hDYWxsYmFjayhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBwYXRjaENhbGxiYWNrKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcubmFtZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucXVlcnkucGxhbiA9IGNvbmZpZy5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLnZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5xdWVyeS5wcmVwYXJhYmxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb25maWcudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY29uZmlnLnZhbHVlcyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5xdWVyeS50ZXh0ID0gY29uZmlnLnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhdGNoQ2FsbGJhY2soY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gcGF0Y2hDYWxsYmFjayh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrID0gcGF0Y2hDYWxsYmFjayhjb25maWcuY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIG91ciBsb2dpYyBoZXJlIHRocm93cywgYmFpbCBvdXQgYW5kIGp1c3QgbGV0IHBnIGRvIGl0cyB0aGluZ1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDbGllbnRRdWVyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcmd1bWVudHNbMF0gPSBjb25maWc7XHJcbiAgICAgICAgYXJndW1lbnRzWzFdID0gdmFsdWVzO1xyXG4gICAgICAgIGFyZ3VtZW50c1syXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDMpID8gYXJndW1lbnRzLmxlbmd0aCA6IDM7XHJcbiAgICAgICAgcXVlcnlSZXN1bHQgPSBvcmlnaW5hbENsaWVudFF1ZXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBvcmlnaW5hbFBnO1xyXG59XHJcbmV4cG9ydHMucG9zdGdyZXM2ID0ge1xyXG4gICAgdmVyc2lvblNwZWNpZmllcjogXCI2LnhcIixcclxuICAgIHBhdGNoOiBwb3N0Z3JlczZQYXRjaEZ1bmN0aW9uLFxyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnJlZ2lzdGVyTW9ua2V5UGF0Y2goXCJwZ1wiLCBleHBvcnRzLnBvc3RncmVzNik7XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBnLnB1Yi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js":
/*!**************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\nvar redisPatchFunction = function (originalRedis) {\r\n    var originalSend = originalRedis.RedisClient.prototype.internal_send_command;\r\n    // Note: This is mixing together both context tracking and dependency tracking\r\n    originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {\r\n        if (commandObj) {\r\n            var cb_1 = commandObj.callback;\r\n            if (!cb_1 || !cb_1.pubsubBound) {\r\n                var address_1 = this.address;\r\n                var startTime_1 = process.hrtime();\r\n                // Note: augmenting the callback on internal_send_command is correct for context\r\n                // tracking, but may be too low-level for dependency tracking. There are some 'errors'\r\n                // which higher levels expect in some cases\r\n                // However, the only other option is to intercept every individual command.\r\n                commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {\r\n                    var hrDuration = process.hrtime(startTime_1);\r\n                    /* tslint:disable-next-line:no-bitwise */\r\n                    var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\r\n                    diagnostic_channel_1.channel.publish(\"redis\", { duration: duration, address: address_1, commandObj: commandObj, err: err, result: result });\r\n                    if (typeof cb_1 === \"function\") {\r\n                        cb_1.apply(this, arguments);\r\n                    }\r\n                });\r\n                commandObj.callback.pubsubBound = true;\r\n            }\r\n        }\r\n        return originalSend.call(this, commandObj);\r\n    };\r\n    return originalRedis;\r\n};\r\nexports.redis = {\r\n    versionSpecifier: \">= 2.0.0 < 3.0.0\",\r\n    patch: redisPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"redis\", exports.redis);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=redis.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvcmVkaXMucHViLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9kaWFnbm9zdGljLWNoYW5uZWwtcHVibGlzaGVycy9kaXN0L3NyYy9yZWRpcy5wdWIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxyXG52YXIgZGlhZ25vc3RpY19jaGFubmVsXzEgPSByZXF1aXJlKFwiZGlhZ25vc3RpYy1jaGFubmVsXCIpO1xyXG52YXIgcmVkaXNQYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKG9yaWdpbmFsUmVkaXMpIHtcclxuICAgIHZhciBvcmlnaW5hbFNlbmQgPSBvcmlnaW5hbFJlZGlzLlJlZGlzQ2xpZW50LnByb3RvdHlwZS5pbnRlcm5hbF9zZW5kX2NvbW1hbmQ7XHJcbiAgICAvLyBOb3RlOiBUaGlzIGlzIG1peGluZyB0b2dldGhlciBib3RoIGNvbnRleHQgdHJhY2tpbmcgYW5kIGRlcGVuZGVuY3kgdHJhY2tpbmdcclxuICAgIG9yaWdpbmFsUmVkaXMuUmVkaXNDbGllbnQucHJvdG90eXBlLmludGVybmFsX3NlbmRfY29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kT2JqKSB7XHJcbiAgICAgICAgaWYgKGNvbW1hbmRPYmopIHtcclxuICAgICAgICAgICAgdmFyIGNiXzEgPSBjb21tYW5kT2JqLmNhbGxiYWNrO1xyXG4gICAgICAgICAgICBpZiAoIWNiXzEgfHwgIWNiXzEucHVic3ViQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzXzEgPSB0aGlzLmFkZHJlc3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lXzEgPSBwcm9jZXNzLmhydGltZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogYXVnbWVudGluZyB0aGUgY2FsbGJhY2sgb24gaW50ZXJuYWxfc2VuZF9jb21tYW5kIGlzIGNvcnJlY3QgZm9yIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIC8vIHRyYWNraW5nLCBidXQgbWF5IGJlIHRvbyBsb3ctbGV2ZWwgZm9yIGRlcGVuZGVuY3kgdHJhY2tpbmcuIFRoZXJlIGFyZSBzb21lICdlcnJvcnMnXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBoaWdoZXIgbGV2ZWxzIGV4cGVjdCBpbiBzb21lIGNhc2VzXHJcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgdG8gaW50ZXJjZXB0IGV2ZXJ5IGluZGl2aWR1YWwgY29tbWFuZC5cclxuICAgICAgICAgICAgICAgIGNvbW1hbmRPYmouY2FsbGJhY2sgPSBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLmJpbmRUb0NvbnRleHQoZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyRHVyYXRpb24gPSBwcm9jZXNzLmhydGltZShzdGFydFRpbWVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2UgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoaHJEdXJhdGlvblswXSAqIDFlMyArIGhyRHVyYXRpb25bMV0gLyAxZTYpIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnB1Ymxpc2goXCJyZWRpc1wiLCB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgYWRkcmVzczogYWRkcmVzc18xLCBjb21tYW5kT2JqOiBjb21tYW5kT2JqLCBlcnI6IGVyciwgcmVzdWx0OiByZXN1bHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYl8xID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2JfMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29tbWFuZE9iai5jYWxsYmFjay5wdWJzdWJCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsU2VuZC5jYWxsKHRoaXMsIGNvbW1hbmRPYmopO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBvcmlnaW5hbFJlZGlzO1xyXG59O1xyXG5leHBvcnRzLnJlZGlzID0ge1xyXG4gICAgdmVyc2lvblNwZWNpZmllcjogXCI+PSAyLjAuMCA8IDMuMC4wXCIsXHJcbiAgICBwYXRjaDogcmVkaXNQYXRjaEZ1bmN0aW9uLFxyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnJlZ2lzdGVyTW9ua2V5UGF0Y2goXCJyZWRpc1wiLCBleHBvcnRzLnJlZGlzKTtcclxufVxyXG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkaXMucHViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js":
/*!****************************************************************************!*\
  !*** ./node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = __webpack_require__(/*! diagnostic-channel */ \"./node_modules/diagnostic-channel/dist/src/channel.js\");\r\n// register a \"filter\" with each logger that publishes the data about to be logged\r\nvar winstonPatchFunction = function (originalWinston) {\r\n    var originalLog = originalWinston.Logger.prototype.log;\r\n    var curLevels;\r\n    var loggingFilter = function (level, message, meta) {\r\n        var levelKind;\r\n        if (curLevels === originalWinston.config.npm.levels) {\r\n            levelKind = \"npm\";\r\n        }\r\n        else if (curLevels === originalWinston.config.syslog.levels) {\r\n            levelKind = \"syslog\";\r\n        }\r\n        else {\r\n            levelKind = \"unknown\";\r\n        }\r\n        diagnostic_channel_1.channel.publish(\"winston\", { level: level, message: message, meta: meta, levelKind: levelKind });\r\n        return message;\r\n    };\r\n    // whenever someone logs, ensure our filter comes last\r\n    originalWinston.Logger.prototype.log = function log() {\r\n        curLevels = this.levels;\r\n        if (!this.filters || this.filters.length === 0) {\r\n            this.filters = [loggingFilter];\r\n        }\r\n        else if (this.filters[this.filters.length - 1] !== loggingFilter) {\r\n            this.filters = this.filters.filter(function (f) { return f !== loggingFilter; });\r\n            this.filters.push(loggingFilter);\r\n        }\r\n        return originalLog.apply(this, arguments);\r\n    };\r\n    return originalWinston;\r\n};\r\nexports.winston = {\r\n    versionSpecifier: \"2.x\",\r\n    patch: winstonPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"winston\", exports.winston);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=winston.pub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsLXB1Ymxpc2hlcnMvZGlzdC9zcmMvd2luc3Rvbi5wdWIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC1wdWJsaXNoZXJzL2Rpc3Qvc3JjL3dpbnN0b24ucHViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZGV0YWlscy5cclxudmFyIGRpYWdub3N0aWNfY2hhbm5lbF8xID0gcmVxdWlyZShcImRpYWdub3N0aWMtY2hhbm5lbFwiKTtcclxuLy8gcmVnaXN0ZXIgYSBcImZpbHRlclwiIHdpdGggZWFjaCBsb2dnZXIgdGhhdCBwdWJsaXNoZXMgdGhlIGRhdGEgYWJvdXQgdG8gYmUgbG9nZ2VkXHJcbnZhciB3aW5zdG9uUGF0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uIChvcmlnaW5hbFdpbnN0b24pIHtcclxuICAgIHZhciBvcmlnaW5hbExvZyA9IG9yaWdpbmFsV2luc3Rvbi5Mb2dnZXIucHJvdG90eXBlLmxvZztcclxuICAgIHZhciBjdXJMZXZlbHM7XHJcbiAgICB2YXIgbG9nZ2luZ0ZpbHRlciA9IGZ1bmN0aW9uIChsZXZlbCwgbWVzc2FnZSwgbWV0YSkge1xyXG4gICAgICAgIHZhciBsZXZlbEtpbmQ7XHJcbiAgICAgICAgaWYgKGN1ckxldmVscyA9PT0gb3JpZ2luYWxXaW5zdG9uLmNvbmZpZy5ucG0ubGV2ZWxzKSB7XHJcbiAgICAgICAgICAgIGxldmVsS2luZCA9IFwibnBtXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1ckxldmVscyA9PT0gb3JpZ2luYWxXaW5zdG9uLmNvbmZpZy5zeXNsb2cubGV2ZWxzKSB7XHJcbiAgICAgICAgICAgIGxldmVsS2luZCA9IFwic3lzbG9nXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXZlbEtpbmQgPSBcInVua25vd25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlhZ25vc3RpY19jaGFubmVsXzEuY2hhbm5lbC5wdWJsaXNoKFwid2luc3RvblwiLCB7IGxldmVsOiBsZXZlbCwgbWVzc2FnZTogbWVzc2FnZSwgbWV0YTogbWV0YSwgbGV2ZWxLaW5kOiBsZXZlbEtpbmQgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gd2hlbmV2ZXIgc29tZW9uZSBsb2dzLCBlbnN1cmUgb3VyIGZpbHRlciBjb21lcyBsYXN0XHJcbiAgICBvcmlnaW5hbFdpbnN0b24uTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiBsb2coKSB7XHJcbiAgICAgICAgY3VyTGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBbbG9nZ2luZ0ZpbHRlcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmlsdGVyc1t0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMV0gIT09IGxvZ2dpbmdGaWx0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5maWx0ZXJzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZiAhPT0gbG9nZ2luZ0ZpbHRlcjsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGxvZ2dpbmdGaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxMb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gb3JpZ2luYWxXaW5zdG9uO1xyXG59O1xyXG5leHBvcnRzLndpbnN0b24gPSB7XHJcbiAgICB2ZXJzaW9uU3BlY2lmaWVyOiBcIjIueFwiLFxyXG4gICAgcGF0Y2g6IHdpbnN0b25QYXRjaEZ1bmN0aW9uLFxyXG59O1xyXG5mdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBkaWFnbm9zdGljX2NoYW5uZWxfMS5jaGFubmVsLnJlZ2lzdGVyTW9ua2V5UGF0Y2goXCJ3aW5zdG9uXCIsIGV4cG9ydHMud2luc3Rvbik7XHJcbn1cclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbnN0b24ucHViLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel/dist/src/channel.js":
/*!*************************************************************!*\
  !*** ./node_modules/diagnostic-channel/dist/src/channel.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar patchRequire_1 = __webpack_require__(/*! ./patchRequire */ \"./node_modules/diagnostic-channel/dist/src/patchRequire.js\");\r\nvar patchRequire_2 = __webpack_require__(/*! ./patchRequire */ \"./node_modules/diagnostic-channel/dist/src/patchRequire.js\");\r\nexports.makePatchingRequire = patchRequire_2.makePatchingRequire;\r\nvar trueFilter = function (publishing) { return true; };\r\nvar ContextPreservingEventEmitter = (function () {\r\n    function ContextPreservingEventEmitter() {\r\n        this.version = __webpack_require__(/*! ./../../package.json */ \"./node_modules/diagnostic-channel/package.json\").version; // Allow for future versions to replace things?\r\n        this.subscribers = {};\r\n        this.contextPreservationFunction = function (cb) { return cb; };\r\n        this.knownPatches = {};\r\n        this.currentlyPublishing = false;\r\n    }\r\n    ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {\r\n        var listeners = this.subscribers[name];\r\n        if (listeners) {\r\n            return listeners.some(function (_a) {\r\n                var filter = _a.filter;\r\n                return !filter || filter(false);\r\n            });\r\n        }\r\n        return false;\r\n    };\r\n    ContextPreservingEventEmitter.prototype.publish = function (name, event) {\r\n        if (this.currentlyPublishing) {\r\n            return; // Avoid reentrancy\r\n        }\r\n        var listeners = this.subscribers[name];\r\n        // Note: Listeners called synchronously to preserve context\r\n        if (listeners) {\r\n            var standardEvent_1 = {\r\n                timestamp: Date.now(),\r\n                data: event,\r\n            };\r\n            this.currentlyPublishing = true;\r\n            listeners.forEach(function (_a) {\r\n                var listener = _a.listener, filter = _a.filter;\r\n                try {\r\n                    if (filter && filter(true)) {\r\n                        listener(standardEvent_1);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // Subscriber threw an error\r\n                }\r\n            });\r\n            this.currentlyPublishing = false;\r\n        }\r\n    };\r\n    ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter) {\r\n        if (filter === void 0) { filter = trueFilter; }\r\n        if (!this.subscribers[name]) {\r\n            this.subscribers[name] = [];\r\n        }\r\n        this.subscribers[name].push({ listener: listener, filter: filter });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {\r\n        if (filter === void 0) { filter = trueFilter; }\r\n        var listeners = this.subscribers[name];\r\n        if (listeners) {\r\n            for (var index = 0; index < listeners.length; ++index) {\r\n                if (listeners[index].listener === listener && listeners[index].filter === filter) {\r\n                    listeners.splice(index, 1);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    // Used for tests\r\n    ContextPreservingEventEmitter.prototype.reset = function () {\r\n        var _this = this;\r\n        this.subscribers = {};\r\n        this.contextPreservationFunction = function (cb) { return cb; };\r\n        // Modify the knownPatches object rather than replace, since a reference will be used in the require patcher\r\n        Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) { return delete _this.knownPatches[prop]; });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {\r\n        return this.contextPreservationFunction(cb);\r\n    };\r\n    ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {\r\n        var previousPreservationStack = this.contextPreservationFunction;\r\n        this.contextPreservationFunction = (function (cb) { return preserver(previousPreservationStack(cb)); });\r\n    };\r\n    ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {\r\n        if (!this.knownPatches[packageName]) {\r\n            this.knownPatches[packageName] = [];\r\n        }\r\n        this.knownPatches[packageName].push(patcher);\r\n    };\r\n    ContextPreservingEventEmitter.prototype.getPatchesObject = function () {\r\n        return this.knownPatches;\r\n    };\r\n    return ContextPreservingEventEmitter;\r\n}());\r\nif (!global.diagnosticsSource) {\r\n    global.diagnosticsSource = new ContextPreservingEventEmitter();\r\n    // TODO: should this only patch require after at least one monkey patch is registered?\r\n    /* tslint:disable-next-line:no-var-requires */\r\n    var moduleModule = __webpack_require__(/*! module */ \"module\");\r\n    // Note: We pass in the object now before any patches are registered, but the object is passed by reference\r\n    // so any updates made to the object will be visible in the patcher.\r\n    moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());\r\n}\r\nexports.channel = global.diagnosticsSource;\r\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsL2Rpc3Qvc3JjL2NoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2RpYWdub3N0aWMtY2hhbm5lbC9kaXN0L3NyYy9jaGFubmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGRldGFpbHMuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHBhdGNoUmVxdWlyZV8xID0gcmVxdWlyZShcIi4vcGF0Y2hSZXF1aXJlXCIpO1xyXG52YXIgcGF0Y2hSZXF1aXJlXzIgPSByZXF1aXJlKFwiLi9wYXRjaFJlcXVpcmVcIik7XHJcbmV4cG9ydHMubWFrZVBhdGNoaW5nUmVxdWlyZSA9IHBhdGNoUmVxdWlyZV8yLm1ha2VQYXRjaGluZ1JlcXVpcmU7XHJcbnZhciB0cnVlRmlsdGVyID0gZnVuY3Rpb24gKHB1Ymxpc2hpbmcpIHsgcmV0dXJuIHRydWU7IH07XHJcbnZhciBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlcigpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSByZXF1aXJlKFwiLi8uLi8uLi9wYWNrYWdlLmpzb25cIikudmVyc2lvbjsgLy8gQWxsb3cgZm9yIGZ1dHVyZSB2ZXJzaW9ucyB0byByZXBsYWNlIHRoaW5ncz9cclxuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5jb250ZXh0UHJlc2VydmF0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiOyB9O1xyXG4gICAgICAgIHRoaXMua25vd25QYXRjaGVzID0ge307XHJcbiAgICAgICAgdGhpcy5jdXJyZW50bHlQdWJsaXNoaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUuc2hvdWxkUHVibGlzaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuc3Vic2NyaWJlcnNbbmFtZV07XHJcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLnNvbWUoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gX2EuZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFmaWx0ZXIgfHwgZmlsdGVyKGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRseVB1Ymxpc2hpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBdm9pZCByZWVudHJhbmN5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmliZXJzW25hbWVdO1xyXG4gICAgICAgIC8vIE5vdGU6IExpc3RlbmVycyBjYWxsZWQgc3luY2hyb25vdXNseSB0byBwcmVzZXJ2ZSBjb250ZXh0XHJcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICB2YXIgc3RhbmRhcmRFdmVudF8xID0ge1xyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZXZlbnQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UHVibGlzaGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2EubGlzdGVuZXIsIGZpbHRlciA9IF9hLmZpbHRlcjtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoc3RhbmRhcmRFdmVudF8xKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZXIgdGhyZXcgYW4gZXJyb3JcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UHVibGlzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0gdHJ1ZUZpbHRlcjsgfVxyXG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW25hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbbmFtZV0ucHVzaCh7IGxpc3RlbmVyOiBsaXN0ZW5lciwgZmlsdGVyOiBmaWx0ZXIgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dFByZXNlcnZpbmdFdmVudEVtaXR0ZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0gdHJ1ZUZpbHRlcjsgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmliZXJzW25hbWVdO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3RlbmVycy5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaW5kZXhdLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJiBsaXN0ZW5lcnNbaW5kZXhdLmZpbHRlciA9PT0gZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFVzZWQgZm9yIHRlc3RzXHJcbiAgICBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5jb250ZXh0UHJlc2VydmF0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiOyB9O1xyXG4gICAgICAgIC8vIE1vZGlmeSB0aGUga25vd25QYXRjaGVzIG9iamVjdCByYXRoZXIgdGhhbiByZXBsYWNlLCBzaW5jZSBhIHJlZmVyZW5jZSB3aWxsIGJlIHVzZWQgaW4gdGhlIHJlcXVpcmUgcGF0Y2hlclxyXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMua25vd25QYXRjaGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBkZWxldGUgX3RoaXMua25vd25QYXRjaGVzW3Byb3BdOyB9KTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0UHJlc2VydmluZ0V2ZW50RW1pdHRlci5wcm90b3R5cGUuYmluZFRvQ29udGV4dCA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRQcmVzZXJ2YXRpb25GdW5jdGlvbihjYik7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dFByZXNlcnZpbmdFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZENvbnRleHRQcmVzZXJ2YXRpb24gPSBmdW5jdGlvbiAocHJlc2VydmVyKSB7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzUHJlc2VydmF0aW9uU3RhY2sgPSB0aGlzLmNvbnRleHRQcmVzZXJ2YXRpb25GdW5jdGlvbjtcclxuICAgICAgICB0aGlzLmNvbnRleHRQcmVzZXJ2YXRpb25GdW5jdGlvbiA9IChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIHByZXNlcnZlcihwcmV2aW91c1ByZXNlcnZhdGlvblN0YWNrKGNiKSk7IH0pO1xyXG4gICAgfTtcclxuICAgIENvbnRleHRQcmVzZXJ2aW5nRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZWdpc3Rlck1vbmtleVBhdGNoID0gZnVuY3Rpb24gKHBhY2thZ2VOYW1lLCBwYXRjaGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmtub3duUGF0Y2hlc1twYWNrYWdlTmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5rbm93blBhdGNoZXNbcGFja2FnZU5hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua25vd25QYXRjaGVzW3BhY2thZ2VOYW1lXS5wdXNoKHBhdGNoZXIpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHRQcmVzZXJ2aW5nRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRQYXRjaGVzT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtub3duUGF0Y2hlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29udGV4dFByZXNlcnZpbmdFdmVudEVtaXR0ZXI7XHJcbn0oKSk7XHJcbmlmICghZ2xvYmFsLmRpYWdub3N0aWNzU291cmNlKSB7XHJcbiAgICBnbG9iYWwuZGlhZ25vc3RpY3NTb3VyY2UgPSBuZXcgQ29udGV4dFByZXNlcnZpbmdFdmVudEVtaXR0ZXIoKTtcclxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIG9ubHkgcGF0Y2ggcmVxdWlyZSBhZnRlciBhdCBsZWFzdCBvbmUgbW9ua2V5IHBhdGNoIGlzIHJlZ2lzdGVyZWQ/XHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdmFyLXJlcXVpcmVzICovXHJcbiAgICB2YXIgbW9kdWxlTW9kdWxlID0gcmVxdWlyZShcIm1vZHVsZVwiKTtcclxuICAgIC8vIE5vdGU6IFdlIHBhc3MgaW4gdGhlIG9iamVjdCBub3cgYmVmb3JlIGFueSBwYXRjaGVzIGFyZSByZWdpc3RlcmVkLCBidXQgdGhlIG9iamVjdCBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlXHJcbiAgICAvLyBzbyBhbnkgdXBkYXRlcyBtYWRlIHRvIHRoZSBvYmplY3Qgd2lsbCBiZSB2aXNpYmxlIGluIHRoZSBwYXRjaGVyLlxyXG4gICAgbW9kdWxlTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gcGF0Y2hSZXF1aXJlXzEubWFrZVBhdGNoaW5nUmVxdWlyZShnbG9iYWwuZGlhZ25vc3RpY3NTb3VyY2UuZ2V0UGF0Y2hlc09iamVjdCgpKTtcclxufVxyXG5leHBvcnRzLmNoYW5uZWwgPSBnbG9iYWwuZGlhZ25vc3RpY3NTb3VyY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel/dist/src/channel.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel/dist/src/patchRequire.js":
/*!******************************************************************!*\
  !*** ./node_modules/diagnostic-channel/dist/src/patchRequire.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar semver = __webpack_require__(/*! semver */ \"./node_modules/semver/semver.js\");\r\n/* tslint:disable-next-line:no-var-requires */\r\nvar moduleModule = __webpack_require__(/*! module */ \"module\");\r\nvar nativeModules = Object.keys(process.binding(\"natives\"));\r\nvar originalRequire = moduleModule.prototype.require;\r\nfunction makePatchingRequire(knownPatches) {\r\n    var patchedModules = {};\r\n    return function patchedRequire(moduleId) {\r\n        var originalModule = originalRequire.apply(this, arguments);\r\n        if (knownPatches[moduleId]) {\r\n            // Fetch the specific path of the module\r\n            var modulePath = moduleModule._resolveFilename(moduleId, this);\r\n            if (patchedModules.hasOwnProperty(modulePath)) {\r\n                // This module has already been patched, no need to reapply\r\n                return patchedModules[modulePath];\r\n            }\r\n            var moduleVersion = void 0;\r\n            if (nativeModules.indexOf(moduleId) < 0) {\r\n                try {\r\n                    moduleVersion = originalRequire.call(this, path.join(moduleId, \"package.json\")).version;\r\n                }\r\n                catch (e) {\r\n                    // This should only happen if moduleId is actually a path rather than a module\r\n                    // This is not a supported scenario\r\n                    return originalModule;\r\n                }\r\n            }\r\n            else {\r\n                // This module is implemented natively so we cannot find a package.json\r\n                // Instead, take the version of node itself\r\n                moduleVersion = process.version.substring(1);\r\n            }\r\n            var prereleaseTagIndex = moduleVersion.indexOf(\"-\");\r\n            if (prereleaseTagIndex >= 0) {\r\n                // We ignore prerelease tags to avoid impossible to fix gaps in support\r\n                // e.g. supporting console in >= 4.0.0 would otherwise not include\r\n                // 8.0.0-pre\r\n                moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);\r\n            }\r\n            var modifiedModule = originalModule;\r\n            for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {\r\n                var modulePatcher = _a[_i];\r\n                if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {\r\n                    modifiedModule = modulePatcher.patch(modifiedModule, modulePath);\r\n                }\r\n            }\r\n            return patchedModules[modulePath] = modifiedModule;\r\n        }\r\n        return originalModule;\r\n    };\r\n}\r\nexports.makePatchingRequire = makePatchingRequire;\r\n//# sourceMappingURL=patchRequire.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsL2Rpc3Qvc3JjL3BhdGNoUmVxdWlyZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsL2Rpc3Qvc3JjL3BhdGNoUmVxdWlyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBkZXRhaWxzLlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbnZhciBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdmFyLXJlcXVpcmVzICovXHJcbnZhciBtb2R1bGVNb2R1bGUgPSByZXF1aXJlKFwibW9kdWxlXCIpO1xyXG52YXIgbmF0aXZlTW9kdWxlcyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuYmluZGluZyhcIm5hdGl2ZXNcIikpO1xyXG52YXIgb3JpZ2luYWxSZXF1aXJlID0gbW9kdWxlTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlO1xyXG5mdW5jdGlvbiBtYWtlUGF0Y2hpbmdSZXF1aXJlKGtub3duUGF0Y2hlcykge1xyXG4gICAgdmFyIHBhdGNoZWRNb2R1bGVzID0ge307XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2hlZFJlcXVpcmUobW9kdWxlSWQpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWxNb2R1bGUgPSBvcmlnaW5hbFJlcXVpcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAoa25vd25QYXRjaGVzW21vZHVsZUlkXSkge1xyXG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgc3BlY2lmaWMgcGF0aCBvZiB0aGUgbW9kdWxlXHJcbiAgICAgICAgICAgIHZhciBtb2R1bGVQYXRoID0gbW9kdWxlTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUobW9kdWxlSWQsIHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hlZE1vZHVsZXMuaGFzT3duUHJvcGVydHkobW9kdWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbW9kdWxlIGhhcyBhbHJlYWR5IGJlZW4gcGF0Y2hlZCwgbm8gbmVlZCB0byByZWFwcGx5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZE1vZHVsZXNbbW9kdWxlUGF0aF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1vZHVsZVZlcnNpb24gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmIChuYXRpdmVNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uID0gb3JpZ2luYWxSZXF1aXJlLmNhbGwodGhpcywgcGF0aC5qb2luKG1vZHVsZUlkLCBcInBhY2thZ2UuanNvblwiKSkudmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgbW9kdWxlSWQgaXMgYWN0dWFsbHkgYSBwYXRoIHJhdGhlciB0aGFuIGEgbW9kdWxlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSBzdXBwb3J0ZWQgc2NlbmFyaW9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNb2R1bGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1vZHVsZSBpcyBpbXBsZW1lbnRlZCBuYXRpdmVseSBzbyB3ZSBjYW5ub3QgZmluZCBhIHBhY2thZ2UuanNvblxyXG4gICAgICAgICAgICAgICAgLy8gSW5zdGVhZCwgdGFrZSB0aGUgdmVyc2lvbiBvZiBub2RlIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbi5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByZXJlbGVhc2VUYWdJbmRleCA9IG1vZHVsZVZlcnNpb24uaW5kZXhPZihcIi1cIik7XHJcbiAgICAgICAgICAgIGlmIChwcmVyZWxlYXNlVGFnSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaWdub3JlIHByZXJlbGVhc2UgdGFncyB0byBhdm9pZCBpbXBvc3NpYmxlIHRvIGZpeCBnYXBzIGluIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIC8vIGUuZy4gc3VwcG9ydGluZyBjb25zb2xlIGluID49IDQuMC4wIHdvdWxkIG90aGVyd2lzZSBub3QgaW5jbHVkZVxyXG4gICAgICAgICAgICAgICAgLy8gOC4wLjAtcHJlXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uID0gbW9kdWxlVmVyc2lvbi5zdWJzdHJpbmcoMCwgcHJlcmVsZWFzZVRhZ0luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRNb2R1bGUgPSBvcmlnaW5hbE1vZHVsZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGtub3duUGF0Y2hlc1ttb2R1bGVJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUGF0Y2hlciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChzZW12ZXIuc2F0aXNmaWVzKG1vZHVsZVZlcnNpb24sIG1vZHVsZVBhdGNoZXIudmVyc2lvblNwZWNpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZE1vZHVsZSA9IG1vZHVsZVBhdGNoZXIucGF0Y2gobW9kaWZpZWRNb2R1bGUsIG1vZHVsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRjaGVkTW9kdWxlc1ttb2R1bGVQYXRoXSA9IG1vZGlmaWVkTW9kdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNb2R1bGU7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubWFrZVBhdGNoaW5nUmVxdWlyZSA9IG1ha2VQYXRjaGluZ1JlcXVpcmU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGNoUmVxdWlyZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel/dist/src/patchRequire.js\n");

/***/ }),

/***/ "./node_modules/diagnostic-channel/package.json":
/*!******************************************************!*\
  !*** ./node_modules/diagnostic-channel/package.json ***!
  \******************************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, bugs, dependencies, description, devDependencies, files, homepage, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

eval("module.exports = {\"_args\":[[\"diagnostic-channel@0.2.0\",\"C:\\\\Users\\\\bobbr\\\\git\\\\vscode-cpptools\\\\Extension\"]],\"_from\":\"diagnostic-channel@0.2.0\",\"_id\":\"diagnostic-channel@0.2.0\",\"_inBundle\":false,\"_integrity\":\"sha1-zJmvlhLCP7H/8TYSxy8sv6qNWhc=\",\"_location\":\"/diagnostic-channel\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"diagnostic-channel@0.2.0\",\"name\":\"diagnostic-channel\",\"escapedName\":\"diagnostic-channel\",\"rawSpec\":\"0.2.0\",\"saveSpec\":null,\"fetchSpec\":\"0.2.0\"},\"_requiredBy\":[\"/applicationinsights\"],\"_resolved\":\"https://registry.npmjs.org/diagnostic-channel/-/diagnostic-channel-0.2.0.tgz\",\"_spec\":\"0.2.0\",\"_where\":\"C:\\\\Users\\\\bobbr\\\\git\\\\vscode-cpptools\\\\Extension\",\"bugs\":{\"url\":\"https://github.com/Microsoft/node-diagnostic-channel/issues\"},\"dependencies\":{\"semver\":\"^5.3.0\"},\"description\":\"Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers\",\"devDependencies\":{\"@types/mocha\":\"^2.2.40\",\"@types/node\":\"^7.0.12\",\"mocha\":\"^3.2.0\",\"rimraf\":\"^2.6.1\",\"tslint\":\"^5.0.0\",\"typescript\":\"^2.2.1\"},\"files\":[\"dist/src/**/*.d.ts\",\"dist/src/**/*.js\",\"LICENSE\",\"README.md\",\"package.json\"],\"homepage\":\"https://github.com/Microsoft/node-diagnostic-channel\",\"license\":\"MIT\",\"main\":\"./dist/src/channel.js\",\"name\":\"diagnostic-channel\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/Microsoft/node-diagnostic-channel.git\"},\"scripts\":{\"build\":\"tsc\",\"clean\":\"rimraf ./dist\",\"lint\":\"tslint -c tslint.json -p tsconfig.json\",\"test\":\"mocha ./dist/tests/**/*.js\"},\"types\":\"./dist/src/channel.d.ts\",\"version\":\"0.2.0\"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlhZ25vc3RpYy1jaGFubmVsL3BhY2thZ2UuanNvbi5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/diagnostic-channel/package.json\n");

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.5+7f2b526d\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar TRY_CATCH_ERROR = { error: null };\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    TRY_CATCH_ERROR.error = error;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === TRY_CATCH_ERROR) {\n      reject(promise, TRY_CATCH_ERROR.error);\n      TRY_CATCH_ERROR.error = null;\n    } else if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = void 0,\n      failed = void 0;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = getThen(entry);\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        handleMaybeThenable(promise, entry, _then);\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNSs3ZjJiNTI2ZFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es6-promise/dist/es6-promise.js\n");

/***/ }),

/***/ "./node_modules/es6-promisify/dist/promise.js":
/*!****************************************************!*\
  !*** ./node_modules/es6-promisify/dist/promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global self, window, module, global, require */\nmodule.exports = function () {\n\n    \"use strict\";\n\n    var globalObject = void 0;\n\n    function isFunction(x) {\n        return typeof x === \"function\";\n    }\n\n    // Seek the global object\n    if (global !== undefined) {\n        globalObject = global;\n    } else if (window !== undefined && window.document) {\n        globalObject = window;\n    } else {\n        globalObject = self;\n    }\n\n    // Test for any native promise implementation, and if that\n    // implementation appears to conform to the specificaton.\n    // This code mostly nicked from the es6-promise module polyfill\n    // and then fooled with.\n    var hasPromiseSupport = function () {\n\n        // No promise object at all, and it's a non-starter\n        if (!globalObject.hasOwnProperty(\"Promise\")) {\n            return false;\n        }\n\n        // There is a Promise object. Does it conform to the spec?\n        var P = globalObject.Promise;\n\n        // Some of these methods are missing from\n        // Firefox/Chrome experimental implementations\n        if (!P.hasOwnProperty(\"resolve\") || !P.hasOwnProperty(\"reject\")) {\n            return false;\n        }\n\n        if (!P.hasOwnProperty(\"all\") || !P.hasOwnProperty(\"race\")) {\n            return false;\n        }\n\n        // Older version of the spec had a resolver object\n        // as the arg rather than a function\n        return function () {\n\n            var resolve = void 0;\n\n            var p = new globalObject.Promise(function (r) {\n                resolve = r;\n            });\n\n            if (p) {\n                return isFunction(resolve);\n            }\n\n            return false;\n        }();\n    }();\n\n    // Export the native Promise implementation if it\n    // looks like it matches the spec\n    if (hasPromiseSupport) {\n        return globalObject.Promise;\n    }\n\n    //  Otherwise, return the es6-promise polyfill by @jaffathecake.\n    return __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\").Promise;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2lmeS9kaXN0L3Byb21pc2UuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNpZnkvZGlzdC9wcm9taXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBnbG9iYWwgc2VsZiwgd2luZG93LCBtb2R1bGUsIGdsb2JhbCwgcmVxdWlyZSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBnbG9iYWxPYmplY3QgPSB2b2lkIDA7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuXG4gICAgLy8gU2VlayB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIGlmIChnbG9iYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbG9iYWxPYmplY3QgPSBnbG9iYWw7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgZ2xvYmFsT2JqZWN0ID0gd2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbE9iamVjdCA9IHNlbGY7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgYW55IG5hdGl2ZSBwcm9taXNlIGltcGxlbWVudGF0aW9uLCBhbmQgaWYgdGhhdFxuICAgIC8vIGltcGxlbWVudGF0aW9uIGFwcGVhcnMgdG8gY29uZm9ybSB0byB0aGUgc3BlY2lmaWNhdG9uLlxuICAgIC8vIFRoaXMgY29kZSBtb3N0bHkgbmlja2VkIGZyb20gdGhlIGVzNi1wcm9taXNlIG1vZHVsZSBwb2x5ZmlsbFxuICAgIC8vIGFuZCB0aGVuIGZvb2xlZCB3aXRoLlxuICAgIHZhciBoYXNQcm9taXNlU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBObyBwcm9taXNlIG9iamVjdCBhdCBhbGwsIGFuZCBpdCdzIGEgbm9uLXN0YXJ0ZXJcbiAgICAgICAgaWYgKCFnbG9iYWxPYmplY3QuaGFzT3duUHJvcGVydHkoXCJQcm9taXNlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBpcyBhIFByb21pc2Ugb2JqZWN0LiBEb2VzIGl0IGNvbmZvcm0gdG8gdGhlIHNwZWM/XG4gICAgICAgIHZhciBQID0gZ2xvYmFsT2JqZWN0LlByb21pc2U7XG5cbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBtZXRob2RzIGFyZSBtaXNzaW5nIGZyb21cbiAgICAgICAgLy8gRmlyZWZveC9DaHJvbWUgZXhwZXJpbWVudGFsIGltcGxlbWVudGF0aW9uc1xuICAgICAgICBpZiAoIVAuaGFzT3duUHJvcGVydHkoXCJyZXNvbHZlXCIpIHx8ICFQLmhhc093blByb3BlcnR5KFwicmVqZWN0XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVAuaGFzT3duUHJvcGVydHkoXCJhbGxcIikgfHwgIVAuaGFzT3duUHJvcGVydHkoXCJyYWNlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbGRlciB2ZXJzaW9uIG9mIHRoZSBzcGVjIGhhZCBhIHJlc29sdmVyIG9iamVjdFxuICAgICAgICAvLyBhcyB0aGUgYXJnIHJhdGhlciB0aGFuIGEgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIHJlc29sdmUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHZhciBwID0gbmV3IGdsb2JhbE9iamVjdC5Qcm9taXNlKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXNvbHZlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KCk7XG4gICAgfSgpO1xuXG4gICAgLy8gRXhwb3J0IHRoZSBuYXRpdmUgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBpZiBpdFxuICAgIC8vIGxvb2tzIGxpa2UgaXQgbWF0Y2hlcyB0aGUgc3BlY1xuICAgIGlmIChoYXNQcm9taXNlU3VwcG9ydCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsT2JqZWN0LlByb21pc2U7XG4gICAgfVxuXG4gICAgLy8gIE90aGVyd2lzZSwgcmV0dXJuIHRoZSBlczYtcHJvbWlzZSBwb2x5ZmlsbCBieSBAamFmZmF0aGVjYWtlLlxuICAgIHJldHVybiByZXF1aXJlKFwiZXM2LXByb21pc2VcIikuUHJvbWlzZTtcbn0oKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/es6-promisify/dist/promise.js\n");

/***/ }),

/***/ "./node_modules/es6-promisify/dist/promisify.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promisify/dist/promisify.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global module, require */\nmodule.exports = function () {\n\n    \"use strict\";\n\n    // Get a promise object. This may be native, or it may be polyfilled\n\n    var ES6Promise = __webpack_require__(/*! ./promise.js */ \"./node_modules/es6-promisify/dist/promise.js\");\n\n    /**\n     * thatLooksLikeAPromiseToMe()\n     *\n     * Duck-types a promise.\n     *\n     * @param {object} o\n     * @return {bool} True if this resembles a promise\n     */\n    function thatLooksLikeAPromiseToMe(o) {\n        return o && typeof o.then === \"function\" && typeof o.catch === \"function\";\n    }\n\n    /**\n     * promisify()\n     *\n     * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n     * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n     * and rejects when `error` is truthy. You can also supply settings object as the second argument.\n     *\n     * @param {function} original - The function to promisify\n     * @param {object} settings - Settings object\n     * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`\n     * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?\n     * @return {function} A promisified version of `original`\n     */\n    return function promisify(original, settings) {\n\n        return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var returnMultipleArguments = settings && settings.multiArgs;\n\n            var target = void 0;\n            if (settings && settings.thisArg) {\n                target = settings.thisArg;\n            } else if (settings) {\n                target = settings;\n            }\n\n            // Return the promisified function\n            return new ES6Promise(function (resolve, reject) {\n\n                // Append the callback bound to the context\n                args.push(function callback(err) {\n\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                        values[_key2 - 1] = arguments[_key2];\n                    }\n\n                    if (false === !!returnMultipleArguments) {\n                        return resolve(values[0]);\n                    }\n\n                    resolve(values);\n                });\n\n                // Call the function\n                var response = original.apply(target, args);\n\n                // If it looks like original already returns a promise,\n                // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.\n                if (thatLooksLikeAPromiseToMe(response)) {\n                    resolve(response);\n                }\n            });\n        };\n    };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2lmeS9kaXN0L3Byb21pc2lmeS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2lmeS9kaXN0L3Byb21pc2lmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIEdldCBhIHByb21pc2Ugb2JqZWN0LiBUaGlzIG1heSBiZSBuYXRpdmUsIG9yIGl0IG1heSBiZSBwb2x5ZmlsbGVkXG5cbiAgICB2YXIgRVM2UHJvbWlzZSA9IHJlcXVpcmUoXCIuL3Byb21pc2UuanNcIik7XG5cbiAgICAvKipcbiAgICAgKiB0aGF0TG9va3NMaWtlQVByb21pc2VUb01lKClcbiAgICAgKlxuICAgICAqIER1Y2stdHlwZXMgYSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICAgKiBAcmV0dXJuIHtib29sfSBUcnVlIGlmIHRoaXMgcmVzZW1ibGVzIGEgcHJvbWlzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRoYXRMb29rc0xpa2VBUHJvbWlzZVRvTWUobykge1xuICAgICAgICByZXR1cm4gbyAmJiB0eXBlb2Ygby50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG8uY2F0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9taXNpZnkoKVxuICAgICAqXG4gICAgICogVHJhbnNmb3JtcyBjYWxsYmFjay1iYXNlZCBmdW5jdGlvbiAtLSBmdW5jKGFyZzEsIGFyZzIgLi4gYXJnTiwgY2FsbGJhY2spIC0tIGludG9cbiAgICAgKiBhbiBFUzYtY29tcGF0aWJsZSBQcm9taXNlLiBQcm9taXNpZnkgcHJvdmlkZXMgYSBkZWZhdWx0IGNhbGxiYWNrIG9mIHRoZSBmb3JtIChlcnJvciwgcmVzdWx0KVxuICAgICAqIGFuZCByZWplY3RzIHdoZW4gYGVycm9yYCBpcyB0cnV0aHkuIFlvdSBjYW4gYWxzbyBzdXBwbHkgc2V0dGluZ3Mgb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcmlnaW5hbCAtIFRoZSBmdW5jdGlvbiB0byBwcm9taXNpZnlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgLSBTZXR0aW5ncyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MudGhpc0FyZyAtIEEgYHRoaXNgIGNvbnRleHQgdG8gdXNlLiBJZiBub3Qgc2V0LCBhc3N1bWUgYHNldHRpbmdzYCBfaXNfIGB0aGlzQXJnYFxuICAgICAqIEBwYXJhbSB7Ym9vbH0gc2V0dGluZ3MubXVsdGlBcmdzIC0gU2hvdWxkIG11bHRpcGxlIGFyZ3VtZW50cyBiZSByZXR1cm5lZCBhcyBhbiBhcnJheT9cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQSBwcm9taXNpZmllZCB2ZXJzaW9uIG9mIGBvcmlnaW5hbGBcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsLCBzZXR0aW5ncykge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXR1cm5NdWx0aXBsZUFyZ3VtZW50cyA9IHNldHRpbmdzICYmIHNldHRpbmdzLm11bHRpQXJncztcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy50aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2V0dGluZ3MudGhpc0FyZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBwcm9taXNpZmllZCBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFUzZQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgY2FsbGJhY2sgYm91bmQgdG8gdGhlIGNvbnRleHRcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gY2FsbGJhY2soZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UgPT09ICEhcmV0dXJuTXVsdGlwbGVBcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG9yaWdpbmFsLmFwcGx5KHRhcmdldCwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIG9yaWdpbmFsIGFscmVhZHkgcmV0dXJucyBhIHByb21pc2UsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBqdXN0IHJlc29sdmUgd2l0aCB0aGF0IHByb21pc2UuIEhvcGVmdWxseSwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdlIGFkZGVkIHdpbGwganVzdCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAgIGlmICh0aGF0TG9va3NMaWtlQVByb21pc2VUb01lKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufSgpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es6-promisify/dist/promisify.js\n");

/***/ }),

/***/ "./node_modules/fd-slicer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fd-slicer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = __webpack_require__(/*! pend */ \"./node_modules/pend/index.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmQtc2xpY2VyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9mZC1zbGljZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIFJlYWRhYmxlID0gc3RyZWFtLlJlYWRhYmxlO1xudmFyIFdyaXRhYmxlID0gc3RyZWFtLldyaXRhYmxlO1xudmFyIFBhc3NUaHJvdWdoID0gc3RyZWFtLlBhc3NUaHJvdWdoO1xudmFyIFBlbmQgPSByZXF1aXJlKCdwZW5kJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5leHBvcnRzLmNyZWF0ZUZyb21CdWZmZXIgPSBjcmVhdGVGcm9tQnVmZmVyO1xuZXhwb3J0cy5jcmVhdGVGcm9tRmQgPSBjcmVhdGVGcm9tRmQ7XG5leHBvcnRzLkJ1ZmZlclNsaWNlciA9IEJ1ZmZlclNsaWNlcjtcbmV4cG9ydHMuRmRTbGljZXIgPSBGZFNsaWNlcjtcblxudXRpbC5pbmhlcml0cyhGZFNsaWNlciwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIEZkU2xpY2VyKGZkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmZkID0gZmQ7XG4gIHRoaXMucGVuZCA9IG5ldyBQZW5kKCk7XG4gIHRoaXMucGVuZC5tYXggPSAxO1xuICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgdGhpcy5hdXRvQ2xvc2UgPSAhIW9wdGlvbnMuYXV0b0Nsb3NlO1xufVxuXG5GZFNsaWNlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGVuZC5nbyhmdW5jdGlvbihjYikge1xuICAgIGZzLnJlYWQoc2VsZi5mZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGZ1bmN0aW9uKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpIHtcbiAgICAgIGNiKCk7XG4gICAgICBjYWxsYmFjayhlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5GZFNsaWNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBlbmQuZ28oZnVuY3Rpb24oY2IpIHtcbiAgICBmcy53cml0ZShzZWxmLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgZnVuY3Rpb24oZXJyLCB3cml0dGVuLCBidWZmZXIpIHtcbiAgICAgIGNiKCk7XG4gICAgICBjYWxsYmFjayhlcnIsIHdyaXR0ZW4sIGJ1ZmZlcik7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuRmRTbGljZXIucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhZFN0cmVhbSh0aGlzLCBvcHRpb25zKTtcbn07XG5cbkZkU2xpY2VyLnByb3RvdHlwZS5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbSh0aGlzLCBvcHRpb25zKTtcbn07XG5cbkZkU2xpY2VyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWZDb3VudCArPSAxO1xufTtcblxuRmRTbGljZXIucHJvdG90eXBlLnVucmVmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5yZWZDb3VudCAtPSAxO1xuXG4gIGlmIChzZWxmLnJlZkNvdW50ID4gMCkgcmV0dXJuO1xuICBpZiAoc2VsZi5yZWZDb3VudCA8IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdW5yZWZcIik7XG5cbiAgaWYgKHNlbGYuYXV0b0Nsb3NlKSB7XG4gICAgZnMuY2xvc2Uoc2VsZi5mZCwgb25DbG9zZURvbmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DbG9zZURvbmUoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwuaW5oZXJpdHMoUmVhZFN0cmVhbSwgUmVhZGFibGUpO1xuZnVuY3Rpb24gUmVhZFN0cmVhbShjb250ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuY29udGV4dC5yZWYoKTtcblxuICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuICB0aGlzLmVuZE9mZnNldCA9IG9wdGlvbnMuZW5kO1xuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG59XG5cblJlYWRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gIHZhciB0b1JlYWQgPSBNYXRoLm1pbihzZWxmLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmssIG4pO1xuICBpZiAoc2VsZi5lbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgIHRvUmVhZCA9IE1hdGgubWluKHRvUmVhZCwgc2VsZi5lbmRPZmZzZXQgLSBzZWxmLnBvcyk7XG4gIH1cbiAgaWYgKHRvUmVhZCA8PSAwKSB7XG4gICAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHNlbGYucHVzaChudWxsKTtcbiAgICBzZWxmLmNvbnRleHQudW5yZWYoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi5jb250ZXh0LnBlbmQuZ28oZnVuY3Rpb24oY2IpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYigpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvUmVhZCk7XG4gICAgZnMucmVhZChzZWxmLmNvbnRleHQuZmQsIGJ1ZmZlciwgMCwgdG9SZWFkLCBzZWxmLnBvcywgZnVuY3Rpb24oZXJyLCBieXRlc1JlYWQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5kZXN0cm95KGVycik7XG4gICAgICB9IGVsc2UgaWYgKGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICBzZWxmLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICAgICAgc2VsZi5jb250ZXh0LnVucmVmKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnBvcyArPSBieXRlc1JlYWQ7XG4gICAgICAgIHNlbGYucHVzaChidWZmZXIuc2xpY2UoMCwgYnl0ZXNSZWFkKSk7XG4gICAgICB9XG4gICAgICBjYigpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblJlYWRTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm47XG4gIGVyciA9IGVyciB8fCBuZXcgRXJyb3IoXCJzdHJlYW0gZGVzdHJveWVkXCIpO1xuICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNvbnRleHQudW5yZWYoKTtcbn07XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGVTdHJlYW0sIFdyaXRhYmxlKTtcbmZ1bmN0aW9uIFdyaXRlU3RyZWFtKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5jb250ZXh0LnJlZigpO1xuXG4gIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XG4gIHRoaXMuZW5kT2Zmc2V0ID0gKG9wdGlvbnMuZW5kID09IG51bGwpID8gSW5maW5pdHkgOiArb3B0aW9ucy5lbmQ7XG4gIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIHRoaXMub24oJ2ZpbmlzaCcsIHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpKTtcbn1cblxuV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgaWYgKHNlbGYucG9zICsgYnVmZmVyLmxlbmd0aCA+IHNlbGYuZW5kT2Zmc2V0KSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIm1heGltdW0gZmlsZSBsZW5ndGggZXhjZWVkZWRcIik7XG4gICAgZXJyLmNvZGUgPSAnRVRPT0JJRyc7XG4gICAgc2VsZi5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi5jb250ZXh0LnBlbmQuZ28oZnVuY3Rpb24oY2IpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYigpO1xuICAgIGZzLndyaXRlKHNlbGYuY29udGV4dC5mZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBzZWxmLnBvcywgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgY2IoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBzZWxmLnBvcyArPSBieXRlcztcbiAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycpO1xuICAgICAgICBjYigpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbldyaXRlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuO1xuICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIHRoaXMuY29udGV4dC51bnJlZigpO1xufTtcblxudXRpbC5pbmhlcml0cyhCdWZmZXJTbGljZXIsIEV2ZW50RW1pdHRlcik7XG5mdW5jdGlvbiBCdWZmZXJTbGljZXIoYnVmZmVyLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIHRoaXMubWF4Q2h1bmtTaXplID0gb3B0aW9ucy5tYXhDaHVua1NpemUgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbkJ1ZmZlclNsaWNlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgZW5kID0gcG9zaXRpb24gKyBsZW5ndGg7XG4gIHZhciBkZWx0YSA9IGVuZCAtIHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgdmFyIHdyaXR0ZW4gPSAoZGVsdGEgPiAwKSA/IGRlbHRhIDogbGVuZ3RoO1xuICB0aGlzLmJ1ZmZlci5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCBwb3NpdGlvbiwgZW5kKTtcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKG51bGwsIHdyaXR0ZW4pO1xuICB9KTtcbn07XG5cbkJ1ZmZlclNsaWNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgYnVmZmVyLmNvcHkodGhpcy5idWZmZXIsIHBvc2l0aW9uLCBvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBjYWxsYmFjayhudWxsLCBsZW5ndGgsIGJ1ZmZlcik7XG4gIH0pO1xufTtcblxuQnVmZmVyU2xpY2VyLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlYWRTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIHJlYWRTdHJlYW0uZGVzdHJveWVkID0gZmFsc2U7XG4gIHJlYWRTdHJlYW0uc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XG4gIHJlYWRTdHJlYW0uZW5kT2Zmc2V0ID0gb3B0aW9ucy5lbmQ7XG4gIC8vIGJ5IHRoZSB0aW1lIHRoaXMgZnVuY3Rpb24gcmV0dXJucywgd2UnbGwgYmUgZG9uZS5cbiAgcmVhZFN0cmVhbS5wb3MgPSByZWFkU3RyZWFtLmVuZE9mZnNldCB8fCB0aGlzLmJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gcmVzcGVjdCB0aGUgbWF4Q2h1bmtTaXplIG9wdGlvbiB0byBzbGljZSB1cCB0aGUgY2h1bmsgaW50byBzbWFsbGVyIHBpZWNlcy5cbiAgdmFyIGVudGlyZVNsaWNlID0gdGhpcy5idWZmZXIuc2xpY2UocmVhZFN0cmVhbS5zdGFydCwgcmVhZFN0cmVhbS5wb3MpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE9mZnNldCA9IG9mZnNldCArIHRoaXMubWF4Q2h1bmtTaXplO1xuICAgIGlmIChuZXh0T2Zmc2V0ID49IGVudGlyZVNsaWNlLmxlbmd0aCkge1xuICAgICAgLy8gbGFzdCBjaHVua1xuICAgICAgaWYgKG9mZnNldCA8IGVudGlyZVNsaWNlLmxlbmd0aCkge1xuICAgICAgICByZWFkU3RyZWFtLndyaXRlKGVudGlyZVNsaWNlLnNsaWNlKG9mZnNldCwgZW50aXJlU2xpY2UubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVhZFN0cmVhbS53cml0ZShlbnRpcmVTbGljZS5zbGljZShvZmZzZXQsIG5leHRPZmZzZXQpKTtcbiAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICB9XG5cbiAgcmVhZFN0cmVhbS5lbmQoKTtcbiAgcmVhZFN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgcmVhZFN0cmVhbS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gcmVhZFN0cmVhbTtcbn07XG5cbkJ1ZmZlclNsaWNlci5wcm90b3R5cGUuY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBidWZmZXJTbGljZXIgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHdyaXRlU3RyZWFtID0gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB3cml0ZVN0cmVhbS5zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgMDtcbiAgd3JpdGVTdHJlYW0uZW5kT2Zmc2V0ID0gKG9wdGlvbnMuZW5kID09IG51bGwpID8gdGhpcy5idWZmZXIubGVuZ3RoIDogK29wdGlvbnMuZW5kO1xuICB3cml0ZVN0cmVhbS5ieXRlc1dyaXR0ZW4gPSAwO1xuICB3cml0ZVN0cmVhbS5wb3MgPSB3cml0ZVN0cmVhbS5zdGFydDtcbiAgd3JpdGVTdHJlYW0uZGVzdHJveWVkID0gZmFsc2U7XG4gIHdyaXRlU3RyZWFtLl93cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdyaXRlU3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgdmFyIGVuZCA9IHdyaXRlU3RyZWFtLnBvcyArIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKGVuZCA+IHdyaXRlU3RyZWFtLmVuZE9mZnNldCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIm1heGltdW0gZmlsZSBsZW5ndGggZXhjZWVkZWRcIik7XG4gICAgICBlcnIuY29kZSA9ICdFVE9PQklHJztcbiAgICAgIHdyaXRlU3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBidWZmZXIuY29weShidWZmZXJTbGljZXIuYnVmZmVyLCB3cml0ZVN0cmVhbS5wb3MsIDAsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgd3JpdGVTdHJlYW0uYnl0ZXNXcml0dGVuICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgd3JpdGVTdHJlYW0ucG9zID0gZW5kO1xuICAgIHdyaXRlU3RyZWFtLmVtaXQoJ3Byb2dyZXNzJyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgd3JpdGVTdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHdyaXRlU3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiB3cml0ZVN0cmVhbTtcbn07XG5cbkJ1ZmZlclNsaWNlci5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVmQ291bnQgKz0gMTtcbn07XG5cbkJ1ZmZlclNsaWNlci5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWZDb3VudCAtPSAxO1xuXG4gIGlmICh0aGlzLnJlZkNvdW50IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdW5yZWZcIik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyU2xpY2VyKGJ1ZmZlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21GZChmZCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEZkU2xpY2VyKGZkLCBvcHRpb25zKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fd-slicer/index.js\n");

/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (flag, argv) {\n\targv = argv || process.argv;\n\n\tvar terminatorPos = argv.indexOf('--');\n\tvar prefix = /^-{1,2}/.test(flag) ? '' : '--';\n\tvar pos = argv.indexOf(prefix + flag);\n\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZsYWcsIGFyZ3YpIHtcblx0YXJndiA9IGFyZ3YgfHwgcHJvY2Vzcy5hcmd2O1xuXG5cdHZhciB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuXHR2YXIgcHJlZml4ID0gL14tezEsMn0vLnRlc3QoZmxhZykgPyAnJyA6ICctLSc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cblx0cmV0dXJuIHBvcyAhPT0gLTEgJiYgKHRlcm1pbmF0b3JQb3MgPT09IC0xID8gdHJ1ZSA6IHBvcyA8IHRlcm1pbmF0b3JQb3MpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/has-flag/index.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/index.js":
/*!*************************************************!*\
  !*** ./node_modules/https-proxy-agent/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar net = __webpack_require__(/*! net */ \"net\");\nvar tls = __webpack_require__(/*! tls */ \"tls\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar Agent = __webpack_require__(/*! agent-base */ \"./node_modules/agent-base/index.js\");\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/https-proxy-agent/node_modules/debug/src/index.js\")('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts)\n    throw new Error(\n      'an HTTP(S) proxy server `host` and `port` must be specified!'\n    );\n  debug('creating new HttpsProxyAgent instance: %o', opts);\n  Agent.call(this, opts);\n\n  var proxy = Object.assign({}, opts);\n\n  // if `true`, then connect to the proxy server over TLS. defaults to `false`.\n  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;\n\n  // prefer `hostname` over `host`, and set the `port` if needed\n  proxy.host = proxy.hostname || proxy.host;\n  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n  // ALPN is supported by Node.js >= v5.\n  // attempt to negotiate http/1.1 for proxy servers that support http/2\n  if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n    proxy.ALPNProtocols = ['http 1.1']\n  }\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  this.proxy = proxy;\n  this.defaultPort = 443;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy;\n\n  // create a socket connection to the proxy server\n  var socket;\n  if (this.secureProxy) {\n    socket = tls.connect(proxy);\n  } else {\n    socket = net.connect(proxy);\n  }\n\n  // we need to buffer any HTTP traffic that happens with the proxy before we get\n  // the CONNECT response, so that if the response is anything other than an \"200\"\n  // response code, then we can re-play the \"data\" events on the socket once the\n  // HTTP parser is hooked up...\n  var buffers = [];\n  var buffersLength = 0;\n\n  function read() {\n    var b = socket.read();\n    if (b) ondata(b);\n    else socket.once('readable', read);\n  }\n\n  function cleanup() {\n    socket.removeListener('data', ondata);\n    socket.removeListener('end', onend);\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    socket.removeListener('readable', read);\n  }\n\n  function onclose(err) {\n    debug('onclose had error %o', err);\n  }\n\n  function onend() {\n    debug('onend');\n  }\n\n  function onerror(err) {\n    cleanup();\n    fn(err);\n  }\n\n  function ondata(b) {\n    buffers.push(b);\n    buffersLength += b.length;\n    var buffered = Buffer.concat(buffers, buffersLength);\n    var str = buffered.toString('ascii');\n\n    if (!~str.indexOf('\\r\\n\\r\\n')) {\n      // keep buffering\n      debug('have not received end of HTTP headers yet...');\n      if (socket.read) {\n        read();\n      } else {\n        socket.once('data', ondata);\n      }\n      return;\n    }\n\n    var firstLine = str.substring(0, str.indexOf('\\r\\n'));\n    var statusCode = +firstLine.split(' ')[1];\n    debug('got proxy server response: %o', firstLine);\n\n    if (200 == statusCode) {\n      // 200 Connected status code!\n      var sock = socket;\n\n      // nullify the buffered data since we won't be needing it\n      buffers = buffered = null;\n\n      if (opts.secureEndpoint) {\n        // since the proxy is connecting to an SSL server, we have\n        // to upgrade this socket connection to an SSL connection\n        debug(\n          'upgrading proxy-connected socket to TLS connection: %o',\n          opts.host\n        );\n        opts.socket = socket;\n        opts.servername = opts.servername || opts.host;\n        opts.host = null;\n        opts.hostname = null;\n        opts.port = null;\n        sock = tls.connect(opts);\n      }\n\n      cleanup();\n      fn(null, sock);\n    } else {\n      // some other status code that's not 200... need to re-play the HTTP header\n      // \"data\" events onto the socket once the HTTP machinery is attached so that\n      // the user can parse and handle the error status code\n      cleanup();\n\n      // save a reference to the concat'd Buffer for the `onsocket` callback\n      buffers = buffered;\n\n      // need to wait for the \"socket\" event to re-play the \"data\" events\n      req.once('socket', onsocket);\n      fn(null, socket);\n    }\n  }\n\n  function onsocket(socket) {\n    // replay the \"buffers\" Buffer onto the `socket`, since at this point\n    // the HTTP module machinery has been hooked up for the user\n    if ('function' == typeof socket.ondata) {\n      // node <= v0.11.3, the `ondata` function is set on the socket\n      socket.ondata(buffers, 0, buffers.length);\n    } else if (socket.listeners('data').length > 0) {\n      // node > v0.11.3, the \"data\" event is listened for directly\n      socket.emit('data', buffers);\n    } else {\n      // never?\n      throw new Error('should not happen...');\n    }\n\n    // nullify the cached Buffer instance\n    buffers = null;\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('end', onend);\n\n  if (socket.read) {\n    read();\n  } else {\n    socket.once('data', ondata);\n  }\n\n  var hostname = opts.host + ':' + opts.port;\n  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n\n  var headers = Object.assign({}, proxy.headers);\n  if (proxy.auth) {\n    headers['Proxy-Authorization'] =\n      'Basic ' + Buffer.from(proxy.auth).toString('base64');\n  }\n\n  // the Host header should only include the port\n  // number when it is a non-standard port\n  var host = opts.host;\n  if (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n    host += ':' + opts.port;\n  }\n  headers['Host'] = host;\n\n  headers['Connection'] = 'close';\n  Object.keys(headers).forEach(function(name) {\n    msg += name + ': ' + headers[name] + '\\r\\n';\n  });\n\n  socket.write(msg + '\\r\\n');\n};\n\nfunction isDefaultPort(port, secure) {\n  return Boolean((!secure && port === 80) || (secure && port === 443));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdGxzID0gcmVxdWlyZSgndGxzJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgQWdlbnQgPSByZXF1aXJlKCdhZ2VudC1iYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdodHRwcy1wcm94eS1hZ2VudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cHNQcm94eUFnZW50O1xuXG4vKipcbiAqIFRoZSBgSHR0cHNQcm94eUFnZW50YCBpbXBsZW1lbnRzIGFuIEhUVFAgQWdlbnQgc3ViY2xhc3MgdGhhdCBjb25uZWN0cyB0byB0aGVcbiAqIHNwZWNpZmllZCBcIkhUVFAocykgcHJveHkgc2VydmVyXCIgaW4gb3JkZXIgdG8gcHJveHkgSFRUUFMgcmVxdWVzdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBIdHRwc1Byb3h5QWdlbnQob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSHR0cHNQcm94eUFnZW50KSkgcmV0dXJuIG5ldyBIdHRwc1Byb3h5QWdlbnQob3B0cyk7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb3B0cykgb3B0cyA9IHVybC5wYXJzZShvcHRzKTtcbiAgaWYgKCFvcHRzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdhbiBIVFRQKFMpIHByb3h5IHNlcnZlciBgaG9zdGAgYW5kIGBwb3J0YCBtdXN0IGJlIHNwZWNpZmllZCEnXG4gICAgKTtcbiAgZGVidWcoJ2NyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvJywgb3B0cyk7XG4gIEFnZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdmFyIHByb3h5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG5cbiAgLy8gaWYgYHRydWVgLCB0aGVuIGNvbm5lY3QgdG8gdGhlIHByb3h5IHNlcnZlciBvdmVyIFRMUy4gZGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgdGhpcy5zZWN1cmVQcm94eSA9IHByb3h5LnByb3RvY29sID8gL15odHRwczo/JC9pLnRlc3QocHJveHkucHJvdG9jb2wpIDogZmFsc2U7XG5cbiAgLy8gcHJlZmVyIGBob3N0bmFtZWAgb3ZlciBgaG9zdGAsIGFuZCBzZXQgdGhlIGBwb3J0YCBpZiBuZWVkZWRcbiAgcHJveHkuaG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gIHByb3h5LnBvcnQgPSArcHJveHkucG9ydCB8fCAodGhpcy5zZWN1cmVQcm94eSA/IDQ0MyA6IDgwKTtcblxuICAvLyBBTFBOIGlzIHN1cHBvcnRlZCBieSBOb2RlLmpzID49IHY1LlxuICAvLyBhdHRlbXB0IHRvIG5lZ290aWF0ZSBodHRwLzEuMSBmb3IgcHJveHkgc2VydmVycyB0aGF0IHN1cHBvcnQgaHR0cC8yXG4gIGlmICh0aGlzLnNlY3VyZVByb3h5ICYmICEoJ0FMUE5Qcm90b2NvbHMnIGluIHByb3h5KSkge1xuICAgIHByb3h5LkFMUE5Qcm90b2NvbHMgPSBbJ2h0dHAgMS4xJ11cbiAgfVxuXG4gIGlmIChwcm94eS5ob3N0ICYmIHByb3h5LnBhdGgpIHtcbiAgICAvLyBpZiBib3RoIGEgYGhvc3RgIGFuZCBgcGF0aGAgYXJlIHNwZWNpZmllZCB0aGVuIGl0J3MgbW9zdCBsaWtlbHkgdGhlXG4gICAgLy8gcmVzdWx0IG9mIGEgYHVybC5wYXJzZSgpYCBjYWxsLi4uIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBgcGF0aGAgcG9ydGlvbiBzb1xuICAgIC8vIHRoYXQgYG5ldC5jb25uZWN0KClgIGRvZXNuJ3QgYXR0ZW1wdCB0byBvcGVuIHRoYXQgYXMgYSB1bml4IHNvY2tldCBmaWxlLlxuICAgIGRlbGV0ZSBwcm94eS5wYXRoO1xuICAgIGRlbGV0ZSBwcm94eS5wYXRobmFtZTtcbiAgfVxuXG4gIHRoaXMucHJveHkgPSBwcm94eTtcbiAgdGhpcy5kZWZhdWx0UG9ydCA9IDQ0Mztcbn1cbmluaGVyaXRzKEh0dHBzUHJveHlBZ2VudCwgQWdlbnQpO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhIG5ldyBIVFRQIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5IdHRwc1Byb3h5QWdlbnQucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24gY29ubmVjdChyZXEsIG9wdHMsIGZuKSB7XG4gIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG5cbiAgLy8gY3JlYXRlIGEgc29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlclxuICB2YXIgc29ja2V0O1xuICBpZiAodGhpcy5zZWN1cmVQcm94eSkge1xuICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHByb3h5KTtcbiAgfSBlbHNlIHtcbiAgICBzb2NrZXQgPSBuZXQuY29ubmVjdChwcm94eSk7XG4gIH1cblxuICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBidWZmZXJzTGVuZ3RoID0gMDtcblxuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHZhciBiID0gc29ja2V0LnJlYWQoKTtcbiAgICBpZiAoYikgb25kYXRhKGIpO1xuICAgIGVsc2Ugc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcmVhZCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKGVycikge1xuICAgIGRlYnVnKCdvbmNsb3NlIGhhZCBlcnJvciAlbycsIGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGZuKGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBvbmRhdGEoYikge1xuICAgIGJ1ZmZlcnMucHVzaChiKTtcbiAgICBidWZmZXJzTGVuZ3RoICs9IGIubGVuZ3RoO1xuICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgYnVmZmVyc0xlbmd0aCk7XG4gICAgdmFyIHN0ciA9IGJ1ZmZlcmVkLnRvU3RyaW5nKCdhc2NpaScpO1xuXG4gICAgaWYgKCF+c3RyLmluZGV4T2YoJ1xcclxcblxcclxcbicpKSB7XG4gICAgICAvLyBrZWVwIGJ1ZmZlcmluZ1xuICAgICAgZGVidWcoJ2hhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uJyk7XG4gICAgICBpZiAoc29ja2V0LnJlYWQpIHtcbiAgICAgICAgcmVhZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0Lm9uY2UoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmaXJzdExpbmUgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5pbmRleE9mKCdcXHJcXG4nKSk7XG4gICAgdmFyIHN0YXR1c0NvZGUgPSArZmlyc3RMaW5lLnNwbGl0KCcgJylbMV07XG4gICAgZGVidWcoJ2dvdCBwcm94eSBzZXJ2ZXIgcmVzcG9uc2U6ICVvJywgZmlyc3RMaW5lKTtcblxuICAgIGlmICgyMDAgPT0gc3RhdHVzQ29kZSkge1xuICAgICAgLy8gMjAwIENvbm5lY3RlZCBzdGF0dXMgY29kZSFcbiAgICAgIHZhciBzb2NrID0gc29ja2V0O1xuXG4gICAgICAvLyBudWxsaWZ5IHRoZSBidWZmZXJlZCBkYXRhIHNpbmNlIHdlIHdvbid0IGJlIG5lZWRpbmcgaXRcbiAgICAgIGJ1ZmZlcnMgPSBidWZmZXJlZCA9IG51bGw7XG5cbiAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGFuIFNTTCBzZXJ2ZXIsIHdlIGhhdmVcbiAgICAgICAgLy8gdG8gdXBncmFkZSB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGFuIFNTTCBjb25uZWN0aW9uXG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgICd1cGdyYWRpbmcgcHJveHktY29ubmVjdGVkIHNvY2tldCB0byBUTFMgY29ubmVjdGlvbjogJW8nLFxuICAgICAgICAgIG9wdHMuaG9zdFxuICAgICAgICApO1xuICAgICAgICBvcHRzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgb3B0cy5zZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lIHx8IG9wdHMuaG9zdDtcbiAgICAgICAgb3B0cy5ob3N0ID0gbnVsbDtcbiAgICAgICAgb3B0cy5ob3N0bmFtZSA9IG51bGw7XG4gICAgICAgIG9wdHMucG9ydCA9IG51bGw7XG4gICAgICAgIHNvY2sgPSB0bHMuY29ubmVjdChvcHRzKTtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpO1xuICAgICAgZm4obnVsbCwgc29jayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNvbWUgb3RoZXIgc3RhdHVzIGNvZGUgdGhhdCdzIG5vdCAyMDAuLi4gbmVlZCB0byByZS1wbGF5IHRoZSBIVFRQIGhlYWRlclxuICAgICAgLy8gXCJkYXRhXCIgZXZlbnRzIG9udG8gdGhlIHNvY2tldCBvbmNlIHRoZSBIVFRQIG1hY2hpbmVyeSBpcyBhdHRhY2hlZCBzbyB0aGF0XG4gICAgICAvLyB0aGUgdXNlciBjYW4gcGFyc2UgYW5kIGhhbmRsZSB0aGUgZXJyb3Igc3RhdHVzIGNvZGVcbiAgICAgIGNsZWFudXAoKTtcblxuICAgICAgLy8gc2F2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29uY2F0J2QgQnVmZmVyIGZvciB0aGUgYG9uc29ja2V0YCBjYWxsYmFja1xuICAgICAgYnVmZmVycyA9IGJ1ZmZlcmVkO1xuXG4gICAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIHRoZSBcInNvY2tldFwiIGV2ZW50IHRvIHJlLXBsYXkgdGhlIFwiZGF0YVwiIGV2ZW50c1xuICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIG9uc29ja2V0KTtcbiAgICAgIGZuKG51bGwsIHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25zb2NrZXQoc29ja2V0KSB7XG4gICAgLy8gcmVwbGF5IHRoZSBcImJ1ZmZlcnNcIiBCdWZmZXIgb250byB0aGUgYHNvY2tldGAsIHNpbmNlIGF0IHRoaXMgcG9pbnRcbiAgICAvLyB0aGUgSFRUUCBtb2R1bGUgbWFjaGluZXJ5IGhhcyBiZWVuIGhvb2tlZCB1cCBmb3IgdGhlIHVzZXJcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc29ja2V0Lm9uZGF0YSkge1xuICAgICAgLy8gbm9kZSA8PSB2MC4xMS4zLCB0aGUgYG9uZGF0YWAgZnVuY3Rpb24gaXMgc2V0IG9uIHRoZSBzb2NrZXRcbiAgICAgIHNvY2tldC5vbmRhdGEoYnVmZmVycywgMCwgYnVmZmVycy5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoc29ja2V0Lmxpc3RlbmVycygnZGF0YScpLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG5vZGUgPiB2MC4xMS4zLCB0aGUgXCJkYXRhXCIgZXZlbnQgaXMgbGlzdGVuZWQgZm9yIGRpcmVjdGx5XG4gICAgICBzb2NrZXQuZW1pdCgnZGF0YScsIGJ1ZmZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXZlcj9cbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hvdWxkIG5vdCBoYXBwZW4uLi4nKTtcbiAgICB9XG5cbiAgICAvLyBudWxsaWZ5IHRoZSBjYWNoZWQgQnVmZmVyIGluc3RhbmNlXG4gICAgYnVmZmVycyA9IG51bGw7XG4gIH1cblxuICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHNvY2tldC5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgc29ja2V0Lm9uKCdlbmQnLCBvbmVuZCk7XG5cbiAgaWYgKHNvY2tldC5yZWFkKSB7XG4gICAgcmVhZCgpO1xuICB9IGVsc2Uge1xuICAgIHNvY2tldC5vbmNlKCdkYXRhJywgb25kYXRhKTtcbiAgfVxuXG4gIHZhciBob3N0bmFtZSA9IG9wdHMuaG9zdCArICc6JyArIG9wdHMucG9ydDtcbiAgdmFyIG1zZyA9ICdDT05ORUNUICcgKyBob3N0bmFtZSArICcgSFRUUC8xLjFcXHJcXG4nO1xuXG4gIHZhciBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJveHkuaGVhZGVycyk7XG4gIGlmIChwcm94eS5hdXRoKSB7XG4gICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID1cbiAgICAgICdCYXNpYyAnICsgQnVmZmVyLmZyb20ocHJveHkuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgLy8gdGhlIEhvc3QgaGVhZGVyIHNob3VsZCBvbmx5IGluY2x1ZGUgdGhlIHBvcnRcbiAgLy8gbnVtYmVyIHdoZW4gaXQgaXMgYSBub24tc3RhbmRhcmQgcG9ydFxuICB2YXIgaG9zdCA9IG9wdHMuaG9zdDtcbiAgaWYgKCFpc0RlZmF1bHRQb3J0KG9wdHMucG9ydCwgb3B0cy5zZWN1cmVFbmRwb2ludCkpIHtcbiAgICBob3N0ICs9ICc6JyArIG9wdHMucG9ydDtcbiAgfVxuICBoZWFkZXJzWydIb3N0J10gPSBob3N0O1xuXG4gIGhlYWRlcnNbJ0Nvbm5lY3Rpb24nXSA9ICdjbG9zZSc7XG4gIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIG1zZyArPSBuYW1lICsgJzogJyArIGhlYWRlcnNbbmFtZV0gKyAnXFxyXFxuJztcbiAgfSk7XG5cbiAgc29ja2V0LndyaXRlKG1zZyArICdcXHJcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFBvcnQocG9ydCwgc2VjdXJlKSB7XG4gIHJldHVybiBCb29sZWFuKCghc2VjdXJlICYmIHBvcnQgPT09IDgwKSB8fCAoc2VjdXJlICYmIHBvcnQgPT09IDQ0MykpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/index.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/node_modules/debug/src/browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/debug/src/browser.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/https-proxy-agent/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/node_modules/debug/src/common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/debug/src/common.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/https-proxy-agent/node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/node_modules/debug/src/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/debug/src/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/https-proxy-agent/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/https-proxy-agent/node_modules/debug/src/node.js\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/node_modules/debug/src/node.js":
/*!***********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/debug/src/node.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Module dependencies.\n */\nvar tty = __webpack_require__(/*! tty */ \"tty\");\n\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var supportsColor = __webpack_require__(/*! supports-color */ \"./node_modules/supports-color/index.js\");\n\n  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n  }\n} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // Camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  }); // Coerce string value into JS value\n\n  var val = process.env[key];\n\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true;\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false;\n  } else if (val === 'null') {\n    val = null;\n  } else {\n    val = Number(val);\n  }\n\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var name = this.namespace,\n      useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = \"\\x1B[3\" + (c < 8 ? c : '8;5;' + c);\n    var prefix = \"  \".concat(colorCode, \";1m\").concat(name, \" \\x1B[0m\");\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + \"\\x1B[0m\");\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  }\n\n  return new Date().toISOString() + ' ';\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env.DEBUG = namespaces;\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/https-proxy-agent/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).replace(/\\s*\\n\\s*/g, ' ');\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nformatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuICAvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gIHZhciBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuICBpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuICAgIGV4cG9ydHMuY29sb3JzID0gWzIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LCA2OSwgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsIDgxLCA5MiwgOTMsIDk4LCA5OSwgMTEyLCAxMTMsIDEyOCwgMTI5LCAxMzQsIDEzNSwgMTQ4LCAxNDksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTQsIDIxNSwgMjIwLCAyMjFdO1xuICB9XG59IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBDYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5LnN1YnN0cmluZyg2KS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgcmV0dXJuIGsudG9VcHBlckNhc2UoKTtcbiAgfSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgdmFsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcbiAgICB2YWwgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2UsXG4gICAgICB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSBcIlxceDFCWzNcIiArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gXCIgIFwiLmNvbmNhdChjb2xvckNvZGUsIFwiOzFtXCIpLmNvbmNhdChuYW1lLCBcIiBcXHgxQlswbVwiKTtcbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgXCJcXHgxQlswbVwiKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgaWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKS5yZXBsYWNlKC9cXHMqXFxuXFxzKi9nLCAnICcpO1xufTtcbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/node_modules/ms/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/https-proxy-agent/node_modules/ms/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/edit.js":
/*!***************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/edit.js ***!
  \***************************************************/
/*! exports provided: removeProperty, setProperty, applyEdit, isWS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeProperty\", function() { return removeProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setProperty\", function() { return setProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyEdit\", function() { return applyEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWS\", function() { return isWS; });\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./node_modules/jsonc-parser/lib/esm/main.js\");\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format */ \"./node_modules/jsonc-parser/lib/esm/format.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nfunction removeProperty(text, path, formattingOptions) {\n    return setProperty(text, path, void 0, formattingOptions);\n}\nfunction setProperty(text, path, value, formattingOptions, getInsertionIndex) {\n    var errors = [];\n    var root = Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"parseTree\"])(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"findNodeAtLocation\"])(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) {\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = Object(_main__WEBPACK_IMPORTED_MODULE_0__[\"findNodeAtLocation\"])(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) {\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n            }\n        }\n        else {\n            if (value === void 0) {\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n        else {\n            if (value === void 0 && parent.children.length >= 0) {\n                //Removal\n                var removalIndex = lastSegment;\n                var toRemove = parent.children[removalIndex];\n                var edit = void 0;\n                if (parent.children.length === 1) {\n                    // only item\n                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                }\n                else if (parent.children.length - 1 === removalIndex) {\n                    // last item\n                    var previous = parent.children[removalIndex - 1];\n                    var offset = previous.offset + previous.length;\n                    var parentEndOffset = parent.offset + parent.length;\n                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                }\n                else {\n                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                throw new Error('Array modification not supported yet');\n            }\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n    var _a;\n}\nfunction withFormatting(text, edit, formattingOptions) {\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) {\n        while (begin > 0 && !Object(_format__WEBPACK_IMPORTED_MODULE_1__[\"isEOL\"])(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !Object(_format__WEBPACK_IMPORTED_MODULE_1__[\"isEOL\"])(newText, end)) {\n            end++;\n        }\n    }\n    var edits = Object(_format__WEBPACK_IMPORTED_MODULE_1__[\"format\"])(newText, { offset: begin, length: end - begin }, formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nfunction applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nfunction isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n//# sourceMappingURL=edit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vZWRpdC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vZWRpdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IHBhcnNlVHJlZSwgZmluZE5vZGVBdExvY2F0aW9uIH0gZnJvbSAnLi9tYWluJztcbmltcG9ydCB7IGZvcm1hdCwgaXNFT0wgfSBmcm9tICcuL2Zvcm1hdCc7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkodGV4dCwgcGF0aCwgZm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICByZXR1cm4gc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdm9pZCAwLCBmb3JtYXR0aW5nT3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdmFsdWUsIGZvcm1hdHRpbmdPcHRpb25zLCBnZXRJbnNlcnRpb25JbmRleCkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgcm9vdCA9IHBhcnNlVHJlZSh0ZXh0LCBlcnJvcnMpO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gdm9pZCAwO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdFNlZ21lbnQgPSBwYXRoLnBvcCgpO1xuICAgICAgICBwYXJlbnQgPSBmaW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKF9hID0ge30sIF9hW2xhc3RTZWdtZW50XSA9IHZhbHVlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAvLyBlbXB0eSBkb2N1bWVudFxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGRlbGV0ZSBpbiBlbXB0eSBkb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogcm9vdCA/IHJvb3Qub2Zmc2V0IDogMCwgbGVuZ3RoOiByb290ID8gcm9vdC5sZW5ndGggOiAwLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfSwgZm9ybWF0dGluZ09wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gZmluZE5vZGVBdExvY2F0aW9uKHBhcmVudCwgW2xhc3RTZWdtZW50XSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIEFTVCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGV4aXN0aW5nLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUJlZ2luID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVFbmQgPSBleGlzdGluZy5wYXJlbnQub2Zmc2V0ICsgZXhpc3RpbmcucGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgcHJldmlvdXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcHJvcGVydHlJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVCZWdpbiA9IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUJlZ2luID0gcGFyZW50Lm9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHBhcmVudC5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVuZCA9IG5leHQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogcmVtb3ZlQmVnaW4sIGxlbmd0aDogcmVtb3ZlRW5kIC0gcmVtb3ZlQmVnaW4sIGNvbnRlbnQ6ICcnIH0sIGZvcm1hdHRpbmdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSBvZiBleGlzdGluZyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogZXhpc3Rpbmcub2Zmc2V0LCBsZW5ndGg6IGV4aXN0aW5nLmxlbmd0aCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIGZvcm1hdHRpbmdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCwgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1Byb3BlcnR5ID0gSlNPTi5zdHJpbmdpZnkobGFzdFNlZ21lbnQpICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5zZXJ0aW9uSW5kZXggPyBnZXRJbnNlcnRpb25JbmRleChwYXJlbnQuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNoaWxkcmVuWzBdLnZhbHVlOyB9KSkgOiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGVkaXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGgsIGxlbmd0aDogMCwgY29udGVudDogJywnICsgbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgZm9ybWF0dGluZ09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudC50eXBlID09PSAnYXJyYXknICYmIHR5cGVvZiBsYXN0U2VnbWVudCA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShwYXJlbnQuY2hpbGRyZW4pKSB7XG4gICAgICAgIHZhciBpbnNlcnRJbmRleCA9IGxhc3RTZWdtZW50O1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IFwiXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIGZvcm1hdHRpbmdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vUmVtb3ZhbFxuICAgICAgICAgICAgICAgIHZhciByZW1vdmFsSW5kZXggPSBsYXN0U2VnbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiBwYXJlbnQubGVuZ3RoIC0gMiwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEgPT09IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3JlbW92YWxJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50RW5kT2Zmc2V0ID0gcGFyZW50Lm9mZnNldCArIHBhcmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IHBhcmVudEVuZE9mZnNldCAtIDIgLSBvZmZzZXQsIGNvbnRlbnQ6ICcnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHRvUmVtb3ZlLm9mZnNldCwgbGVuZ3RoOiBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4ICsgMV0ub2Zmc2V0IC0gdG9SZW1vdmUub2Zmc2V0LCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgZm9ybWF0dGluZ09wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBtb2RpZmljYXRpb24gbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhZGQgXCIgKyAodHlwZW9mIGxhc3RTZWdtZW50ICE9PSAnbnVtYmVyJyA/ICdpbmRleCcgOiAncHJvcGVydHknKSArIFwiIHRvIHBhcmVudCBvZiB0eXBlIFwiICsgcGFyZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YXIgX2E7XG59XG5mdW5jdGlvbiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBmb3JtYXR0aW5nT3B0aW9ucykge1xuICAgIC8vIGFwcGx5IHRoZSBlZGl0XG4gICAgdmFyIG5ld1RleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdCk7XG4gICAgLy8gZm9ybWF0IHRoZSBuZXcgdGV4dFxuICAgIHZhciBiZWdpbiA9IGVkaXQub2Zmc2V0O1xuICAgIHZhciBlbmQgPSBlZGl0Lm9mZnNldCArIGVkaXQuY29udGVudC5sZW5ndGg7XG4gICAgaWYgKGVkaXQubGVuZ3RoID09PSAwIHx8IGVkaXQuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgd2hpbGUgKGJlZ2luID4gMCAmJiAhaXNFT0wobmV3VGV4dCwgYmVnaW4gLSAxKSkge1xuICAgICAgICAgICAgYmVnaW4tLTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbmV3VGV4dC5sZW5ndGggJiYgIWlzRU9MKG5ld1RleHQsIGVuZCkpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlZGl0cyA9IGZvcm1hdChuZXdUZXh0LCB7IG9mZnNldDogYmVnaW4sIGxlbmd0aDogZW5kIC0gYmVnaW4gfSwgZm9ybWF0dGluZ09wdGlvbnMpO1xuICAgIC8vIGFwcGx5IHRoZSBmb3JtYXR0aW5nIGVkaXRzIGFuZCB0cmFjayB0aGUgYmVnaW4gYW5kIGVuZCBvZmZzZXRzIG9mIHRoZSBjaGFuZ2VzXG4gICAgZm9yICh2YXIgaSA9IGVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlZGl0XzEgPSBlZGl0c1tpXTtcbiAgICAgICAgbmV3VGV4dCA9IGFwcGx5RWRpdChuZXdUZXh0LCBlZGl0XzEpO1xuICAgICAgICBiZWdpbiA9IE1hdGgubWluKGJlZ2luLCBlZGl0XzEub2Zmc2V0KTtcbiAgICAgICAgZW5kID0gTWF0aC5tYXgoZW5kLCBlZGl0XzEub2Zmc2V0ICsgZWRpdF8xLmxlbmd0aCk7XG4gICAgICAgIGVuZCArPSBlZGl0XzEuY29udGVudC5sZW5ndGggLSBlZGl0XzEubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBzaW5nbGUgZWRpdCB3aXRoIGFsbCBjaGFuZ2VzXG4gICAgdmFyIGVkaXRMZW5ndGggPSB0ZXh0Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCAtIGVuZCkgLSBiZWdpbjtcbiAgICByZXR1cm4gW3sgb2Zmc2V0OiBiZWdpbiwgbGVuZ3RoOiBlZGl0TGVuZ3RoLCBjb250ZW50OiBuZXdUZXh0LnN1YnN0cmluZyhiZWdpbiwgZW5kKSB9XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUVkaXQodGV4dCwgZWRpdCkge1xuICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBlZGl0Lm9mZnNldCkgKyBlZGl0LmNvbnRlbnQgKyB0ZXh0LnN1YnN0cmluZyhlZGl0Lm9mZnNldCArIGVkaXQubGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1dTKHRleHQsIG9mZnNldCkge1xuICAgIHJldHVybiAnXFxyXFxuIFxcdCcuaW5kZXhPZih0ZXh0LmNoYXJBdChvZmZzZXQpKSAhPT0gLTE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZGl0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jsonc-parser/lib/esm/edit.js\n");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/format.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/format.js ***!
  \*****************************************************/
/*! exports provided: format, isEOL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEOL\", function() { return isEOL; });\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ \"./node_modules/jsonc-parser/lib/esm/main.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, 0, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = _main__WEBPACK_IMPORTED_MODULE_0__[\"createScanner\"](formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].Trivia || token === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineBreakTrivia) {\n            lineBreak = lineBreak || (token === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineBreakTrivia);\n            token = scanner.scan();\n        }\n        hasError = token === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].Unknown || scanner.getTokenError() !== _main__WEBPACK_IMPORTED_MODULE_0__[\"ScanError\"].None;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].EOF) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].EOF) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineCommentTrivia || secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].BlockCommentTrivia)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineCommentTrivia ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CloseBraceToken) {\n            if (firstToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].OpenBraceToken) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CloseBracketToken) {\n            if (firstToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].OpenBracketToken) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].OpenBracketToken:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].OpenBraceToken:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CommaToken:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineCommentTrivia:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].BlockCommentTrivia:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].ColonToken:\n                    replaceContent = ' ';\n                    break;\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].StringLiteral:\n                    if (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].ColonToken) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].NullKeyword:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].TrueKeyword:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].FalseKeyword:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].NumericLiteral:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CloseBraceToken:\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CloseBracketToken:\n                    if (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineCommentTrivia || secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].BlockCommentTrivia) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].CommaToken && secondToken !== _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].EOF) {\n                        hasError = true;\n                    }\n                    break;\n                case _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].Unknown:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].LineCommentTrivia || secondToken === _main__WEBPACK_IMPORTED_MODULE_0__[\"SyntaxKind\"].BlockCommentTrivia)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, offset, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nfunction isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vZm9ybWF0LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9qc29uYy1wYXJzZXIvbGliL2VzbS9mb3JtYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vbWFpbic7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGRvY3VtZW50VGV4dCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5pdGlhbEluZGVudExldmVsO1xuICAgIHZhciBmb3JtYXRUZXh0O1xuICAgIHZhciBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgdmFyIHJhbmdlU3RhcnQ7XG4gICAgdmFyIHJhbmdlRW5kO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZVN0YXJ0ID0gcmFuZ2Uub2Zmc2V0O1xuICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyByYW5nZS5sZW5ndGg7XG4gICAgICAgIGZvcm1hdFRleHRTdGFydCA9IHJhbmdlU3RhcnQ7XG4gICAgICAgIHdoaWxlIChmb3JtYXRUZXh0U3RhcnQgPiAwICYmICFpc0VPTChkb2N1bWVudFRleHQsIGZvcm1hdFRleHRTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0U3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gcmFuZ2VFbmQ7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBkb2N1bWVudFRleHQubGVuZ3RoICYmICFpc0VPTChkb2N1bWVudFRleHQsIGVuZE9mZnNldCkpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdFRleHQgPSBkb2N1bWVudFRleHQuc3Vic3RyaW5nKGZvcm1hdFRleHRTdGFydCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgaW5pdGlhbEluZGVudExldmVsID0gY29tcHV0ZUluZGVudExldmVsKGZvcm1hdFRleHQsIDAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9ybWF0VGV4dCA9IGRvY3VtZW50VGV4dDtcbiAgICAgICAgaW5pdGlhbEluZGVudExldmVsID0gMDtcbiAgICAgICAgZm9ybWF0VGV4dFN0YXJ0ID0gMDtcbiAgICAgICAgcmFuZ2VTdGFydCA9IDA7XG4gICAgICAgIHJhbmdlRW5kID0gZG9jdW1lbnRUZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGVvbCA9IGdldEVPTChvcHRpb25zLCBkb2N1bWVudFRleHQpO1xuICAgIHZhciBsaW5lQnJlYWsgPSBmYWxzZTtcbiAgICB2YXIgaW5kZW50TGV2ZWwgPSAwO1xuICAgIHZhciBpbmRlbnRWYWx1ZTtcbiAgICBpZiAob3B0aW9ucy5pbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgaW5kZW50VmFsdWUgPSByZXBlYXQoJyAnLCBvcHRpb25zLnRhYlNpemUgfHwgNCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRlbnRWYWx1ZSA9ICdcXHQnO1xuICAgIH1cbiAgICB2YXIgc2Nhbm5lciA9IEpzb24uY3JlYXRlU2Nhbm5lcihmb3JtYXRUZXh0LCBmYWxzZSk7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gbmV3TGluZUFuZEluZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTmV4dCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIGxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5Ucml2aWEgfHwgdG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEpIHtcbiAgICAgICAgICAgIGxpbmVCcmVhayA9IGxpbmVCcmVhayB8fCAodG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEpO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFcnJvciA9IHRva2VuID09PSBKc29uLlN5bnRheEtpbmQuVW5rbm93biB8fCBzY2FubmVyLmdldFRva2VuRXJyb3IoKSAhPT0gSnNvbi5TY2FuRXJyb3IuTm9uZTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICB2YXIgZWRpdE9wZXJhdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBhZGRFZGl0KHRleHQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgaWYgKCFoYXNFcnJvciAmJiBzdGFydE9mZnNldCA8IHJhbmdlRW5kICYmIGVuZE9mZnNldCA+IHJhbmdlU3RhcnQgJiYgZG9jdW1lbnRUZXh0LnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSAhPT0gdGV4dCkge1xuICAgICAgICAgICAgZWRpdE9wZXJhdGlvbnMucHVzaCh7IG9mZnNldDogc3RhcnRPZmZzZXQsIGxlbmd0aDogZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsIGNvbnRlbnQ6IHRleHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpcnN0VG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgIGlmIChmaXJzdFRva2VuICE9PSBKc29uLlN5bnRheEtpbmQuRU9GKSB7XG4gICAgICAgIHZhciBmaXJzdFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIHZhciBpbml0aWFsSW5kZW50ID0gcmVwZWF0KGluZGVudFZhbHVlLCBpbml0aWFsSW5kZW50TGV2ZWwpO1xuICAgICAgICBhZGRFZGl0KGluaXRpYWxJbmRlbnQsIGZvcm1hdFRleHRTdGFydCwgZmlyc3RUb2tlblN0YXJ0KTtcbiAgICB9XG4gICAgd2hpbGUgKGZpcnN0VG9rZW4gIT09IEpzb24uU3ludGF4S2luZC5FT0YpIHtcbiAgICAgICAgdmFyIGZpcnN0VG9rZW5FbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIHZhciBzZWNvbmRUb2tlbiA9IHNjYW5OZXh0KCk7XG4gICAgICAgIHZhciByZXBsYWNlQ29udGVudCA9ICcnO1xuICAgICAgICB3aGlsZSAoIWxpbmVCcmVhayAmJiAoc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSB8fCBzZWNvbmRUb2tlbiA9PT0gSnNvbi5TeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSkpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzIG9uIHRoZSBzYW1lIGxpbmU6IGtlZXAgdGhlbSBvbiB0aGUgc2FtZSBsaW5lLCBidXQgaWdub3JlIHRoZW0gb3RoZXJ3aXNlXG4gICAgICAgICAgICB2YXIgY29tbWVudFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgICAgICBhZGRFZGl0KCcgJywgZmlyc3RUb2tlbkVuZCwgY29tbWVudFRva2VuU3RhcnQpO1xuICAgICAgICAgICAgZmlyc3RUb2tlbkVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSA/IG5ld0xpbmVBbmRJbmRlbnQoKSA6ICcnO1xuICAgICAgICAgICAgc2Vjb25kVG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWNvbmRUb2tlbiA9PT0gSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbikge1xuICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4gIT09IEpzb24uU3ludGF4S2luZC5PcGVuQnJhY2VUb2tlbikge1xuICAgICAgICAgICAgICAgIGluZGVudExldmVsLS07XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbikge1xuICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4gIT09IEpzb24uU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RUb2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgSnNvbi5TeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW46XG4gICAgICAgICAgICAgICAgY2FzZSBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW46XG4gICAgICAgICAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZUFuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuOlxuICAgICAgICAgICAgICAgIGNhc2UgSnNvbi5TeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhOlxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBKc29uLlN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhOlxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbCBmb2xsb3dpbmcgY29tbWVudCBvbiB0aGUgc2FtZSBsaW5lOiBrZWVwIG9uIHNhbWUgbGluZSwgc2VwYXJhdGUgd2l0aCAnICdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgSnNvbi5TeW50YXhLaW5kLkNvbG9uVG9rZW46XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5Db2xvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIEpzb24uU3ludGF4S2luZC5OdWxsS2V5d29yZDpcbiAgICAgICAgICAgICAgICBjYXNlIEpzb24uU3ludGF4S2luZC5UcnVlS2V5d29yZDpcbiAgICAgICAgICAgICAgICBjYXNlIEpzb24uU3ludGF4S2luZC5GYWxzZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAgY2FzZSBKc29uLlN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgICAgICAgICAgY2FzZSBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuOlxuICAgICAgICAgICAgICAgIGNhc2UgSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSB8fCBzZWNvbmRUb2tlbiA9PT0gSnNvbi5TeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kVG9rZW4gIT09IEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICYmIHNlY29uZFRva2VuICE9PSBKc29uLlN5bnRheEtpbmQuRU9GKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBKc29uLlN5bnRheEtpbmQuVW5rbm93bjpcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lQnJlYWsgJiYgKHNlY29uZFRva2VuID09PSBKc29uLlN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgfHwgc2Vjb25kVG9rZW4gPT09IEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEpKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlY29uZFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIGFkZEVkaXQocmVwbGFjZUNvbnRlbnQsIGZpcnN0VG9rZW5FbmQsIHNlY29uZFRva2VuU3RhcnQpO1xuICAgICAgICBmaXJzdFRva2VuID0gc2Vjb25kVG9rZW47XG4gICAgfVxuICAgIHJldHVybiBlZGl0T3BlcmF0aW9ucztcbn1cbmZ1bmN0aW9uIHJlcGVhdChzLCBjb3VudCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlSW5kZW50TGV2ZWwoY29udGVudCwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuQ2hhcnMgPSAwO1xuICAgIHZhciB0YWJTaXplID0gb3B0aW9ucy50YWJTaXplIHx8IDQ7XG4gICAgd2hpbGUgKGkgPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBjb250ZW50LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpIHtcbiAgICAgICAgICAgIG5DaGFycysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgbkNoYXJzICs9IHRhYlNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKG5DaGFycyAvIHRhYlNpemUpO1xufVxuZnVuY3Rpb24gZ2V0RU9MKG9wdGlvbnMsIHRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcclxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1xccic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChvcHRpb25zICYmIG9wdGlvbnMuZW9sKSB8fCAnXFxuJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VPTCh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbicuaW5kZXhPZih0ZXh0LmNoYXJBdChvZmZzZXQpKSAhPT0gLTE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jsonc-parser/lib/esm/format.js\n");

/***/ }),

/***/ "./node_modules/jsonc-parser/lib/esm/main.js":
/*!***************************************************!*\
  !*** ./node_modules/jsonc-parser/lib/esm/main.js ***!
  \***************************************************/
/*! exports provided: ScanError, SyntaxKind, createScanner, stripComments, ParseErrorCode, getLocation, parse, parseTree, findNodeAtLocation, getNodeValue, visit, format, modify, applyEdits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScanError\", function() { return ScanError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SyntaxKind\", function() { return SyntaxKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createScanner\", function() { return createScanner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripComments\", function() { return stripComments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseErrorCode\", function() { return ParseErrorCode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLocation\", function() { return getLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTree\", function() { return parseTree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNodeAtLocation\", function() { return findNodeAtLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNodeValue\", function() { return getNodeValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visit\", function() { return visit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modify\", function() { return modify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyEdits\", function() { return applyEdits; });\n/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format */ \"./node_modules/jsonc-parser/lib/esm/format.js\");\n/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edit */ \"./node_modules/jsonc-parser/lib/esm/edit.js\");\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nvar ScanError;\n(function (ScanError) {\n    ScanError[ScanError[\"None\"] = 0] = \"None\";\n    ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n    ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n    ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n    ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n    ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError || (ScanError = {}));\nvar SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"Unknown\"] = 0] = \"Unknown\";\n    SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n    SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n    SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n    SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n    SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n    SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n    SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n    SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n    SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n    SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n    SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n    SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n    SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n    SyntaxKind[SyntaxKind[\"EOF\"] = 16] = \"EOF\";\n})(SyntaxKind || (SyntaxKind = {}));\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nfunction createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = SyntaxKind.Unknown;\n        scanError = ScanError.None;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = ScanError.UnexpectedEndOfNumber;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = ScanError.UnexpectedEndOfNumber;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = ScanError.UnexpectedEndOfString;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                ch = text.charCodeAt(pos++);\n                switch (ch) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch_1 = scanHexDigits(4, true);\n                        if (ch_1 >= 0) {\n                            result += String.fromCharCode(ch_1);\n                        }\n                        else {\n                            scanError = ScanError.InvalidUnicode;\n                        }\n                        break;\n                    default:\n                        scanError = ScanError.InvalidEscapeCharacter;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                else {\n                    scanError = ScanError.InvalidCharacter;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = ScanError.None;\n        tokenOffset = pos;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = SyntaxKind.EOF;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = SyntaxKind.Trivia;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            return token = SyntaxKind.LineBreakTrivia;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = SyntaxKind.OpenBraceToken;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = SyntaxKind.CloseBraceToken;\n            case 91 /* openBracket */:\n                pos++;\n                return token = SyntaxKind.OpenBracketToken;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = SyntaxKind.CloseBracketToken;\n            case 58 /* colon */:\n                pos++;\n                return token = SyntaxKind.ColonToken;\n            case 44 /* comma */:\n                pos++;\n                return token = SyntaxKind.CommaToken;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = SyntaxKind.StringLiteral;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = SyntaxKind.LineCommentTrivia;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var commentClosed = false;\n                    while (pos < len) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && (pos + 1 < len) && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = ScanError.UnexpectedEndOfComment;\n                    }\n                    value = text.substring(start, pos);\n                    return token = SyntaxKind.BlockCommentTrivia;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = SyntaxKind.Unknown;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = SyntaxKind.Unknown;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = SyntaxKind.NumericLiteral;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = SyntaxKind.TrueKeyword;\n                        case 'false': return token = SyntaxKind.FalseKeyword;\n                        case 'null': return token = SyntaxKind.NullKeyword;\n                    }\n                    return token = SyntaxKind.Unknown;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = SyntaxKind.Unknown;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenError: function () { return scanError; }\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nfunction stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case SyntaxKind.LineCommentTrivia:\n            case SyntaxKind.BlockCommentTrivia:\n            case SyntaxKind.EOF:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== void 0) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== SyntaxKind.EOF);\n    return parts.join('');\n}\nvar ParseErrorCode;\n(function (ParseErrorCode) {\n    ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 0] = \"InvalidSymbol\";\n    ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 1] = \"InvalidNumberFormat\";\n    ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 2] = \"PropertyNameExpected\";\n    ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 3] = \"ValueExpected\";\n    ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 4] = \"ColonExpected\";\n    ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 5] = \"CommaExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 6] = \"CloseBraceExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 7] = \"CloseBracketExpected\";\n    ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 8] = \"EndOfFileExpected\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 9] = \"InvalidCommentToken\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 10] = \"UnexpectedEndOfComment\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 11] = \"UnexpectedEndOfString\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 12] = \"UnexpectedEndOfNumber\";\n    ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 13] = \"InvalidUnicode\";\n    ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 14] = \"InvalidEscapeCharacter\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 15] = \"InvalidCharacter\";\n})(ParseErrorCode || (ParseErrorCode = {}));\nfunction getLiteralNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        default: return 'null';\n    }\n}\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nfunction getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = void 0;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object'\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.columnOffset = void 0;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = void 0;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.columnOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = void 0;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = void 0;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nfunction parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nfunction parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.columnOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nfunction findNodeAtLocation(root, path) {\n    if (!root) {\n        return void 0;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return void 0;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return void 0;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return void 0;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nfunction getNodeValue(node) {\n    if (node.type === 'array') {\n        return node.children.map(getNodeValue);\n    }\n    else if (node.type === 'object') {\n        var obj = Object.create(null);\n        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n            var prop = _a[_i];\n            obj[prop.children[0].value] = getNodeValue(prop.children[1]);\n        }\n        return obj;\n    }\n    return node.value;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nfunction visit(text, visitor, options) {\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case ScanError.InvalidUnicode:\n                    handleError(ParseErrorCode.InvalidUnicode);\n                    break;\n                case ScanError.InvalidEscapeCharacter:\n                    handleError(ParseErrorCode.InvalidEscapeCharacter);\n                    break;\n                case ScanError.UnexpectedEndOfNumber:\n                    handleError(ParseErrorCode.UnexpectedEndOfNumber);\n                    break;\n                case ScanError.UnexpectedEndOfComment:\n                    if (!disallowComments) {\n                        handleError(ParseErrorCode.UnexpectedEndOfComment);\n                    }\n                    break;\n                case ScanError.UnexpectedEndOfString:\n                    handleError(ParseErrorCode.UnexpectedEndOfString);\n                    break;\n                case ScanError.InvalidCharacter:\n                    handleError(ParseErrorCode.InvalidCharacter);\n                    break;\n            }\n            switch (token) {\n                case SyntaxKind.LineCommentTrivia:\n                case SyntaxKind.BlockCommentTrivia:\n                    if (disallowComments) {\n                        handleError(ParseErrorCode.InvalidCommentToken);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case SyntaxKind.Unknown:\n                    handleError(ParseErrorCode.InvalidSymbol);\n                    break;\n                case SyntaxKind.Trivia:\n                case SyntaxKind.LineBreakTrivia:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== SyntaxKind.EOF) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case SyntaxKind.NumericLiteral:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(ParseErrorCode.InvalidNumberFormat);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(ParseErrorCode.InvalidNumberFormat);\n                }\n                onLiteralValue(value);\n                break;\n            case SyntaxKind.NullKeyword:\n                onLiteralValue(null);\n                break;\n            case SyntaxKind.TrueKeyword:\n                onLiteralValue(true);\n                break;\n            case SyntaxKind.FalseKeyword:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n            handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === SyntaxKind.ColonToken) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n        }\n        else {\n            handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n            if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                if (!needsComma) {\n                    handleError(ParseErrorCode.ValueExpected, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(ParseErrorCode.CommaExpected, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n            handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n            if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                if (!needsComma) {\n                    handleError(ParseErrorCode.ValueExpected, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(ParseErrorCode.CommaExpected, [], []);\n            }\n            if (!parseValue()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n            handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case SyntaxKind.OpenBracketToken:\n                return parseArray();\n            case SyntaxKind.OpenBraceToken:\n                return parseObject();\n            case SyntaxKind.StringLiteral:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === SyntaxKind.EOF) {\n        return true;\n    }\n    if (!parseValue()) {\n        handleError(ParseErrorCode.ValueExpected, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== SyntaxKind.EOF) {\n        handleError(ParseErrorCode.EndOfFileExpected, [], []);\n    }\n    return true;\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nfunction format(documentText, range, options) {\n    return Object(_format__WEBPACK_IMPORTED_MODULE_0__[\"format\"])(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nfunction modify(text, path, value, options) {\n    return Object(_edit__WEBPACK_IMPORTED_MODULE_1__[\"setProperty\"])(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nfunction applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = Object(_edit__WEBPACK_IMPORTED_MODULE_1__[\"applyEdit\"])(text, edits[i]);\n    }\n    return text;\n}\n//# sourceMappingURL=main.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGZvcm1hdCBhcyBfZm9ybWF0IH0gZnJvbSAnLi9mb3JtYXQnO1xuaW1wb3J0IHsgc2V0UHJvcGVydHksIGFwcGx5RWRpdCB9IGZyb20gJy4vZWRpdCc7XG5leHBvcnQgdmFyIFNjYW5FcnJvcjtcbihmdW5jdGlvbiAoU2NhbkVycm9yKSB7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMV0gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAzXSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRVbmljb2RlXCJdID0gNF0gPSBcIkludmFsaWRVbmljb2RlXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSA1XSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gNl0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbn0pKFNjYW5FcnJvciB8fCAoU2NhbkVycm9yID0ge30pKTtcbmV4cG9ydCB2YXIgU3ludGF4S2luZDtcbihmdW5jdGlvbiAoU3ludGF4S2luZCkge1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIk9wZW5CcmFjZVRva2VuXCJdID0gMV0gPSBcIk9wZW5CcmFjZVRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQ2xvc2VCcmFjZVRva2VuXCJdID0gMl0gPSBcIkNsb3NlQnJhY2VUb2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIk9wZW5CcmFja2V0VG9rZW5cIl0gPSAzXSA9IFwiT3BlbkJyYWNrZXRUb2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkNsb3NlQnJhY2tldFRva2VuXCJdID0gNF0gPSBcIkNsb3NlQnJhY2tldFRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQ29tbWFUb2tlblwiXSA9IDVdID0gXCJDb21tYVRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQ29sb25Ub2tlblwiXSA9IDZdID0gXCJDb2xvblRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiTnVsbEtleXdvcmRcIl0gPSA3XSA9IFwiTnVsbEtleXdvcmRcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJUcnVlS2V5d29yZFwiXSA9IDhdID0gXCJUcnVlS2V5d29yZFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkZhbHNlS2V5d29yZFwiXSA9IDldID0gXCJGYWxzZUtleXdvcmRcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJTdHJpbmdMaXRlcmFsXCJdID0gMTBdID0gXCJTdHJpbmdMaXRlcmFsXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiTnVtZXJpY0xpdGVyYWxcIl0gPSAxMV0gPSBcIk51bWVyaWNMaXRlcmFsXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiTGluZUNvbW1lbnRUcml2aWFcIl0gPSAxMl0gPSBcIkxpbmVDb21tZW50VHJpdmlhXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQmxvY2tDb21tZW50VHJpdmlhXCJdID0gMTNdID0gXCJCbG9ja0NvbW1lbnRUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJMaW5lQnJlYWtUcml2aWFcIl0gPSAxNF0gPSBcIkxpbmVCcmVha1RyaXZpYVwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlRyaXZpYVwiXSA9IDE1XSA9IFwiVHJpdmlhXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiRU9GXCJdID0gMTZdID0gXCJFT0ZcIjtcbn0pKFN5bnRheEtpbmQgfHwgKFN5bnRheEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FubmVyKHRleHQsIGlnbm9yZVRyaXZpYSkge1xuICAgIGlmIChpZ25vcmVUcml2aWEgPT09IHZvaWQgMCkgeyBpZ25vcmVUcml2aWEgPSBmYWxzZTsgfVxuICAgIHZhciBwb3MgPSAwLCBsZW4gPSB0ZXh0Lmxlbmd0aCwgdmFsdWUgPSAnJywgdG9rZW5PZmZzZXQgPSAwLCB0b2tlbiA9IFN5bnRheEtpbmQuVW5rbm93biwgc2NhbkVycm9yID0gU2NhbkVycm9yLk5vbmU7XG4gICAgZnVuY3Rpb24gc2NhbkhleERpZ2l0cyhjb3VudCwgZXhhY3QpIHtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgIHdoaWxlIChkaWdpdHMgPCBjb3VudCB8fCAhZXhhY3QpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID49IDQ4IC8qIF8wICovICYmIGNoIDw9IDU3IC8qIF85ICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA0OCAvKiBfMCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDY1IC8qIEEgKi8gJiYgY2ggPD0gNzAgLyogRiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gNjUgLyogQSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gOTcgLyogYSAqLyAmJiBjaCA8PSAxMDIgLyogZiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gOTcgLyogYSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWdpdHMgPCBjb3VudCkge1xuICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKSB7XG4gICAgICAgIHBvcyA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB0b2tlbk9mZnNldCA9IDA7XG4gICAgICAgIHRva2VuID0gU3ludGF4S2luZC5Vbmtub3duO1xuICAgICAgICBzY2FuRXJyb3IgPSBTY2FuRXJyb3IuTm9uZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk51bWJlcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zO1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ4IC8qIF8wICovKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0NiAvKiBkb3QgKi8pIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiAodGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDY5IC8qIEUgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwMSAvKiBlICovKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQzIC8qIHBsdXMgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1IC8qIG1pbnVzICovKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsIHN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAzNCAvKiBkb3VibGVRdW90ZSAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTIgLyogYmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM0IC8qIGRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFwiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDkyIC8qIGJhY2tzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0NyAvKiBzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OCAvKiBiICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAyIC8qIGYgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTAgLyogbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNCAvKiByICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2IC8qIHQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTcgLyogdSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaF8xID0gc2NhbkhleERpZ2l0cyg0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaF8xID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IFNjYW5FcnJvci5JbnZhbGlkVW5pY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gU2NhbkVycm9yLkludmFsaWRFc2NhcGVDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID49IDAgJiYgY2ggPD0gMHgxZikge1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IFNjYW5FcnJvci5JbnZhbGlkQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIGVycm9yIGJ1dCBjb250aW51ZSB3aXRoIHN0cmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICBzY2FuRXJyb3IgPSBTY2FuRXJyb3IuTm9uZTtcbiAgICAgICAgdG9rZW5PZmZzZXQgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0b2tlbk9mZnNldCA9IGxlbjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuRU9GO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIC8vIHRyaXZpYTogd2hpdGVzcGFjZVxuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChpc1doaXRlU3BhY2UoY29kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5Ucml2aWE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpdmlhOiBuZXdsaW5lc1xuICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY29kZSkpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAxMyAvKiBjYXJyaWFnZVJldHVybiAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTAgLyogbGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgLy8gdG9rZW5zOiBbXXt9OixcbiAgICAgICAgICAgIGNhc2UgMTIzIC8qIG9wZW5CcmFjZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuO1xuICAgICAgICAgICAgY2FzZSAxMjUgLyogY2xvc2VCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbjtcbiAgICAgICAgICAgIGNhc2UgOTEgLyogb3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuO1xuICAgICAgICAgICAgY2FzZSA5MyAvKiBjbG9zZUJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbjtcbiAgICAgICAgICAgIGNhc2UgNTggLyogY29sb24gKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5Db2xvblRva2VuO1xuICAgICAgICAgICAgY2FzZSA0NCAvKiBjb21tYSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSBTeW50YXhLaW5kLkNvbW1hVG9rZW47XG4gICAgICAgICAgICAvLyBzdHJpbmdzXG4gICAgICAgICAgICBjYXNlIDM0IC8qIGRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2NhblN0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDtcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzXG4gICAgICAgICAgICBjYXNlIDQ3IC8qIHNsYXNoICovOlxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvcyAtIDE7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIHNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNdWx0aS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0MiAvKiBhc3RlcmlzayAqLykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDQyIC8qIGFzdGVyaXNrICovICYmIChwb3MgKyAxIDwgbGVuKSAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIHNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnRDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGp1c3QgYSBzaW5nbGUgc2xhc2hcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuVW5rbm93bjtcbiAgICAgICAgICAgIC8vIG51bWJlcnNcbiAgICAgICAgICAgIGNhc2UgNDUgLyogbWludXMgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBsZW4gfHwgIWlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuVW5rbm93bjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3VuZCBhIG1pbnVzLCBmb2xsb3dlZCBieSBhIG51bWJlciBzb1xuICAgICAgICAgICAgLy8gd2UgZmFsbCB0aHJvdWdoIHRvIHByb2NlZWQgd2l0aCBzY2FubmluZ1xuICAgICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgICAgY2FzZSA0OCAvKiBfMCAqLzpcbiAgICAgICAgICAgIGNhc2UgNDkgLyogXzEgKi86XG4gICAgICAgICAgICBjYXNlIDUwIC8qIF8yICovOlxuICAgICAgICAgICAgY2FzZSA1MSAvKiBfMyAqLzpcbiAgICAgICAgICAgIGNhc2UgNTIgLyogXzQgKi86XG4gICAgICAgICAgICBjYXNlIDUzIC8qIF81ICovOlxuICAgICAgICAgICAgY2FzZSA1NCAvKiBfNiAqLzpcbiAgICAgICAgICAgIGNhc2UgNTUgLyogXzcgKi86XG4gICAgICAgICAgICBjYXNlIDU2IC8qIF84ICovOlxuICAgICAgICAgICAgY2FzZSA1NyAvKiBfOSAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBzY2FuTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5OdW1lcmljTGl0ZXJhbDtcbiAgICAgICAgICAgIC8vIGxpdGVyYWxzIGFuZCB1bmtub3duIHN5bWJvbHNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gaXMgYSBsaXRlcmFsPyBSZWFkIHRoZSBmdWxsIHdvcmQuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbiAmJiBpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbk9mZnNldCAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcodG9rZW5PZmZzZXQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXdvcmRzOiB0cnVlLCBmYWxzZSwgbnVsbFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzogcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5UcnVlS2V5d29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzogcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5GYWxzZUtleXdvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzogcmV0dXJuIHRva2VuID0gU3ludGF4S2luZC5OdWxsS2V5d29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSBTeW50YXhLaW5kLlVua25vd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IFN5bnRheEtpbmQuVW5rbm93bjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjb2RlKSB8fCBpc0xpbmVCcmVhayhjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAxMjUgLyogY2xvc2VCcmFjZSAqLzpcbiAgICAgICAgICAgIGNhc2UgOTMgLyogY2xvc2VCcmFja2V0ICovOlxuICAgICAgICAgICAgY2FzZSAxMjMgLyogb3BlbkJyYWNlICovOlxuICAgICAgICAgICAgY2FzZSA5MSAvKiBvcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgIGNhc2UgMzQgLyogZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICBjYXNlIDU4IC8qIGNvbG9uICovOlxuICAgICAgICAgICAgY2FzZSA0NCAvKiBjb21tYSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0Tm9uVHJpdmlhKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgPSBzY2FuTmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChyZXN1bHQgPj0gU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAmJiByZXN1bHQgPD0gU3ludGF4S2luZC5Ucml2aWEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb3M7IH0sXG4gICAgICAgIHNjYW46IGlnbm9yZVRyaXZpYSA/IHNjYW5OZXh0Tm9uVHJpdmlhIDogc2Nhbk5leHQsXG4gICAgICAgIGdldFRva2VuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbjsgfSxcbiAgICAgICAgZ2V0VG9rZW5WYWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXG4gICAgICAgIGdldFRva2VuT2Zmc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbk9mZnNldDsgfSxcbiAgICAgICAgZ2V0VG9rZW5MZW5ndGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvcyAtIHRva2VuT2Zmc2V0OyB9LFxuICAgICAgICBnZXRUb2tlbkVycm9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2FuRXJyb3I7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSAzMiAvKiBzcGFjZSAqLyB8fCBjaCA9PT0gOSAvKiB0YWIgKi8gfHwgY2ggPT09IDExIC8qIHZlcnRpY2FsVGFiICovIHx8IGNoID09PSAxMiAvKiBmb3JtRmVlZCAqLyB8fFxuICAgICAgICBjaCA9PT0gMTYwIC8qIG5vbkJyZWFraW5nU3BhY2UgKi8gfHwgY2ggPT09IDU3NjAgLyogb2doYW0gKi8gfHwgY2ggPj0gODE5MiAvKiBlblF1YWQgKi8gJiYgY2ggPD0gODIwMyAvKiB6ZXJvV2lkdGhTcGFjZSAqLyB8fFxuICAgICAgICBjaCA9PT0gODIzOSAvKiBuYXJyb3dOb0JyZWFrU3BhY2UgKi8gfHwgY2ggPT09IDgyODcgLyogbWF0aGVtYXRpY2FsU3BhY2UgKi8gfHwgY2ggPT09IDEyMjg4IC8qIGlkZW9ncmFwaGljU3BhY2UgKi8gfHwgY2ggPT09IDY1Mjc5IC8qIGJ5dGVPcmRlck1hcmsgKi87XG59XG5mdW5jdGlvbiBpc0xpbmVCcmVhayhjaCkge1xuICAgIHJldHVybiBjaCA9PT0gMTAgLyogbGluZUZlZWQgKi8gfHwgY2ggPT09IDEzIC8qIGNhcnJpYWdlUmV0dXJuICovIHx8IGNoID09PSA4MjMyIC8qIGxpbmVTZXBhcmF0b3IgKi8gfHwgY2ggPT09IDgyMzMgLyogcGFyYWdyYXBoU2VwYXJhdG9yICovO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSA0OCAvKiBfMCAqLyAmJiBjaCA8PSA1NyAvKiBfOSAqLztcbn1cbi8qKlxuICogVGFrZXMgSlNPTiB3aXRoIEphdmFTY3JpcHQtc3R5bGUgY29tbWVudHMgYW5kIHJlbW92ZVxuICogdGhlbS4gT3B0aW9uYWxseSByZXBsYWNlcyBldmVyeSBub25lLW5ld2xpbmUgY2hhcmFjdGVyXG4gKiBvZiBjb21tZW50cyB3aXRoIGEgcmVwbGFjZUNoYXJhY3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBDb21tZW50cyh0ZXh0LCByZXBsYWNlQ2gpIHtcbiAgICB2YXIgX3NjYW5uZXIgPSBjcmVhdGVTY2FubmVyKHRleHQpLCBwYXJ0cyA9IFtdLCBraW5kLCBvZmZzZXQgPSAwLCBwb3M7XG4gICAgZG8ge1xuICAgICAgICBwb3MgPSBfc2Nhbm5lci5nZXRQb3NpdGlvbigpO1xuICAgICAgICBraW5kID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYTpcbiAgICAgICAgICAgIGNhc2UgU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWE6XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuRU9GOlxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRleHQuc3Vic3RyaW5nKG9mZnNldCwgcG9zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlQ2ggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKF9zY2FubmVyLmdldFRva2VuVmFsdWUoKS5yZXBsYWNlKC9bXlxcclxcbl0vZywgcmVwbGFjZUNoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9zY2FubmVyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChraW5kICE9PSBTeW50YXhLaW5kLkVPRik7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuZXhwb3J0IHZhciBQYXJzZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoUGFyc2VFcnJvckNvZGUpIHtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRTeW1ib2xcIl0gPSAwXSA9IFwiSW52YWxpZFN5bWJvbFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZE51bWJlckZvcm1hdFwiXSA9IDFdID0gXCJJbnZhbGlkTnVtYmVyRm9ybWF0XCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiXSA9IDJdID0gXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVmFsdWVFeHBlY3RlZFwiXSA9IDNdID0gXCJWYWx1ZUV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJDb2xvbkV4cGVjdGVkXCJdID0gNF0gPSBcIkNvbG9uRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNvbW1hRXhwZWN0ZWRcIl0gPSA1XSA9IFwiQ29tbWFFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ2xvc2VCcmFjZUV4cGVjdGVkXCJdID0gNl0gPSBcIkNsb3NlQnJhY2VFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ2xvc2VCcmFja2V0RXhwZWN0ZWRcIl0gPSA3XSA9IFwiQ2xvc2VCcmFja2V0RXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkVuZE9mRmlsZUV4cGVjdGVkXCJdID0gOF0gPSBcIkVuZE9mRmlsZUV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkQ29tbWVudFRva2VuXCJdID0gOV0gPSBcIkludmFsaWRDb21tZW50VG9rZW5cIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIl0gPSAxMF0gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiXSA9IDExXSA9IFwiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAxMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZFVuaWNvZGVcIl0gPSAxM10gPSBcIkludmFsaWRVbmljb2RlXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCJdID0gMTRdID0gXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gMTVdID0gXCJJbnZhbGlkQ2hhcmFjdGVyXCI7XG59KShQYXJzZUVycm9yQ29kZSB8fCAoUGFyc2VFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0TGl0ZXJhbE5vZGVUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ251bGwnO1xuICAgIH1cbn1cbi8qKlxuICogRm9yIGEgZ2l2ZW4gb2Zmc2V0LCBldmFsdWF0ZSB0aGUgbG9jYXRpb24gaW4gdGhlIEpTT04gZG9jdW1lbnQuIEVhY2ggc2VnbWVudCBpbiB0aGUgbG9jYXRpb24gcGF0aCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIGFycmF5IGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb24odGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTsgLy8gc3RyaW5ncyBvciBudW1iZXJzXG4gICAgdmFyIGVhcmx5UmV0dXJuRXhjZXB0aW9uID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBwcmV2aW91c05vZGUgPSB2b2lkIDA7XG4gICAgdmFyIHByZXZpb3VzTm9kZUluc3QgPSB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfTtcbiAgICB2YXIgaXNBdFByb3BlcnR5S2V5ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgdHlwZSkge1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3Qub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC50eXBlID0gdHlwZTtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5jb2x1bW5PZmZzZXQgPSB2b2lkIDA7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IHByZXZpb3VzTm9kZUluc3Q7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZpc2l0KHRleHQsIHtcbiAgICAgICAgICAgIG9uT2JqZWN0QmVnaW46IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBwb3NpdGlvbiA+IG9mZnNldDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKCcnKTsgLy8gcHVzaCBhIHBsYWNlaG9sZGVyICh3aWxsIGJlIHJlcGxhY2VkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT2JqZWN0UHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKG5hbWUsIG9mZnNldCwgbGVuZ3RoLCAncHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PYmplY3RFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFycmF5QmVnaW46IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXJyYXlFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgZ2V0TGl0ZXJhbE5vZGVUeXBlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZXBhcmF0b3I6IGZ1bmN0aW9uIChzZXAsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJzonICYmIHByZXZpb3VzTm9kZSAmJiBwcmV2aW91c05vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUuY29sdW1uT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXAgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IGxhc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBlYXJseVJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBzZWdtZW50cyxcbiAgICAgICAgcHJldmlvdXNOb2RlOiBwcmV2aW91c05vZGUsXG4gICAgICAgIGlzQXRQcm9wZXJ0eUtleTogaXNBdFByb3BlcnR5S2V5LFxuICAgICAgICBtYXRjaGVzOiBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGsgPCBwYXR0ZXJuLmxlbmd0aCAmJiBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybltrXSA9PT0gc2VnbWVudHNbaV0gfHwgcGF0dGVybltrXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybltrXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGsgPT09IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGVycm9ycywgb3B0aW9ucykge1xuICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkgeyBlcnJvcnMgPSBbXTsgfVxuICAgIHZhciBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgIHZhciBjdXJyZW50UGFyZW50ID0gW107XG4gICAgdmFyIHByZXZpb3VzUGFyZW50cyA9IFtdO1xuICAgIGZ1bmN0aW9uIG9uVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFBhcmVudCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFByb3BlcnR5KSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50W2N1cnJlbnRQcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmlzaXRvciA9IHtcbiAgICAgICAgb25PYmplY3RCZWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgb25WYWx1ZShvYmplY3QpO1xuICAgICAgICAgICAgcHJldmlvdXNQYXJlbnRzLnB1c2goY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb2JqZWN0O1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT2JqZWN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcHJldmlvdXNQYXJlbnRzLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5QmVnaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgb25WYWx1ZShhcnJheSk7XG4gICAgICAgICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBhcnJheTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGl0ZXJhbFZhbHVlOiBvblZhbHVlLFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7IGVycm9yOiBlcnJvciwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3VycmVudFBhcmVudFswXTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmVlKHRleHQsIGVycm9ycywgb3B0aW9ucykge1xuICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkgeyBlcnJvcnMgPSBbXTsgfVxuICAgIHZhciBjdXJyZW50UGFyZW50ID0geyB0eXBlOiAnYXJyYXknLCBvZmZzZXQ6IC0xLCBsZW5ndGg6IC0xLCBjaGlsZHJlbjogW10gfTsgLy8gYXJ0aWZpY2lhbCByb290XG4gICAgZnVuY3Rpb24gZW5zdXJlUHJvcGVydHlDb21wbGV0ZShlbmRPZmZzZXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5sZW5ndGggPSBlbmRPZmZzZXQgLSBjdXJyZW50UGFyZW50Lm9mZnNldDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblZhbHVlKHZhbHVlTm9kZSkge1xuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2godmFsdWVOb2RlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlTm9kZTtcbiAgICB9XG4gICAgdmFyIHZpc2l0b3IgPSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW46IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ29iamVjdCcsIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IC0xLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIGNoaWxkcmVuOiBbXSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb25WYWx1ZSh7IHR5cGU6ICdwcm9wZXJ0eScsIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IC0xLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIGNoaWxkcmVuOiBbXSB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbmFtZSwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT2JqZWN0RW5kOiBmdW5jdGlvbiAob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gb2Zmc2V0ICsgbGVuZ3RoIC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb25WYWx1ZSh7IHR5cGU6ICdhcnJheScsIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IC0xLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIGNoaWxkcmVuOiBbXSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcnJheUVuZDogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IG9mZnNldCArIGxlbmd0aCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxpdGVyYWxWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgb25WYWx1ZSh7IHR5cGU6IGdldExpdGVyYWxOb2RlVHlwZSh2YWx1ZSksIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2VwYXJhdG9yOiBmdW5jdGlvbiAoc2VwLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmNvbHVtbk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBlcnJvcjogZXJyb3IsIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmlzaXQodGV4dCwgdmlzaXRvciwgb3B0aW9ucyk7XG4gICAgdmFyIHJlc3VsdCA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBkZWxldGUgcmVzdWx0LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBhdGggaW4gYSBKU09OIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2RlQXRMb2NhdGlvbihyb290LCBwYXRoKSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhdGhfMSA9IHBhdGg7IF9pIDwgcGF0aF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHBhdGhfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdvYmplY3QnIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IG5vZGUuY2hpbGRyZW47IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eU5vZGUuY2hpbGRyZW4pICYmIHByb3BlcnR5Tm9kZS5jaGlsZHJlblswXS52YWx1ZSA9PT0gc2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcHJvcGVydHlOb2RlLmNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdhcnJheScgfHwgaW5kZXggPCAwIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pIHx8IGluZGV4ID49IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBKYXZhU2NyaXB0IG9iamVjdCBvZiB0aGUgZ2l2ZW4gSlNPTiBET00gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChnZXROb2RlVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbm9kZS5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2FbX2ldO1xuICAgICAgICAgICAgb2JqW3Byb3AuY2hpbGRyZW5bMF0udmFsdWVdID0gZ2V0Tm9kZVZhbHVlKHByb3AuY2hpbGRyZW5bMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnZhbHVlO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3NjYW5uZXIgPSBjcmVhdGVTY2FubmVyKHRleHQsIGZhbHNlKTtcbiAgICBmdW5jdGlvbiB0b05vQXJnVmlzaXQodmlzaXRGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZpc2l0RnVuY3Rpb24oX3NjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgX3NjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7IH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b09uZUFyZ1Zpc2l0KHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB2aXNpdEZ1bmN0aW9uKGFyZywgX3NjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgX3NjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7IH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICB2YXIgb25PYmplY3RCZWdpbiA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0QmVnaW4pLCBvbk9iamVjdFByb3BlcnR5ID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0UHJvcGVydHkpLCBvbk9iamVjdEVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25BcnJheUJlZ2luKSwgb25BcnJheUVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQXJyYXlFbmQpLCBvbkxpdGVyYWxWYWx1ZSA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkxpdGVyYWxWYWx1ZSksIG9uU2VwYXJhdG9yID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uU2VwYXJhdG9yKSwgb25Db21tZW50ID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25Db21tZW50KSwgb25FcnJvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkVycm9yKTtcbiAgICB2YXIgZGlzYWxsb3dDb21tZW50cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhbGxvd0NvbW1lbnRzO1xuICAgIHZhciBhbGxvd1RyYWlsaW5nQ29tbWEgPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hO1xuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNjYW5FcnJvci5JbnZhbGlkVW5pY29kZTpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNjYW5FcnJvci5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihQYXJzZUVycm9yQ29kZS5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FsbG93Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTY2FuRXJyb3IuSW52YWxpZENoYXJhY3RlcjpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuSW52YWxpZENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYTpcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuSW52YWxpZENvbW1lbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuVW5rbm93bjpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuSW52YWxpZFN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4S2luZC5Ucml2aWE6XG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBza2lwVW50aWxBZnRlciwgc2tpcFVudGlsKSB7XG4gICAgICAgIGlmIChza2lwVW50aWxBZnRlciA9PT0gdm9pZCAwKSB7IHNraXBVbnRpbEFmdGVyID0gW107IH1cbiAgICAgICAgaWYgKHNraXBVbnRpbCA9PT0gdm9pZCAwKSB7IHNraXBVbnRpbCA9IFtdOyB9XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIubGVuZ3RoICsgc2tpcFVudGlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IF9zY2FubmVyLmdldFRva2VuKCk7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gIT09IFN5bnRheEtpbmQuRU9GKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2tpcFVudGlsLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKGlzVmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICBpZiAoaXNWYWx1ZSkge1xuICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25PYmplY3RQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCgpIHtcbiAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWw6XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UoX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuTnVsbEtleXdvcmQ6XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQ6XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuRmFsc2VLZXl3b3JkOlxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNjYW5OZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5KCkge1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihQYXJzZUVycm9yQ29kZS5Qcm9wZXJ0eU5hbWVFeHBlY3RlZCwgW10sIFtTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiwgU3ludGF4S2luZC5Db21tYVRva2VuXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTdHJpbmcoZmFsc2UpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gU3ludGF4S2luZC5Db2xvblRva2VuKSB7XG4gICAgICAgICAgICBvblNlcGFyYXRvcignOicpO1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb2xvblxuICAgICAgICAgICAgaWYgKCFwYXJzZVZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkLCBbXSwgW1N5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuLCBTeW50YXhLaW5kLkNvbW1hVG9rZW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQsIFtdLCBbU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4sIFN5bnRheEtpbmQuQ29tbWFUb2tlbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdCgpIHtcbiAgICAgICAgb25PYmplY3RCZWdpbigpO1xuICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIG9wZW4gYnJhY2VcbiAgICAgICAgdmFyIG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IFN5bnRheEtpbmQuRU9GKSB7XG4gICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gU3ludGF4S2luZC5Db21tYVRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIFtdLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uU2VwYXJhdG9yKCcsJyk7XG4gICAgICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQsIFtdLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlUHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIFtdLCBbU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4sIFN5bnRheEtpbmQuQ29tbWFUb2tlbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVlZHNDb21tYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb25PYmplY3RFbmQoKTtcbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNlRXhwZWN0ZWQsIFtTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbl0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY2xvc2UgYnJhY2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheSgpIHtcbiAgICAgICAgb25BcnJheUJlZ2luKCk7XG4gICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgb3BlbiBicmFja2V0XG4gICAgICAgIHZhciBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IFN5bnRheEtpbmQuRU9GKSB7XG4gICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gU3ludGF4S2luZC5Db21tYVRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIFtdLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uU2VwYXJhdG9yKCcsJyk7XG4gICAgICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICYmIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCwgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgW10sIFtTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuLCBTeW50YXhLaW5kLkNvbW1hVG9rZW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9uQXJyYXlFbmQoKTtcbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKFBhcnNlRXJyb3JDb2RlLkNsb3NlQnJhY2tldEV4cGVjdGVkLCBbU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbl0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY2xvc2UgYnJhY2tldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KCk7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlIFN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxpdGVyYWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuTmV4dCgpO1xuICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSBTeW50YXhLaW5kLkVPRikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZVZhbHVlKCkpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gU3ludGF4S2luZC5FT0YpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoUGFyc2VFcnJvckNvZGUuRW5kT2ZGaWxlRXhwZWN0ZWQsIFtdLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZWRpdHMgbmVlZGVkIHRvIGZvcm1hdCBhIEpTT04gZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50VGV4dCBUaGUgaW5wdXQgdGV4dFxuICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0byBmb3JtYXQgb3IgYHVuZGVmaW5lZGAgdG8gZm9ybWF0IHRoZSBmdWxsIGNvbnRlbnRcbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBmb3JtYXR0aW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBlZGl0IG9wZXJhdGlvbnMgZGVzY3JpYmluZyB0aGUgZm9ybWF0dGluZyBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbCBkb2N1bWVudC4gRWRpdHMgY2FuIGJlIGVpdGhlciBpbnNlcnRzLCByZXBsYWNlbWVudHMgb3JcbiAqIHJlbW92YWxzIG9mIHRleHQgc2VnbWVudHMuIEFsbCBvZmZzZXRzIHJlZmVyIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQuIE5vIHR3byBlZGl0cyBtdXN0IGNoYW5nZSBvciByZW1vdmUgdGhlIHNhbWUgcmFuZ2Ugb2ZcbiAqIHRleHQgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50LiBIb3dldmVyLCBtdWx0aXBsZSBlZGl0cyBjYW4gaGF2ZVxuICogdGhlIHNhbWUgb2Zmc2V0LCBmb3IgZXhhbXBsZSBtdWx0aXBsZSBpbnNlcnRzLCBvciBhbiBpbnNlcnQgZm9sbG93ZWQgYnkgYSByZW1vdmUgb3IgcmVwbGFjZS4gVGhlIG9yZGVyIGluIHRoZSBhcnJheSBkZWZpbmVzIHdoaWNoIGVkaXQgaXMgYXBwbGllZCBmaXJzdC5cbiAqIFRvIGFwcGx5IGVkaXRzIHRvIGFuIGlucHV0LCB5b3UgY2FuIHVzZSBgYXBwbHlFZGl0c2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9mb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBlZGl0cyBuZWVkZWQgdG8gbW9kaWZ5IGEgdmFsdWUgaW4gdGhlIEpTT04gZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50VGV4dCBUaGUgaW5wdXQgdGV4dFxuICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2YgdGhlIHZhbHVlIHRvIGNoYW5nZS4gVGhlIHBhdGggcmVwcmVzZW50cyBlaXRoZXIgdG8gdGhlIGRvY3VtZW50IHJvb3QsIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgaXRlbS5cbiAqIElmIHRoZSBwYXRoIHBvaW50cyB0byBhbiBub24tZXhpc3RpbmcgcHJvcGVydHkgb3IgaXRlbSwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb3IgaXRlbS4gSWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCxcbiAqIHRoZSBwcm9wZXJ0eSBvciBpdGVtIHdpbGwgYmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnNcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBlZGl0IG9wZXJhdGlvbnMgZGVzY3JpYmluZyB0aGUgZm9ybWF0dGluZyBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbCBkb2N1bWVudC4gRWRpdHMgY2FuIGJlIGVpdGhlciBpbnNlcnRzLCByZXBsYWNlbWVudHMgb3JcbiAqIHJlbW92YWxzIG9mIHRleHQgc2VnbWVudHMuIEFsbCBvZmZzZXRzIHJlZmVyIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQuIE5vIHR3byBlZGl0cyBtdXN0IGNoYW5nZSBvciByZW1vdmUgdGhlIHNhbWUgcmFuZ2Ugb2ZcbiAqIHRleHQgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50LiBIb3dldmVyLCBtdWx0aXBsZSBlZGl0cyBjYW4gaGF2ZVxuICogdGhlIHNhbWUgb2Zmc2V0LCBmb3IgZXhhbXBsZSBtdWx0aXBsZSBpbnNlcnRzLCBvciBhbiBpbnNlcnQgZm9sbG93ZWQgYnkgYSByZW1vdmUgb3IgcmVwbGFjZS4gVGhlIG9yZGVyIGluIHRoZSBhcnJheSBkZWZpbmVzIHdoaWNoIGVkaXQgaXMgYXBwbGllZCBmaXJzdC5cbiAqIFRvIGFwcGx5IGVkaXRzIHRvIGFuIGlucHV0LCB5b3UgY2FuIHVzZSBgYXBwbHlFZGl0c2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeSh0ZXh0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBzZXRQcm9wZXJ0eSh0ZXh0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucy5mb3JtYXR0aW5nT3B0aW9ucywgb3B0aW9ucy5nZXRJbnNlcnRpb25JbmRleCk7XG59XG4vKipcbiAqIEFwcGxpZXMgZWRpdHMgdG8gYSBpbnB1dCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUVkaXRzKHRleHQsIGVkaXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IGVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jsonc-parser/lib/esm/main.js\n");

/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG52YXIgcGF0aCA9IHsgc2VwOiAnLycgfVxudHJ5IHtcbiAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxufSBjYXRjaCAoZXIpIHt9XG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBhID0gYSB8fCB7fVxuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYltrXVxuICB9KVxuICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGFba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHJldHVybiBtaW5pbWF0Y2hcblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWluaW1hdGNoKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5NaW5pbWF0Y2ggPSBmdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG9yaWcuTWluaW1hdGNoKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHJldHVybiBNaW5pbWF0Y2hcbiAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaFxufVxuXG5mdW5jdGlvbiBtaW5pbWF0Y2ggKHAsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2IgcGF0dGVybiBzdHJpbmcgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBcIlwiIG9ubHkgbWF0Y2hlcyBcIlwiXG4gIGlmIChwYXR0ZXJuLnRyaW0oKSA9PT0gJycpIHJldHVybiBwID09PSAnJ1xuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbmZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSkge1xuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2xvYiBwYXR0ZXJuIHN0cmluZyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuICBwYXR0ZXJuID0gcGF0dGVybi50cmltKClcblxuICAvLyB3aW5kb3dzIHN1cHBvcnQ6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5zZXQgPSBbXVxuICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHRoaXMucmVnZXhwID0gbnVsbFxuICB0aGlzLm5lZ2F0ZSA9IGZhbHNlXG4gIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gIHRoaXMuZW1wdHkgPSBmYWxzZVxuXG4gIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgdGhpcy5tYWtlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZSA9IG1ha2VcbmZ1bmN0aW9uIG1ha2UgKCkge1xuICAvLyBkb24ndCBkbyBpdCBtb3JlIHRoYW4gb25jZS5cbiAgaWYgKHRoaXMuX21hZGUpIHJldHVyblxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBjb25zb2xlLmVycm9yXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2YgcGF0aC1wb3J0aW9uXG4gIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICBzZXQgPSB0aGlzLmdsb2JQYXJ0cyA9IHNldC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChzbGFzaFNwbGl0KVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uIChzLCBzaSwgc2V0KSB7XG4gICAgcmV0dXJuIHMubWFwKHRoaXMucGFyc2UsIHRoaXMpXG4gIH0sIHRoaXMpXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLmluZGV4T2YoZmFsc2UpID09PSAtMVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgdGhpcy5zZXQgPSBzZXRcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZU5lZ2F0ZSA9IHBhcnNlTmVnYXRlXG5mdW5jdGlvbiBwYXJzZU5lZ2F0ZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBuZWdhdGUgPSBmYWxzZVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgbmVnYXRlT2Zmc2V0ID0gMFxuXG4gIGlmIChvcHRpb25zLm5vbmVnYXRlKSByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgOyBpIDwgbCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnXG4gICAgOyBpKyspIHtcbiAgICBuZWdhdGUgPSAhbmVnYXRlXG4gICAgbmVnYXRlT2Zmc2V0KytcbiAgfVxuXG4gIGlmIChuZWdhdGVPZmZzZXQpIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKG5lZ2F0ZU9mZnNldClcbiAgdGhpcy5uZWdhdGUgPSBuZWdhdGVcbn1cblxuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VFeHBhbmQocGF0dGVybiwgb3B0aW9ucylcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kXG5cbmZ1bmN0aW9uIGJyYWNlRXhwYW5kIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgfVxuXG4gIHBhdHRlcm4gPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IHRoaXMucGF0dGVybiA6IHBhdHRlcm5cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5kZWZpbmVkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMubm9icmFjZSB8fFxuICAgICFwYXR0ZXJuLm1hdGNoKC9cXHsuKlxcfS8pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gMTAyNCAqIDY0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHNob3J0Y3V0c1xuICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhciAmJiBwYXR0ZXJuID09PSAnKionKSByZXR1cm4gR0xPQlNUQVJcbiAgaWYgKHBhdHRlcm4gPT09ICcnKSByZXR1cm4gJydcblxuICB2YXIgcmUgPSAnJ1xuICB2YXIgaGFzTWFnaWMgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHZhciBlc2NhcGluZyA9IGZhbHNlXG4gIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgdmFyIHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICB2YXIgbmVnYXRpdmVMaXN0cyA9IFtdXG4gIHZhciBzdGF0ZUNoYXJcbiAgdmFyIGluQ2xhc3MgPSBmYWxzZVxuICB2YXIgcmVDbGFzc1N0YXJ0ID0gLTFcbiAgdmFyIGNsYXNzU3RhcnQgPSAtMVxuICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICB2YXIgcGF0dGVyblN0YXJ0ID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICcuJyA/ICcnIC8vIGFueXRoaW5nXG4gIC8vIG5vdCAoc3RhcnQgb3IgLyBmb2xsb3dlZCBieSAuIG9yIC4uIGZvbGxvd2VkIGJ5IC8gb3IgZW5kKVxuICA6IG9wdGlvbnMuZG90ID8gJyg/ISg/Ol58XFxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcXFwvKSknXG4gIDogJyg/IVxcXFwuKSdcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZUNoYXIgKCkge1xuICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgc3dpdGNoIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICByZSArPSBxbWFya1xuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2VsZi5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGgsIGNcbiAgICA7IChpIDwgbGVuKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKVxuICAgIDsgaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgIGlmIChlc2NhcGluZyAmJiByZVNwZWNpYWxzW2NdKSB7XG4gICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIC8vIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC5cbiAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBlc2NhcGluZyA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgIC8vIGZvciB0aGUgXCJleHRnbG9iXCIgc3R1ZmYuXG4gICAgICBjYXNlICc/JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqIDwtLSBzdGF0ZUNoYXInLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAvLyB0aGUgZ2xvYiBbIWFdIG1lYW5zIFteYV0gaW4gcmVnZXhwXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgaWYgKGMgPT09ICchJyAmJiBpID09PSBjbGFzc1N0YXJ0ICsgMSkgYyA9ICdeJ1xuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdGVDaGFyLCB0aGVuIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAvLyBIYW5kbGUgdGhlIHN0YXRlQ2hhciwgdGhlbiBwcm9jZWVkIHdpdGggdGhpcyBvbmUuXG4gICAgICAgIHNlbGYuZGVidWcoJ2NhbGwgY2xlYXJTdGF0ZUNoYXIgJWonLCBzdGF0ZUNoYXIpXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgc3RhdGVDaGFyID0gY1xuICAgICAgICAvLyBpZiBleHRnbG9iIGlzIGRpc2FibGVkLCB0aGVuICsoYXNkZnxmb28pIGlzbid0IGEgdGhpbmcuXG4gICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAvLyB0aGUgcGF0dGVybkxpc3Qgc3R1ZmYuXG4gICAgICAgIGlmIChvcHRpb25zLm5vZXh0KSBjbGVhclN0YXRlQ2hhcigpXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZUNoYXIpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCgnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucHVzaCh7XG4gICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICByZVN0YXJ0OiByZS5sZW5ndGgsXG4gICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZVxuICAgICAgICB9KVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgcmUgKz0gc3RhdGVDaGFyID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonXG4gICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICB2YXIgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAvLyBUaGUgb3RoZXJzIGFyZSAoPzo8cGF0dGVybj4pPHR5cGU+XG4gICAgICAgIHJlICs9IHBsLmNsb3NlXG4gICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICBuZWdhdGl2ZUxpc3RzLnB1c2gocGwpXG4gICAgICAgIH1cbiAgICAgICAgcGwucmVFbmQgPSByZS5sZW5ndGhcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGggfHwgZXNjYXBpbmcpIHtcbiAgICAgICAgICByZSArPSAnXFxcXHwnXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHJlICs9ICd8J1xuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlc2UgYXJlIG1vc3RseSB0aGUgc2FtZSBpbiByZWdleHAgYW5kIGdsb2JcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZS10cmFja2luZyBjaGFyIGJlZm9yZSB0aGUgW1xuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGluQ2xhc3MgPSB0cnVlXG4gICAgICAgIGNsYXNzU3RhcnQgPSBpXG4gICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICddJzpcbiAgICAgICAgLy8gIGEgcmlnaHQgYnJhY2tldCBzaGFsbCBsb3NlIGl0cyBzcGVjaWFsXG4gICAgICAgIC8vICBtZWFuaW5nIGFuZCByZXByZXNlbnQgaXRzZWxmIGluXG4gICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgLy8gIGZpcnN0IGluIHRoZSBsaXN0LiAgLS0gUE9TSVguMiAyLjguMy4yXG4gICAgICAgIGlmIChpID09PSBjbGFzc1N0YXJ0ICsgMSB8fCAhaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgICAgICAgLy8gXCJbei1hXVwiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbei1hXFxdXCJcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBhbiBpbnZhbGlkIHJlLiBpZiBzbywgcmUtd2FsayB0aGUgY29udGVudHMgb2YgdGhlXG4gICAgICAgICAgLy8gd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlIGFueSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgICAgLy8gVE9ETzogSXQgd291bGQgcHJvYmFibHkgYmUgZmFzdGVyIHRvIGRldGVybWluZSB0aGlzXG4gICAgICAgICAgLy8gd2l0aG91dCBhIHRyeS9jYXRjaCBhbmQgYSBuZXcgUmVnRXhwLCBidXQgaXQncyB0cmlja3lcbiAgICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICAgIHZhciBjcyA9IHBhdHRlcm4uc3Vic3RyaW5nKGNsYXNzU3RhcnQgKyAxLCBpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGNsYXNzIVxuICAgICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdICsgJ1xcXFxdJ1xuICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICAgICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJy4nOlxuICAgIGNhc2UgJ1snOlxuICAgIGNhc2UgJygnOiBhZGRQYXR0ZXJuU3RhcnQgPSB0cnVlXG4gIH1cblxuICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxhY2sgb2YgbmVnYXRpdmUgbG9va2JlaGluZCBpbiBKU1xuICAvLyBBIHBhdHRlcm4gbGlrZTogKi4hKHgpLiEoeXx6KSBuZWVkcyB0byBlbnN1cmUgdGhhdCBhIG5hbWVcbiAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gIC8vIGxvb2thaGVhZCwgaGFzIHRvIGxvb2sgQUxMIHRoZSB3YXkgYWhlYWQsIHRvIHRoZSBlbmQgb2ZcbiAgLy8gdGhlIHBhdHRlcm4uXG4gIGZvciAodmFyIG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgdmFyIG5sID0gbmVnYXRpdmVMaXN0c1tuXVxuXG4gICAgdmFyIG5sQmVmb3JlID0gcmUuc2xpY2UoMCwgbmwucmVTdGFydClcbiAgICB2YXIgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICB2YXIgbmxMYXN0ID0gcmUuc2xpY2UobmwucmVFbmQgLSA4LCBubC5yZUVuZClcbiAgICB2YXIgbmxBZnRlciA9IHJlLnNsaWNlKG5sLnJlRW5kKVxuXG4gICAgbmxMYXN0ICs9IG5sQWZ0ZXJcblxuICAgIC8vIEhhbmRsZSBuZXN0ZWQgc3R1ZmYgbGlrZSAqKCouanN8ISgqLmpzb24pKSwgd2hlcmUgb3BlbiBwYXJlbnNcbiAgICAvLyBtZWFuIHRoYXQgd2Ugc2hvdWxkICpub3QqIGluY2x1ZGUgdGhlICkgaW4gdGhlIGJpdCB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICB2YXIgb3BlblBhcmVuc0JlZm9yZSA9IG5sQmVmb3JlLnNwbGl0KCcoJykubGVuZ3RoIC0gMVxuICAgIHZhciBjbGVhbkFmdGVyID0gbmxBZnRlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvcGVuUGFyZW5zQmVmb3JlOyBpKyspIHtcbiAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgIH1cbiAgICBubEFmdGVyID0gY2xlYW5BZnRlclxuXG4gICAgdmFyIGRvbGxhciA9ICcnXG4gICAgaWYgKG5sQWZ0ZXIgPT09ICcnICYmIGlzU3ViICE9PSBTVUJQQVJTRSkge1xuICAgICAgZG9sbGFyID0gJyQnXG4gICAgfVxuICAgIHZhciBuZXdSZSA9IG5sQmVmb3JlICsgbmxGaXJzdCArIG5sQWZ0ZXIgKyBkb2xsYXIgKyBubExhc3RcbiAgICByZSA9IG5ld1JlXG4gIH1cblxuICAvLyBpZiB0aGUgcmUgaXMgbm90IFwiXCIgYXQgdGhpcyBwb2ludCwgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAvLyBpdCBkb2Vzbid0IG1hdGNoIGFnYWluc3QgYW4gZW1wdHkgcGF0aCBwYXJ0LlxuICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gIGlmIChyZSAhPT0gJycgJiYgaGFzTWFnaWMpIHtcbiAgICByZSA9ICcoPz0uKScgKyByZVxuICB9XG5cbiAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgIHJlID0gcGF0dGVyblN0YXJ0ICsgcmVcbiAgfVxuXG4gIC8vIHBhcnNpbmcganVzdCBhIHBpZWNlIG9mIGEgbGFyZ2VyIHBhdHRlcm4uXG4gIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICByZXR1cm4gW3JlLCBoYXNNYWdpY11cbiAgfVxuXG4gIC8vIHNraXAgdGhlIHJlZ2V4cCBmb3Igbm9uLW1hZ2ljYWwgcGF0dGVybnNcbiAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAvLyBhbiBleGFjdCBtYXRjaCBhZ2FpbnN0IGEgZmlsZSBldGMuXG4gIGlmICghaGFzTWFnaWMpIHtcbiAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gIH1cblxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gIHRyeSB7XG4gICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKVxuICB9IGNhdGNoIChlcikge1xuICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgIC8vIGFueXRoaW5nLiAgVGhpcyB0cmljayBsb29rcyBmb3IgYSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBzdHJpbmcsIHdoaWNoIGlzIG9mIGNvdXJzZSBpbXBvc3NpYmxlLCBleGNlcHQgaW4gbXVsdGktbGluZVxuICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgIHJldHVybiBuZXcgUmVnRXhwKCckLicpXG4gIH1cblxuICByZWdFeHAuX2dsb2IgPSBwYXR0ZXJuXG4gIHJlZ0V4cC5fc3JjID0gcmVcblxuICByZXR1cm4gcmVnRXhwXG59XG5cbm1pbmltYXRjaC5tYWtlUmUgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zIHx8IHt9KS5tYWtlUmUoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2VSZSA9IG1ha2VSZVxuZnVuY3Rpb24gbWFrZVJlICgpIHtcbiAgaWYgKHRoaXMucmVnZXhwIHx8IHRoaXMucmVnZXhwID09PSBmYWxzZSkgcmV0dXJuIHRoaXMucmVnZXhwXG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gIC8vIHBhdHRlcm4gc3RyaW5ncywgb3IgXCIqKlwiLlxuICAvL1xuICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAvLyBiZSB1c2VkLCByZWFsbHksIGJ1dCBpdCdzIHByZXR0eSBjb252ZW5pZW50IHNvbWV0aW1lcyxcbiAgLy8gd2hlbiB5b3UganVzdCB3YW50IHRvIHdvcmsgd2l0aCBhIHJlZ2V4LlxuICB2YXIgc2V0ID0gdGhpcy5zZXRcblxuICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXMucmVnZXhwXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB2YXIgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhciA/IHN0YXJcbiAgICA6IG9wdGlvbnMuZG90ID8gdHdvU3RhckRvdFxuICAgIDogdHdvU3Rhck5vRG90XG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcblxuICB2YXIgcmUgPSBzZXQubWFwKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKHAgPT09IEdMT0JTVEFSKSA/IHR3b1N0YXJcbiAgICAgIDogKHR5cGVvZiBwID09PSAnc3RyaW5nJykgPyByZWdFeHBFc2NhcGUocClcbiAgICAgIDogcC5fc3JjXG4gICAgfSkuam9pbignXFxcXFxcLycpXG4gIH0pLmpvaW4oJ3wnKVxuXG4gIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gIHJlID0gJ14oPzonICsgcmUgKyAnKSQnXG5cbiAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gIGlmICh0aGlzLm5lZ2F0ZSkgcmUgPSAnXig/IScgKyByZSArICcpLiokJ1xuXG4gIHRyeSB7XG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBmbGFncylcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gbWF0Y2hcbmZ1bmN0aW9uIG1hdGNoIChmLCBwYXJ0aWFsKSB7XG4gIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKVxuICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gIC8vIGNvbW1lbnRzLCBldGMuXG4gIGlmICh0aGlzLmNvbW1lbnQpIHJldHVybiBmYWxzZVxuICBpZiAodGhpcy5lbXB0eSkgcmV0dXJuIGYgPT09ICcnXG5cbiAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSByZXR1cm4gdHJ1ZVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmIChwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgZiA9IGYuc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgLy8gdHJlYXQgdGhlIHRlc3QgcGF0aCBhcyBhIHNldCBvZiBwYXRocGFydHMuXG4gIGYgPSBmLnNwbGl0KHNsYXNoU3BsaXQpXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmKVxuXG4gIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KVxuXG4gIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gIHZhciBmaWxlbmFtZVxuICB2YXIgaVxuICBmb3IgKGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZmlsZW5hbWUgPSBmW2ldXG4gICAgaWYgKGZpbGVuYW1lKSBicmVha1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXR0ZXJuID0gc2V0W2ldXG4gICAgdmFyIGZpbGUgPSBmXG4gICAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWxlID0gW2ZpbGVuYW1lXVxuICAgIH1cbiAgICB2YXIgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gIXRoaXMubmVnYXRlXG4gICAgfVxuICB9XG5cbiAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdGhpcy5uZWdhdGVcbn1cblxuLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbi8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4vLyB0aGUgcGFydHMgbWF0Y2guXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoT25lID0gZnVuY3Rpb24gKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsXG4gICAgeyAndGhpcyc6IHRoaXMsIGZpbGU6IGZpbGUsIHBhdHRlcm46IHBhdHRlcm4gfSlcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aClcblxuICBmb3IgKHZhciBmaSA9IDAsXG4gICAgICBwaSA9IDAsXG4gICAgICBmbCA9IGZpbGUubGVuZ3RoLFxuICAgICAgcGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgICAgOyAoZmkgPCBmbCkgJiYgKHBpIDwgcGwpXG4gICAgICA7IGZpKyssIHBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJylcbiAgICB2YXIgcCA9IHBhdHRlcm5bcGldXG4gICAgdmFyIGYgPSBmaWxlW2ZpXVxuXG4gICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKVxuXG4gICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgIGlmIChwID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKVxuXG4gICAgICAvLyBcIioqXCJcbiAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAvLyBhL2IvY1xuICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgLy9cbiAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICB2YXIgZnIgPSBmaVxuICAgICAgdmFyIHByID0gcGkgKyAxXG4gICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKVxuICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8IGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl1cblxuICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKVxuXG4gICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSlcbiAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHwgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKVxuICAgICAgICAgIGZyKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgKnBhdHRlcm4qIGxlZnQsIHRoZW5cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub2Nhc2UpIHtcbiAgICAgICAgaGl0ID0gZi50b0xvd2VyQ2FzZSgpID09PSBwLnRvTG93ZXJDYXNlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpdCA9IGYgPT09IHBcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9IGVsc2Uge1xuICAgICAgaGl0ID0gZi5tYXRjaChwKVxuICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9XG5cbiAgICBpZiAoIWhpdCkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuXG4gIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICByZXR1cm4gcGFydGlhbFxuICB9IGVsc2UgaWYgKHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICB2YXIgZW1wdHlGaWxlRW5kID0gKGZpID09PSBmbCAtIDEpICYmIChmaWxlW2ZpXSA9PT0gJycpXG4gICAgcmV0dXJuIGVtcHR5RmlsZUVuZFxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/minimatch/minimatch.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9ta2RpcnAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuICAgIFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcbiAgICBcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmICghZXIpIHtcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG5cbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycjApIHtcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWRlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/index.js\n");

/***/ }),

/***/ "./node_modules/os-tmpdir/index.js":
/*!*****************************************!*\
  !*** ./node_modules/os-tmpdir/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3MtdG1wZGlyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy9vcy10bXBkaXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG52YXIgdHJhaWxpbmdTbGFzaFJlID0gaXNXaW5kb3dzID8gL1teOl1cXFxcJC8gOiAvLlxcLyQvO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi8zZTdhMTQzODE0OTdhM2I3M2RkYTY4ZDA1YjUxMzA1NjNjZGFiNDIwL2xpYi9vcy5qcyNMMjUtTDQzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHBhdGg7XG5cblx0aWYgKGlzV2luZG93cykge1xuXHRcdHBhdGggPSBwcm9jZXNzLmVudi5URU1QIHx8XG5cdFx0XHRwcm9jZXNzLmVudi5UTVAgfHxcblx0XHRcdChwcm9jZXNzLmVudi5TeXN0ZW1Sb290IHx8IHByb2Nlc3MuZW52LndpbmRpcikgKyAnXFxcXHRlbXAnO1xuXHR9IGVsc2Uge1xuXHRcdHBhdGggPSBwcm9jZXNzLmVudi5UTVBESVIgfHxcblx0XHRcdHByb2Nlc3MuZW52LlRNUCB8fFxuXHRcdFx0cHJvY2Vzcy5lbnYuVEVNUCB8fFxuXHRcdFx0Jy90bXAnO1xuXHR9XG5cblx0aWYgKHRyYWlsaW5nU2xhc2hSZS50ZXN0KHBhdGgpKSB7XG5cdFx0cGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuXHR9XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/os-tmpdir/index.js\n");

/***/ }),

/***/ "./node_modules/pend/index.js":
/*!************************************!*\
  !*** ./node_modules/pend/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Pend;\n\nfunction Pend() {\n  this.pending = 0;\n  this.max = Infinity;\n  this.listeners = [];\n  this.waiting = [];\n  this.error = null;\n}\n\nPend.prototype.go = function(fn) {\n  if (this.pending < this.max) {\n    pendGo(this, fn);\n  } else {\n    this.waiting.push(fn);\n  }\n};\n\nPend.prototype.wait = function(cb) {\n  if (this.pending === 0) {\n    cb(this.error);\n  } else {\n    this.listeners.push(cb);\n  }\n};\n\nPend.prototype.hold = function() {\n  return pendHold(this);\n};\n\nfunction pendHold(self) {\n  self.pending += 1;\n  var called = false;\n  return onCb;\n  function onCb(err) {\n    if (called) throw new Error(\"callback called twice\");\n    called = true;\n    self.error = self.error || err;\n    self.pending -= 1;\n    if (self.waiting.length > 0 && self.pending < self.max) {\n      pendGo(self, self.waiting.shift());\n    } else if (self.pending === 0) {\n      var listeners = self.listeners;\n      self.listeners = [];\n      listeners.forEach(cbListener);\n    }\n  }\n  function cbListener(listener) {\n    listener(self.error);\n  }\n}\n\nfunction pendGo(self, fn) {\n  fn(pendHold(self));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGVuZC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvcGVuZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFBlbmQ7XG5cbmZ1bmN0aW9uIFBlbmQoKSB7XG4gIHRoaXMucGVuZGluZyA9IDA7XG4gIHRoaXMubWF4ID0gSW5maW5pdHk7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG4gIHRoaXMud2FpdGluZyA9IFtdO1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxuUGVuZC5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbihmbikge1xuICBpZiAodGhpcy5wZW5kaW5nIDwgdGhpcy5tYXgpIHtcbiAgICBwZW5kR28odGhpcywgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2FpdGluZy5wdXNoKGZuKTtcbiAgfVxufTtcblxuUGVuZC5wcm90b3R5cGUud2FpdCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcgPT09IDApIHtcbiAgICBjYih0aGlzLmVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGNiKTtcbiAgfVxufTtcblxuUGVuZC5wcm90b3R5cGUuaG9sZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcGVuZEhvbGQodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBwZW5kSG9sZChzZWxmKSB7XG4gIHNlbGYucGVuZGluZyArPSAxO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBvbkNiO1xuICBmdW5jdGlvbiBvbkNiKGVycikge1xuICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGNhbGxlZCB0d2ljZVwiKTtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHNlbGYuZXJyb3IgPSBzZWxmLmVycm9yIHx8IGVycjtcbiAgICBzZWxmLnBlbmRpbmcgLT0gMTtcbiAgICBpZiAoc2VsZi53YWl0aW5nLmxlbmd0aCA+IDAgJiYgc2VsZi5wZW5kaW5nIDwgc2VsZi5tYXgpIHtcbiAgICAgIHBlbmRHbyhzZWxmLCBzZWxmLndhaXRpbmcuc2hpZnQoKSk7XG4gICAgfSBlbHNlIGlmIChzZWxmLnBlbmRpbmcgPT09IDApIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycztcbiAgICAgIHNlbGYubGlzdGVuZXJzID0gW107XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaChjYkxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKHNlbGYuZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlbmRHbyhzZWxmLCBmbikge1xuICBmbihwZW5kSG9sZChzZWxmKSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pend/index.js\n");

/***/ }),

/***/ "./node_modules/semver/semver.js":
/*!***************************************!*\
  !*** ./node_modules/semver/semver.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\nComparator.prototype.intersects = function(comp, loose) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, loose);\n    return satisfies(this.value, rangeTmp, loose);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, loose);\n    return satisfies(comp.semver, rangeTmp, loose);\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, loose) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'));\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, loose) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'));\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if (range instanceof Range) {\n    if (range.loose === loose) {\n      return range;\n    } else {\n      return new Range(range.raw, loose);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, loose);\n  }\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\nRange.prototype.intersects = function(range, loose) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function(thisComparators) {\n    return thisComparators.every(function(thisComparator) {\n      return range.set.some(function(rangeComparators) {\n        return rangeComparators.every(function(rangeComparator) {\n          return thisComparator.intersects(rangeComparator, loose);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, loose);\n      }\n    }\n  })\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, loose);\n      }\n    }\n  })\n  return min;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\nfunction intersects(r1, r2, loose) {\n  r1 = new Range(r1, loose)\n  r2 = new Range(r2, loose)\n  return r1.intersects(r2)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7XG5cbi8vIFRoZSBkZWJ1ZyBmdW5jdGlvbiBpcyBleGNsdWRlZCBlbnRpcmVseSBmcm9tIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuLyogbm9taW4gKi8gdmFyIGRlYnVnO1xuLyogbm9taW4gKi8gaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52ICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAgIC8qIG5vbWluICovIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIG5vbWluICovIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAvKiBub21pbiAqLyBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgIC8qIG5vbWluICovIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIC8qIG5vbWluICovIH07XG4vKiBub21pbiAqLyBlbHNlXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcblxudmFyIE1BWF9MRU5HVEggPSAyNTY7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG52YXIgcmUgPSBleHBvcnRzLnJlID0gW107XG52YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXTtcbnZhciBSID0gMDtcblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxudmFyIE5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbnZhciBOVU1FUklDSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdID0gJ1swLTldKyc7XG5cblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudmFyIE5PTk5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcblxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudmFyIE1BSU5WRVJTSU9OID0gUisrO1xuc3JjW01BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgTUFJTlZFUlNJT05MT09TRSA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpJztcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVIgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgUFJFUkVMRUFTRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknO1xuXG52YXIgUFJFUkVMRUFTRUxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbnZhciBCVUlMRElERU5USUZJRVIgPSBSKys7XG5zcmNbQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBCVUlMRCA9IFIrKztcbnNyY1tCVUlMRF0gPSAnKD86XFxcXCsoJyArIHNyY1tCVUlMRElERU5USUZJRVJdICtcbiAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW0JVSUxESURFTlRJRklFUl0gKyAnKSopKSc7XG5cblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnZhciBGVUxMID0gUisrO1xudmFyIEZVTExQTEFJTiA9ICd2PycgKyBzcmNbTUFJTlZFUlNJT05dICtcbiAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnNyY1tGVUxMXSA9ICdeJyArIEZVTExQTEFJTiArICckJztcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxudmFyIExPT1NFUExBSU4gPSAnW3Y9XFxcXHNdKicgKyBzcmNbTUFJTlZFUlNJT05MT09TRV0gK1xuICAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICc/JyArXG4gICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnZhciBMT09TRSA9IFIrKztcbnNyY1tMT09TRV0gPSAnXicgKyBMT09TRVBMQUlOICsgJyQnO1xuXG52YXIgR1RMVCA9IFIrKztcbnNyY1tHVExUXSA9ICcoKD86PHw+KT89PyknO1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG52YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG52YXIgWFJBTkdFSURFTlRJRklFUiA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKic7XG5cbnZhciBYUkFOR0VQTEFJTiA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTl0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0UgPSBSKys7XG5zcmNbWFJBTkdFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBYUkFOR0VMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnZhciBMT05FVElMREUgPSBSKys7XG5zcmNbTE9ORVRJTERFXSA9ICcoPzp+Pj8pJztcblxudmFyIFRJTERFVFJJTSA9IFIrKztcbnNyY1tUSUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xcXFxzKyc7XG5yZVtUSUxERVRSSU1dID0gbmV3IFJlZ0V4cChzcmNbVElMREVUUklNXSwgJ2cnKTtcbnZhciB0aWxkZVRyaW1SZXBsYWNlID0gJyQxfic7XG5cbnZhciBUSUxERSA9IFIrKztcbnNyY1tUSUxERV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgVElMREVMT09TRSA9IFIrKztcbnNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxudmFyIExPTkVDQVJFVCA9IFIrKztcbnNyY1tMT05FQ0FSRVRdID0gJyg/OlxcXFxeKSc7XG5cbnZhciBDQVJFVFRSSU0gPSBSKys7XG5zcmNbQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORUNBUkVUXSArICdcXFxccysnO1xucmVbQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NBUkVUVFJJTV0sICdnJyk7XG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xuXG52YXIgQ0FSRVQgPSBSKys7XG5zcmNbQ0FSRVRdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIENBUkVUTE9PU0UgPSBSKys7XG5zcmNbQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbnZhciBDT01QQVJBVE9STE9PU0UgPSBSKys7XG5zcmNbQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnO1xudmFyIENPTVBBUkFUT1IgPSBSKys7XG5zcmNbQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBGVUxMUExBSU4gKyAnKSR8XiQnO1xuXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG52YXIgQ09NUEFSQVRPUlRSSU0gPSBSKys7XG5zcmNbQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1tHVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSc7XG5cbi8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcbnJlW0NPTVBBUkFUT1JUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJztcblxuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxudmFyIEhZUEhFTlJBTkdFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxudmFyIEhZUEhFTlJBTkdFTE9PU0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG52YXIgU1RBUiA9IFIrKztcbnNyY1tTVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcblxuLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4vLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLlxuZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHtcbiAgZGVidWcoaSwgc3JjW2ldKTtcbiAgaWYgKCFyZVtpXSlcbiAgICByZVtpXSA9IG5ldyBSZWdFeHAoc3JjW2ldKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZnVuY3Rpb24gcGFyc2UodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpXG4gICAgcmV0dXJuIHZlcnNpb247XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciByID0gbG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXTtcbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkO1xuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbDtcbn1cblxuXG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5mdW5jdGlvbiBjbGVhbih2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgbG9vc2UpO1xuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGw7XG59XG5cbmV4cG9ydHMuU2VtVmVyID0gU2VtVmVyO1xuXG5mdW5jdGlvbiBTZW1WZXIodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICBlbHNlXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG5cbiAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcblxuICB0aGlzLnJhdyA9IHZlcnNpb247XG5cbiAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgdGhpcy5tYWpvciA9ICttWzFdO1xuICB0aGlzLm1pbm9yID0gK21bMl07XG4gIHRoaXMucGF0Y2ggPSArbVszXTtcblxuICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcblxuICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgaWYgKCFtWzRdKVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICBlbHNlXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgdmFyIG51bSA9ICtpZDtcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdO1xuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLmxvb3NlLCBvdGhlcik7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIGkgPSAwO1xuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKTtcbiAgfSB3aGlsZSAoKytpKTtcbn07XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24ocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgIC8vIHByZXBhdGNoLlxuICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHwgdGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtaW5vcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgY2FzZSAncHJlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gLTEpIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSlcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpO1xuICB9XG4gIHRoaXMuZm9ybWF0KCk7XG4gIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydHMuaW5jID0gaW5jO1xuZnVuY3Rpb24gaW5jKHZlcnNpb24sIHJlbGVhc2UsIGxvb3NlLCBpZGVudGlmaWVyKSB7XG4gIGlmICh0eXBlb2YobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZTtcbiAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmY7XG5mdW5jdGlvbiBkaWZmKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKTtcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMik7XG4gICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiAncHJlJytrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3ByZXJlbGVhc2UnO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnM7XG5cbnZhciBudW1lcmljID0gL15bMC05XSskLztcbmZ1bmN0aW9uIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHZhciBhbnVtID0gbnVtZXJpYy50ZXN0KGEpO1xuICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthO1xuICAgIGIgPSArYjtcbiAgfVxuXG4gIHJldHVybiAoYW51bSAmJiAhYm51bSkgPyAtMSA6XG4gICAgICAgICAoYm51bSAmJiAhYW51bSkgPyAxIDpcbiAgICAgICAgIGEgPCBiID8gLTEgOlxuICAgICAgICAgYSA+IGIgPyAxIDpcbiAgICAgICAgIDA7XG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnM7XG5mdW5jdGlvbiByY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKTtcbn1cblxuZXhwb3J0cy5tYWpvciA9IG1ham9yO1xuZnVuY3Rpb24gbWFqb3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yO1xufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3I7XG5mdW5jdGlvbiBtaW5vcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3I7XG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcbmZ1bmN0aW9uIHBhdGNoKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaDtcbn1cblxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpO1xufVxuXG5leHBvcnRzLmNvbXBhcmVMb29zZSA9IGNvbXBhcmVMb29zZTtcbmZ1bmN0aW9uIGNvbXBhcmVMb29zZShhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIHRydWUpO1xufVxuXG5leHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmU7XG5mdW5jdGlvbiByY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSk7XG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5mdW5jdGlvbiBzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yc29ydCA9IHJzb3J0O1xuZnVuY3Rpb24gcnNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ndCA9IGd0O1xuZnVuY3Rpb24gZ3QoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMDtcbn1cblxuZXhwb3J0cy5sdCA9IGx0O1xuZnVuY3Rpb24gbHQoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMDtcbn1cblxuZXhwb3J0cy5lcSA9IGVxO1xuZnVuY3Rpb24gZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwO1xufVxuXG5leHBvcnRzLm5lcSA9IG5lcTtcbmZ1bmN0aW9uIG5lcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDA7XG59XG5cbmV4cG9ydHMuZ3RlID0gZ3RlO1xuZnVuY3Rpb24gZ3RlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwO1xufVxuXG5leHBvcnRzLmx0ZSA9IGx0ZTtcbmZ1bmN0aW9uIGx0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMDtcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXA7XG5mdW5jdGlvbiBjbXAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gIHZhciByZXQ7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhID09PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSAhPT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyc6IGNhc2UgJz0nOiBjYXNlICc9PSc6IHJldCA9IGVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnIT0nOiByZXQgPSBuZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+JzogcmV0ID0gZ3QoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+PSc6IHJldCA9IGd0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzwnOiByZXQgPSBsdChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzw9JzogcmV0ID0gbHRlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvcGVyYXRvcjogJyArIG9wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yO1xuZnVuY3Rpb24gQ29tcGFyYXRvcihjb21wLCBsb29zZSkge1xuICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICBpZiAoY29tcC5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gY29tcDtcbiAgICBlbHNlXG4gICAgICBjb21wID0gY29tcC52YWx1ZTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSlcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuXG4gIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHRoaXMucGFyc2UoY29tcCk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICBlbHNlXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uO1xuXG4gIGRlYnVnKCdjb21wJywgdGhpcyk7XG59XG5cbnZhciBBTlkgPSB7fTtcbkNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oY29tcCkge1xuICB2YXIgciA9IHRoaXMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBtID0gY29tcC5tYXRjaChyKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV07XG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpXG4gICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pXG4gICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gIGVsc2VcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGNvbXAsIGxvb3NlKSB7XG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdmFyIHJhbmdlVG1wO1xuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIGxvb3NlKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKHRoaXMudmFsdWUsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIGxvb3NlKTtcbiAgfVxuXG4gIHZhciBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8Jyk7XG4gIHZhciBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbjtcbiAgdmFyIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9Jyk7XG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBsb29zZSkgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKTtcblxuICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuO1xufTtcblxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5mdW5jdGlvbiBSYW5nZShyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09IGxvb3NlKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBsb29zZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIGxvb3NlKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHRoaXMubG9vc2UgPSBsb29zZTtcblxuICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICB0aGlzLnJhdyA9IHJhbmdlO1xuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbihyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKTtcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAvLyB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgcmV0dXJuIGMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgU2VtVmVyIFJhbmdlOiAnICsgcmFuZ2UpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uKGNvbXBzKSB7XG4gICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKCk7XG4gIH0pLmpvaW4oJ3x8JykudHJpbSgpO1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5sb29zZTtcbiAgcmFuZ2UgPSByYW5nZS50cmltKCk7XG4gIGRlYnVnKCdyYW5nZScsIHJhbmdlLCBsb29zZSk7XG4gIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICB2YXIgaHIgPSBsb29zZSA/IHJlW0hZUEhFTlJBTkdFTE9PU0VdIDogcmVbSFlQSEVOUkFOR0VdO1xuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpO1xuICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSk7XG4gIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpO1xuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW0NPTVBBUkFUT1JUUklNXSk7XG5cbiAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtUSUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKTtcblxuICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpO1xuXG4gIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcblxuICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gIHZhciBjb21wUmUgPSBsb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIHNldCA9IHJhbmdlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpLnNwbGl0KC9cXHMrLyk7XG4gIGlmICh0aGlzLmxvb3NlKSB7XG4gICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uKGNvbXApIHtcbiAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKTtcbiAgICB9KTtcbiAgfVxuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KTtcblxuICByZXR1cm4gc2V0O1xufTtcblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQuc29tZShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmFuZ2Uuc2V0LnNvbWUoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9ycykge1xuICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIGxvb3NlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gIH0pO1xufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygndGlsZGVzJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdzdGFycycsIGNvbXApO1xuICByZXR1cm4gY29tcDtcbn1cblxuZnVuY3Rpb24gaXNYKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKSB7XG4gIHZhciByID0gbG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZVxuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSkge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBsb29zZSk7XG4gIHZhciByID0gbG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIGxvb3NlKTtcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24ocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKVxuICAgICAgZ3RsdCA9ICcnO1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSlcbiAgICAgICAgbSA9IDA7XG4gICAgICBpZiAoeHApXG4gICAgICAgIHAgPSAwO1xuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49JztcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgaWYgKHhtKVxuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwO1xuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBsb29zZSk7XG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVtTVEFSXSwgJycpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVtIWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMFxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSgkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgICAgICAgICAgICAgICAgICAgICAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcblxuICBpZiAoaXNYKGZNKSlcbiAgICBmcm9tID0gJyc7XG4gIGVsc2UgaWYgKGlzWChmbSkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKGZwKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4nICsgZm0gKyAnLjAnO1xuICBlbHNlXG4gICAgZnJvbSA9ICc+PScgKyBmcm9tO1xuXG4gIGlmIChpc1godE0pKVxuICAgIHRvID0gJyc7XG4gIGVsc2UgaWYgKGlzWCh0bSkpXG4gICAgdG8gPSAnPCcgKyAoK3RNICsgMSkgKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWCh0cCkpXG4gICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCc7XG4gIGVsc2UgaWYgKHRwcilcbiAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHI7XG4gIGVsc2VcbiAgICB0byA9ICc8PScgKyB0bztcblxuICByZXR1cm4gKGZyb20gKyAnICcgKyB0bykudHJpbSgpO1xufVxuXG5cbi8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcblJhbmdlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHRlc3RTZXQoc2V0LCB2ZXJzaW9uKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllcztcbmZ1bmN0aW9uIHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKTtcbn1cblxuZXhwb3J0cy5tYXhTYXRpc2Z5aW5nID0gbWF4U2F0aXNmeWluZztcbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1heFNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7IC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2O1xuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBsb29zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4O1xufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWluU1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIGxvb3NlKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgeyAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pbjtcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZTtcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8JywgbG9vc2UpO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0cjtcbmZ1bmN0aW9uIGd0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+JywgbG9vc2UpO1xufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgbG9vc2UpIHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHQ7XG4gICAgICBsdGVmbiA9IGd0ZTtcbiAgICAgIGx0Zm4gPSBndDtcbiAgICAgIGNvbXAgPSAnPCc7XG4gICAgICBlY29tcCA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTtcblxuICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICB2YXIgbG93ID0gbnVsbDtcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvcjtcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5mdW5jdGlvbiBwcmVyZWxlYXNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgbG9vc2UpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIGxvb3NlKVxuICByMiA9IG5ldyBSYW5nZShyMiwgbG9vc2UpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/semver/semver.js\n");

/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./node_modules/has-flag/index.js\");\n\nconst env = process.env;\n\nconst support = level => {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n};\n\nlet supportLevel = (() => {\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn 1;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn 0;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Hyper':\n\t\t\t\treturn 3;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n})();\n\nif ('FORCE_COLOR' in env) {\n\tsupportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : (supportLevel || 1);\n}\n\nmodule.exports = process && support(supportLevel);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGhhc0ZsYWcgPSByZXF1aXJlKCdoYXMtZmxhZycpO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3Qgc3VwcG9ydCA9IGxldmVsID0+IHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59O1xuXG5sZXQgc3VwcG9ydExldmVsID0gKCgpID0+IHtcblx0aWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0XHRoYXNGbGFnKCduby1jb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHQvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG5cdFx0Ly8gbGlidXYgdGhhdCBlbmFibGVzIDI1NiBjb2xvciBvdXRwdXQgb24gV2luZG93cy4gQW55dGhpbmcgZWFybGllciBhbmQgaXRcblx0XHQvLyB3b24ndCB3b3JrLiBIb3dldmVyLCBoZXJlIHdlIHRhcmdldCBOb2RlLmpzIDggYXQgbWluaW11bSBhcyBpdCBpcyBhbiBMVFNcblx0XHQvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93c1xuXHRcdC8vIHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAyNTYgY29sb3JzLlxuXHRcdGNvbnN0IG9zUmVsZWFzZSA9IG9zLnJlbGVhc2UoKS5zcGxpdCgnLicpO1xuXHRcdGlmIChcblx0XHRcdE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPj0gOCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKCdURVJNX1BST0dSQU0nIGluIGVudikge1xuXHRcdGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cblx0XHRzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcblx0XHRcdGNhc2UgJ2lUZXJtLmFwcCc6XG5cdFx0XHRcdHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcblx0XHRcdGNhc2UgJ0h5cGVyJzpcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gTm8gZGVmYXVsdFxuXHRcdH1cblx0fVxuXG5cdGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59KSgpO1xuXG5pZiAoJ0ZPUkNFX0NPTE9SJyBpbiBlbnYpIHtcblx0c3VwcG9ydExldmVsID0gcGFyc2VJbnQoZW52LkZPUkNFX0NPTE9SLCAxMCkgPT09IDAgPyAwIDogKHN1cHBvcnRMZXZlbCB8fCAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzICYmIHN1cHBvcnQoc3VwcG9ydExldmVsKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/supports-color/index.js\n");

/***/ }),

/***/ "./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst osTmpDir = __webpack_require__(/*! os-tmpdir */ \"./node_modules/os-tmpdir/index.js\");\nconst _c = process.binding('constants');\n\n/*\n * The working inner variables.\n */\nconst\n  /**\n   * The temporary directory.\n   * @type {string}\n   */\n  tmpDir = osTmpDir(),\n\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 448 /* 0o700 */,\n  FILE_MODE = 384 /* 0o600 */,\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [];\n\nvar\n  _gracefulCleanup = false,\n  _uncaughtException = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|Function)} options\n * @param {Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  if (typeof options == 'function') {\n    return [callback || {}, options];\n  }\n\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  if (opts.name) {\n    return path.join(opts.dir || tmpDir, opts.name);\n  }\n\n  // mkstemps like template\n  if (opts.template) {\n    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    opts.prefix || 'tmp-',\n    process.pid,\n    _randomChars(12),\n    opts.postfix || ''\n  ].join('');\n\n  return path.join(opts.dir || tmpDir, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    const name = _generateTmpName(opts);\n\n    // check whether the path exists then retry if needed\n    fs.stat(name, function (err) {\n      if (!err) {\n        if (tries-- > 0) return _getUniqueName();\n\n        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n      }\n\n      cb(null, name);\n    });\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|fileCallback)} options the config options or the callback function\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(err) {\n          if (err) {\n            // Low probability, and the file exists, so this could be\n            // ignored.  If it isn't we certainly need to unlink the\n            // file, and if that fails too its error is more\n            // important.\n            try {\n              fs.unlinkSync(name);\n            } catch (e) {\n              if (!isENOENT(e)) {\n                err = e;\n              }\n            }\n            return cb(err);\n          }\n          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));\n        });\n      }\n      if (opts.detachDescriptor) {\n        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));\n      }\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  opts.postfix = opts.postfix || '.tmp';\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd); \n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)\n  };\n}\n\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {string} root\n * @private\n */\nfunction _rmdirRecursiveSync(root) {\n  const dirs = [root];\n\n  do {\n    var\n      dir = dirs.pop(),\n      deferred = false,\n      files = fs.readdirSync(dir);\n\n    for (var i = 0, length = files.length; i < length; i++) {\n      var\n        file = path.join(dir, files[i]),\n        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n\n      if (stat.isDirectory()) {\n        if (!deferred) {\n          deferred = true;\n          dirs.push(dir);\n        }\n        dirs.push(file);\n      } else {\n        fs.unlinkSync(file);\n      }\n    }\n\n    if (!deferred) {\n      fs.rmdirSync(dir);\n    }\n  } while (dirs.length !== 0);\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @returns {fileCallback}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n    try {\n      if (0 <= fdPath[0]) {\n        fs.closeSync(fdPath[0]);\n      }\n    }\n    catch (e) {\n      // under some node/windows related circumstances, a temporary file\n      // may have not be created as expected or the file was already closed\n      // by the user, in which case we will simply ignore the error\n      if (!isEBADF(e) && !isENOENT(e)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      if (!isENOENT(e)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n  }, [fd, name]);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {string} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, arg) {\n  var called = false;\n\n  return function _cleanupCallback(next) {\n    if (!called) {\n      const index = _removeObjects.indexOf(_cleanupCallback);\n      if (index >= 0) {\n        _removeObjects.splice(index, 1);\n      }\n\n      called = true;\n      removeFunction(arg);\n    }\n\n    if (next) next(null);\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0].call(null);\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n */\nfunction isEBADF(error) {\n  return isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n */\nfunction isENOENT(error) {\n  return isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {String}\n *   error.errno {String|Number} any numerical value will be negated\n *\n * - Node >= 6.0 < 7.0:\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 4.0 < 6.0: introduces SystemError\n *   error.code {String}\n *   error.errno {Number} negated\n *\n * - Node >= 0.10 < 4.0:\n *   error.code {Number} negated\n *   error.errno n/a\n */\nfunction isExpectedError(error, code, errno) {\n  return error.code == code || error.code == errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * Also removes the created files and directories when an uncaught exception occurs.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\nconst version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n    _garbageCollector();\n\n    throw err;\n  });\n}\n\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n  _garbageCollector();\n});\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?number} tries the number of tries before give up the name generation\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fix name\n * @property {?string} dir the tmp directory to use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call after entry was removed\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\nmodule.exports.tmpdir = tmpDir;\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG1wL2xpYi90bXAuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3RtcC9saWIvdG1wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVG1wXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTcgS0FSQVNaSSBJc3R2YW4gPGdpdGh1YkBzcGFtLnJhc3ppLmh1PlxuICpcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBvc1RtcERpciA9IHJlcXVpcmUoJ29zLXRtcGRpcicpO1xuY29uc3QgX2MgPSBwcm9jZXNzLmJpbmRpbmcoJ2NvbnN0YW50cycpO1xuXG4vKlxuICogVGhlIHdvcmtpbmcgaW5uZXIgdmFyaWFibGVzLlxuICovXG5jb25zdFxuICAvKipcbiAgICogVGhlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0bXBEaXIgPSBvc1RtcERpcigpLFxuXG4gIC8vIHRoZSByYW5kb20gY2hhcmFjdGVycyB0byBjaG9vc2UgZnJvbVxuICBSQU5ET01fQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxuXG4gIFRFTVBMQVRFX1BBVFRFUk4gPSAvWFhYWFhYLyxcblxuICBERUZBVUxUX1RSSUVTID0gMyxcblxuICBDUkVBVEVfRkxBR1MgPSAoX2MuT19DUkVBVCB8fCBfYy5mcy5PX0NSRUFUKSB8IChfYy5PX0VYQ0wgfHwgX2MuZnMuT19FWENMKSB8IChfYy5PX1JEV1IgfHwgX2MuZnMuT19SRFdSKSxcblxuICBFQkFERiA9IF9jLkVCQURGIHx8IF9jLm9zLmVycm5vLkVCQURGLFxuICBFTk9FTlQgPSBfYy5FTk9FTlQgfHwgX2Mub3MuZXJybm8uRU5PRU5ULFxuXG4gIERJUl9NT0RFID0gNDQ4IC8qIDBvNzAwICovLFxuICBGSUxFX01PREUgPSAzODQgLyogMG82MDAgKi8sXG5cbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXTtcblxudmFyXG4gIF9ncmFjZWZ1bENsZWFudXAgPSBmYWxzZSxcbiAgX3VuY2F1Z2h0RXhjZXB0aW9uID0gZmFsc2U7XG5cbi8qKlxuICogUmFuZG9tIG5hbWUgZ2VuZXJhdG9yIGJhc2VkIG9uIGNyeXB0by5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwOi8vYmxvZy50b21wYXdsYWsub3JnL2hvdy10by1nZW5lcmF0ZS1yYW5kb20tdmFsdWVzLW5vZGVqcy1qYXZhc2NyaXB0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGhvd01hbnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgcmFuZG9tIG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yYW5kb21DaGFycyhob3dNYW55KSB7XG4gIHZhclxuICAgIHZhbHVlID0gW10sXG4gICAgcm5kID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgZmFpbCBiZWNhdXNlIHdlIHJhbiBvdXQgb2YgZW50cm9weVxuICB0cnkge1xuICAgIHJuZCA9IGNyeXB0by5yYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJuZCA9IGNyeXB0by5wc2V1ZG9SYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgdmFsdWUucHVzaChSQU5ET01fQ0hBUlNbcm5kW2ldICUgUkFORE9NX0NIQVJTLmxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBhcnNlZCBhcmd1bWVudHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBbY2FsbGJhY2sgfHwge30sIG9wdGlvbnNdO1xuICB9XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHJldHVybiBbe30sIGNhbGxiYWNrXTtcbiAgfVxuXG4gIHJldHVybiBbb3B0aW9ucywgY2FsbGJhY2tdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyB0ZW1wb3JhcnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5ldyByYW5kb20gbmFtZSBhY2NvcmRpbmcgdG8gb3B0c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlVG1wTmFtZShvcHRzKSB7XG4gIGlmIChvcHRzLm5hbWUpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKG9wdHMuZGlyIHx8IHRtcERpciwgb3B0cy5uYW1lKTtcbiAgfVxuXG4gIC8vIG1rc3RlbXBzIGxpa2UgdGVtcGxhdGVcbiAgaWYgKG9wdHMudGVtcGxhdGUpIHtcbiAgICByZXR1cm4gb3B0cy50ZW1wbGF0ZS5yZXBsYWNlKFRFTVBMQVRFX1BBVFRFUk4sIF9yYW5kb21DaGFycyg2KSk7XG4gIH1cblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCB8fCAndG1wLScsXG4gICAgcHJvY2Vzcy5waWQsXG4gICAgX3JhbmRvbUNoYXJzKDEyKSxcbiAgICBvcHRzLnBvc3RmaXggfHwgJydcbiAgXS5qb2luKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKG9wdHMuZGlyIHx8IHRtcERpciwgbmFtZSk7XG59XG5cbi8qKlxuICogR2V0cyBhIHRlbXBvcmFyeSBmaWxlIG5hbWUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3x0bXBOYW1lQ2FsbGJhY2spfSBvcHRpb25zIG9wdGlvbnMgb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSB7P3RtcE5hbWVDYWxsYmFja30gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyXG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdLFxuICAgIHRyaWVzID0gb3B0cy5uYW1lID8gMSA6IG9wdHMudHJpZXMgfHwgREVGQVVMVF9UUklFUztcblxuICBpZiAoaXNOYU4odHJpZXMpIHx8IHRyaWVzIDwgMClcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIHRyaWVzJykpO1xuXG4gIGlmIChvcHRzLnRlbXBsYXRlICYmICFvcHRzLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUgcHJvdmlkZWQnKSk7XG5cbiAgKGZ1bmN0aW9uIF9nZXRVbmlxdWVOYW1lKCkge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgcGF0aCBleGlzdHMgdGhlbiByZXRyeSBpZiBuZWVkZWRcbiAgICBmcy5zdGF0KG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGlmICh0cmllcy0tID4gMCkgcmV0dXJuIF9nZXRVbmlxdWVOYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGNiKG51bGwsIG5hbWUpO1xuICAgIH0pO1xuICB9KCkpO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgdG1wTmFtZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkIG9yIGNvdWxkIG5vdCBnZW5lcmF0ZSBhIGZpbGVuYW1lXG4gKi9cbmZ1bmN0aW9uIHRtcE5hbWVTeW5jKG9wdGlvbnMpIHtcbiAgdmFyXG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICB0cmllcyA9IG9wdHMubmFtZSA/IDEgOiBvcHRzLnRyaWVzIHx8IERFRkFVTFRfVFJJRVM7XG5cbiAgaWYgKGlzTmFOKHRyaWVzKSB8fCB0cmllcyA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyaWVzJyk7XG5cbiAgaWYgKG9wdHMudGVtcGxhdGUgJiYgIW9wdHMudGVtcGxhdGUubWF0Y2goVEVNUExBVEVfUEFUVEVSTikpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRlbXBsYXRlIHByb3ZpZGVkJyk7XG5cbiAgZG8ge1xuICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICBmcy5zdGF0U3luYyhuYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH0gd2hpbGUgKHRyaWVzLS0gPiAwKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYSB1bmlxdWUgdG1wIGZpbGVuYW1lLCBtYXggdHJpZXMgcmVhY2hlZCcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIG9wZW5zIGEgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xmaWxlQ2FsbGJhY2spfSBvcHRpb25zIHRoZSBjb25maWcgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2ZpbGVDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmlsZShvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgb3B0cy5wb3N0Zml4ID0gKF9pc1VuZGVmaW5lZChvcHRzLnBvc3RmaXgpKSA/ICcudG1wJyA6IG9wdHMucG9zdGZpeDtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIGFuZCBvcGVuIHRoZSBmaWxlXG4gICAgZnMub3BlbihuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUsIGZ1bmN0aW9uIF9maWxlQ3JlYXRlZChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKG9wdHMuZGlzY2FyZERlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiBfZGlzY2FyZENhbGxiYWNrKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIC8vIExvdyBwcm9iYWJpbGl0eSwgYW5kIHRoZSBmaWxlIGV4aXN0cywgc28gdGhpcyBjb3VsZCBiZVxuICAgICAgICAgICAgLy8gaWdub3JlZC4gIElmIGl0IGlzbid0IHdlIGNlcnRhaW5seSBuZWVkIHRvIHVubGluayB0aGVcbiAgICAgICAgICAgIC8vIGZpbGUsIGFuZCBpZiB0aGF0IGZhaWxzIHRvbyBpdHMgZXJyb3IgaXMgbW9yZVxuICAgICAgICAgICAgLy8gaW1wb3J0YW50LlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhuYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0VOT0VOVChlKSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYihudWxsLCBuYW1lLCB1bmRlZmluZWQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIC0xLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuZGV0YWNoRGVzY3JpcHRvcikge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgbmFtZSwgZmQsIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIC0xLCBvcHRzKSk7XG4gICAgICB9XG4gICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZmQsIG9wdHMpKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBmaWxlLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0ZpbGVTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSwgZmQgYW5kIHJlbW92ZUNhbGxiYWNrXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgY2Fubm90IGNyZWF0ZSBhIGZpbGVcbiAqL1xuZnVuY3Rpb24gZmlsZVN5bmMob3B0aW9ucykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIG9wdHMucG9zdGZpeCA9IG9wdHMucG9zdGZpeCB8fCAnLnRtcCc7XG5cbiAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIHZhciBmZCA9IGZzLm9wZW5TeW5jKG5hbWUsIENSRUFURV9GTEFHUywgb3B0cy5tb2RlIHx8IEZJTEVfTU9ERSk7XG4gIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZkKTsgXG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cylcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGZpbGVzIGFuZCBmb2xkZXJzIGluIGEgZGlyZWN0b3J5IHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb290XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcm1kaXJSZWN1cnNpdmVTeW5jKHJvb3QpIHtcbiAgY29uc3QgZGlycyA9IFtyb290XTtcblxuICBkbyB7XG4gICAgdmFyXG4gICAgICBkaXIgPSBkaXJzLnBvcCgpLFxuICAgICAgZGVmZXJyZWQgPSBmYWxzZSxcbiAgICAgIGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBmaWxlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyXG4gICAgICAgIGZpbGUgPSBwYXRoLmpvaW4oZGlyLCBmaWxlc1tpXSksXG4gICAgICAgIHN0YXQgPSBmcy5sc3RhdFN5bmMoZmlsZSk7IC8vIGxzdGF0IHNvIHdlIGRvbid0IHJlY3Vyc2UgaW50byBzeW1saW5rZWQgZGlyZWN0b3JpZXNcblxuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgICAgZGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgIGRpcnMucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZzLnVubGlua1N5bmMoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgZnMucm1kaXJTeW5jKGRpcik7XG4gICAgfVxuICB9IHdoaWxlIChkaXJzLmxlbmd0aCAhPT0gMCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xkaXJDYWxsYmFjayl9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9kaXJDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZGlyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhclxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGNiKG51bGwsIG5hbWUsIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cykpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGRpci5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtEaXJTeW5jT2JqZWN0fSBvYmplY3QgY29uc2lzdHMgb2YgbmFtZSBhbmQgcmVtb3ZlQ2FsbGJhY2tcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBjYW5ub3QgY3JlYXRlIGEgZGlyZWN0b3J5XG4gKi9cbmZ1bmN0aW9uIGRpclN5bmMob3B0aW9ucykge1xuICB2YXJcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IG5hbWUgPSB0bXBOYW1lU3luYyhvcHRzKTtcbiAgZnMubWtkaXJTeW5jKG5hbWUsIG9wdHMubW9kZSB8fCBESVJfTU9ERSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMpXG4gIH07XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm5zIHtmaWxlQ2FsbGJhY2t9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBmZCwgb3B0cykge1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soZnVuY3Rpb24gX3JlbW92ZUNhbGxiYWNrKGZkUGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoMCA8PSBmZFBhdGhbMF0pIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkUGF0aFswXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyB1bmRlciBzb21lIG5vZGUvd2luZG93cyByZWxhdGVkIGNpcmN1bXN0YW5jZXMsIGEgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIC8vIG1heSBoYXZlIG5vdCBiZSBjcmVhdGVkIGFzIGV4cGVjdGVkIG9yIHRoZSBmaWxlIHdhcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgLy8gYnkgdGhlIHVzZXIsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBzaW1wbHkgaWdub3JlIHRoZSBlcnJvclxuICAgICAgaWYgKCFpc0VCQURGKGUpICYmICFpc0VOT0VOVChlKSkge1xuICAgICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmcy51bmxpbmtTeW5jKGZkUGF0aFsxXSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWlzRU5PRU5UKGUpKSB7XG4gICAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtmZCwgbmFtZV0pO1xuXG4gIGlmICghb3B0cy5rZWVwKSB7XG4gICAgX3JlbW92ZU9iamVjdHMudW5zaGlmdChyZW1vdmVDYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cykge1xuICBjb25zdCByZW1vdmVGdW5jdGlvbiA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IF9ybWRpclJlY3Vyc2l2ZVN5bmMgOiBmcy5ybWRpclN5bmMuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIHtcbiAgICBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW1vdmVGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvbiwgYXJnKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gX3JlbW92ZU9iamVjdHMuaW5kZXhPZihfY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIF9yZW1vdmVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICByZW1vdmVGdW5jdGlvbihhcmcpO1xuICAgIH1cblxuICAgIGlmIChuZXh0KSBuZXh0KG51bGwpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2FyYmFnZUNvbGxlY3RvcigpIHtcbiAgaWYgKF91bmNhdWdodEV4Y2VwdGlvbiAmJiAhX2dyYWNlZnVsQ2xlYW51cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQgcmVtb3ZlcyBpdHNlbGYgZnJvbSBfcmVtb3ZlT2JqZWN0cyxcbiAgLy8gbG9vcCB1bnRpbCBfcmVtb3ZlT2JqZWN0cyBpcyBlbXB0eVxuICB3aGlsZSAoX3JlbW92ZU9iamVjdHMubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9yZW1vdmVPYmplY3RzWzBdLmNhbGwobnVsbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gYWxyZWFkeSByZW1vdmVkP1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVCQURGIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKi9cbmZ1bmN0aW9uIGlzRUJBREYoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVCQURGLCAnRUJBREYnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFTk9FTlQgdG8gY29tcGVuc2F0ZSBjaGFuZ2VzIG1hZGUgdG8gTm9kZSA3LnggdW5kZXIgV2luZG93cy5cbiAqL1xuZnVuY3Rpb24gaXNFTk9FTlQoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVOT0VOVCwgJ0VOT0VOVCcpO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZXhwZWN0ZWQgZXJyb3IgY29kZSBtYXRjaGVzIHRoZSBhY3R1YWwgY29kZSBhbmQgZXJybm8sXG4gKiB3aGljaCB3aWxsIGRpZmZlciBiZXR3ZWVuIHRoZSBzdXBwb3J0ZWQgbm9kZSB2ZXJzaW9ucy5cbiAqXG4gKiAtIE5vZGUgPj0gNy4wOlxuICogICBlcnJvci5jb2RlIHtTdHJpbmd9XG4gKiAgIGVycm9yLmVycm5vIHtTdHJpbmd8TnVtYmVyfSBhbnkgbnVtZXJpY2FsIHZhbHVlIHdpbGwgYmUgbmVnYXRlZFxuICpcbiAqIC0gTm9kZSA+PSA2LjAgPCA3LjA6XG4gKiAgIGVycm9yLmNvZGUge1N0cmluZ31cbiAqICAgZXJyb3IuZXJybm8ge051bWJlcn0gbmVnYXRlZFxuICpcbiAqIC0gTm9kZSA+PSA0LjAgPCA2LjA6IGludHJvZHVjZXMgU3lzdGVtRXJyb3JcbiAqICAgZXJyb3IuY29kZSB7U3RyaW5nfVxuICogICBlcnJvci5lcnJubyB7TnVtYmVyfSBuZWdhdGVkXG4gKlxuICogLSBOb2RlID49IDAuMTAgPCA0LjA6XG4gKiAgIGVycm9yLmNvZGUge051bWJlcn0gbmVnYXRlZFxuICogICBlcnJvci5lcnJubyBuL2FcbiAqL1xuZnVuY3Rpb24gaXNFeHBlY3RlZEVycm9yKGVycm9yLCBjb2RlLCBlcnJubykge1xuICByZXR1cm4gZXJyb3IuY29kZSA9PSBjb2RlIHx8IGVycm9yLmNvZGUgPT0gZXJybm87XG59XG5cbi8qKlxuICogU2V0cyB0aGUgZ3JhY2VmdWwgY2xlYW51cC5cbiAqXG4gKiBBbHNvIHJlbW92ZXMgdGhlIGNyZWF0ZWQgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIHdoZW4gYW4gdW5jYXVnaHQgZXhjZXB0aW9uIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gc2V0R3JhY2VmdWxDbGVhbnVwKCkge1xuICBfZ3JhY2VmdWxDbGVhbnVwID0gdHJ1ZTtcbn1cblxuY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59KTtcblxuaWYgKHZlcnNpb25bMF0gPT09IDAgJiYgKHZlcnNpb25bMV0gPCA5IHx8IHZlcnNpb25bMV0gPT09IDkgJiYgdmVyc2lvblsyXSA8IDUpKSB7XG4gIHByb2Nlc3MuYWRkTGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gX3VuY2F1Z2h0RXhjZXB0aW9uVGhyb3duKGVycikge1xuICAgIF91bmNhdWdodEV4Y2VwdGlvbiA9IHRydWU7XG4gICAgX2dhcmJhZ2VDb2xsZWN0b3IoKTtcblxuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbnByb2Nlc3MuYWRkTGlzdGVuZXIoJ2V4aXQnLCBmdW5jdGlvbiBfZXhpdChjb2RlKSB7XG4gIGlmIChjb2RlKSBfdW5jYXVnaHRFeGNlcHRpb24gPSB0cnVlO1xuICBfZ2FyYmFnZUNvbGxlY3RvcigpO1xufSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdHJpZXMgdGhlIG51bWJlciBvZiB0cmllcyBiZWZvcmUgZ2l2ZSB1cCB0aGUgbmFtZSBnZW5lcmF0aW9uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRlbXBsYXRlIHRoZSBcIm1rc3RlbXBcIiBsaWtlIGZpbGVuYW1lIHRlbXBsYXRlXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG5hbWUgZml4IG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGlyIHRoZSB0bXAgZGlyZWN0b3J5IHRvIHVzZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwcmVmaXggcHJlZml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcG9zdGZpeCBwb3N0Zml4IGZvciB0aGUgZ2VuZXJhdGVkIG5hbWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGVTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaXJTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZGlyZWN0b3J5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgdG1wTmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGRpckNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdGVtcG9yYXJ5IGNyZWF0ZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gKlxuICogQGNhbGxiYWNrIGNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtzaW1wbGVDYWxsYmFja30gW25leHRdIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZW50cnkgd2FzIHJlbW92ZWRcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBjb21wb3NpdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYXN6aS9ub2RlLXRtcC9pc3N1ZXMvNTd8cmFzemkvbm9kZS10bXAjNTd9XG4gKlxuICogQGNhbGxiYWNrIHNpbXBsZUNhbGxiYWNrXG4gKi9cblxuLy8gZXhwb3J0aW5nIGFsbCB0aGUgbmVlZGVkIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzLnRtcGRpciA9IHRtcERpcjtcblxubW9kdWxlLmV4cG9ydHMuZGlyID0gZGlyO1xubW9kdWxlLmV4cG9ydHMuZGlyU3luYyA9IGRpclN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLmZpbGUgPSBmaWxlO1xubW9kdWxlLmV4cG9ydHMuZmlsZVN5bmMgPSBmaWxlU3luYztcblxubW9kdWxlLmV4cG9ydHMudG1wTmFtZSA9IHRtcE5hbWU7XG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lU3luYyA9IHRtcE5hbWVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRHcmFjZWZ1bENsZWFudXAgPSBzZXRHcmFjZWZ1bENsZWFudXA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tmp/lib/tmp.js\n");

/***/ }),

/***/ "./node_modules/vscode-cpptools/out/api.js":
/*!*************************************************!*\
  !*** ./node_modules/vscode-cpptools/out/api.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\n/**\r\n * API version information.\r\n */\r\nvar Version;\r\n(function (Version) {\r\n    Version[Version[\"v0\"] = 0] = \"v0\";\r\n    Version[Version[\"v1\"] = 1] = \"v1\";\r\n    Version[Version[\"v2\"] = 2] = \"v2\";\r\n    Version[Version[\"latest\"] = 2] = \"latest\";\r\n})(Version = exports.Version || (exports.Version = {}));\r\nfunction isCppToolsExtension(extension) {\r\n    return extension.getApi !== undefined;\r\n}\r\n/**\r\n * Helper function to get the CppToolsApi from the cpptools extension.\r\n * @param version The desired API version\r\n * @example\r\n```\r\n    import {CppToolsApi, Version, CustomConfigurationProvider, getCppToolsApi} from 'vscode-cpptools';\r\n\r\n    let api: CppToolsApi|undefined = await getCppToolsApi(Version.v1);\r\n    if (api) {\r\n        // Inform cpptools that a custom config provider\r\n        // will be able to service the current workspace.\r\n        api.registerCustomConfigurationProvider(provider);\r\n\r\n        // Do any required setup that the provider needs.\r\n\r\n        // Notify cpptools that the provider is ready to\r\n        // provide IntelliSense configurations.\r\n        api.notifyReady(provider);\r\n    }\r\n    // Dispose of the 'api' in your extension's\r\n    // deactivate() method, or whenever you want to\r\n    // unregister the provider.\r\n```\r\n */\r\nfunction getCppToolsApi(version) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let cpptools = vscode.extensions.getExtension(\"ms-vscode.cpptools\");\r\n        let extension;\r\n        let api;\r\n        if (cpptools) {\r\n            if (!cpptools.isActive) {\r\n                extension = yield cpptools.activate();\r\n            }\r\n            else {\r\n                extension = cpptools.exports;\r\n            }\r\n            if (isCppToolsExtension(extension)) {\r\n                // ms-vscode.cpptools > 0.17.5\r\n                try {\r\n                    api = extension.getApi(version);\r\n                }\r\n                catch (err) {\r\n                    // Unfortunately, ms-vscode.cpptools [0.17.6, 0.18.1] throws a RangeError if you specify a version greater than v1.\r\n                    // These versions of the extension will not be able to act on the newer interface and v2 is a superset of v1, so we can safely fall back to v1.\r\n                    let e = err;\r\n                    if (e.message && e.message.startsWith(\"Invalid version\")) {\r\n                        api = extension.getApi(Version.v1);\r\n                    }\r\n                }\r\n                if (version !== Version.v1) {\r\n                    if (!api.getVersion) {\r\n                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version 1 instead.`);\r\n                    }\r\n                    else if (version !== api.getVersion()) {\r\n                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version ${api.getVersion()} instead.`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // ms-vscode.cpptools version 0.17.5\r\n                api = extension;\r\n                if (version !== Version.v0) {\r\n                    console.warn(`vscode-cpptools-api version ${version} requested, but is not available in version 0.17.5 of the cpptools extension. Using version 0 instead.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"C/C++ extension is not installed\");\r\n        }\r\n        return api;\r\n    });\r\n}\r\nexports.getCppToolsApi = getCppToolsApi;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWNwcHRvb2xzL291dC9hcGkuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1jcHB0b29scy9vdXQvYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuLyoqXHJcbiAqIEFQSSB2ZXJzaW9uIGluZm9ybWF0aW9uLlxyXG4gKi9cclxudmFyIFZlcnNpb247XHJcbihmdW5jdGlvbiAoVmVyc2lvbikge1xyXG4gICAgVmVyc2lvbltWZXJzaW9uW1widjBcIl0gPSAwXSA9IFwidjBcIjtcclxuICAgIFZlcnNpb25bVmVyc2lvbltcInYxXCJdID0gMV0gPSBcInYxXCI7XHJcbiAgICBWZXJzaW9uW1ZlcnNpb25bXCJ2MlwiXSA9IDJdID0gXCJ2MlwiO1xyXG4gICAgVmVyc2lvbltWZXJzaW9uW1wibGF0ZXN0XCJdID0gMl0gPSBcImxhdGVzdFwiO1xyXG59KShWZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uIHx8IChleHBvcnRzLlZlcnNpb24gPSB7fSkpO1xyXG5mdW5jdGlvbiBpc0NwcFRvb2xzRXh0ZW5zaW9uKGV4dGVuc2lvbikge1xyXG4gICAgcmV0dXJuIGV4dGVuc2lvbi5nZXRBcGkgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgQ3BwVG9vbHNBcGkgZnJvbSB0aGUgY3BwdG9vbHMgZXh0ZW5zaW9uLlxyXG4gKiBAcGFyYW0gdmVyc2lvbiBUaGUgZGVzaXJlZCBBUEkgdmVyc2lvblxyXG4gKiBAZXhhbXBsZVxyXG5gYGBcclxuICAgIGltcG9ydCB7Q3BwVG9vbHNBcGksIFZlcnNpb24sIEN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlciwgZ2V0Q3BwVG9vbHNBcGl9IGZyb20gJ3ZzY29kZS1jcHB0b29scyc7XHJcblxyXG4gICAgbGV0IGFwaTogQ3BwVG9vbHNBcGl8dW5kZWZpbmVkID0gYXdhaXQgZ2V0Q3BwVG9vbHNBcGkoVmVyc2lvbi52MSk7XHJcbiAgICBpZiAoYXBpKSB7XHJcbiAgICAgICAgLy8gSW5mb3JtIGNwcHRvb2xzIHRoYXQgYSBjdXN0b20gY29uZmlnIHByb3ZpZGVyXHJcbiAgICAgICAgLy8gd2lsbCBiZSBhYmxlIHRvIHNlcnZpY2UgdGhlIGN1cnJlbnQgd29ya3NwYWNlLlxyXG4gICAgICAgIGFwaS5yZWdpc3RlckN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcihwcm92aWRlcik7XHJcblxyXG4gICAgICAgIC8vIERvIGFueSByZXF1aXJlZCBzZXR1cCB0aGF0IHRoZSBwcm92aWRlciBuZWVkcy5cclxuXHJcbiAgICAgICAgLy8gTm90aWZ5IGNwcHRvb2xzIHRoYXQgdGhlIHByb3ZpZGVyIGlzIHJlYWR5IHRvXHJcbiAgICAgICAgLy8gcHJvdmlkZSBJbnRlbGxpU2Vuc2UgY29uZmlndXJhdGlvbnMuXHJcbiAgICAgICAgYXBpLm5vdGlmeVJlYWR5KHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIC8vIERpc3Bvc2Ugb2YgdGhlICdhcGknIGluIHlvdXIgZXh0ZW5zaW9uJ3NcclxuICAgIC8vIGRlYWN0aXZhdGUoKSBtZXRob2QsIG9yIHdoZW5ldmVyIHlvdSB3YW50IHRvXHJcbiAgICAvLyB1bnJlZ2lzdGVyIHRoZSBwcm92aWRlci5cclxuYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDcHBUb29sc0FwaSh2ZXJzaW9uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBjcHB0b29scyA9IHZzY29kZS5leHRlbnNpb25zLmdldEV4dGVuc2lvbihcIm1zLXZzY29kZS5jcHB0b29sc1wiKTtcclxuICAgICAgICBsZXQgZXh0ZW5zaW9uO1xyXG4gICAgICAgIGxldCBhcGk7XHJcbiAgICAgICAgaWYgKGNwcHRvb2xzKSB7XHJcbiAgICAgICAgICAgIGlmICghY3BwdG9vbHMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHlpZWxkIGNwcHRvb2xzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBjcHB0b29scy5leHBvcnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0NwcFRvb2xzRXh0ZW5zaW9uKGV4dGVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1zLXZzY29kZS5jcHB0b29scyA+IDAuMTcuNVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkgPSBleHRlbnNpb24uZ2V0QXBpKHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIG1zLXZzY29kZS5jcHB0b29scyBbMC4xNy42LCAwLjE4LjFdIHRocm93cyBhIFJhbmdlRXJyb3IgaWYgeW91IHNwZWNpZnkgYSB2ZXJzaW9uIGdyZWF0ZXIgdGhhbiB2MS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSB2ZXJzaW9ucyBvZiB0aGUgZXh0ZW5zaW9uIHdpbGwgbm90IGJlIGFibGUgdG8gYWN0IG9uIHRoZSBuZXdlciBpbnRlcmZhY2UgYW5kIHYyIGlzIGEgc3VwZXJzZXQgb2YgdjEsIHNvIHdlIGNhbiBzYWZlbHkgZmFsbCBiYWNrIHRvIHYxLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UgJiYgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJJbnZhbGlkIHZlcnNpb25cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpID0gZXh0ZW5zaW9uLmdldEFwaShWZXJzaW9uLnYxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gVmVyc2lvbi52MSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXBpLmdldFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGB2c2NvZGUtY3BwdG9vbHMtYXBpIHZlcnNpb24gJHt2ZXJzaW9ufSByZXF1ZXN0ZWQsIGJ1dCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGNwcHRvb2xzIGV4dGVuc2lvbi4gVXNpbmcgdmVyc2lvbiAxIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZlcnNpb24gIT09IGFwaS5nZXRWZXJzaW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGB2c2NvZGUtY3BwdG9vbHMtYXBpIHZlcnNpb24gJHt2ZXJzaW9ufSByZXF1ZXN0ZWQsIGJ1dCBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGNwcHRvb2xzIGV4dGVuc2lvbi4gVXNpbmcgdmVyc2lvbiAke2FwaS5nZXRWZXJzaW9uKCl9IGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbXMtdnNjb2RlLmNwcHRvb2xzIHZlcnNpb24gMC4xNy41XHJcbiAgICAgICAgICAgICAgICBhcGkgPSBleHRlbnNpb247XHJcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gVmVyc2lvbi52MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgdnNjb2RlLWNwcHRvb2xzLWFwaSB2ZXJzaW9uICR7dmVyc2lvbn0gcmVxdWVzdGVkLCBidXQgaXMgbm90IGF2YWlsYWJsZSBpbiB2ZXJzaW9uIDAuMTcuNSBvZiB0aGUgY3BwdG9vbHMgZXh0ZW5zaW9uLiBVc2luZyB2ZXJzaW9uIDAgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQy9DKysgZXh0ZW5zaW9uIGlzIG5vdCBpbnN0YWxsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcGk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmdldENwcFRvb2xzQXBpID0gZ2V0Q3BwVG9vbHNBcGk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-cpptools/out/api.js\n");

/***/ }),

/***/ "./node_modules/vscode-cpptools/out/testApi.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-cpptools/out/testApi.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst api_1 = __webpack_require__(/*! ./api */ \"./node_modules/vscode-cpptools/out/api.js\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\n/**\r\n * Status codes.\r\n */\r\nvar Status;\r\n(function (Status) {\r\n    Status[Status[\"TagParsingBegun\"] = 1] = \"TagParsingBegun\";\r\n    Status[Status[\"TagParsingDone\"] = 2] = \"TagParsingDone\";\r\n    Status[Status[\"IntelliSenseCompiling\"] = 3] = \"IntelliSenseCompiling\";\r\n    Status[Status[\"IntelliSenseReady\"] = 4] = \"IntelliSenseReady\";\r\n})(Status = exports.Status || (exports.Status = {}));\r\nfunction isCppToolsTestExtension(extension) {\r\n    return extension.getTestApi !== undefined;\r\n}\r\nfunction getCppToolsTestApi(version) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let cpptools = vscode.extensions.getExtension(\"ms-vscode.cpptools\");\r\n        let extension;\r\n        let api;\r\n        if (cpptools) {\r\n            if (!cpptools.isActive) {\r\n                extension = yield cpptools.activate();\r\n            }\r\n            else {\r\n                extension = cpptools.exports;\r\n            }\r\n            if (isCppToolsTestExtension(extension)) {\r\n                // ms-vscode.cpptools > 0.17.5\r\n                try {\r\n                    api = extension.getTestApi(version);\r\n                }\r\n                catch (err) {\r\n                    // Unfortunately, ms-vscode.cpptools [0.17.6, 0.18.1] throws a RangeError if you specify a version greater than v1.\r\n                    // These versions of the extension will not be able to act on the newer interface and v2 is a superset of v1, so we can safely fall back to v1.\r\n                    let e = err;\r\n                    if (e.message && e.message.startsWith(\"Invalid version\")) {\r\n                        api = extension.getTestApi(api_1.Version.v1);\r\n                    }\r\n                }\r\n                if (version !== api_1.Version.v1) {\r\n                    if (!api.getVersion) {\r\n                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version 1 instead.`);\r\n                    }\r\n                    else if (version !== api.getVersion()) {\r\n                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version ${api.getVersion()} instead.`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // ms-vscode.cpptools version 0.17.5\r\n                api = extension;\r\n                if (version !== api_1.Version.v0) {\r\n                    console.warn(`vscode-cpptools-api version ${version} requested, but is not available in version 0.17.5 of the cpptools extension. Using version 0 instead.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"C/C++ extension is not installed\");\r\n        }\r\n        return api;\r\n    });\r\n}\r\nexports.getCppToolsTestApi = getCppToolsTestApi;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWNwcHRvb2xzL291dC90ZXN0QXBpLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtY3BwdG9vbHMvb3V0L3Rlc3RBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCIuL2FwaVwiKTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuLyoqXHJcbiAqIFN0YXR1cyBjb2Rlcy5cclxuICovXHJcbnZhciBTdGF0dXM7XHJcbihmdW5jdGlvbiAoU3RhdHVzKSB7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiVGFnUGFyc2luZ0JlZ3VuXCJdID0gMV0gPSBcIlRhZ1BhcnNpbmdCZWd1blwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIlRhZ1BhcnNpbmdEb25lXCJdID0gMl0gPSBcIlRhZ1BhcnNpbmdEb25lXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiSW50ZWxsaVNlbnNlQ29tcGlsaW5nXCJdID0gM10gPSBcIkludGVsbGlTZW5zZUNvbXBpbGluZ1wiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIkludGVsbGlTZW5zZVJlYWR5XCJdID0gNF0gPSBcIkludGVsbGlTZW5zZVJlYWR5XCI7XHJcbn0pKFN0YXR1cyA9IGV4cG9ydHMuU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IHt9KSk7XHJcbmZ1bmN0aW9uIGlzQ3BwVG9vbHNUZXN0RXh0ZW5zaW9uKGV4dGVuc2lvbikge1xyXG4gICAgcmV0dXJuIGV4dGVuc2lvbi5nZXRUZXN0QXBpICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3BwVG9vbHNUZXN0QXBpKHZlcnNpb24pIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgbGV0IGNwcHRvb2xzID0gdnNjb2RlLmV4dGVuc2lvbnMuZ2V0RXh0ZW5zaW9uKFwibXMtdnNjb2RlLmNwcHRvb2xzXCIpO1xyXG4gICAgICAgIGxldCBleHRlbnNpb247XHJcbiAgICAgICAgbGV0IGFwaTtcclxuICAgICAgICBpZiAoY3BwdG9vbHMpIHtcclxuICAgICAgICAgICAgaWYgKCFjcHB0b29scy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0geWllbGQgY3BwdG9vbHMuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGNwcHRvb2xzLmV4cG9ydHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzQ3BwVG9vbHNUZXN0RXh0ZW5zaW9uKGV4dGVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1zLXZzY29kZS5jcHB0b29scyA+IDAuMTcuNVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkgPSBleHRlbnNpb24uZ2V0VGVzdEFwaSh2ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBtcy12c2NvZGUuY3BwdG9vbHMgWzAuMTcuNiwgMC4xOC4xXSB0aHJvd3MgYSBSYW5nZUVycm9yIGlmIHlvdSBzcGVjaWZ5IGEgdmVyc2lvbiBncmVhdGVyIHRoYW4gdjEuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgdmVyc2lvbnMgb2YgdGhlIGV4dGVuc2lvbiB3aWxsIG5vdCBiZSBhYmxlIHRvIGFjdCBvbiB0aGUgbmV3ZXIgaW50ZXJmYWNlIGFuZCB2MiBpcyBhIHN1cGVyc2V0IG9mIHYxLCBzbyB3ZSBjYW4gc2FmZWx5IGZhbGwgYmFjayB0byB2MS5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlICYmIGUubWVzc2FnZS5zdGFydHNXaXRoKFwiSW52YWxpZCB2ZXJzaW9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaSA9IGV4dGVuc2lvbi5nZXRUZXN0QXBpKGFwaV8xLlZlcnNpb24udjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBhcGlfMS5WZXJzaW9uLnYxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcGkuZ2V0VmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHZzY29kZS1jcHB0b29scy1hcGkgdmVyc2lvbiAke3ZlcnNpb259IHJlcXVlc3RlZCwgYnV0IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgY3BwdG9vbHMgZXh0ZW5zaW9uLiBVc2luZyB2ZXJzaW9uIDEgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmVyc2lvbiAhPT0gYXBpLmdldFZlcnNpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHZzY29kZS1jcHB0b29scy1hcGkgdmVyc2lvbiAke3ZlcnNpb259IHJlcXVlc3RlZCwgYnV0IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgY3BwdG9vbHMgZXh0ZW5zaW9uLiBVc2luZyB2ZXJzaW9uICR7YXBpLmdldFZlcnNpb24oKX0gaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtcy12c2NvZGUuY3BwdG9vbHMgdmVyc2lvbiAwLjE3LjVcclxuICAgICAgICAgICAgICAgIGFwaSA9IGV4dGVuc2lvbjtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBhcGlfMS5WZXJzaW9uLnYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGB2c2NvZGUtY3BwdG9vbHMtYXBpIHZlcnNpb24gJHt2ZXJzaW9ufSByZXF1ZXN0ZWQsIGJ1dCBpcyBub3QgYXZhaWxhYmxlIGluIHZlcnNpb24gMC4xNy41IG9mIHRoZSBjcHB0b29scyBleHRlbnNpb24uIFVzaW5nIHZlcnNpb24gMCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDL0MrKyBleHRlbnNpb24gaXMgbm90IGluc3RhbGxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q3BwVG9vbHNUZXN0QXBpID0gZ2V0Q3BwVG9vbHNUZXN0QXBpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-cpptools/out/testApi.js\n");

/***/ }),

/***/ "./node_modules/vscode-extension-telemetry/lib/telemetryReporter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-extension-telemetry/lib/telemetryReporter.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nprocess.env['APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL'] = true;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar vscode = __webpack_require__(/*! vscode */ \"vscode\");\nvar appInsights = __webpack_require__(/*! applicationinsights */ \"./node_modules/applicationinsights/out/applicationinsights.js\");\nvar TelemetryReporter = /** @class */ (function () {\n    // tslint:disable-next-line\n    function TelemetryReporter(extensionId, extensionVersion, key) {\n        var _this = this;\n        this.extensionId = extensionId;\n        this.extensionVersion = extensionVersion;\n        this.userOptIn = false;\n        var logFilePath = process.env['VSCODE_LOGS'] || '';\n        if (logFilePath && extensionId && process.env['VSCODE_LOG_LEVEL'] === 'trace') {\n            logFilePath = path.join(logFilePath, extensionId + \".txt\");\n            this.logStream = fs.createWriteStream(logFilePath, { flags: 'a', encoding: 'utf8', autoClose: true });\n        }\n        this.updateUserOptIn(key);\n        this.configListener = vscode.workspace.onDidChangeConfiguration(function () { return _this.updateUserOptIn(key); });\n    }\n    TelemetryReporter.prototype.updateUserOptIn = function (key) {\n        var config = vscode.workspace.getConfiguration(TelemetryReporter.TELEMETRY_CONFIG_ID);\n        if (this.userOptIn !== config.get(TelemetryReporter.TELEMETRY_CONFIG_ENABLED_ID, true)) {\n            this.userOptIn = config.get(TelemetryReporter.TELEMETRY_CONFIG_ENABLED_ID, true);\n            if (this.userOptIn) {\n                this.createAppInsightsClient(key);\n            }\n            else {\n                this.dispose();\n            }\n        }\n    };\n    TelemetryReporter.prototype.createAppInsightsClient = function (key) {\n        //check if another instance is already initialized\n        if (appInsights.defaultClient) {\n            this.appInsightsClient = new appInsights.TelemetryClient(key);\n            // no other way to enable offline mode\n            this.appInsightsClient.channel.setUseDiskRetryCaching(true);\n        }\n        else {\n            appInsights.setup(key)\n                .setAutoCollectRequests(false)\n                .setAutoCollectPerformance(false)\n                .setAutoCollectExceptions(false)\n                .setAutoCollectDependencies(false)\n                .setAutoDependencyCorrelation(false)\n                .setAutoCollectConsole(false)\n                .setUseDiskRetryCaching(true)\n                .start();\n            this.appInsightsClient = appInsights.defaultClient;\n        }\n        this.appInsightsClient.commonProperties = this.getCommonProperties();\n        if (vscode && vscode.env) {\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = vscode.env.machineId;\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = vscode.env.sessionId;\n        }\n        //check if it's an Asimov key to change the endpoint\n        if (key && key.indexOf('AIF-') === 0) {\n            this.appInsightsClient.config.endpointUrl = \"https://vortex.data.microsoft.com/collect/v1\";\n        }\n    };\n    // __GDPR__COMMON__ \"common.os\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.platformversion\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.extname\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.extversion\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.vscodemachineid\" : { \"endPoint\": \"MacAddressHash\", \"classification\": \"EndUserPseudonymizedInformation\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.vscodesessionid\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n    // __GDPR__COMMON__ \"common.vscodeversion\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n    TelemetryReporter.prototype.getCommonProperties = function () {\n        var commonProperties = Object.create(null);\n        commonProperties['common.os'] = os.platform();\n        commonProperties['common.platformversion'] = (os.release() || '').replace(/^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/, '$1$2$3');\n        commonProperties['common.extname'] = this.extensionId;\n        commonProperties['common.extversion'] = this.extensionVersion;\n        if (vscode && vscode.env) {\n            commonProperties['common.vscodemachineid'] = vscode.env.machineId;\n            commonProperties['common.vscodesessionid'] = vscode.env.sessionId;\n            commonProperties['common.vscodeversion'] = vscode.version;\n        }\n        return commonProperties;\n    };\n    TelemetryReporter.prototype.sendTelemetryEvent = function (eventName, properties, measurements) {\n        if (this.userOptIn && eventName && this.appInsightsClient) {\n            this.appInsightsClient.trackEvent({\n                name: this.extensionId + \"/\" + eventName,\n                properties: properties,\n                measurements: measurements\n            });\n            if (this.logStream) {\n                this.logStream.write(\"telemetry/\" + eventName + \" \" + JSON.stringify({ properties: properties, measurements: measurements }) + \"\\n\");\n            }\n        }\n    };\n    TelemetryReporter.prototype.dispose = function () {\n        var _this = this;\n        this.configListener.dispose();\n        var flushEventsToLogger = new Promise(function (resolve) {\n            if (!_this.logStream) {\n                return resolve(void 0);\n            }\n            _this.logStream.on('finish', resolve);\n            _this.logStream.end();\n        });\n        var flushEventsToAI = new Promise(function (resolve) {\n            if (_this.appInsightsClient) {\n                _this.appInsightsClient.flush({\n                    callback: function () {\n                        // all data flushed\n                        _this.appInsightsClient = undefined;\n                        resolve(void 0);\n                    }\n                });\n            }\n            else {\n                resolve(void 0);\n            }\n        });\n        return Promise.all([flushEventsToAI, flushEventsToLogger]);\n    };\n    TelemetryReporter.TELEMETRY_CONFIG_ID = 'telemetry';\n    TelemetryReporter.TELEMETRY_CONFIG_ENABLED_ID = 'enableTelemetry';\n    return TelemetryReporter;\n}());\nexports.default = TelemetryReporter;\n//# sourceMappingURL=telemetryReporter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWV4dGVuc2lvbi10ZWxlbWV0cnkvbGliL3RlbGVtZXRyeVJlcG9ydGVyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtZXh0ZW5zaW9uLXRlbGVtZXRyeS9saWIvdGVsZW1ldHJ5UmVwb3J0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoQykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5wcm9jZXNzLmVudlsnQVBQTElDQVRJT05fSU5TSUdIVFNfTk9fRElBR05PU1RJQ19DSEFOTkVMJ10gPSB0cnVlO1xudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xudmFyIG9zID0gcmVxdWlyZShcIm9zXCIpO1xudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbnZhciB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xudmFyIGFwcEluc2lnaHRzID0gcmVxdWlyZShcImFwcGxpY2F0aW9uaW5zaWdodHNcIik7XG52YXIgVGVsZW1ldHJ5UmVwb3J0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgZnVuY3Rpb24gVGVsZW1ldHJ5UmVwb3J0ZXIoZXh0ZW5zaW9uSWQsIGV4dGVuc2lvblZlcnNpb24sIGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbklkID0gZXh0ZW5zaW9uSWQ7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uVmVyc2lvbiA9IGV4dGVuc2lvblZlcnNpb247XG4gICAgICAgIHRoaXMudXNlck9wdEluID0gZmFsc2U7XG4gICAgICAgIHZhciBsb2dGaWxlUGF0aCA9IHByb2Nlc3MuZW52WydWU0NPREVfTE9HUyddIHx8ICcnO1xuICAgICAgICBpZiAobG9nRmlsZVBhdGggJiYgZXh0ZW5zaW9uSWQgJiYgcHJvY2Vzcy5lbnZbJ1ZTQ09ERV9MT0dfTEVWRUwnXSA9PT0gJ3RyYWNlJykge1xuICAgICAgICAgICAgbG9nRmlsZVBhdGggPSBwYXRoLmpvaW4obG9nRmlsZVBhdGgsIGV4dGVuc2lvbklkICsgXCIudHh0XCIpO1xuICAgICAgICAgICAgdGhpcy5sb2dTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShsb2dGaWxlUGF0aCwgeyBmbGFnczogJ2EnLCBlbmNvZGluZzogJ3V0ZjgnLCBhdXRvQ2xvc2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVVc2VyT3B0SW4oa2V5KTtcbiAgICAgICAgdGhpcy5jb25maWdMaXN0ZW5lciA9IHZzY29kZS53b3Jrc3BhY2Uub25EaWRDaGFuZ2VDb25maWd1cmF0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZVVzZXJPcHRJbihrZXkpOyB9KTtcbiAgICB9XG4gICAgVGVsZW1ldHJ5UmVwb3J0ZXIucHJvdG90eXBlLnVwZGF0ZVVzZXJPcHRJbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihUZWxlbWV0cnlSZXBvcnRlci5URUxFTUVUUllfQ09ORklHX0lEKTtcbiAgICAgICAgaWYgKHRoaXMudXNlck9wdEluICE9PSBjb25maWcuZ2V0KFRlbGVtZXRyeVJlcG9ydGVyLlRFTEVNRVRSWV9DT05GSUdfRU5BQkxFRF9JRCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXNlck9wdEluID0gY29uZmlnLmdldChUZWxlbWV0cnlSZXBvcnRlci5URUxFTUVUUllfQ09ORklHX0VOQUJMRURfSUQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlck9wdEluKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVBcHBJbnNpZ2h0c0NsaWVudChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbGVtZXRyeVJlcG9ydGVyLnByb3RvdHlwZS5jcmVhdGVBcHBJbnNpZ2h0c0NsaWVudCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy9jaGVjayBpZiBhbm90aGVyIGluc3RhbmNlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKGFwcEluc2lnaHRzLmRlZmF1bHRDbGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwSW5zaWdodHNDbGllbnQgPSBuZXcgYXBwSW5zaWdodHMuVGVsZW1ldHJ5Q2xpZW50KGtleSk7XG4gICAgICAgICAgICAvLyBubyBvdGhlciB3YXkgdG8gZW5hYmxlIG9mZmxpbmUgbW9kZVxuICAgICAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jaGFubmVsLnNldFVzZURpc2tSZXRyeUNhY2hpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcHBJbnNpZ2h0cy5zZXR1cChrZXkpXG4gICAgICAgICAgICAgICAgLnNldEF1dG9Db2xsZWN0UmVxdWVzdHMoZmFsc2UpXG4gICAgICAgICAgICAgICAgLnNldEF1dG9Db2xsZWN0UGVyZm9ybWFuY2UoZmFsc2UpXG4gICAgICAgICAgICAgICAgLnNldEF1dG9Db2xsZWN0RXhjZXB0aW9ucyhmYWxzZSlcbiAgICAgICAgICAgICAgICAuc2V0QXV0b0NvbGxlY3REZXBlbmRlbmNpZXMoZmFsc2UpXG4gICAgICAgICAgICAgICAgLnNldEF1dG9EZXBlbmRlbmN5Q29ycmVsYXRpb24oZmFsc2UpXG4gICAgICAgICAgICAgICAgLnNldEF1dG9Db2xsZWN0Q29uc29sZShmYWxzZSlcbiAgICAgICAgICAgICAgICAuc2V0VXNlRGlza1JldHJ5Q2FjaGluZyh0cnVlKVxuICAgICAgICAgICAgICAgIC5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudCA9IGFwcEluc2lnaHRzLmRlZmF1bHRDbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jb21tb25Qcm9wZXJ0aWVzID0gdGhpcy5nZXRDb21tb25Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIGlmICh2c2NvZGUgJiYgdnNjb2RlLmVudikge1xuICAgICAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jb250ZXh0LnRhZ3NbdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jb250ZXh0LmtleXMudXNlcklkXSA9IHZzY29kZS5lbnYubWFjaGluZUlkO1xuICAgICAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jb250ZXh0LnRhZ3NbdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC5jb250ZXh0LmtleXMuc2Vzc2lvbklkXSA9IHZzY29kZS5lbnYuc2Vzc2lvbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgaWYgaXQncyBhbiBBc2ltb3Yga2V5IHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZignQUlGLScpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFwcEluc2lnaHRzQ2xpZW50LmNvbmZpZy5lbmRwb2ludFVybCA9IFwiaHR0cHM6Ly92b3J0ZXguZGF0YS5taWNyb3NvZnQuY29tL2NvbGxlY3QvdjFcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gX19HRFBSX19DT01NT05fXyBcImNvbW1vbi5vc1wiIDogeyBcImNsYXNzaWZpY2F0aW9uXCI6IFwiU3lzdGVtTWV0YURhdGFcIiwgXCJwdXJwb3NlXCI6IFwiRmVhdHVyZUluc2lnaHRcIiB9XG4gICAgLy8gX19HRFBSX19DT01NT05fXyBcImNvbW1vbi5wbGF0Zm9ybXZlcnNpb25cIiA6IHsgXCJjbGFzc2lmaWNhdGlvblwiOiBcIlN5c3RlbU1ldGFEYXRhXCIsIFwicHVycG9zZVwiOiBcIkZlYXR1cmVJbnNpZ2h0XCIgfVxuICAgIC8vIF9fR0RQUl9fQ09NTU9OX18gXCJjb21tb24uZXh0bmFtZVwiIDogeyBcImNsYXNzaWZpY2F0aW9uXCI6IFwiUHVibGljTm9uUGVyc29uYWxEYXRhXCIsIFwicHVycG9zZVwiOiBcIkZlYXR1cmVJbnNpZ2h0XCIgfVxuICAgIC8vIF9fR0RQUl9fQ09NTU9OX18gXCJjb21tb24uZXh0dmVyc2lvblwiIDogeyBcImNsYXNzaWZpY2F0aW9uXCI6IFwiUHVibGljTm9uUGVyc29uYWxEYXRhXCIsIFwicHVycG9zZVwiOiBcIkZlYXR1cmVJbnNpZ2h0XCIgfVxuICAgIC8vIF9fR0RQUl9fQ09NTU9OX18gXCJjb21tb24udnNjb2RlbWFjaGluZWlkXCIgOiB7IFwiZW5kUG9pbnRcIjogXCJNYWNBZGRyZXNzSGFzaFwiLCBcImNsYXNzaWZpY2F0aW9uXCI6IFwiRW5kVXNlclBzZXVkb255bWl6ZWRJbmZvcm1hdGlvblwiLCBcInB1cnBvc2VcIjogXCJGZWF0dXJlSW5zaWdodFwiIH1cbiAgICAvLyBfX0dEUFJfX0NPTU1PTl9fIFwiY29tbW9uLnZzY29kZXNlc3Npb25pZFwiIDogeyBcImNsYXNzaWZpY2F0aW9uXCI6IFwiU3lzdGVtTWV0YURhdGFcIiwgXCJwdXJwb3NlXCI6IFwiRmVhdHVyZUluc2lnaHRcIiB9XG4gICAgLy8gX19HRFBSX19DT01NT05fXyBcImNvbW1vbi52c2NvZGV2ZXJzaW9uXCIgOiB7IFwiY2xhc3NpZmljYXRpb25cIjogXCJTeXN0ZW1NZXRhRGF0YVwiLCBcInB1cnBvc2VcIjogXCJGZWF0dXJlSW5zaWdodFwiIH1cbiAgICBUZWxlbWV0cnlSZXBvcnRlci5wcm90b3R5cGUuZ2V0Q29tbW9uUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbW1vblByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb21tb25Qcm9wZXJ0aWVzWydjb21tb24ub3MnXSA9IG9zLnBsYXRmb3JtKCk7XG4gICAgICAgIGNvbW1vblByb3BlcnRpZXNbJ2NvbW1vbi5wbGF0Zm9ybXZlcnNpb24nXSA9IChvcy5yZWxlYXNlKCkgfHwgJycpLnJlcGxhY2UoL14oXFxkKykoXFwuXFxkKyk/KFxcLlxcZCspPyguKikvLCAnJDEkMiQzJyk7XG4gICAgICAgIGNvbW1vblByb3BlcnRpZXNbJ2NvbW1vbi5leHRuYW1lJ10gPSB0aGlzLmV4dGVuc2lvbklkO1xuICAgICAgICBjb21tb25Qcm9wZXJ0aWVzWydjb21tb24uZXh0dmVyc2lvbiddID0gdGhpcy5leHRlbnNpb25WZXJzaW9uO1xuICAgICAgICBpZiAodnNjb2RlICYmIHZzY29kZS5lbnYpIHtcbiAgICAgICAgICAgIGNvbW1vblByb3BlcnRpZXNbJ2NvbW1vbi52c2NvZGVtYWNoaW5laWQnXSA9IHZzY29kZS5lbnYubWFjaGluZUlkO1xuICAgICAgICAgICAgY29tbW9uUHJvcGVydGllc1snY29tbW9uLnZzY29kZXNlc3Npb25pZCddID0gdnNjb2RlLmVudi5zZXNzaW9uSWQ7XG4gICAgICAgICAgICBjb21tb25Qcm9wZXJ0aWVzWydjb21tb24udnNjb2RldmVyc2lvbiddID0gdnNjb2RlLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vblByb3BlcnRpZXM7XG4gICAgfTtcbiAgICBUZWxlbWV0cnlSZXBvcnRlci5wcm90b3R5cGUuc2VuZFRlbGVtZXRyeUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcHJvcGVydGllcywgbWVhc3VyZW1lbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJPcHRJbiAmJiBldmVudE5hbWUgJiYgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5hcHBJbnNpZ2h0c0NsaWVudC50cmFja0V2ZW50KHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmV4dGVuc2lvbklkICsgXCIvXCIgKyBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBtZWFzdXJlbWVudHM6IG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ1N0cmVhbS53cml0ZShcInRlbGVtZXRyeS9cIiArIGV2ZW50TmFtZSArIFwiIFwiICsgSlNPTi5zdHJpbmdpZnkoeyBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBtZWFzdXJlbWVudHM6IG1lYXN1cmVtZW50cyB9KSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUZWxlbWV0cnlSZXBvcnRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWdMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgIHZhciBmbHVzaEV2ZW50c1RvTG9nZ2VyID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubG9nU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmxvZ1N0cmVhbS5vbignZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICBfdGhpcy5sb2dTdHJlYW0uZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmx1c2hFdmVudHNUb0FJID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hcHBJbnNpZ2h0c0NsaWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFwcEluc2lnaHRzQ2xpZW50LmZsdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkYXRhIGZsdXNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFwcEluc2lnaHRzQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2ZsdXNoRXZlbnRzVG9BSSwgZmx1c2hFdmVudHNUb0xvZ2dlcl0pO1xuICAgIH07XG4gICAgVGVsZW1ldHJ5UmVwb3J0ZXIuVEVMRU1FVFJZX0NPTkZJR19JRCA9ICd0ZWxlbWV0cnknO1xuICAgIFRlbGVtZXRyeVJlcG9ydGVyLlRFTEVNRVRSWV9DT05GSUdfRU5BQkxFRF9JRCA9ICdlbmFibGVUZWxlbWV0cnknO1xuICAgIHJldHVybiBUZWxlbWV0cnlSZXBvcnRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUZWxlbWV0cnlSZXBvcnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbGVtZXRyeVJlcG9ydGVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-extension-telemetry/lib/telemetryReporter.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/cancellation.js":
/*!*********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/cancellation.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && (candidate === CancellationToken.None\r\n            || candidate === CancellationToken.Cancelled\r\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\r\n    }\r\n    CancellationToken.is = is;\r\n})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    let handle = setTimeout(callback.bind(context), 0);\r\n    return { dispose() { clearTimeout(handle); } };\r\n});\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this._emitter = undefined;\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new events_1.Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else {\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n}\r\nexports.CancellationTokenSource = CancellationTokenSource;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NhbmNlbGxhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NhbmNlbGxhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL2lzXCIpO1xyXG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XHJcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcclxuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXHJcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcclxuICAgIH0pO1xyXG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHRydWUsXHJcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXHJcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXHJcbiAgICAgICAgICAgIHx8IChJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkgJiYgISFjYW5kaWRhdGUub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQpKTtcclxuICAgIH1cclxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XHJcbn0pKENhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XHJcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgbGV0IGhhbmRsZSA9IHNldFRpbWVvdXQoY2FsbGJhY2suYmluZChjb250ZXh0KSwgMCk7XHJcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBjbGVhclRpbWVvdXQoaGFuZGxlKTsgfSB9O1xyXG59KTtcclxuY2xhc3MgTXV0YWJsZVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvcnRjdXRFdmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XHJcbiAgICBnZXQgdG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xyXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/cancellation.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/events.js":
/*!***************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/events.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Disposable;\r\n(function (Disposable) {\r\n    function create(func) {\r\n        return {\r\n            dispose: func\r\n        };\r\n    }\r\n    Disposable.create = create;\r\n})(Disposable = exports.Disposable || (exports.Disposable = {}));\r\nvar Event;\r\n(function (Event) {\r\n    const _disposable = { dispose() { } };\r\n    Event.None = function () { return _disposable; };\r\n})(Event = exports.Event || (exports.Event = {}));\r\nclass CallbackList {\r\n    add(callback, context = null, bucket) {\r\n        if (!this._callbacks) {\r\n            this._callbacks = [];\r\n            this._contexts = [];\r\n        }\r\n        this._callbacks.push(callback);\r\n        this._contexts.push(context);\r\n        if (Array.isArray(bucket)) {\r\n            bucket.push({ dispose: () => this.remove(callback, context) });\r\n        }\r\n    }\r\n    remove(callback, context = null) {\r\n        if (!this._callbacks) {\r\n            return;\r\n        }\r\n        var foundCallbackWithDifferentContext = false;\r\n        for (var i = 0, len = this._callbacks.length; i < len; i++) {\r\n            if (this._callbacks[i] === callback) {\r\n                if (this._contexts[i] === context) {\r\n                    // callback & context match => remove it\r\n                    this._callbacks.splice(i, 1);\r\n                    this._contexts.splice(i, 1);\r\n                    return;\r\n                }\r\n                else {\r\n                    foundCallbackWithDifferentContext = true;\r\n                }\r\n            }\r\n        }\r\n        if (foundCallbackWithDifferentContext) {\r\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\r\n        }\r\n    }\r\n    invoke(...args) {\r\n        if (!this._callbacks) {\r\n            return [];\r\n        }\r\n        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\r\n        for (var i = 0, len = callbacks.length; i < len; i++) {\r\n            try {\r\n                ret.push(callbacks[i].apply(contexts[i], args));\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    isEmpty() {\r\n        return !this._callbacks || this._callbacks.length === 0;\r\n    }\r\n    dispose() {\r\n        this._callbacks = undefined;\r\n        this._contexts = undefined;\r\n    }\r\n}\r\nclass Emitter {\r\n    constructor(_options) {\r\n        this._options = _options;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                if (!this._callbacks) {\r\n                    this._callbacks = new CallbackList();\r\n                }\r\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                this._callbacks.add(listener, thisArgs);\r\n                let result;\r\n                result = {\r\n                    dispose: () => {\r\n                        this._callbacks.remove(listener, thisArgs);\r\n                        result.dispose = Emitter._noop;\r\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\r\n                            this._options.onLastListenerRemove(this);\r\n                        }\r\n                    }\r\n                };\r\n                if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        if (this._callbacks) {\r\n            this._callbacks.invoke.call(this._callbacks, event);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._callbacks) {\r\n            this._callbacks.dispose();\r\n            this._callbacks = undefined;\r\n        }\r\n    }\r\n}\r\nEmitter._noop = function () { };\r\nexports.Emitter = Emitter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2V2ZW50cy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2V2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRGlzcG9zYWJsZTtcclxuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGUoZnVuYykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKERpc3Bvc2FibGUgPSBleHBvcnRzLkRpc3Bvc2FibGUgfHwgKGV4cG9ydHMuRGlzcG9zYWJsZSA9IHt9KSk7XHJcbnZhciBFdmVudDtcclxuKGZ1bmN0aW9uIChFdmVudCkge1xyXG4gICAgY29uc3QgX2Rpc3Bvc2FibGUgPSB7IGRpc3Bvc2UoKSB7IH0gfTtcclxuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcclxufSkoRXZlbnQgPSBleHBvcnRzLkV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0ge30pKTtcclxuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcclxuICAgIGFkZChjYWxsYmFjaywgY29udGV4dCA9IG51bGwsIGJ1Y2tldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWNrZXQpKSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dHNbaV0gPT09IGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayAmIGNvbnRleHQgbWF0Y2ggPT4gcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBhZGRpbmcgYSBsaXN0ZW5lciB3aXRoIGEgY29udGV4dCwgeW91IHNob3VsZCByZW1vdmUgaXQgd2l0aCB0aGUgc2FtZSBjb250ZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW52b2tlKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXQgPSBbXSwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzLnNsaWNlKDApLCBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzLnNsaWNlKDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0c1tpXSwgYXJncykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jb250ZXh0cyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcclxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxyXG4gICAgICovXHJcbiAgICBnZXQgZXZlbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja0xpc3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucmVtb3ZlKGxpc3RlbmVyLCB0aGlzQXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cclxuICAgICAqIHN1YnNjcmliZXJzXHJcbiAgICAgKi9cclxuICAgIGZpcmUoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5pbnZva2UuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5FbWl0dGVyLl9ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xyXG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/events.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/is.js":
/*!***********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/is.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2lzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvaXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcclxufVxyXG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xyXG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xyXG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xyXG59XHJcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xyXG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XHJcbn1cclxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xyXG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XHJcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xyXG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/is.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/linkedMap.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/linkedMap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Touch;\r\n(function (Touch) {\r\n    Touch.None = 0;\r\n    Touch.First = 1;\r\n    Touch.Last = 2;\r\n})(Touch = exports.Touch || (exports.Touch = {}));\r\nclass LinkedMap {\r\n    constructor() {\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = Touch.None) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== Touch.None) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case Touch.None:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case Touch.First:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case Touch.Last:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n    }\r\n    delete(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return false;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return true;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    forEachReverse(callbackfn, thisArg) {\r\n        let current = this._tail;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.previous;\r\n        }\r\n    }\r\n    values() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.value);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    keys() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.key);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    /* JSON RPC run on es5 which has no Symbol.iterator\r\n    public keys(): IterableIterator<K> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<K> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<K> {\r\n                if (current) {\r\n                    let result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    public values(): IterableIterator<V> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<V> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<V> {\r\n                if (current) {\r\n                    let result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    */\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\r\n            return;\r\n        }\r\n        if (touch === Touch.First) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n        }\r\n        else if (touch === Touch.Last) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n        }\r\n    }\r\n}\r\nexports.LinkedMap = LinkedMap;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2xpbmtlZE1hcC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2xpbmtlZE1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFRvdWNoO1xyXG4oZnVuY3Rpb24gKFRvdWNoKSB7XHJcbiAgICBUb3VjaC5Ob25lID0gMDtcclxuICAgIFRvdWNoLkZpcnN0ID0gMTtcclxuICAgIFRvdWNoLkxhc3QgPSAyO1xyXG59KShUb3VjaCA9IGV4cG9ydHMuVG91Y2ggfHwgKGV4cG9ydHMuVG91Y2ggPSB7fSkpO1xyXG5jbGFzcyBMaW5rZWRNYXAge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcclxuICAgIH1cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlLCB0b3VjaCA9IFRvdWNoLk5vbmUpIHtcclxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSB7IGtleSwgdmFsdWUsIG5leHQ6IHVuZGVmaW5lZCwgcHJldmlvdXM6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtRmlyc3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNoaWZ0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuICAgIH1cclxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaFJldmVyc2UoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fdGFpbDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbHVlcygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudmFsdWUpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAga2V5cygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQua2V5KTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qIEpTT04gUlBDIHJ1biBvbiBlczUgd2hpY2ggaGFzIG5vIFN5bWJvbC5pdGVyYXRvclxyXG4gICAgcHVibGljIGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxLPiB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIGxldCBpdGVyYXRvcjogSXRlcmFibGVJdGVyYXRvcjxLPiA9IHtcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5leHQoKTpJdGVyYXRvclJlc3VsdDxLPiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWx1ZXMoKTogSXRlcmFibGVJdGVyYXRvcjxWPiB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIGxldCBpdGVyYXRvcjogSXRlcmFibGVJdGVyYXRvcjxWPiA9IHtcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5leHQoKTpJdGVyYXRvclJlc3VsdDxWPiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgYWRkSXRlbUZpcnN0KGl0ZW0pIHtcclxuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxyXG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcclxuICAgIH1cclxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcclxuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxyXG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xyXG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcclxuICAgIH1cclxuICAgIHJlbW92ZUl0ZW0oaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtLnByZXZpb3VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xyXG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcclxuICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3VjaCAhPT0gVG91Y2guRmlyc3QgJiYgdG91Y2ggIT09IFRvdWNoLkxhc3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvdWNoID09PSBUb3VjaC5GaXJzdCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcclxuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtXHJcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcclxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXHJcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXQgaGVhZFxyXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcclxuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSBUb3VjaC5MYXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xyXG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW0uXHJcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXh0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgdGFpbCBidXQgaXMgaGVhZFxyXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcclxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxyXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcclxuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcclxuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTGlua2VkTWFwID0gTGlua2VkTWFwO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/linkedMap.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/main.js":
/*!*************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n/// <reference path=\"./thenable.ts\" />\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-jsonrpc/lib/messages.js\");\r\nexports.RequestType = messages_1.RequestType;\r\nexports.RequestType0 = messages_1.RequestType0;\r\nexports.RequestType1 = messages_1.RequestType1;\r\nexports.RequestType2 = messages_1.RequestType2;\r\nexports.RequestType3 = messages_1.RequestType3;\r\nexports.RequestType4 = messages_1.RequestType4;\r\nexports.RequestType5 = messages_1.RequestType5;\r\nexports.RequestType6 = messages_1.RequestType6;\r\nexports.RequestType7 = messages_1.RequestType7;\r\nexports.RequestType8 = messages_1.RequestType8;\r\nexports.RequestType9 = messages_1.RequestType9;\r\nexports.ResponseError = messages_1.ResponseError;\r\nexports.ErrorCodes = messages_1.ErrorCodes;\r\nexports.NotificationType = messages_1.NotificationType;\r\nexports.NotificationType0 = messages_1.NotificationType0;\r\nexports.NotificationType1 = messages_1.NotificationType1;\r\nexports.NotificationType2 = messages_1.NotificationType2;\r\nexports.NotificationType3 = messages_1.NotificationType3;\r\nexports.NotificationType4 = messages_1.NotificationType4;\r\nexports.NotificationType5 = messages_1.NotificationType5;\r\nexports.NotificationType6 = messages_1.NotificationType6;\r\nexports.NotificationType7 = messages_1.NotificationType7;\r\nexports.NotificationType8 = messages_1.NotificationType8;\r\nexports.NotificationType9 = messages_1.NotificationType9;\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nexports.MessageReader = messageReader_1.MessageReader;\r\nexports.StreamMessageReader = messageReader_1.StreamMessageReader;\r\nexports.IPCMessageReader = messageReader_1.IPCMessageReader;\r\nexports.SocketMessageReader = messageReader_1.SocketMessageReader;\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nexports.MessageWriter = messageWriter_1.MessageWriter;\r\nexports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;\r\nexports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;\r\nexports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nexports.Disposable = events_1.Disposable;\r\nexports.Event = events_1.Event;\r\nexports.Emitter = events_1.Emitter;\r\nconst cancellation_1 = __webpack_require__(/*! ./cancellation */ \"./node_modules/vscode-jsonrpc/lib/cancellation.js\");\r\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\r\nexports.CancellationToken = cancellation_1.CancellationToken;\r\nconst linkedMap_1 = __webpack_require__(/*! ./linkedMap */ \"./node_modules/vscode-jsonrpc/lib/linkedMap.js\");\r\n__export(__webpack_require__(/*! ./pipeSupport */ \"./node_modules/vscode-jsonrpc/lib/pipeSupport.js\"));\r\n__export(__webpack_require__(/*! ./socketSupport */ \"./node_modules/vscode-jsonrpc/lib/socketSupport.js\"));\r\nvar CancelNotification;\r\n(function (CancelNotification) {\r\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\r\n})(CancelNotification || (CancelNotification = {}));\r\nexports.NullLogger = Object.freeze({\r\n    error: () => { },\r\n    warn: () => { },\r\n    info: () => { },\r\n    log: () => { }\r\n});\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case Trace.Off:\r\n                return 'off';\r\n            case Trace.Messages:\r\n                return 'messages';\r\n            case Trace.Verbose:\r\n                return 'verbose';\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    Trace.toString = toString;\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\nvar TraceFormat;\r\n(function (TraceFormat) {\r\n    TraceFormat[\"Text\"] = \"text\";\r\n    TraceFormat[\"JSON\"] = \"json\";\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\n(function (TraceFormat) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        if (value === 'json') {\r\n            return TraceFormat.JSON;\r\n        }\r\n        else {\r\n            return TraceFormat.Text;\r\n        }\r\n    }\r\n    TraceFormat.fromString = fromString;\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\nvar SetTraceNotification;\r\n(function (SetTraceNotification) {\r\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\r\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\r\nvar LogTraceNotification;\r\n(function (LogTraceNotification) {\r\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\r\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\r\nvar ConnectionErrors;\r\n(function (ConnectionErrors) {\r\n    /**\r\n     * The connection is closed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\r\n    /**\r\n     * The connection got disposed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\r\n    /**\r\n     * The connection is already in listening mode.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\r\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\r\nclass ConnectionError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n        Object.setPrototypeOf(this, ConnectionError.prototype);\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\nvar ConnectionStrategy;\r\n(function (ConnectionStrategy) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.cancelUndispatched);\r\n    }\r\n    ConnectionStrategy.is = is;\r\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\r\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\r\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\r\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nfunction _createMessageConnection(messageReader, messageWriter, logger, strategy) {\r\n    let sequenceNumber = 0;\r\n    let notificationSquenceNumber = 0;\r\n    let unknownResponseSquenceNumber = 0;\r\n    const version = '2.0';\r\n    let starRequestHandler = undefined;\r\n    let requestHandlers = Object.create(null);\r\n    let starNotificationHandler = undefined;\r\n    let notificationHandlers = Object.create(null);\r\n    let timer;\r\n    let messageQueue = new linkedMap_1.LinkedMap();\r\n    let responsePromises = Object.create(null);\r\n    let requestTokens = Object.create(null);\r\n    let trace = Trace.Off;\r\n    let traceFormat = TraceFormat.Text;\r\n    let tracer;\r\n    let state = ConnectionState.New;\r\n    let errorEmitter = new events_1.Emitter();\r\n    let closeEmitter = new events_1.Emitter();\r\n    let unhandledNotificationEmitter = new events_1.Emitter();\r\n    let disposeEmitter = new events_1.Emitter();\r\n    function createRequestQueueKey(id) {\r\n        return 'req-' + id.toString();\r\n    }\r\n    function createResponseQueueKey(id) {\r\n        if (id === null) {\r\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\r\n        }\r\n        else {\r\n            return 'res-' + id.toString();\r\n        }\r\n    }\r\n    function createNotificationQueueKey() {\r\n        return 'not-' + (++notificationSquenceNumber).toString();\r\n    }\r\n    function addMessageToQueue(queue, message) {\r\n        if (messages_1.isRequestMessage(message)) {\r\n            queue.set(createRequestQueueKey(message.id), message);\r\n        }\r\n        else if (messages_1.isResponseMessage(message)) {\r\n            queue.set(createResponseQueueKey(message.id), message);\r\n        }\r\n        else {\r\n            queue.set(createNotificationQueueKey(), message);\r\n        }\r\n    }\r\n    function cancelUndispatched(_message) {\r\n        return undefined;\r\n    }\r\n    function isListening() {\r\n        return state === ConnectionState.Listening;\r\n    }\r\n    function isClosed() {\r\n        return state === ConnectionState.Closed;\r\n    }\r\n    function isDisposed() {\r\n        return state === ConnectionState.Disposed;\r\n    }\r\n    function closeHandler() {\r\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\r\n            state = ConnectionState.Closed;\r\n            closeEmitter.fire(undefined);\r\n        }\r\n        // If the connection is disposed don't sent close events.\r\n    }\r\n    ;\r\n    function readErrorHandler(error) {\r\n        errorEmitter.fire([error, undefined, undefined]);\r\n    }\r\n    function writeErrorHandler(data) {\r\n        errorEmitter.fire(data);\r\n    }\r\n    messageReader.onClose(closeHandler);\r\n    messageReader.onError(readErrorHandler);\r\n    messageWriter.onClose(closeHandler);\r\n    messageWriter.onError(writeErrorHandler);\r\n    function triggerMessageQueue() {\r\n        if (timer || messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        timer = setImmediate(() => {\r\n            timer = undefined;\r\n            processMessageQueue();\r\n        });\r\n    }\r\n    function processMessageQueue() {\r\n        if (messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        let message = messageQueue.shift();\r\n        try {\r\n            if (messages_1.isRequestMessage(message)) {\r\n                handleRequest(message);\r\n            }\r\n            else if (messages_1.isNotificationMessage(message)) {\r\n                handleNotification(message);\r\n            }\r\n            else if (messages_1.isResponseMessage(message)) {\r\n                handleResponse(message);\r\n            }\r\n            else {\r\n                handleInvalidMessage(message);\r\n            }\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    }\r\n    let callback = (message) => {\r\n        try {\r\n            // We have received a cancellation message. Check if the message is still in the queue\r\n            // and cancel it if allowed to do so.\r\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\r\n                let key = createRequestQueueKey(message.params.id);\r\n                let toCancel = messageQueue.get(key);\r\n                if (messages_1.isRequestMessage(toCancel)) {\r\n                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\r\n                    if (response && (response.error !== void 0 || response.result !== void 0)) {\r\n                        messageQueue.delete(key);\r\n                        response.id = toCancel.id;\r\n                        traceSendingResponse(response, message.method, Date.now());\r\n                        messageWriter.write(response);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            addMessageToQueue(messageQueue, message);\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    };\r\n    function handleRequest(requestMessage) {\r\n        if (isDisposed()) {\r\n            // we return here silently since we fired an event when the\r\n            // connection got disposed.\r\n            return;\r\n        }\r\n        function reply(resultOrError, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id\r\n            };\r\n            if (resultOrError instanceof messages_1.ResponseError) {\r\n                message.error = resultOrError.toJson();\r\n            }\r\n            else {\r\n                message.result = resultOrError === void 0 ? null : resultOrError;\r\n            }\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replyError(error, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                error: error.toJson()\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replySuccess(result, method, startTime) {\r\n            // The JSON RPC defines that a response must either have a result or an error\r\n            // So we can't treat undefined as a valid response result.\r\n            if (result === void 0) {\r\n                result = null;\r\n            }\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                result: result\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        traceReceivedRequest(requestMessage);\r\n        let element = requestHandlers[requestMessage.method];\r\n        let type;\r\n        let requestHandler;\r\n        if (element) {\r\n            type = element.type;\r\n            requestHandler = element.handler;\r\n        }\r\n        let startTime = Date.now();\r\n        if (requestHandler || starRequestHandler) {\r\n            let cancellationSource = new cancellation_1.CancellationTokenSource();\r\n            let tokenKey = String(requestMessage.id);\r\n            requestTokens[tokenKey] = cancellationSource;\r\n            try {\r\n                let handlerResult;\r\n                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, cancellationSource.token);\r\n                }\r\n                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(...requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);\r\n                }\r\n                else {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\r\n                }\r\n                let promise = handlerResult;\r\n                if (!handlerResult) {\r\n                    delete requestTokens[tokenKey];\r\n                    replySuccess(handlerResult, requestMessage.method, startTime);\r\n                }\r\n                else if (promise.then) {\r\n                    promise.then((resultOrError) => {\r\n                        delete requestTokens[tokenKey];\r\n                        reply(resultOrError, requestMessage.method, startTime);\r\n                    }, error => {\r\n                        delete requestTokens[tokenKey];\r\n                        if (error instanceof messages_1.ResponseError) {\r\n                            replyError(error, requestMessage.method, startTime);\r\n                        }\r\n                        else if (error && Is.string(error.message)) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                        }\r\n                        else {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    delete requestTokens[tokenKey];\r\n                    reply(handlerResult, requestMessage.method, startTime);\r\n                }\r\n            }\r\n            catch (error) {\r\n                delete requestTokens[tokenKey];\r\n                if (error instanceof messages_1.ResponseError) {\r\n                    reply(error, requestMessage.method, startTime);\r\n                }\r\n                else if (error && Is.string(error.message)) {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                }\r\n                else {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\r\n        }\r\n    }\r\n    function handleResponse(responseMessage) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        if (responseMessage.id === null) {\r\n            if (responseMessage.error) {\r\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\r\n            }\r\n            else {\r\n                logger.error(`Received response message without id. No further error information provided.`);\r\n            }\r\n        }\r\n        else {\r\n            let key = String(responseMessage.id);\r\n            let responsePromise = responsePromises[key];\r\n            traceReceivedResponse(responseMessage, responsePromise);\r\n            if (responsePromise) {\r\n                delete responsePromises[key];\r\n                try {\r\n                    if (responseMessage.error) {\r\n                        let error = responseMessage.error;\r\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\r\n                    }\r\n                    else if (responseMessage.result !== void 0) {\r\n                        responsePromise.resolve(responseMessage.result);\r\n                    }\r\n                    else {\r\n                        throw new Error('Should never happen.');\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    if (error.message) {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\r\n                    }\r\n                    else {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleNotification(message) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        let type = undefined;\r\n        let notificationHandler;\r\n        if (message.method === CancelNotification.type.method) {\r\n            notificationHandler = (params) => {\r\n                let id = params.id;\r\n                let source = requestTokens[String(id)];\r\n                if (source) {\r\n                    source.cancel();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            let element = notificationHandlers[message.method];\r\n            if (element) {\r\n                notificationHandler = element.handler;\r\n                type = element.type;\r\n            }\r\n        }\r\n        if (notificationHandler || starNotificationHandler) {\r\n            try {\r\n                traceReceivedNotification(message);\r\n                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);\r\n                }\r\n                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);\r\n                }\r\n                else {\r\n                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.message) {\r\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\r\n                }\r\n                else {\r\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            unhandledNotificationEmitter.fire(message);\r\n        }\r\n    }\r\n    function handleInvalidMessage(message) {\r\n        if (!message) {\r\n            logger.error('Received empty message.');\r\n            return;\r\n        }\r\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\r\n        // Test whether we find an id to reject the promise\r\n        let responseMessage = message;\r\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\r\n            let key = String(responseMessage.id);\r\n            let responseHandler = responsePromises[key];\r\n            if (responseHandler) {\r\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\r\n            }\r\n        }\r\n    }\r\n    function traceSendingRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-request', message);\r\n        }\r\n    }\r\n    function traceSendingNotification(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Sending notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-notification', message);\r\n        }\r\n    }\r\n    function traceSendingResponse(message, method, startTime) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-response', message);\r\n        }\r\n    }\r\n    function traceReceivedRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-request', message);\r\n        }\r\n    }\r\n    function traceReceivedNotification(message) {\r\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Received notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-notification', message);\r\n        }\r\n    }\r\n    function traceReceivedResponse(message, responsePromise) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            if (responsePromise) {\r\n                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\r\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\r\n            }\r\n            else {\r\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\r\n            }\r\n        }\r\n        else {\r\n            logLSPMessage('receive-response', message);\r\n        }\r\n    }\r\n    function logLSPMessage(type, message) {\r\n        if (!tracer || trace === Trace.Off) {\r\n            return;\r\n        }\r\n        const lspMessage = {\r\n            isLSPMessage: true,\r\n            type,\r\n            message,\r\n            timestamp: Date.now()\r\n        };\r\n        tracer.log(lspMessage);\r\n    }\r\n    function throwIfClosedOrDisposed() {\r\n        if (isClosed()) {\r\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\r\n        }\r\n        if (isDisposed()) {\r\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\r\n        }\r\n    }\r\n    function throwIfListening() {\r\n        if (isListening()) {\r\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\r\n        }\r\n    }\r\n    function throwIfNotListening() {\r\n        if (!isListening()) {\r\n            throw new Error('Call listen() first.');\r\n        }\r\n    }\r\n    function undefinedToNull(param) {\r\n        if (param === void 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function computeMessageParams(type, params) {\r\n        let result;\r\n        let numberOfParams = type.numberOfParams;\r\n        switch (numberOfParams) {\r\n            case 0:\r\n                result = null;\r\n                break;\r\n            case 1:\r\n                result = undefinedToNull(params[0]);\r\n                break;\r\n            default:\r\n                result = [];\r\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\r\n                    result.push(undefinedToNull(params[i]));\r\n                }\r\n                if (params.length < numberOfParams) {\r\n                    for (let i = params.length; i < numberOfParams; i++) {\r\n                        result.push(null);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n    let connection = {\r\n        sendNotification: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            let messageParams;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = params[0];\r\n                        break;\r\n                    default:\r\n                        messageParams = params;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n            }\r\n            let notificationMessage = {\r\n                jsonrpc: version,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingNotification(notificationMessage);\r\n            messageWriter.write(notificationMessage);\r\n        },\r\n        onNotification: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starNotificationHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    notificationHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    notificationHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        sendRequest: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfNotListening();\r\n            let method;\r\n            let messageParams;\r\n            let token = undefined;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        // The cancellation token is optional so it can also be undefined.\r\n                        if (cancellation_1.CancellationToken.is(params[0])) {\r\n                            messageParams = null;\r\n                            token = params[0];\r\n                        }\r\n                        else {\r\n                            messageParams = undefinedToNull(params[0]);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const last = params.length - 1;\r\n                        if (cancellation_1.CancellationToken.is(params[last])) {\r\n                            token = params[last];\r\n                            if (params.length === 2) {\r\n                                messageParams = undefinedToNull(params[0]);\r\n                            }\r\n                            else {\r\n                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));\r\n                            }\r\n                        }\r\n                        else {\r\n                            messageParams = params.map(value => undefinedToNull(value));\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n                let numberOfParams = type.numberOfParams;\r\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\r\n            }\r\n            let id = sequenceNumber++;\r\n            let result = new Promise((resolve, reject) => {\r\n                let requestMessage = {\r\n                    jsonrpc: version,\r\n                    id: id,\r\n                    method: method,\r\n                    params: messageParams\r\n                };\r\n                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };\r\n                traceSendingRequest(requestMessage);\r\n                try {\r\n                    messageWriter.write(requestMessage);\r\n                }\r\n                catch (e) {\r\n                    // Writing the message failed. So we need to reject the promise.\r\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\r\n                    responsePromise = null;\r\n                }\r\n                if (responsePromise) {\r\n                    responsePromises[String(id)] = responsePromise;\r\n                }\r\n            });\r\n            if (token) {\r\n                token.onCancellationRequested(() => {\r\n                    connection.sendNotification(CancelNotification.type, { id });\r\n                });\r\n            }\r\n            return result;\r\n        },\r\n        onRequest: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starRequestHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    requestHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    requestHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\r\n            let _sendNotification = false;\r\n            let _traceFormat = TraceFormat.Text;\r\n            if (sendNotificationOrTraceOptions !== void 0) {\r\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                    _sendNotification = sendNotificationOrTraceOptions;\r\n                }\r\n                else {\r\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\r\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\r\n                }\r\n            }\r\n            trace = _value;\r\n            traceFormat = _traceFormat;\r\n            if (trace === Trace.Off) {\r\n                tracer = undefined;\r\n            }\r\n            else {\r\n                tracer = _tracer;\r\n            }\r\n            if (_sendNotification && !isClosed() && !isDisposed()) {\r\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\r\n            }\r\n        },\r\n        onError: errorEmitter.event,\r\n        onClose: closeEmitter.event,\r\n        onUnhandledNotification: unhandledNotificationEmitter.event,\r\n        onDispose: disposeEmitter.event,\r\n        dispose: () => {\r\n            if (isDisposed()) {\r\n                return;\r\n            }\r\n            state = ConnectionState.Disposed;\r\n            disposeEmitter.fire(undefined);\r\n            let error = new Error('Connection got disposed.');\r\n            Object.keys(responsePromises).forEach((key) => {\r\n                responsePromises[key].reject(error);\r\n            });\r\n            responsePromises = Object.create(null);\r\n            requestTokens = Object.create(null);\r\n            messageQueue = new linkedMap_1.LinkedMap();\r\n            // Test for backwards compatibility\r\n            if (Is.func(messageWriter.dispose)) {\r\n                messageWriter.dispose();\r\n            }\r\n            if (Is.func(messageReader.dispose)) {\r\n                messageReader.dispose();\r\n            }\r\n        },\r\n        listen: () => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfListening();\r\n            state = ConnectionState.Listening;\r\n            messageReader.listen(callback);\r\n        },\r\n        inspect: () => {\r\n            console.log(\"inspect\");\r\n        }\r\n    };\r\n    connection.onNotification(LogTraceNotification.type, (params) => {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\r\n    });\r\n    return connection;\r\n}\r\nfunction isMessageReader(value) {\r\n    return value.listen !== void 0 && value.read === void 0;\r\n}\r\nfunction isMessageWriter(value) {\r\n    return value.write !== void 0 && value.end === void 0;\r\n}\r\nfunction createMessageConnection(input, output, logger, strategy) {\r\n    if (!logger) {\r\n        logger = exports.NullLogger;\r\n    }\r\n    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);\r\n    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);\r\n    return _createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL21haW4uanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vdGhlbmFibGUudHNcIiAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IElzID0gcmVxdWlyZShcIi4vaXNcIik7XHJcbmNvbnN0IG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlc1wiKTtcclxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTA7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTE7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTI7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUzID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTM7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTQ7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTU7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTY7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTc7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTg7XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTk7XHJcbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcjtcclxuZXhwb3J0cy5FcnJvckNvZGVzID0gbWVzc2FnZXNfMS5FcnJvckNvZGVzO1xyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU7XHJcbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUwO1xyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMTtcclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTI7XHJcbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUzO1xyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNDtcclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTU7XHJcbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU2O1xyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNztcclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTg7XHJcbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU5O1xyXG5jb25zdCBtZXNzYWdlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlUmVhZGVyXCIpO1xyXG5leHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjtcclxuZXhwb3J0cy5TdHJlYW1NZXNzYWdlUmVhZGVyID0gbWVzc2FnZVJlYWRlcl8xLlN0cmVhbU1lc3NhZ2VSZWFkZXI7XHJcbmV4cG9ydHMuSVBDTWVzc2FnZVJlYWRlciA9IG1lc3NhZ2VSZWFkZXJfMS5JUENNZXNzYWdlUmVhZGVyO1xyXG5leHBvcnRzLlNvY2tldE1lc3NhZ2VSZWFkZXIgPSBtZXNzYWdlUmVhZGVyXzEuU29ja2V0TWVzc2FnZVJlYWRlcjtcclxuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gcmVxdWlyZShcIi4vbWVzc2FnZVdyaXRlclwiKTtcclxuZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gbWVzc2FnZVdyaXRlcl8xLk1lc3NhZ2VXcml0ZXI7XHJcbmV4cG9ydHMuU3RyZWFtTWVzc2FnZVdyaXRlciA9IG1lc3NhZ2VXcml0ZXJfMS5TdHJlYW1NZXNzYWdlV3JpdGVyO1xyXG5leHBvcnRzLklQQ01lc3NhZ2VXcml0ZXIgPSBtZXNzYWdlV3JpdGVyXzEuSVBDTWVzc2FnZVdyaXRlcjtcclxuZXhwb3J0cy5Tb2NrZXRNZXNzYWdlV3JpdGVyID0gbWVzc2FnZVdyaXRlcl8xLlNvY2tldE1lc3NhZ2VXcml0ZXI7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG5leHBvcnRzLkRpc3Bvc2FibGUgPSBldmVudHNfMS5EaXNwb3NhYmxlO1xyXG5leHBvcnRzLkV2ZW50ID0gZXZlbnRzXzEuRXZlbnQ7XHJcbmV4cG9ydHMuRW1pdHRlciA9IGV2ZW50c18xLkVtaXR0ZXI7XHJcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gcmVxdWlyZShcIi4vY2FuY2VsbGF0aW9uXCIpO1xyXG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7XHJcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbjtcclxuY29uc3QgbGlua2VkTWFwXzEgPSByZXF1aXJlKFwiLi9saW5rZWRNYXBcIik7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BpcGVTdXBwb3J0XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc29ja2V0U3VwcG9ydFwiKSk7XHJcbnZhciBDYW5jZWxOb3RpZmljYXRpb247XHJcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XHJcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xyXG59KShDYW5jZWxOb3RpZmljYXRpb24gfHwgKENhbmNlbE5vdGlmaWNhdGlvbiA9IHt9KSk7XHJcbmV4cG9ydHMuTnVsbExvZ2dlciA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgZXJyb3I6ICgpID0+IHsgfSxcclxuICAgIHdhcm46ICgpID0+IHsgfSxcclxuICAgIGluZm86ICgpID0+IHsgfSxcclxuICAgIGxvZzogKCkgPT4geyB9XHJcbn0pO1xyXG52YXIgVHJhY2U7XHJcbihmdW5jdGlvbiAoVHJhY2UpIHtcclxuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xyXG4gICAgVHJhY2VbVHJhY2VbXCJNZXNzYWdlc1wiXSA9IDFdID0gXCJNZXNzYWdlc1wiO1xyXG4gICAgVHJhY2VbVHJhY2VbXCJWZXJib3NlXCJdID0gMl0gPSBcIlZlcmJvc2VcIjtcclxufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcclxuKGZ1bmN0aW9uIChUcmFjZSkge1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xyXG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLlZlcmJvc2U7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcclxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xyXG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XHJcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAndmVyYm9zZSc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcclxufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcclxudmFyIFRyYWNlRm9ybWF0O1xyXG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XHJcbiAgICBUcmFjZUZvcm1hdFtcIlRleHRcIl0gPSBcInRleHRcIjtcclxuICAgIFRyYWNlRm9ybWF0W1wiSlNPTlwiXSA9IFwianNvblwiO1xyXG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xyXG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5KU09OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVHJhY2VGb3JtYXQuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcbn0pKFRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IHt9KSk7XHJcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChTZXRUcmFjZU5vdGlmaWNhdGlvbikge1xyXG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2VOb3RpZmljYXRpb24nKTtcclxufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcclxudmFyIExvZ1RyYWNlTm90aWZpY2F0aW9uO1xyXG4oZnVuY3Rpb24gKExvZ1RyYWNlTm90aWZpY2F0aW9uKSB7XHJcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZU5vdGlmaWNhdGlvbicpO1xyXG59KShMb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xyXG52YXIgQ29ubmVjdGlvbkVycm9ycztcclxuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiQ2xvc2VkXCJdID0gMV0gPSBcIkNsb3NlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkRpc3Bvc2VkXCJdID0gMl0gPSBcIkRpc3Bvc2VkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGFscmVhZHkgaW4gbGlzdGVuaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xyXG59KShDb25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzIHx8IChleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSB7fSkpO1xyXG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XHJcbnZhciBDb25uZWN0aW9uU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNhbmNlbFVuZGlzcGF0Y2hlZCk7XHJcbiAgICB9XHJcbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcclxufSkoQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0ge30pKTtcclxudmFyIENvbm5lY3Rpb25TdGF0ZTtcclxuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcclxuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XHJcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTGlzdGVuaW5nXCJdID0gMl0gPSBcIkxpc3RlbmluZ1wiO1xyXG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcclxuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xyXG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIF9jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihtZXNzYWdlUmVhZGVyLCBtZXNzYWdlV3JpdGVyLCBsb2dnZXIsIHN0cmF0ZWd5KSB7XHJcbiAgICBsZXQgc2VxdWVuY2VOdW1iZXIgPSAwO1xyXG4gICAgbGV0IG5vdGlmaWNhdGlvblNxdWVuY2VOdW1iZXIgPSAwO1xyXG4gICAgbGV0IHVua25vd25SZXNwb25zZVNxdWVuY2VOdW1iZXIgPSAwO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xyXG4gICAgbGV0IHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcclxuICAgIGxldCByZXF1ZXN0SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgbGV0IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xyXG4gICAgbGV0IG5vdGlmaWNhdGlvbkhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGxldCB0aW1lcjtcclxuICAgIGxldCBtZXNzYWdlUXVldWUgPSBuZXcgbGlua2VkTWFwXzEuTGlua2VkTWFwKCk7XHJcbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBsZXQgcmVxdWVzdFRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBsZXQgdHJhY2UgPSBUcmFjZS5PZmY7XHJcbiAgICBsZXQgdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xyXG4gICAgbGV0IHRyYWNlcjtcclxuICAgIGxldCBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5OZXc7XHJcbiAgICBsZXQgZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcclxuICAgIGxldCBjbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xyXG4gICAgbGV0IHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xyXG4gICAgbGV0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShpZCkge1xyXG4gICAgICAgIHJldHVybiAncmVxLScgKyBpZC50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xyXG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy11bmtub3duLScgKyAoKyt1bmtub3duUmVzcG9uc2VTcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuICdub3QtJyArICgrK25vdGlmaWNhdGlvblNxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNZXNzYWdlVG9RdWV1ZShxdWV1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlc18xLmlzUmVxdWVzdE1lc3NhZ2UobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuaXNSZXNwb25zZU1lc3NhZ2UobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCksIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNhbmNlbFVuZGlzcGF0Y2hlZChfbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0xpc3RlbmluZygpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xyXG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XHJcbiAgICAgICAgICAgIGNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzIGRpc3Bvc2VkIGRvbid0IHNlbnQgY2xvc2UgZXZlbnRzLlxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xyXG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKFtlcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWRdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcclxuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShkYXRhKTtcclxuICAgIH1cclxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xyXG4gICAgbWVzc2FnZVJlYWRlci5vbkVycm9yKHJlYWRFcnJvckhhbmRsZXIpO1xyXG4gICAgbWVzc2FnZVdyaXRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XHJcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xyXG4gICAgZnVuY3Rpb24gdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpIHtcclxuICAgICAgICBpZiAodGltZXIgfHwgbWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lciA9IHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZVF1ZXVlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtZXNzYWdlID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuaXNSZXF1ZXN0TWVzc2FnZShtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLmlzTm90aWZpY2F0aW9uTWVzc2FnZShtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuaXNSZXNwb25zZU1lc3NhZ2UobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgY2FsbGJhY2sgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSBjYW5jZWxsYXRpb24gbWVzc2FnZS4gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlXHJcbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwgaXQgaWYgYWxsb3dlZCB0byBkbyBzby5cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuaXNOb3RpZmljYXRpb25NZXNzYWdlKG1lc3NhZ2UpICYmIG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5wYXJhbXMuaWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuaXNSZXF1ZXN0TWVzc2FnZSh0b0NhbmNlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBzdHJhdGVneSAmJiBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQgPyBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwsIGNhbmNlbFVuZGlzcGF0Y2hlZCkgOiBjYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHZvaWQgMCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHZvaWQgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVF1ZXVlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5pZCA9IHRvQ2FuY2VsLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRNZXNzYWdlVG9RdWV1ZShtZXNzYWdlUXVldWUsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxyXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZC5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiByZXBseShyZXN1bHRPckVycm9yLCBtZXRob2QsIHN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdE9yRXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB2b2lkIDAgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5RXJyb3IoZXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci50b0pzb24oKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5U3VjY2VzcyhyZXN1bHQsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBKU09OIFJQQyBkZWZpbmVzIHRoYXQgYSByZXNwb25zZSBtdXN0IGVpdGhlciBoYXZlIGEgcmVzdWx0IG9yIGFuIGVycm9yXHJcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2VSZWNlaXZlZFJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gcmVxdWVzdEhhbmRsZXJzW3JlcXVlc3RNZXNzYWdlLm1ldGhvZF07XHJcbiAgICAgICAgbGV0IHR5cGU7XHJcbiAgICAgICAgbGV0IHJlcXVlc3RIYW5kbGVyO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIgfHwgc3RhclJlcXVlc3RIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGxldCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcclxuICAgICAgICAgICAgbGV0IHRva2VuS2V5ID0gU3RyaW5nKHJlcXVlc3RNZXNzYWdlLmlkKTtcclxuICAgICAgICAgICAgcmVxdWVzdFRva2Vuc1t0b2tlbktleV0gPSBjYW5jZWxsYXRpb25Tb3VyY2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5wYXJhbXMgPT09IHZvaWQgMCB8fCAodHlwZSAhPT0gdm9pZCAwICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdEhhbmRsZXIoY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN0YXJSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChJcy5hcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpICYmICh0eXBlID09PSB2b2lkIDAgfHwgdHlwZS5udW1iZXJPZlBhcmFtcyA+IDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RUb2tlbnNbdG9rZW5LZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RUb2tlbnNbdG9rZW5LZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseShyZXN1bHRPckVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdFRva2Vuc1t0b2tlbktleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0VG9rZW5zW3Rva2VuS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdFRva2Vuc1t0b2tlbktleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQsIGBVbmhhbmRsZWQgbWV0aG9kICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xyXG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5pZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBTdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKTtcclxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZXNba2V5XTtcclxuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3BvbnNlUHJvbWlzZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZU1lc3NhZ2UucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xyXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPSAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBwYXJhbXMuaWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlID0gcmVxdWVzdFRva2Vuc1tTdHJpbmcoaWQpXTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IG5vdGlmaWNhdGlvbkhhbmRsZXJzW21lc3NhZ2UubWV0aG9kXTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyIHx8IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zID09PSB2b2lkIDAgfHwgKHR5cGUgIT09IHZvaWQgMCAmJiB0eXBlLm51bWJlck9mUGFyYW1zID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPyBub3RpZmljYXRpb25IYW5kbGVyKCkgOiBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChJcy5hcnJheShtZXNzYWdlLnBhcmFtcykgJiYgKHR5cGUgPT09IHZvaWQgMCB8fCB0eXBlLm51bWJlck9mUGFyYW1zID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID8gbm90aWZpY2F0aW9uSGFuZGxlciguLi5tZXNzYWdlLnBhcmFtcykgOiBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCwgLi4ubWVzc2FnZS5wYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciA/IG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpIDogc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmZpcmUobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlY2VpdmVkIGVtcHR5IG1lc3NhZ2UuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIHdoaWNoIGlzIG5laXRoZXIgYSByZXNwb25zZSBub3IgYSBub3RpZmljYXRpb24gbWVzc2FnZTpcXG4ke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDQpfWApO1xyXG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBmaW5kIGFuIGlkIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxyXG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xyXG4gICAgICAgICAgICBsZXQga2V5ID0gU3RyaW5nKHJlc3BvbnNlTWVzc2FnZS5pZCk7XHJcbiAgICAgICAgICAgIGxldCByZXNwb25zZUhhbmRsZXIgPSByZXNwb25zZVByb21pc2VzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlci5yZWplY3QobmV3IEVycm9yKCdUaGUgcmVjZWl2ZWQgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yIHByb3BlcnR5LicpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSAmJiBtZXNzYWdlLnBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5wYXJhbXMsIG51bGwsIDQpfVxcblxcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlcXVlc3QnLCBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5wYXJhbXMsIG51bGwsIDQpfVxcblxcbmA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSkge1xyXG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UuZXJyb3IuZGF0YSwgbnVsbCwgNCl9XFxuXFxuYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLnJlc3VsdCwgbnVsbCwgNCl9XFxuXFxuYDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVzcG9uc2UgJyR7bWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuIFByb2Nlc3NpbmcgcmVxdWVzdCB0b29rICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXNwb25zZScsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgJiYgbWVzc2FnZS5wYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UucGFyYW1zLCBudWxsLCA0KX1cXG5cXG5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVxdWVzdCcsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIgfHwgbWVzc2FnZS5tZXRob2QgPT09IExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UucGFyYW1zLCBudWxsLCA0KX1cXG5cXG5gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcclxuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLmVycm9yLmRhdGEsIG51bGwsIDQpfVxcblxcbmA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5yZXN1bHQsIG51bGwsIDQpfVxcblxcbmA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBtZXNzYWdlLmVycm9yID8gYCBSZXF1ZXN0IGZhaWxlZDogJHttZXNzYWdlLmVycm9yLm1lc3NhZ2V9ICgke21lc3NhZ2UuZXJyb3IuY29kZX0pLmAgOiAnJztcclxuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJyBpbiAke0RhdGUubm93KCkgLSByZXNwb25zZVByb21pc2UudGltZXJTdGFydH1tcy4ke2Vycm9yfWAsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJHttZXNzYWdlLmlkfSB3aXRob3V0IGFjdGl2ZSByZXNwb25zZSBwcm9taXNlLmAsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF0cmFjZXIgfHwgdHJhY2UgPT09IFRyYWNlLk9mZikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxzcE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIGlzTFNQTWVzc2FnZTogdHJ1ZSxcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cmFjZXIubG9nKGxzcE1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XHJcbiAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkNsb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5EaXNwb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgZGlzcG9zZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGhyb3dJZkxpc3RlbmluZygpIHtcclxuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQWxyZWFkeUxpc3RlbmluZywgJ0Nvbm5lY3Rpb24gaXMgYWxyZWFkeSBsaXN0ZW5pbmcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0aHJvd0lmTm90TGlzdGVuaW5nKCkge1xyXG4gICAgICAgIGlmICghaXNMaXN0ZW5pbmcoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBsZXQgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xyXG4gICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWRUb051bGwocGFyYW1zWzBdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWRUb051bGwocGFyYW1zW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGV0IGNvbm5lY3Rpb24gPSB7XHJcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLnBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcclxuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHBhcmFtc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBub3RpZmljYXRpb25NZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihub3RpZmljYXRpb25NZXNzYWdlKTtcclxuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTm90aWZpY2F0aW9uOiAodHlwZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xyXG4gICAgICAgICAgICBpZiAoSXMuZnVuYyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyc1t0eXBlXSA9IHsgdHlwZTogdW5kZWZpbmVkLCBoYW5kbGVyIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyc1t0eXBlLm1ldGhvZF0gPSB7IHR5cGUsIGhhbmRsZXIgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VuZFJlcXVlc3Q6ICh0eXBlLCAuLi5wYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcclxuICAgICAgICAgICAgdGhyb3dJZk5vdExpc3RlbmluZygpO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcclxuICAgICAgICAgICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FuY2VsbGF0aW9uIHRva2VuIGlzIG9wdGlvbmFsIHNvIGl0IGNhbiBhbHNvIGJlIHVuZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKHBhcmFtc1swXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkVG9OdWxsKHBhcmFtc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhcmFtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW2xhc3RdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbXNbbGFzdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWRUb051bGwocGFyYW1zWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBwYXJhbXMuc2xpY2UoMCwgbGFzdCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHBhcmFtcy5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcclxuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpZCA9IHNlcXVlbmNlTnVtYmVyKys7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmUsIHJlamVjdCB9O1xyXG4gICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXcml0aW5nIHRoZSBtZXNzYWdlIGZhaWxlZC4gU28gd2UgbmVlZCB0byByZWplY3QgdGhlIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciwgZS5tZXNzYWdlID8gZS5tZXNzYWdlIDogJ1Vua25vd24gcmVhc29uJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlc1tTdHJpbmcoaWQpXSA9IHJlc3BvbnNlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihDYW5jZWxOb3RpZmljYXRpb24udHlwZSwgeyBpZCB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblJlcXVlc3Q6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XHJcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFyUmVxdWVzdEhhbmRsZXIgPSB0eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnNbdHlwZV0gPSB7IHR5cGU6IHVuZGVmaW5lZCwgaGFuZGxlciB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzW3R5cGUubWV0aG9kXSA9IHsgdHlwZSwgaGFuZGxlciB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFjZTogKF92YWx1ZSwgX3RyYWNlciwgc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBfc2VuZE5vdGlmaWNhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcclxuICAgICAgICAgICAgaWYgKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90cmFjZUZvcm1hdCA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy50cmFjZUZvcm1hdCB8fCBUcmFjZUZvcm1hdC5UZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNlID0gX3ZhbHVlO1xyXG4gICAgICAgICAgICB0cmFjZUZvcm1hdCA9IF90cmFjZUZvcm1hdDtcclxuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlciA9IF90cmFjZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCB7IHZhbHVlOiBUcmFjZS50b1N0cmluZyhfdmFsdWUpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVycm9yOiBlcnJvckVtaXR0ZXIuZXZlbnQsXHJcbiAgICAgICAgb25DbG9zZTogY2xvc2VFbWl0dGVyLmV2ZW50LFxyXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxyXG4gICAgICAgIG9uRGlzcG9zZTogZGlzcG9zZUVtaXR0ZXIuZXZlbnQsXHJcbiAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XHJcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGdvdCBkaXNwb3NlZC4nKTtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzcG9uc2VQcm9taXNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzW2tleV0ucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xyXG4gICAgICAgICAgICAvLyBUZXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlV3JpdGVyLmRpc3Bvc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlUmVhZGVyLmRpc3Bvc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZMaXN0ZW5pbmcoKTtcclxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xyXG4gICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmxpc3RlbihjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zcGVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHRyYWNlID09PSBUcmFjZS5WZXJib3NlID8gcGFyYW1zLnZlcmJvc2UgOiB1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBpc01lc3NhZ2VSZWFkZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5saXN0ZW4gIT09IHZvaWQgMCAmJiB2YWx1ZS5yZWFkID09PSB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gaXNNZXNzYWdlV3JpdGVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUud3JpdGUgIT09IHZvaWQgMCAmJiB2YWx1ZS5lbmQgPT09IHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIHN0cmF0ZWd5KSB7XHJcbiAgICBpZiAoIWxvZ2dlcikge1xyXG4gICAgICAgIGxvZ2dlciA9IGV4cG9ydHMuTnVsbExvZ2dlcjtcclxuICAgIH1cclxuICAgIGxldCByZWFkZXIgPSBpc01lc3NhZ2VSZWFkZXIoaW5wdXQpID8gaW5wdXQgOiBuZXcgbWVzc2FnZVJlYWRlcl8xLlN0cmVhbU1lc3NhZ2VSZWFkZXIoaW5wdXQpO1xyXG4gICAgbGV0IHdyaXRlciA9IGlzTWVzc2FnZVdyaXRlcihvdXRwdXQpID8gb3V0cHV0IDogbmV3IG1lc3NhZ2VXcml0ZXJfMS5TdHJlYW1NZXNzYWdlV3JpdGVyKG91dHB1dCk7XHJcbiAgICByZXR1cm4gX2NyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIHN0cmF0ZWd5KTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/main.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messageReader.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messageReader.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nlet DefaultSize = 8192;\r\nlet CR = Buffer.from('\\r', 'ascii')[0];\r\nlet LF = Buffer.from('\\n', 'ascii')[0];\r\nlet CRLF = '\\r\\n';\r\nclass MessageBuffer {\r\n    constructor(encoding = 'utf8') {\r\n        this.encoding = encoding;\r\n        this.index = 0;\r\n        this.buffer = Buffer.allocUnsafe(DefaultSize);\r\n    }\r\n    append(chunk) {\r\n        var toAppend = chunk;\r\n        if (typeof (chunk) === 'string') {\r\n            var str = chunk;\r\n            var bufferLen = Buffer.byteLength(str, this.encoding);\r\n            toAppend = Buffer.allocUnsafe(bufferLen);\r\n            toAppend.write(str, 0, bufferLen, this.encoding);\r\n        }\r\n        if (this.buffer.length - this.index >= toAppend.length) {\r\n            toAppend.copy(this.buffer, this.index, 0, toAppend.length);\r\n        }\r\n        else {\r\n            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\r\n            if (this.index === 0) {\r\n                this.buffer = Buffer.allocUnsafe(newSize);\r\n                toAppend.copy(this.buffer, 0, 0, toAppend.length);\r\n            }\r\n            else {\r\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\r\n            }\r\n        }\r\n        this.index += toAppend.length;\r\n    }\r\n    tryReadHeaders() {\r\n        let result = undefined;\r\n        let current = 0;\r\n        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\r\n            current++;\r\n        }\r\n        // No header / body separator found (e.g CRLFCRLF)\r\n        if (current + 3 >= this.index) {\r\n            return result;\r\n        }\r\n        result = Object.create(null);\r\n        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);\r\n        headers.forEach((header) => {\r\n            let index = header.indexOf(':');\r\n            if (index === -1) {\r\n                throw new Error('Message header must separate key and value using :');\r\n            }\r\n            let key = header.substr(0, index);\r\n            let value = header.substr(index + 1).trim();\r\n            result[key] = value;\r\n        });\r\n        let nextStart = current + 4;\r\n        this.buffer = this.buffer.slice(nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    tryReadContent(length) {\r\n        if (this.index < length) {\r\n            return null;\r\n        }\r\n        let result = this.buffer.toString(this.encoding, 0, length);\r\n        let nextStart = length;\r\n        this.buffer.copy(this.buffer, 0, nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    get numberOfBytes() {\r\n        return this.index;\r\n    }\r\n}\r\nvar MessageReader;\r\n(function (MessageReader) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\r\n    }\r\n    MessageReader.is = is;\r\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\r\nclass AbstractMessageReader {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n        this.partialMessageEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error) {\r\n        this.errorEmitter.fire(this.asError(error));\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    get onPartialMessage() {\r\n        return this.partialMessageEmitter.event;\r\n    }\r\n    firePartialMessage(info) {\r\n        this.partialMessageEmitter.fire(info);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageReader = AbstractMessageReader;\r\nclass StreamMessageReader extends AbstractMessageReader {\r\n    constructor(readable, encoding = 'utf8') {\r\n        super();\r\n        this.readable = readable;\r\n        this.buffer = new MessageBuffer(encoding);\r\n        this._partialMessageTimeout = 10000;\r\n    }\r\n    set partialMessageTimeout(timeout) {\r\n        this._partialMessageTimeout = timeout;\r\n    }\r\n    get partialMessageTimeout() {\r\n        return this._partialMessageTimeout;\r\n    }\r\n    listen(callback) {\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.partialMessageTimer = undefined;\r\n        this.callback = callback;\r\n        this.readable.on('data', (data) => {\r\n            this.onData(data);\r\n        });\r\n        this.readable.on('error', (error) => this.fireError(error));\r\n        this.readable.on('close', () => this.fireClose());\r\n    }\r\n    onData(data) {\r\n        this.buffer.append(data);\r\n        while (true) {\r\n            if (this.nextMessageLength === -1) {\r\n                let headers = this.buffer.tryReadHeaders();\r\n                if (!headers) {\r\n                    return;\r\n                }\r\n                let contentLength = headers['Content-Length'];\r\n                if (!contentLength) {\r\n                    throw new Error('Header must provide a Content-Length property.');\r\n                }\r\n                let length = parseInt(contentLength);\r\n                if (isNaN(length)) {\r\n                    throw new Error('Content-Length value must be a number.');\r\n                }\r\n                this.nextMessageLength = length;\r\n                // Take the encoding form the header. For compatibility\r\n                // treat both utf-8 and utf8 as node utf8\r\n            }\r\n            var msg = this.buffer.tryReadContent(this.nextMessageLength);\r\n            if (msg === null) {\r\n                /** We haven't recevied the full message yet. */\r\n                this.setPartialMessageTimer();\r\n                return;\r\n            }\r\n            this.clearPartialMessageTimer();\r\n            this.nextMessageLength = -1;\r\n            this.messageToken++;\r\n            var json = JSON.parse(msg);\r\n            this.callback(json);\r\n        }\r\n    }\r\n    clearPartialMessageTimer() {\r\n        if (this.partialMessageTimer) {\r\n            clearTimeout(this.partialMessageTimer);\r\n            this.partialMessageTimer = undefined;\r\n        }\r\n    }\r\n    setPartialMessageTimer() {\r\n        this.clearPartialMessageTimer();\r\n        if (this._partialMessageTimeout <= 0) {\r\n            return;\r\n        }\r\n        this.partialMessageTimer = setTimeout((token, timeout) => {\r\n            this.partialMessageTimer = undefined;\r\n            if (token === this.messageToken) {\r\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\r\n                this.setPartialMessageTimer();\r\n            }\r\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\r\n    }\r\n}\r\nexports.StreamMessageReader = StreamMessageReader;\r\nclass IPCMessageReader extends AbstractMessageReader {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose());\r\n    }\r\n    listen(callback) {\r\n        this.process.on('message', callback);\r\n    }\r\n}\r\nexports.IPCMessageReader = IPCMessageReader;\r\nclass SocketMessageReader extends StreamMessageReader {\r\n    constructor(socket, encoding = 'utf-8') {\r\n        super(socket, encoding);\r\n    }\r\n}\r\nexports.SocketMessageReader = SocketMessageReader;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL21lc3NhZ2VSZWFkZXIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9tZXNzYWdlUmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL2lzXCIpO1xyXG5sZXQgRGVmYXVsdFNpemUgPSA4MTkyO1xyXG5sZXQgQ1IgPSBCdWZmZXIuZnJvbSgnXFxyJywgJ2FzY2lpJylbMF07XHJcbmxldCBMRiA9IEJ1ZmZlci5mcm9tKCdcXG4nLCAnYXNjaWknKVswXTtcclxubGV0IENSTEYgPSAnXFxyXFxuJztcclxuY2xhc3MgTWVzc2FnZUJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGY4Jykge1xyXG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShEZWZhdWx0U2l6ZSk7XHJcbiAgICB9XHJcbiAgICBhcHBlbmQoY2h1bmspIHtcclxuICAgICAgICB2YXIgdG9BcHBlbmQgPSBjaHVuaztcclxuICAgICAgICBpZiAodHlwZW9mIChjaHVuaykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBjaHVuaztcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlckxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgdGhpcy5lbmNvZGluZyk7XHJcbiAgICAgICAgICAgIHRvQXBwZW5kID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlckxlbik7XHJcbiAgICAgICAgICAgIHRvQXBwZW5kLndyaXRlKHN0ciwgMCwgYnVmZmVyTGVuLCB0aGlzLmVuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMuaW5kZXggPj0gdG9BcHBlbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRvQXBwZW5kLmNvcHkodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgsIDAsIHRvQXBwZW5kLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IChNYXRoLmNlaWwoKHRoaXMuaW5kZXggKyB0b0FwcGVuZC5sZW5ndGgpIC8gRGVmYXVsdFNpemUpICsgMSkgKiBEZWZhdWx0U2l6ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5ld1NpemUpO1xyXG4gICAgICAgICAgICAgICAgdG9BcHBlbmQuY29weSh0aGlzLmJ1ZmZlciwgMCwgMCwgdG9BcHBlbmQubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIuc2xpY2UoMCwgdGhpcy5pbmRleCksIHRvQXBwZW5kXSwgbmV3U2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmRleCArPSB0b0FwcGVuZC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICB0cnlSZWFkSGVhZGVycygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gMDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCArIDMgPCB0aGlzLmluZGV4ICYmICh0aGlzLmJ1ZmZlcltjdXJyZW50XSAhPT0gQ1IgfHwgdGhpcy5idWZmZXJbY3VycmVudCArIDFdICE9PSBMRiB8fCB0aGlzLmJ1ZmZlcltjdXJyZW50ICsgMl0gIT09IENSIHx8IHRoaXMuYnVmZmVyW2N1cnJlbnQgKyAzXSAhPT0gTEYpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm8gaGVhZGVyIC8gYm9keSBzZXBhcmF0b3IgZm91bmQgKGUuZyBDUkxGQ1JMRilcclxuICAgICAgICBpZiAoY3VycmVudCArIDMgPj0gdGhpcy5pbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5idWZmZXIudG9TdHJpbmcoJ2FzY2lpJywgMCwgY3VycmVudCkuc3BsaXQoQ1JMRik7XHJcbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGhlYWRlciBtdXN0IHNlcGFyYXRlIGtleSBhbmQgdmFsdWUgdXNpbmcgOicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBoZWFkZXIuc3Vic3RyKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gY3VycmVudCArIDQ7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShuZXh0U3RhcnQpO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4IC0gbmV4dFN0YXJ0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0cnlSZWFkQ29udGVudChsZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5pbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGxlbmd0aCk7XHJcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5KHRoaXMuYnVmZmVyLCAwLCBuZXh0U3RhcnQpO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4IC0gbmV4dFN0YXJ0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgbnVtYmVyT2ZCeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcclxuICAgIH1cclxufVxyXG52YXIgTWVzc2FnZVJlYWRlcjtcclxuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcclxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25QYXJ0aWFsTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XHJcbn0pKE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgfHwgKGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHt9KSk7XHJcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIGdldCBvbkVycm9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcclxuICAgIH1cclxuICAgIGZpcmVFcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUodGhpcy5hc0Vycm9yKGVycm9yKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb25DbG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBmaXJlQ2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcclxuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5maXJlKGluZm8pO1xyXG4gICAgfVxyXG4gICAgYXNFcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFJlYWRlciByZWNldmllZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xyXG5jbGFzcyBTdHJlYW1NZXNzYWdlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBlbmNvZGluZyA9ICd1dGY4Jykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHJlYWRhYmxlO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpO1xyXG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xyXG4gICAgfVxyXG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XHJcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gdGltZW91dDtcclxuICAgIH1cclxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dDtcclxuICAgIH1cclxuICAgIGxpc3RlbihjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbignZXJyb3InLCAoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XHJcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcclxuICAgIH1cclxuICAgIG9uRGF0YShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLmJ1ZmZlci50cnlSZWFkSGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcGFyc2VJbnQoY29udGVudExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBlbmNvZGluZyBmb3JtIHRoZSBoZWFkZXIuIEZvciBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAvLyB0cmVhdCBib3RoIHV0Zi04IGFuZCB1dGY4IGFzIG5vZGUgdXRmOFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQ29udGVudCh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLyoqIFdlIGhhdmVuJ3QgcmVjZXZpZWQgdGhlIGZ1bGwgbWVzc2FnZSB5ZXQuICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVRva2VuKys7XHJcbiAgICAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZShtc2cpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGpzb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcclxuICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLm1lc3NhZ2VUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBTdHJlYW1NZXNzYWdlUmVhZGVyO1xyXG5jbGFzcyBJUENNZXNzYWdlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb2Nlc3MpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XHJcbiAgICAgICAgbGV0IGV2ZW50RW1pdHRlciA9IHRoaXMucHJvY2VzcztcclxuICAgICAgICBldmVudEVtaXR0ZXIub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xyXG4gICAgICAgIGV2ZW50RW1pdHRlci5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcclxuICAgIH1cclxuICAgIGxpc3RlbihjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzcy5vbignbWVzc2FnZScsIGNhbGxiYWNrKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLklQQ01lc3NhZ2VSZWFkZXIgPSBJUENNZXNzYWdlUmVhZGVyO1xyXG5jbGFzcyBTb2NrZXRNZXNzYWdlUmVhZGVyIGV4dGVuZHMgU3RyZWFtTWVzc2FnZVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xyXG4gICAgICAgIHN1cGVyKHNvY2tldCwgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU29ja2V0TWVzc2FnZVJlYWRlciA9IFNvY2tldE1lc3NhZ2VSZWFkZXI7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/messageReader.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messageWriter.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messageWriter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/events.js\");\r\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\nlet ContentLength = 'Content-Length: ';\r\nlet CRLF = '\\r\\n';\r\nvar MessageWriter;\r\n(function (MessageWriter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.write);\r\n    }\r\n    MessageWriter.is = is;\r\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\r\nclass AbstractMessageWriter {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error, message, count) {\r\n        this.errorEmitter.fire([this.asError(error), message, count]);\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageWriter = AbstractMessageWriter;\r\nclass StreamMessageWriter extends AbstractMessageWriter {\r\n    constructor(writable, encoding = 'utf8') {\r\n        super();\r\n        this.writable = writable;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.writable.on('error', (error) => this.fireError(error));\r\n        this.writable.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.writable.write(headers.join(''), 'ascii');\r\n            // Now write the content. This can be written in any encoding\r\n            this.writable.write(json, this.encoding);\r\n            this.errorCount = 0;\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.StreamMessageWriter = StreamMessageWriter;\r\nclass IPCMessageWriter extends AbstractMessageWriter {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        this.errorCount = 0;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose);\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        try {\r\n            if (this.process.send) {\r\n                this.sending = true;\r\n                this.process.send(msg, undefined, undefined, (error) => {\r\n                    this.sending = false;\r\n                    if (error) {\r\n                        this.errorCount++;\r\n                        this.fireError(error, msg, this.errorCount);\r\n                    }\r\n                    else {\r\n                        this.errorCount = 0;\r\n                    }\r\n                    if (this.queue.length > 0) {\r\n                        this.doWriteMessage(this.queue.shift());\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.IPCMessageWriter = IPCMessageWriter;\r\nclass SocketMessageWriter extends AbstractMessageWriter {\r\n    constructor(socket, encoding = 'utf8') {\r\n        super();\r\n        this.socket = socket;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.socket.on('error', (error) => this.fireError(error));\r\n        this.socket.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.sending = true;\r\n            this.socket.write(headers.join(''), 'ascii', (error) => {\r\n                if (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n                try {\r\n                    // Now write the content. This can be written in any encoding\r\n                    this.socket.write(json, this.encoding, (error) => {\r\n                        this.sending = false;\r\n                        if (error) {\r\n                            this.handleError(error, msg);\r\n                        }\r\n                        else {\r\n                            this.errorCount = 0;\r\n                        }\r\n                        if (this.queue.length > 0) {\r\n                            this.doWriteMessage(this.queue.shift());\r\n                        }\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n            });\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n}\r\nexports.SocketMessageWriter = SocketMessageWriter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL21lc3NhZ2VXcml0ZXIuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9tZXNzYWdlV3JpdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL2lzXCIpO1xyXG5sZXQgQ29udGVudExlbmd0aCA9ICdDb250ZW50LUxlbmd0aDogJztcclxubGV0IENSTEYgPSAnXFxyXFxuJztcclxudmFyIE1lc3NhZ2VXcml0ZXI7XHJcbihmdW5jdGlvbiAoTWVzc2FnZVdyaXRlcikge1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJlxyXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS53cml0ZSk7XHJcbiAgICB9XHJcbiAgICBNZXNzYWdlV3JpdGVyLmlzID0gaXM7XHJcbn0pKE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgfHwgKGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IHt9KSk7XHJcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9uRXJyb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUoW3RoaXMuYXNFcnJvcihlcnJvciksIG1lc3NhZ2UsIGNvdW50XSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb25DbG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBmaXJlQ2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgYXNFcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFdyaXRlciByZWNldmllZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xyXG5jbGFzcyBTdHJlYW1NZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdyaXRhYmxlLCBlbmNvZGluZyA9ICd1dGY4Jykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xyXG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcclxuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMud3JpdGFibGUub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xyXG4gICAgICAgIHRoaXMud3JpdGFibGUub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZShtc2cpIHtcclxuICAgICAgICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChqc29uLCB0aGlzLmVuY29kaW5nKTtcclxuICAgICAgICBsZXQgaGVhZGVycyA9IFtcclxuICAgICAgICAgICAgQ29udGVudExlbmd0aCwgY29udGVudExlbmd0aC50b1N0cmluZygpLCBDUkxGLFxyXG4gICAgICAgICAgICBDUkxGXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBIZWFkZXIgbXVzdCBiZSB3cml0dGVuIGluIEFTQ0lJIGVuY29kaW5nXHJcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUud3JpdGUoaGVhZGVycy5qb2luKCcnKSwgJ2FzY2lpJyk7XHJcbiAgICAgICAgICAgIC8vIE5vdyB3cml0ZSB0aGUgY29udGVudC4gVGhpcyBjYW4gYmUgd3JpdHRlbiBpbiBhbnkgZW5jb2RpbmdcclxuICAgICAgICAgICAgdGhpcy53cml0YWJsZS53cml0ZShqc29uLCB0aGlzLmVuY29kaW5nKTtcclxuICAgICAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xyXG4gICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLlN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBTdHJlYW1NZXNzYWdlV3JpdGVyO1xyXG5jbGFzcyBJUENNZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb2Nlc3MpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XHJcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgdGhpcy5zZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGV2ZW50RW1pdHRlciA9IHRoaXMucHJvY2VzcztcclxuICAgICAgICBldmVudEVtaXR0ZXIub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xyXG4gICAgICAgIGV2ZW50RW1pdHRlci5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmZpcmVDbG9zZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZShtc2cpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VuZGluZyAmJiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy83NjU3XHJcbiAgICAgICAgICAgIHRoaXMuZG9Xcml0ZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRvV3JpdGVNZXNzYWdlKG1zZykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3Muc2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcy5zZW5kKG1zZywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1dyaXRlTWVzc2FnZSh0aGlzLnF1ZXVlLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcclxuICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JUENNZXNzYWdlV3JpdGVyID0gSVBDTWVzc2FnZVdyaXRlcjtcclxuY2xhc3MgU29ja2V0TWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcclxuICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgdGhpcy5zZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xyXG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xyXG4gICAgfVxyXG4gICAgd3JpdGUobXNnKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlbmRpbmcgJiYgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNzY1N1xyXG4gICAgICAgICAgICB0aGlzLmRvV3JpdGVNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb1dyaXRlTWVzc2FnZShtc2cpIHtcclxuICAgICAgICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KG1zZyk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChqc29uLCB0aGlzLmVuY29kaW5nKTtcclxuICAgICAgICBsZXQgaGVhZGVycyA9IFtcclxuICAgICAgICAgICAgQ29udGVudExlbmd0aCwgY29udGVudExlbmd0aC50b1N0cmluZygpLCBDUkxGLFxyXG4gICAgICAgICAgICBDUkxGXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBIZWFkZXIgbXVzdCBiZSB3cml0dGVuIGluIEFTQ0lJIGVuY29kaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGhlYWRlcnMuam9pbignJyksICdhc2NpaScsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdyaXRlIHRoZSBjb250ZW50LiBUaGlzIGNhbiBiZSB3cml0dGVuIGluIGFueSBlbmNvZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGpzb24sIHRoaXMuZW5jb2RpbmcsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvV3JpdGVNZXNzYWdlKHRoaXMucXVldWUuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XHJcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNvY2tldE1lc3NhZ2VXcml0ZXIgPSBTb2NrZXRNZXNzYWdlV3JpdGVyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/messageWriter.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/messages.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/messages.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/is.js\");\r\n/**\r\n * Predefined error codes.\r\n */\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    // Defined by JSON RPC\r\n    ErrorCodes.ParseError = -32700;\r\n    ErrorCodes.InvalidRequest = -32600;\r\n    ErrorCodes.MethodNotFound = -32601;\r\n    ErrorCodes.InvalidParams = -32602;\r\n    ErrorCodes.InternalError = -32603;\r\n    ErrorCodes.serverErrorStart = -32099;\r\n    ErrorCodes.serverErrorEnd = -32000;\r\n    ErrorCodes.ServerNotInitialized = -32002;\r\n    ErrorCodes.UnknownErrorCode = -32001;\r\n    // Defined by the protocol.\r\n    ErrorCodes.RequestCancelled = -32800;\r\n    // Defined by VSCode library.\r\n    ErrorCodes.MessageWriteError = 1;\r\n    ErrorCodes.MessageReadError = 2;\r\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\r\n/**\r\n * An error object return in a response in case a request\r\n * has failed.\r\n */\r\nclass ResponseError extends Error {\r\n    constructor(code, message, data) {\r\n        super(message);\r\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\r\n        this.data = data;\r\n        Object.setPrototypeOf(this, ResponseError.prototype);\r\n    }\r\n    toJson() {\r\n        return {\r\n            code: this.code,\r\n            message: this.message,\r\n            data: this.data,\r\n        };\r\n    }\r\n}\r\nexports.ResponseError = ResponseError;\r\n/**\r\n * An abstract implementation of a MessageType.\r\n */\r\nclass AbstractMessageType {\r\n    constructor(_method, _numberOfParams) {\r\n        this._method = _method;\r\n        this._numberOfParams = _numberOfParams;\r\n    }\r\n    get method() {\r\n        return this._method;\r\n    }\r\n    get numberOfParams() {\r\n        return this._numberOfParams;\r\n    }\r\n}\r\nexports.AbstractMessageType = AbstractMessageType;\r\n/**\r\n * Classes to type request response pairs\r\n */\r\nclass RequestType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType0 = RequestType0;\r\nclass RequestType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType = RequestType;\r\nclass RequestType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType1 = RequestType1;\r\nclass RequestType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType2 = RequestType2;\r\nclass RequestType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType3 = RequestType3;\r\nclass RequestType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType4 = RequestType4;\r\nclass RequestType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType5 = RequestType5;\r\nclass RequestType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType6 = RequestType6;\r\nclass RequestType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType7 = RequestType7;\r\nclass RequestType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType8 = RequestType8;\r\nclass RequestType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType9 = RequestType9;\r\nclass NotificationType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType = NotificationType;\r\nclass NotificationType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType0 = NotificationType0;\r\nclass NotificationType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType1 = NotificationType1;\r\nclass NotificationType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType2 = NotificationType2;\r\nclass NotificationType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType3 = NotificationType3;\r\nclass NotificationType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType4 = NotificationType4;\r\nclass NotificationType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType5 = NotificationType5;\r\nclass NotificationType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType6 = NotificationType6;\r\nclass NotificationType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType7 = NotificationType7;\r\nclass NotificationType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType8 = NotificationType8;\r\nclass NotificationType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType9 = NotificationType9;\r\n/**\r\n * Tests if the given message is a request message\r\n */\r\nfunction isRequestMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\r\n}\r\nexports.isRequestMessage = isRequestMessage;\r\n/**\r\n * Tests if the given message is a notification message\r\n */\r\nfunction isNotificationMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && message.id === void 0;\r\n}\r\nexports.isNotificationMessage = isNotificationMessage;\r\n/**\r\n * Tests if the given message is a response message\r\n */\r\nfunction isResponseMessage(message) {\r\n    let candidate = message;\r\n    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\r\n}\r\nexports.isResponseMessage = isResponseMessage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL21lc3NhZ2VzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvbWVzc2FnZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgaXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcclxuLyoqXHJcbiAqIFByZWRlZmluZWQgZXJyb3IgY29kZXMuXHJcbiAqL1xyXG52YXIgRXJyb3JDb2RlcztcclxuKGZ1bmN0aW9uIChFcnJvckNvZGVzKSB7XHJcbiAgICAvLyBEZWZpbmVkIGJ5IEpTT04gUlBDXHJcbiAgICBFcnJvckNvZGVzLlBhcnNlRXJyb3IgPSAtMzI3MDA7XHJcbiAgICBFcnJvckNvZGVzLkludmFsaWRSZXF1ZXN0ID0gLTMyNjAwO1xyXG4gICAgRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCA9IC0zMjYwMTtcclxuICAgIEVycm9yQ29kZXMuSW52YWxpZFBhcmFtcyA9IC0zMjYwMjtcclxuICAgIEVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciA9IC0zMjYwMztcclxuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JTdGFydCA9IC0zMjA5OTtcclxuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JFbmQgPSAtMzIwMDA7XHJcbiAgICBFcnJvckNvZGVzLlNlcnZlck5vdEluaXRpYWxpemVkID0gLTMyMDAyO1xyXG4gICAgRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlID0gLTMyMDAxO1xyXG4gICAgLy8gRGVmaW5lZCBieSB0aGUgcHJvdG9jb2wuXHJcbiAgICBFcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQgPSAtMzI4MDA7XHJcbiAgICAvLyBEZWZpbmVkIGJ5IFZTQ29kZSBsaWJyYXJ5LlxyXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciA9IDE7XHJcbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VSZWFkRXJyb3IgPSAyO1xyXG59KShFcnJvckNvZGVzID0gZXhwb3J0cy5FcnJvckNvZGVzIHx8IChleHBvcnRzLkVycm9yQ29kZXMgPSB7fSkpO1xyXG4vKipcclxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XHJcbiAqIGhhcyBmYWlsZWQuXHJcbiAqL1xyXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmVzcG9uc2VFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgfVxyXG4gICAgdG9Kc29uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xyXG4vKipcclxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoX21ldGhvZCwgX251bWJlck9mUGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gX21ldGhvZDtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlBhcmFtcyA9IF9udW1iZXJPZlBhcmFtcztcclxuICAgIH1cclxuICAgIGdldCBtZXRob2QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcclxuICAgIH1cclxuICAgIGdldCBudW1iZXJPZlBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZQYXJhbXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VUeXBlID0gQWJzdHJhY3RNZXNzYWdlVHlwZTtcclxuLyoqXHJcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xyXG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUzID0gUmVxdWVzdFR5cGUzO1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gUmVxdWVzdFR5cGU2O1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xyXG5jbGFzcyBSZXF1ZXN0VHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XHJcbiAgICAgICAgdGhpcy5fID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gUmVxdWVzdFR5cGU5O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlVHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcclxuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xyXG4gICAgICAgIHRoaXMuXyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBOb3RpZmljYXRpb25UeXBlO1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IE5vdGlmaWNhdGlvblR5cGUzO1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IE5vdGlmaWNhdGlvblR5cGU2O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xyXG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVR5cGUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IE5vdGlmaWNhdGlvblR5cGU5O1xyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzUmVxdWVzdE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xyXG59XHJcbmV4cG9ydHMuaXNSZXF1ZXN0TWVzc2FnZSA9IGlzUmVxdWVzdE1lc3NhZ2U7XHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc05vdGlmaWNhdGlvbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgbGV0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XHJcbn1cclxuZXhwb3J0cy5pc05vdGlmaWNhdGlvbk1lc3NhZ2UgPSBpc05vdGlmaWNhdGlvbk1lc3NhZ2U7XHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzUmVzcG9uc2VNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgIGxldCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xyXG4gICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcclxufVxyXG5leHBvcnRzLmlzUmVzcG9uc2VNZXNzYWdlID0gaXNSZXNwb25zZU1lc3NhZ2U7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/messages.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/pipeSupport.js":
/*!********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/pipeSupport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_1 = __webpack_require__(/*! path */ \"path\");\r\nconst os_1 = __webpack_require__(/*! os */ \"os\");\r\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nfunction generateRandomPipeName() {\r\n    const randomSuffix = crypto_1.randomBytes(21).toString('hex');\r\n    if (process.platform === 'win32') {\r\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\r\n    }\r\n    else {\r\n        // Mac/Unix: use socket file\r\n        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);\r\n    }\r\n}\r\nexports.generateRandomPipeName = generateRandomPipeName;\r\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(pipeName, () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientPipeTransport = createClientPipeTransport;\r\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(pipeName);\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerPipeTransport = createServerPipeTransport;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL3BpcGVTdXBwb3J0LmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvcGlwZVN1cHBvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcclxuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xyXG5jb25zdCBtZXNzYWdlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlUmVhZGVyXCIpO1xyXG5jb25zdCBtZXNzYWdlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlV3JpdGVyXCIpO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVBpcGVOYW1lKCkge1xyXG4gICAgY29uc3QgcmFuZG9tU3VmZml4ID0gY3J5cHRvXzEucmFuZG9tQnl0ZXMoMjEpLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcXFxcXFxcXC5cXFxccGlwZVxcXFx2c2NvZGUtanNvbnJwYy0ke3JhbmRvbVN1ZmZpeH0tc29ja2A7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBNYWMvVW5peDogdXNlIHNvY2tldCBmaWxlXHJcbiAgICAgICAgcmV0dXJuIHBhdGhfMS5qb2luKG9zXzEudG1wZGlyKCksIGB2c2NvZGUtJHtyYW5kb21TdWZmaXh9LnNvY2tgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdlbmVyYXRlUmFuZG9tUGlwZU5hbWUgPSBnZW5lcmF0ZVJhbmRvbVBpcGVOYW1lO1xyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRQaXBlVHJhbnNwb3J0KHBpcGVOYW1lLCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcclxuICAgIGxldCBjb25uZWN0UmVzb2x2ZTtcclxuICAgIGxldCBjb25uZWN0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgc2VydmVyID0gbmV0XzEuY3JlYXRlU2VydmVyKChzb2NrZXQpID0+IHtcclxuICAgICAgICAgICAgc2VydmVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGNvbm5lY3RSZXNvbHZlKFtcclxuICAgICAgICAgICAgICAgIG5ldyBtZXNzYWdlUmVhZGVyXzEuU29ja2V0TWVzc2FnZVJlYWRlcihzb2NrZXQsIGVuY29kaW5nKSxcclxuICAgICAgICAgICAgICAgIG5ldyBtZXNzYWdlV3JpdGVyXzEuU29ja2V0TWVzc2FnZVdyaXRlcihzb2NrZXQsIGVuY29kaW5nKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXJ2ZXIub24oJ2Vycm9yJywgcmVqZWN0KTtcclxuICAgICAgICBzZXJ2ZXIubGlzdGVuKHBpcGVOYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7IHJldHVybiBjb25uZWN0ZWQ7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUNsaWVudFBpcGVUcmFuc3BvcnQgPSBjcmVhdGVDbGllbnRQaXBlVHJhbnNwb3J0O1xyXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJQaXBlVHJhbnNwb3J0KHBpcGVOYW1lLCBlbmNvZGluZyA9ICd1dGYtOCcpIHtcclxuICAgIGNvbnN0IHNvY2tldCA9IG5ldF8xLmNyZWF0ZUNvbm5lY3Rpb24ocGlwZU5hbWUpO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBuZXcgbWVzc2FnZVJlYWRlcl8xLlNvY2tldE1lc3NhZ2VSZWFkZXIoc29ja2V0LCBlbmNvZGluZyksXHJcbiAgICAgICAgbmV3IG1lc3NhZ2VXcml0ZXJfMS5Tb2NrZXRNZXNzYWdlV3JpdGVyKHNvY2tldCwgZW5jb2RpbmcpXHJcbiAgICBdO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlU2VydmVyUGlwZVRyYW5zcG9ydCA9IGNyZWF0ZVNlcnZlclBpcGVUcmFuc3BvcnQ7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/pipeSupport.js\n");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/socketSupport.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/socketSupport.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst messageReader_1 = __webpack_require__(/*! ./messageReader */ \"./node_modules/vscode-jsonrpc/lib/messageReader.js\");\r\nconst messageWriter_1 = __webpack_require__(/*! ./messageWriter */ \"./node_modules/vscode-jsonrpc/lib/messageWriter.js\");\r\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(port, '127.0.0.1', () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientSocketTransport = createClientSocketTransport;\r\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(port, '127.0.0.1');\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerSocketTransport = createServerSocketTransport;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL3NvY2tldFN1cHBvcnQuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9zb2NrZXRTdXBwb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcclxuY29uc3QgbWVzc2FnZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vbWVzc2FnZVJlYWRlclwiKTtcclxuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gcmVxdWlyZShcIi4vbWVzc2FnZVdyaXRlclwiKTtcclxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U29ja2V0VHJhbnNwb3J0KHBvcnQsIGVuY29kaW5nID0gJ3V0Zi04Jykge1xyXG4gICAgbGV0IGNvbm5lY3RSZXNvbHZlO1xyXG4gICAgbGV0IGNvbm5lY3RlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29ubmVjdFJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBzZXJ2ZXIgPSBuZXRfMS5jcmVhdGVTZXJ2ZXIoKHNvY2tldCkgPT4ge1xyXG4gICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgY29ubmVjdFJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgbmV3IG1lc3NhZ2VSZWFkZXJfMS5Tb2NrZXRNZXNzYWdlUmVhZGVyKHNvY2tldCwgZW5jb2RpbmcpLFxyXG4gICAgICAgICAgICAgICAgbmV3IG1lc3NhZ2VXcml0ZXJfMS5Tb2NrZXRNZXNzYWdlV3JpdGVyKHNvY2tldCwgZW5jb2RpbmcpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlcnZlci5vbignZXJyb3InLCByZWplY3QpO1xyXG4gICAgICAgIHNlcnZlci5saXN0ZW4ocG9ydCwgJzEyNy4wLjAuMScsICgpID0+IHtcclxuICAgICAgICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHsgcmV0dXJuIGNvbm5lY3RlZDsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlQ2xpZW50U29ja2V0VHJhbnNwb3J0ID0gY3JlYXRlQ2xpZW50U29ja2V0VHJhbnNwb3J0O1xyXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJTb2NrZXRUcmFuc3BvcnQocG9ydCwgZW5jb2RpbmcgPSAndXRmLTgnKSB7XHJcbiAgICBjb25zdCBzb2NrZXQgPSBuZXRfMS5jcmVhdGVDb25uZWN0aW9uKHBvcnQsICcxMjcuMC4wLjEnKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbmV3IG1lc3NhZ2VSZWFkZXJfMS5Tb2NrZXRNZXNzYWdlUmVhZGVyKHNvY2tldCwgZW5jb2RpbmcpLFxyXG4gICAgICAgIG5ldyBtZXNzYWdlV3JpdGVyXzEuU29ja2V0TWVzc2FnZVdyaXRlcihzb2NrZXQsIGVuY29kaW5nKVxyXG4gICAgXTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZVNlcnZlclNvY2tldFRyYW5zcG9ydCA9IGNyZWF0ZVNlcnZlclNvY2tldFRyYW5zcG9ydDtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-jsonrpc/lib/socketSupport.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/client.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/client.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst c2p = __webpack_require__(/*! ./codeConverter */ \"./node_modules/vscode-languageclient/lib/codeConverter.js\");\r\nconst p2c = __webpack_require__(/*! ./protocolConverter */ \"./node_modules/vscode-languageclient/lib/protocolConverter.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst async_1 = __webpack_require__(/*! ./utils/async */ \"./node_modules/vscode-languageclient/lib/utils/async.js\");\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\n__export(__webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\"));\r\nclass ConsoleLogger {\r\n    error(message) {\r\n        console.error(message);\r\n    }\r\n    warn(message) {\r\n        console.warn(message);\r\n    }\r\n    info(message) {\r\n        console.info(message);\r\n    }\r\n    log(message) {\r\n        console.log(message);\r\n    }\r\n}\r\nfunction createConnection(input, output, errorHandler, closeHandler) {\r\n    let logger = new ConsoleLogger();\r\n    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);\r\n    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });\r\n    connection.onClose(closeHandler);\r\n    let result = {\r\n        listen: () => connection.listen(),\r\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\r\n        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),\r\n        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),\r\n        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),\r\n        trace: (value, tracer, sendNotificationOrTraceOptions) => {\r\n            const defaultTraceOptions = {\r\n                sendNotification: false,\r\n                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text\r\n            };\r\n            if (sendNotificationOrTraceOptions === void 0) {\r\n                connection.trace(value, tracer, defaultTraceOptions);\r\n            }\r\n            else if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                connection.trace(value, tracer, sendNotificationOrTraceOptions);\r\n            }\r\n            else {\r\n                connection.trace(value, tracer, sendNotificationOrTraceOptions);\r\n            }\r\n        },\r\n        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),\r\n        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),\r\n        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),\r\n        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),\r\n        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),\r\n        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),\r\n        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),\r\n        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),\r\n        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),\r\n        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),\r\n        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),\r\n        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),\r\n        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),\r\n        dispose: () => connection.dispose()\r\n    };\r\n    return result;\r\n}\r\n/**\r\n * An action to be performed when the connection is producing errors.\r\n */\r\nvar ErrorAction;\r\n(function (ErrorAction) {\r\n    /**\r\n     * Continue running the server.\r\n     */\r\n    ErrorAction[ErrorAction[\"Continue\"] = 1] = \"Continue\";\r\n    /**\r\n     * Shutdown the server.\r\n     */\r\n    ErrorAction[ErrorAction[\"Shutdown\"] = 2] = \"Shutdown\";\r\n})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));\r\n/**\r\n * An action to be performed when the connection to a server got closed.\r\n */\r\nvar CloseAction;\r\n(function (CloseAction) {\r\n    /**\r\n     * Don't restart the server. The connection stays closed.\r\n     */\r\n    CloseAction[CloseAction[\"DoNotRestart\"] = 1] = \"DoNotRestart\";\r\n    /**\r\n     * Restart the server.\r\n     */\r\n    CloseAction[CloseAction[\"Restart\"] = 2] = \"Restart\";\r\n})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));\r\nclass DefaultErrorHandler {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.restarts = [];\r\n    }\r\n    error(_error, _message, count) {\r\n        if (count && count <= 3) {\r\n            return ErrorAction.Continue;\r\n        }\r\n        return ErrorAction.Shutdown;\r\n    }\r\n    closed() {\r\n        this.restarts.push(Date.now());\r\n        if (this.restarts.length < 5) {\r\n            return CloseAction.Restart;\r\n        }\r\n        else {\r\n            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];\r\n            if (diff <= 3 * 60 * 1000) {\r\n                vscode_1.window.showErrorMessage(`The ${this.name} server crashed 5 times in the last 3 minutes. The server will not be restarted.`);\r\n                return CloseAction.DoNotRestart;\r\n            }\r\n            else {\r\n                this.restarts.shift();\r\n                return CloseAction.Restart;\r\n            }\r\n        }\r\n    }\r\n}\r\nvar RevealOutputChannelOn;\r\n(function (RevealOutputChannelOn) {\r\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Info\"] = 1] = \"Info\";\r\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Warn\"] = 2] = \"Warn\";\r\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Error\"] = 3] = \"Error\";\r\n    RevealOutputChannelOn[RevealOutputChannelOn[\"Never\"] = 4] = \"Never\";\r\n})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));\r\nvar State;\r\n(function (State) {\r\n    State[State[\"Stopped\"] = 1] = \"Stopped\";\r\n    State[State[\"Starting\"] = 3] = \"Starting\";\r\n    State[State[\"Running\"] = 2] = \"Running\";\r\n})(State = exports.State || (exports.State = {}));\r\nvar ClientState;\r\n(function (ClientState) {\r\n    ClientState[ClientState[\"Initial\"] = 0] = \"Initial\";\r\n    ClientState[ClientState[\"Starting\"] = 1] = \"Starting\";\r\n    ClientState[ClientState[\"StartFailed\"] = 2] = \"StartFailed\";\r\n    ClientState[ClientState[\"Running\"] = 3] = \"Running\";\r\n    ClientState[ClientState[\"Stopping\"] = 4] = \"Stopping\";\r\n    ClientState[ClientState[\"Stopped\"] = 5] = \"Stopped\";\r\n})(ClientState || (ClientState = {}));\r\nconst SupporedSymbolKinds = [\r\n    vscode_languageserver_protocol_1.SymbolKind.File,\r\n    vscode_languageserver_protocol_1.SymbolKind.Module,\r\n    vscode_languageserver_protocol_1.SymbolKind.Namespace,\r\n    vscode_languageserver_protocol_1.SymbolKind.Package,\r\n    vscode_languageserver_protocol_1.SymbolKind.Class,\r\n    vscode_languageserver_protocol_1.SymbolKind.Method,\r\n    vscode_languageserver_protocol_1.SymbolKind.Property,\r\n    vscode_languageserver_protocol_1.SymbolKind.Field,\r\n    vscode_languageserver_protocol_1.SymbolKind.Constructor,\r\n    vscode_languageserver_protocol_1.SymbolKind.Enum,\r\n    vscode_languageserver_protocol_1.SymbolKind.Interface,\r\n    vscode_languageserver_protocol_1.SymbolKind.Function,\r\n    vscode_languageserver_protocol_1.SymbolKind.Variable,\r\n    vscode_languageserver_protocol_1.SymbolKind.Constant,\r\n    vscode_languageserver_protocol_1.SymbolKind.String,\r\n    vscode_languageserver_protocol_1.SymbolKind.Number,\r\n    vscode_languageserver_protocol_1.SymbolKind.Boolean,\r\n    vscode_languageserver_protocol_1.SymbolKind.Array,\r\n    vscode_languageserver_protocol_1.SymbolKind.Object,\r\n    vscode_languageserver_protocol_1.SymbolKind.Key,\r\n    vscode_languageserver_protocol_1.SymbolKind.Null,\r\n    vscode_languageserver_protocol_1.SymbolKind.EnumMember,\r\n    vscode_languageserver_protocol_1.SymbolKind.Struct,\r\n    vscode_languageserver_protocol_1.SymbolKind.Event,\r\n    vscode_languageserver_protocol_1.SymbolKind.Operator,\r\n    vscode_languageserver_protocol_1.SymbolKind.TypeParameter\r\n];\r\nconst SupportedCompletionItemKinds = [\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Text,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Method,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Function,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Field,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Variable,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Class,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Interface,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Module,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Property,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Unit,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Value,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Enum,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Color,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.File,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Reference,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Folder,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Constant,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Struct,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Event,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.Operator,\r\n    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter\r\n];\r\nfunction ensure(target, key) {\r\n    if (target[key] === void 0) {\r\n        target[key] = {};\r\n    }\r\n    return target[key];\r\n}\r\nvar DynamicFeature;\r\n(function (DynamicFeature) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.messages !== void 0;\r\n    }\r\n    DynamicFeature.is = is;\r\n})(DynamicFeature || (DynamicFeature = {}));\r\nclass DocumentNotifiactions {\r\n    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {\r\n        this._client = _client;\r\n        this._event = _event;\r\n        this._type = _type;\r\n        this._middleware = _middleware;\r\n        this._createParams = _createParams;\r\n        this._selectorFilter = _selectorFilter;\r\n        this._selectors = new Map();\r\n    }\r\n    static textDocumentFilter(selectors, textDocument) {\r\n        for (const selector of selectors) {\r\n            if (vscode_1.languages.match(selector, textDocument)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    register(_message, data) {\r\n        if (!data.registerOptions.documentSelector) {\r\n            return;\r\n        }\r\n        if (!this._listener) {\r\n            this._listener = this._event(this.callback, this);\r\n        }\r\n        this._selectors.set(data.id, data.registerOptions.documentSelector);\r\n    }\r\n    callback(data) {\r\n        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {\r\n            if (this._middleware) {\r\n                this._middleware(data, (data) => this._client.sendNotification(this._type, this._createParams(data)));\r\n            }\r\n            else {\r\n                this._client.sendNotification(this._type, this._createParams(data));\r\n            }\r\n            this.notificationSent(data);\r\n        }\r\n    }\r\n    notificationSent(_data) {\r\n    }\r\n    unregister(id) {\r\n        this._selectors.delete(id);\r\n        if (this._selectors.size === 0 && this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n    dispose() {\r\n        this._selectors.clear();\r\n        if (this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n}\r\nclass DidOpenTextDocumentFeature extends DocumentNotifiactions {\r\n    constructor(client, _syncedDocuments) {\r\n        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);\r\n        this._syncedDocuments = _syncedDocuments;\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {\r\n            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });\r\n        }\r\n    }\r\n    register(message, data) {\r\n        super.register(message, data);\r\n        if (!data.registerOptions.documentSelector) {\r\n            return;\r\n        }\r\n        let documentSelector = data.registerOptions.documentSelector;\r\n        vscode_1.workspace.textDocuments.forEach((textDocument) => {\r\n            let uri = textDocument.uri.toString();\r\n            if (this._syncedDocuments.has(uri)) {\r\n                return;\r\n            }\r\n            if (vscode_1.languages.match(documentSelector, textDocument)) {\r\n                let middleware = this._client.clientOptions.middleware;\r\n                let didOpen = (textDocument) => {\r\n                    this._client.sendNotification(this._type, this._createParams(textDocument));\r\n                };\r\n                if (middleware.didOpen) {\r\n                    middleware.didOpen(textDocument, didOpen);\r\n                }\r\n                else {\r\n                    didOpen(textDocument);\r\n                }\r\n                this._syncedDocuments.set(uri, textDocument);\r\n            }\r\n        });\r\n    }\r\n    notificationSent(textDocument) {\r\n        super.notificationSent(textDocument);\r\n        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);\r\n    }\r\n}\r\nclass DidCloseTextDocumentFeature extends DocumentNotifiactions {\r\n    constructor(client, _syncedDocuments) {\r\n        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);\r\n        this._syncedDocuments = _syncedDocuments;\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {\r\n            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });\r\n        }\r\n    }\r\n    notificationSent(textDocument) {\r\n        super.notificationSent(textDocument);\r\n        this._syncedDocuments.delete(textDocument.uri.toString());\r\n    }\r\n    unregister(id) {\r\n        let selector = this._selectors.get(id);\r\n        // The super call removed the selector from the map\r\n        // of selectors.\r\n        super.unregister(id);\r\n        let selectors = this._selectors.values();\r\n        this._syncedDocuments.forEach((textDocument) => {\r\n            if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {\r\n                let middleware = this._client.clientOptions.middleware;\r\n                let didClose = (textDocument) => {\r\n                    this._client.sendNotification(this._type, this._createParams(textDocument));\r\n                };\r\n                this._syncedDocuments.delete(textDocument.uri.toString());\r\n                if (middleware.didClose) {\r\n                    middleware.didClose(textDocument, didClose);\r\n                }\r\n                else {\r\n                    didClose(textDocument);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DidChangeTextDocumentFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        this._changeData = new Map();\r\n        this._forcingDelivery = false;\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })\r\n            });\r\n        }\r\n    }\r\n    register(_message, data) {\r\n        if (!data.registerOptions.documentSelector) {\r\n            return;\r\n        }\r\n        if (!this._listener) {\r\n            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);\r\n        }\r\n        this._changeData.set(data.id, {\r\n            documentSelector: data.registerOptions.documentSelector,\r\n            syncKind: data.registerOptions.syncKind\r\n        });\r\n    }\r\n    callback(event) {\r\n        // Text document changes are send for dirty changes as well. We don't\r\n        // have dirty / undirty events in the LSP so we ignore content changes\r\n        // with length zero.\r\n        if (event.contentChanges.length === 0) {\r\n            return;\r\n        }\r\n        for (const changeData of this._changeData.values()) {\r\n            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {\r\n                let middleware = this._client.clientOptions.middleware;\r\n                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {\r\n                    let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);\r\n                    if (middleware.didChange) {\r\n                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params));\r\n                    }\r\n                    else {\r\n                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);\r\n                    }\r\n                }\r\n                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {\r\n                    let didChange = (event) => {\r\n                        if (this._changeDelayer) {\r\n                            if (this._changeDelayer.uri !== event.document.uri.toString()) {\r\n                                // Use this force delivery to track boolean state. Otherwise we might call two times.\r\n                                this.forceDelivery();\r\n                                this._changeDelayer.uri = event.document.uri.toString();\r\n                            }\r\n                            this._changeDelayer.delayer.trigger(() => {\r\n                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));\r\n                            });\r\n                        }\r\n                        else {\r\n                            this._changeDelayer = {\r\n                                uri: event.document.uri.toString(),\r\n                                delayer: new async_1.Delayer(200)\r\n                            };\r\n                            this._changeDelayer.delayer.trigger(() => {\r\n                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));\r\n                            }, -1);\r\n                        }\r\n                    };\r\n                    if (middleware.didChange) {\r\n                        middleware.didChange(event, didChange);\r\n                    }\r\n                    else {\r\n                        didChange(event);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    unregister(id) {\r\n        this._changeData.delete(id);\r\n        if (this._changeData.size === 0 && this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n    dispose() {\r\n        this._changeDelayer = undefined;\r\n        this._forcingDelivery = false;\r\n        this._changeData.clear();\r\n        if (this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n    forceDelivery() {\r\n        if (this._forcingDelivery || !this._changeDelayer) {\r\n            return;\r\n        }\r\n        try {\r\n            this._forcingDelivery = true;\r\n            this._changeDelayer.delayer.forceDelivery();\r\n        }\r\n        finally {\r\n            this._forcingDelivery = false;\r\n        }\r\n    }\r\n}\r\nclass WillSaveFeature extends DocumentNotifiactions {\r\n    constructor(client) {\r\n        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');\r\n        value.willSave = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: { documentSelector: documentSelector }\r\n            });\r\n        }\r\n    }\r\n}\r\nclass WillSaveWaitUntilFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        this._selectors = new Map();\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');\r\n        value.willSaveWaitUntil = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: { documentSelector: documentSelector }\r\n            });\r\n        }\r\n    }\r\n    register(_message, data) {\r\n        if (!data.registerOptions.documentSelector) {\r\n            return;\r\n        }\r\n        if (!this._listener) {\r\n            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);\r\n        }\r\n        this._selectors.set(data.id, data.registerOptions.documentSelector);\r\n    }\r\n    callback(event) {\r\n        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {\r\n            let middleware = this._client.clientOptions.middleware;\r\n            let willSaveWaitUntil = (event) => {\r\n                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then((edits) => {\r\n                    let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);\r\n                    return vEdits === void 0 ? [] : vEdits;\r\n                });\r\n            };\r\n            event.waitUntil(middleware.willSaveWaitUntil\r\n                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)\r\n                : willSaveWaitUntil(event));\r\n        }\r\n    }\r\n    unregister(id) {\r\n        this._selectors.delete(id);\r\n        if (this._selectors.size === 0 && this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n    dispose() {\r\n        this._selectors.clear();\r\n        if (this._listener) {\r\n            this._listener.dispose();\r\n            this._listener = undefined;\r\n        }\r\n    }\r\n}\r\nclass DidSaveTextDocumentFeature extends DocumentNotifiactions {\r\n    constructor(client) {\r\n        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;\r\n        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })\r\n            });\r\n        }\r\n    }\r\n    register(method, data) {\r\n        this._includeText = !!data.registerOptions.includeText;\r\n        super.register(method, data);\r\n    }\r\n}\r\nclass FileSystemWatcherFeature {\r\n    constructor(_client, _notifyFileEvent) {\r\n        this._client = _client;\r\n        this._notifyFileEvent = _notifyFileEvent;\r\n        this._watchers = new Map();\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;\r\n    }\r\n    initialize(_capabilities, _documentSelector) {\r\n    }\r\n    register(_method, data) {\r\n        if (!Array.isArray(data.registerOptions.watchers)) {\r\n            return;\r\n        }\r\n        let disposeables = [];\r\n        for (let watcher of data.registerOptions.watchers) {\r\n            if (!Is.string(watcher.globPattern)) {\r\n                continue;\r\n            }\r\n            let watchCreate = true, watchChange = true, watchDelete = true;\r\n            if (watcher.kind !== void 0 && watcher.kind !== null) {\r\n                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;\r\n                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) != 0;\r\n                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) != 0;\r\n            }\r\n            let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);\r\n            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);\r\n            disposeables.push(fileSystemWatcher);\r\n        }\r\n        this._watchers.set(data.id, disposeables);\r\n    }\r\n    registerRaw(id, fileSystemWatchers) {\r\n        let disposeables = [];\r\n        for (let fileSystemWatcher of fileSystemWatchers) {\r\n            this.hookListeners(fileSystemWatcher, true, true, true, disposeables);\r\n        }\r\n        this._watchers.set(id, disposeables);\r\n    }\r\n    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {\r\n        if (watchCreate) {\r\n            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({\r\n                uri: this._client.code2ProtocolConverter.asUri(resource),\r\n                type: vscode_languageserver_protocol_1.FileChangeType.Created\r\n            }), null, listeners);\r\n        }\r\n        if (watchChange) {\r\n            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({\r\n                uri: this._client.code2ProtocolConverter.asUri(resource),\r\n                type: vscode_languageserver_protocol_1.FileChangeType.Changed\r\n            }), null, listeners);\r\n        }\r\n        if (watchDelete) {\r\n            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({\r\n                uri: this._client.code2ProtocolConverter.asUri(resource),\r\n                type: vscode_languageserver_protocol_1.FileChangeType.Deleted\r\n            }), null, listeners);\r\n        }\r\n    }\r\n    unregister(id) {\r\n        let disposeables = this._watchers.get(id);\r\n        if (disposeables) {\r\n            for (let disposable of disposeables) {\r\n                disposable.dispose();\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        this._watchers.forEach((disposeables) => {\r\n            for (let disposable of disposeables) {\r\n                disposable.dispose();\r\n            }\r\n        });\r\n        this._watchers.clear();\r\n    }\r\n}\r\nclass TextDocumentFeature {\r\n    constructor(_client, _message) {\r\n        this._client = _client;\r\n        this._message = _message;\r\n        this._providers = new Map();\r\n    }\r\n    get messages() {\r\n        return this._message;\r\n    }\r\n    register(message, data) {\r\n        if (message.method !== this.messages.method) {\r\n            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);\r\n        }\r\n        if (!data.registerOptions.documentSelector) {\r\n            return;\r\n        }\r\n        let provider = this.registerLanguageProvider(data.registerOptions);\r\n        if (provider) {\r\n            this._providers.set(data.id, provider);\r\n        }\r\n    }\r\n    unregister(id) {\r\n        let provider = this._providers.get(id);\r\n        if (provider) {\r\n            provider.dispose();\r\n        }\r\n    }\r\n    dispose() {\r\n        this._providers.forEach((value) => {\r\n            value.dispose();\r\n        });\r\n        this._providers.clear();\r\n    }\r\n}\r\nexports.TextDocumentFeature = TextDocumentFeature;\r\nclass WorkspaceFeature {\r\n    constructor(_client, _message) {\r\n        this._client = _client;\r\n        this._message = _message;\r\n        this._providers = new Map();\r\n    }\r\n    get messages() {\r\n        return this._message;\r\n    }\r\n    register(message, data) {\r\n        if (message.method !== this.messages.method) {\r\n            throw new Error(`Register called on wron feature. Requested ${message.method} but reached feature ${this.messages.method}`);\r\n        }\r\n        let provider = this.registerLanguageProvider(data.registerOptions);\r\n        if (provider) {\r\n            this._providers.set(data.id, provider);\r\n        }\r\n    }\r\n    unregister(id) {\r\n        let provider = this._providers.get(id);\r\n        if (provider) {\r\n            provider.dispose();\r\n        }\r\n    }\r\n    dispose() {\r\n        this._providers.forEach((value) => {\r\n            value.dispose();\r\n        });\r\n        this._providers.clear();\r\n    }\r\n}\r\nclass CompletionItemFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let completion = ensure(ensure(capabilites, 'textDocument'), 'completion');\r\n        completion.dynamicRegistration = true;\r\n        completion.contextSupport = true;\r\n        completion.completionItem = {\r\n            snippetSupport: true,\r\n            commitCharactersSupport: true,\r\n            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],\r\n            deprecatedSupport: true,\r\n            preselectSupport: true\r\n        };\r\n        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.completionProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.completionProvider)\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let triggerCharacters = options.triggerCharacters || [];\r\n        let client = this._client;\r\n        let provideCompletionItems = (document, position, context, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let resolveCompletionItem = (item, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item), token).then(client.protocol2CodeConverter.asCompletionItem, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);\r\n                return Promise.resolve(item);\r\n            });\r\n        };\r\n        let middleware = this._client.clientOptions.middleware;\r\n        return vscode_1.languages.registerCompletionItemProvider(options.documentSelector, {\r\n            provideCompletionItems: (document, position, token, context) => {\r\n                return middleware.provideCompletionItem\r\n                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)\r\n                    : provideCompletionItems(document, position, context, token);\r\n            },\r\n            resolveCompletionItem: options.resolveProvider\r\n                ? (item, token) => {\r\n                    return middleware.resolveCompletionItem\r\n                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)\r\n                        : resolveCompletionItem(item, token);\r\n                }\r\n                : undefined\r\n        }, ...triggerCharacters);\r\n    }\r\n}\r\nclass HoverFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.HoverRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        const hoverCapability = (ensure(ensure(capabilites, 'textDocument'), 'hover'));\r\n        hoverCapability.dynamicRegistration = true;\r\n        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.hoverProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideHover = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerHoverProvider(options.documentSelector, {\r\n            provideHover: (document, position, token) => {\r\n                return middleware.provideHover\r\n                    ? middleware.provideHover(document, position, token, provideHover)\r\n                    : provideHover(document, position, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass SignatureHelpFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');\r\n        config.dynamicRegistration = true;\r\n        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.signatureHelpProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.signatureHelpProvider)\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let providerSignatureHelp = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        let triggerCharacters = options.triggerCharacters || [];\r\n        return vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, {\r\n            provideSignatureHelp: (document, position, token) => {\r\n                return middleware.provideSignatureHelp\r\n                    ? middleware.provideSignatureHelp(document, position, token, providerSignatureHelp)\r\n                    : providerSignatureHelp(document, position, token);\r\n            }\r\n        }, ...triggerCharacters);\r\n    }\r\n}\r\nclass DefinitionFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'definition').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.definitionProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDefinition = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDefinitionProvider(options.documentSelector, {\r\n            provideDefinition: (document, position, token) => {\r\n                return middleware.provideDefinition\r\n                    ? middleware.provideDefinition(document, position, token, provideDefinition)\r\n                    : provideDefinition(document, position, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass ReferencesFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.referencesProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let providerReferences = (document, position, options, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerReferenceProvider(options.documentSelector, {\r\n            provideReferences: (document, position, options, token) => {\r\n                return middleware.provideReferences\r\n                    ? middleware.provideReferences(document, position, options, token, providerReferences)\r\n                    : providerReferences(document, position, options, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DocumentHighlightFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentHighlightProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDocumentHighlights = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, {\r\n            provideDocumentHighlights: (document, position, token) => {\r\n                return middleware.provideDocumentHighlights\r\n                    ? middleware.provideDocumentHighlights(document, position, token, provideDocumentHighlights)\r\n                    : provideDocumentHighlights(document, position, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DocumentSymbolFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');\r\n        symbolCapabilities.dynamicRegistration = true;\r\n        symbolCapabilities.symbolKind = {\r\n            valueSet: SupporedSymbolKinds\r\n        };\r\n        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentSymbolProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDocumentSymbols = (document, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then((data) => {\r\n                if (data === null) {\r\n                    return undefined;\r\n                }\r\n                if (data.length === 0) {\r\n                    return [];\r\n                }\r\n                else {\r\n                    let element = data[0];\r\n                    if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {\r\n                        return client.protocol2CodeConverter.asDocumentSymbols(data);\r\n                    }\r\n                    else {\r\n                        return client.protocol2CodeConverter.asSymbolInformations(data);\r\n                    }\r\n                }\r\n            }, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, {\r\n            provideDocumentSymbols: (document, token) => {\r\n                return middleware.provideDocumentSymbols\r\n                    ? middleware.provideDocumentSymbols(document, token, provideDocumentSymbols)\r\n                    : provideDocumentSymbols(document, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass WorkspaceSymbolFeature extends WorkspaceFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');\r\n        symbolCapabilities.dynamicRegistration = true;\r\n        symbolCapabilities.symbolKind = {\r\n            valueSet: SupporedSymbolKinds\r\n        };\r\n    }\r\n    initialize(capabilities) {\r\n        if (!capabilities.workspaceSymbolProvider) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: undefined\r\n        });\r\n    }\r\n    registerLanguageProvider(_options) {\r\n        let client = this._client;\r\n        let provideWorkspaceSymbols = (query, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerWorkspaceSymbolProvider({\r\n            provideWorkspaceSymbols: (query, token) => {\r\n                return middleware.provideWorkspaceSymbols\r\n                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)\r\n                    : provideWorkspaceSymbols(query, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass CodeActionFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        const cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');\r\n        cap.dynamicRegistration = true;\r\n        cap.codeActionLiteralSupport = {\r\n            codeActionKind: {\r\n                valueSet: [\r\n                    '',\r\n                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.Source,\r\n                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports\r\n                ]\r\n            }\r\n        };\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.codeActionProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        let codeActionKinds = undefined;\r\n        if (!Is.boolean(capabilities.codeActionProvider)) {\r\n            codeActionKinds = capabilities.codeActionProvider.codeActionKinds;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: { documentSelector: documentSelector, codeActionKinds }\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideCodeActions = (document, range, context, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                range: client.code2ProtocolConverter.asRange(range),\r\n                context: client.code2ProtocolConverter.asCodeActionContext(context)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {\r\n                if (values === null) {\r\n                    return undefined;\r\n                }\r\n                let result = [];\r\n                for (let item of values) {\r\n                    if (vscode_languageserver_protocol_1.Command.is(item)) {\r\n                        result.push(client.protocol2CodeConverter.asCommand(item));\r\n                    }\r\n                    else {\r\n                        result.push(client.protocol2CodeConverter.asCodeAction(item));\r\n                    }\r\n                    ;\r\n                }\r\n                return result;\r\n            }, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerCodeActionsProvider(options.documentSelector, {\r\n            provideCodeActions: (document, range, context, token) => {\r\n                return middleware.provideCodeActions\r\n                    ? middleware.provideCodeActions(document, range, context, token, provideCodeActions)\r\n                    : provideCodeActions(document, range, context, token);\r\n            }\r\n        }, options.codeActionKinds\r\n            ? { providedCodeActionKinds: client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }\r\n            : undefined);\r\n    }\r\n}\r\nclass CodeLensFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.codeLensProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.codeLensProvider)\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideCodeLenses = (document, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let resolveCodeLens = (codeLens, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);\r\n                return codeLens;\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerCodeLensProvider(options.documentSelector, {\r\n            provideCodeLenses: (document, token) => {\r\n                return middleware.provideCodeLenses\r\n                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)\r\n                    : provideCodeLenses(document, token);\r\n            },\r\n            resolveCodeLens: (options.resolveProvider)\r\n                ? (codeLens, token) => {\r\n                    return middleware.resolveCodeLens\r\n                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)\r\n                        : resolveCodeLens(codeLens, token);\r\n                }\r\n                : undefined\r\n        });\r\n    }\r\n}\r\nclass DocumentFormattingFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentFormattingProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDocumentFormattingEdits = (document, options, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                options: client.code2ProtocolConverter.asFormattingOptions(options)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, {\r\n            provideDocumentFormattingEdits: (document, options, token) => {\r\n                return middleware.provideDocumentFormattingEdits\r\n                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)\r\n                    : provideDocumentFormattingEdits(document, options, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DocumentRangeFormattingFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentRangeFormattingProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDocumentRangeFormattingEdits = (document, range, options, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                range: client.code2ProtocolConverter.asRange(range),\r\n                options: client.code2ProtocolConverter.asFormattingOptions(options)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, {\r\n            provideDocumentRangeFormattingEdits: (document, range, options, token) => {\r\n                return middleware.provideDocumentRangeFormattingEdits\r\n                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)\r\n                    : provideDocumentRangeFormattingEdits(document, range, options, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DocumentOnTypeFormattingFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentOnTypeFormattingProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentOnTypeFormattingProvider)\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let moreTriggerCharacter = options.moreTriggerCharacter || [];\r\n        let provideOnTypeFormattingEdits = (document, position, ch, options, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                position: client.code2ProtocolConverter.asPosition(position),\r\n                ch: ch,\r\n                options: client.code2ProtocolConverter.asFormattingOptions(options)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);\r\n                return Promise.resolve([]);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, {\r\n            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {\r\n                return middleware.provideOnTypeFormattingEdits\r\n                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)\r\n                    : provideOnTypeFormattingEdits(document, position, ch, options, token);\r\n            }\r\n        }, options.firstTriggerCharacter, ...moreTriggerCharacter);\r\n    }\r\n}\r\nclass RenameFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.RenameRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let rename = ensure(ensure(capabilites, 'textDocument'), 'rename');\r\n        rename.dynamicRegistration = true;\r\n        rename.prepareSupport = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.renameProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        let options = Object.assign({}, { documentSelector: documentSelector });\r\n        if (Is.boolean(capabilities.renameProvider)) {\r\n            options.prepareProvider = false;\r\n        }\r\n        else {\r\n            options.prepareProvider = capabilities.renameProvider.prepareProvider;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: options\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideRenameEdits = (document, position, newName, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                position: client.code2ProtocolConverter.asPosition(position),\r\n                newName: newName\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);\r\n                return Promise.reject(new Error(error.message));\r\n            });\r\n        };\r\n        let prepareRename = (document, position, token) => {\r\n            let params = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\r\n                position: client.code2ProtocolConverter.asPosition(position),\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {\r\n                if (vscode_languageserver_protocol_1.Range.is(result)) {\r\n                    return client.protocol2CodeConverter.asRange(result);\r\n                }\r\n                else if (result && result.range) {\r\n                    return {\r\n                        range: client.protocol2CodeConverter.asRange(result.range),\r\n                        placeholder: result.placeholder\r\n                    };\r\n                }\r\n                return null;\r\n            }, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error);\r\n                return Promise.reject(new Error(error.message));\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerRenameProvider(options.documentSelector, {\r\n            provideRenameEdits: (document, position, newName, token) => {\r\n                return middleware.provideRenameEdits\r\n                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)\r\n                    : provideRenameEdits(document, position, newName, token);\r\n            },\r\n            prepareRename: options.prepareProvider\r\n                ? (document, position, token) => {\r\n                    return middleware.prepareRename\r\n                        ? middleware.prepareRename(document, position, token, prepareRename)\r\n                        : prepareRename(document, position, token);\r\n                }\r\n                : undefined\r\n        });\r\n    }\r\n}\r\nclass DocumentLinkFeature extends TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'documentLink').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.documentLinkProvider || !documentSelector) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentLinkProvider)\r\n        });\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideDocumentLinks = (document, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);\r\n                Promise.resolve(new Error(error.message));\r\n            });\r\n        };\r\n        let resolveDocumentLink = (link, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);\r\n                Promise.resolve(new Error(error.message));\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, {\r\n            provideDocumentLinks: (document, token) => {\r\n                return middleware.provideDocumentLinks\r\n                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)\r\n                    : provideDocumentLinks(document, token);\r\n            },\r\n            resolveDocumentLink: options.resolveProvider\r\n                ? (link, token) => {\r\n                    return middleware.resolveDocumentLink\r\n                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)\r\n                        : resolveDocumentLink(link, token);\r\n                }\r\n                : undefined\r\n        });\r\n    }\r\n}\r\nclass ConfigurationFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        this._listeners = new Map();\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;\r\n    }\r\n    initialize() {\r\n        let section = this._client.clientOptions.synchronize.configurationSection;\r\n        if (section !== void 0) {\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: {\r\n                    section: section\r\n                }\r\n            });\r\n        }\r\n    }\r\n    register(_message, data) {\r\n        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {\r\n            this.onDidChangeConfiguration(data.registerOptions.section, event);\r\n        });\r\n        this._listeners.set(data.id, disposable);\r\n        if (data.registerOptions.section !== void 0) {\r\n            this.onDidChangeConfiguration(data.registerOptions.section, undefined);\r\n        }\r\n    }\r\n    unregister(id) {\r\n        let disposable = this._listeners.get(id);\r\n        if (disposable) {\r\n            this._listeners.delete(id);\r\n            disposable.dispose();\r\n        }\r\n    }\r\n    dispose() {\r\n        for (let disposable of this._listeners.values()) {\r\n            disposable.dispose();\r\n        }\r\n        this._listeners.clear();\r\n    }\r\n    onDidChangeConfiguration(configurationSection, event) {\r\n        let sections;\r\n        if (Is.string(configurationSection)) {\r\n            sections = [configurationSection];\r\n        }\r\n        else {\r\n            sections = configurationSection;\r\n        }\r\n        if (sections !== void 0 && event !== void 0) {\r\n            let affected = sections.some((section) => event.affectsConfiguration(section));\r\n            if (!affected) {\r\n                return;\r\n            }\r\n        }\r\n        let didChangeConfiguration = (sections) => {\r\n            if (sections === void 0) {\r\n                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });\r\n                return;\r\n            }\r\n            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });\r\n        };\r\n        let middleware = this.getMiddleware();\r\n        middleware\r\n            ? middleware(sections, didChangeConfiguration)\r\n            : didChangeConfiguration(sections);\r\n    }\r\n    extractSettingsInformation(keys) {\r\n        function ensurePath(config, path) {\r\n            let current = config;\r\n            for (let i = 0; i < path.length - 1; i++) {\r\n                let obj = current[path[i]];\r\n                if (!obj) {\r\n                    obj = Object.create(null);\r\n                    current[path[i]] = obj;\r\n                }\r\n                current = obj;\r\n            }\r\n            return current;\r\n        }\r\n        let resource = this._client.clientOptions.workspaceFolder\r\n            ? this._client.clientOptions.workspaceFolder.uri\r\n            : undefined;\r\n        let result = Object.create(null);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            let key = keys[i];\r\n            let index = key.indexOf('.');\r\n            let config = null;\r\n            if (index >= 0) {\r\n                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));\r\n            }\r\n            else {\r\n                config = vscode_1.workspace.getConfiguration(key, resource);\r\n            }\r\n            if (config) {\r\n                let path = keys[i].split('.');\r\n                ensurePath(result, path)[path[path.length - 1]] = config;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getMiddleware() {\r\n        let middleware = this._client.clientOptions.middleware;\r\n        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {\r\n            return middleware.workspace.didChangeConfiguration;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\nclass ExecuteCommandFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        this._commands = new Map();\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities) {\r\n        if (!capabilities.executeCommandProvider) {\r\n            return;\r\n        }\r\n        this.register(this.messages, {\r\n            id: UUID.generateUuid(),\r\n            registerOptions: Object.assign({}, capabilities.executeCommandProvider)\r\n        });\r\n    }\r\n    register(_message, data) {\r\n        let client = this._client;\r\n        if (data.registerOptions.commands) {\r\n            let disposeables = [];\r\n            for (const command of data.registerOptions.commands) {\r\n                disposeables.push(vscode_1.commands.registerCommand(command, (...args) => {\r\n                    let params = {\r\n                        command,\r\n                        arguments: args\r\n                    };\r\n                    return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {\r\n                        client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);\r\n                    });\r\n                }));\r\n            }\r\n            this._commands.set(data.id, disposeables);\r\n        }\r\n    }\r\n    unregister(id) {\r\n        let disposeables = this._commands.get(id);\r\n        if (disposeables) {\r\n            disposeables.forEach(disposable => disposable.dispose());\r\n        }\r\n    }\r\n    dispose() {\r\n        this._commands.forEach((value) => {\r\n            value.forEach(disposable => disposable.dispose());\r\n        });\r\n        this._commands.clear();\r\n    }\r\n}\r\nvar MessageTransports;\r\n(function (MessageTransports) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);\r\n    }\r\n    MessageTransports.is = is;\r\n})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));\r\nclass OnReady {\r\n    constructor(_resolve, _reject) {\r\n        this._resolve = _resolve;\r\n        this._reject = _reject;\r\n        this._used = false;\r\n    }\r\n    get isUsed() {\r\n        return this._used;\r\n    }\r\n    resolve() {\r\n        this._used = true;\r\n        this._resolve();\r\n    }\r\n    reject(error) {\r\n        this._used = true;\r\n        this._reject(error);\r\n    }\r\n}\r\nclass BaseLanguageClient {\r\n    constructor(id, name, clientOptions) {\r\n        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;\r\n        this._features = [];\r\n        this._method2Message = new Map();\r\n        this._dynamicFeatures = new Map();\r\n        this._id = id;\r\n        this._name = name;\r\n        clientOptions = clientOptions || {};\r\n        this._clientOptions = {\r\n            documentSelector: clientOptions.documentSelector || [],\r\n            synchronize: clientOptions.synchronize || {},\r\n            diagnosticCollectionName: clientOptions.diagnosticCollectionName,\r\n            outputChannelName: clientOptions.outputChannelName || this._name,\r\n            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,\r\n            stdioEncoding: clientOptions.stdioEncoding || 'utf8',\r\n            initializationOptions: clientOptions.initializationOptions,\r\n            initializationFailedHandler: clientOptions.initializationFailedHandler,\r\n            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._name),\r\n            middleware: clientOptions.middleware || {},\r\n            uriConverters: clientOptions.uriConverters,\r\n            workspaceFolder: clientOptions.workspaceFolder\r\n        };\r\n        this._clientOptions.synchronize = this._clientOptions.synchronize || {};\r\n        this.state = ClientState.Initial;\r\n        this._connectionPromise = undefined;\r\n        this._resolvedConnection = undefined;\r\n        this._initializeResult = undefined;\r\n        if (clientOptions.outputChannel) {\r\n            this._outputChannel = clientOptions.outputChannel;\r\n            this._disposeOutputChannel = false;\r\n        }\r\n        else {\r\n            this._outputChannel = undefined;\r\n            this._disposeOutputChannel = true;\r\n        }\r\n        this._listeners = undefined;\r\n        this._providers = undefined;\r\n        this._diagnostics = undefined;\r\n        this._fileEvents = [];\r\n        this._fileEventDelayer = new async_1.Delayer(250);\r\n        this._onReady = new Promise((resolve, reject) => {\r\n            this._onReadyCallbacks = new OnReady(resolve, reject);\r\n        });\r\n        this._onStop = undefined;\r\n        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();\r\n        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();\r\n        this._tracer = {\r\n            log: (messageOrDataObject, data) => {\r\n                if (Is.string(messageOrDataObject)) {\r\n                    this.logTrace(messageOrDataObject, data);\r\n                }\r\n                else {\r\n                    this.logObjectTrace(messageOrDataObject);\r\n                }\r\n            },\r\n        };\r\n        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);\r\n        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);\r\n        this._syncedDocuments = new Map();\r\n        this.registerBuiltinFeatures();\r\n    }\r\n    get state() {\r\n        return this._state;\r\n    }\r\n    set state(value) {\r\n        let oldState = this.getPublicState();\r\n        this._state = value;\r\n        let newState = this.getPublicState();\r\n        if (newState !== oldState) {\r\n            this._stateChangeEmitter.fire({ oldState, newState });\r\n        }\r\n    }\r\n    getPublicState() {\r\n        if (this.state === ClientState.Running) {\r\n            return State.Running;\r\n        }\r\n        else if (this.state === ClientState.Starting) {\r\n            return State.Starting;\r\n        }\r\n        else {\r\n            return State.Stopped;\r\n        }\r\n    }\r\n    get initializeResult() {\r\n        return this._initializeResult;\r\n    }\r\n    sendRequest(type, ...params) {\r\n        if (!this.isConnectionActive()) {\r\n            throw new Error('Language client is not ready yet');\r\n        }\r\n        this.forceDocumentSync();\r\n        try {\r\n            return this._resolvedConnection.sendRequest(type, ...params);\r\n        }\r\n        catch (error) {\r\n            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);\r\n            throw error;\r\n        }\r\n    }\r\n    onRequest(type, handler) {\r\n        if (!this.isConnectionActive()) {\r\n            throw new Error('Language client is not ready yet');\r\n        }\r\n        try {\r\n            this._resolvedConnection.onRequest(type, handler);\r\n        }\r\n        catch (error) {\r\n            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);\r\n            throw error;\r\n        }\r\n    }\r\n    sendNotification(type, params) {\r\n        if (!this.isConnectionActive()) {\r\n            throw new Error('Language client is not ready yet');\r\n        }\r\n        this.forceDocumentSync();\r\n        try {\r\n            this._resolvedConnection.sendNotification(type, params);\r\n        }\r\n        catch (error) {\r\n            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);\r\n            throw error;\r\n        }\r\n    }\r\n    onNotification(type, handler) {\r\n        if (!this.isConnectionActive()) {\r\n            throw new Error('Language client is not ready yet');\r\n        }\r\n        try {\r\n            this._resolvedConnection.onNotification(type, handler);\r\n        }\r\n        catch (error) {\r\n            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);\r\n            throw error;\r\n        }\r\n    }\r\n    get clientOptions() {\r\n        return this._clientOptions;\r\n    }\r\n    get protocol2CodeConverter() {\r\n        return this._p2c;\r\n    }\r\n    get code2ProtocolConverter() {\r\n        return this._c2p;\r\n    }\r\n    get onTelemetry() {\r\n        return this._telemetryEmitter.event;\r\n    }\r\n    get onDidChangeState() {\r\n        return this._stateChangeEmitter.event;\r\n    }\r\n    get outputChannel() {\r\n        if (!this._outputChannel) {\r\n            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);\r\n        }\r\n        return this._outputChannel;\r\n    }\r\n    get diagnostics() {\r\n        return this._diagnostics;\r\n    }\r\n    createDefaultErrorHandler() {\r\n        return new DefaultErrorHandler(this._name);\r\n    }\r\n    set trace(value) {\r\n        this._trace = value;\r\n        this.onReady().then(() => {\r\n            this.resolveConnection().then((connection) => {\r\n                connection.trace(this._trace, this._tracer, {\r\n                    sendNotification: false,\r\n                    traceFormat: this._traceFormat\r\n                });\r\n            });\r\n        }, () => {\r\n        });\r\n    }\r\n    data2String(data) {\r\n        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {\r\n            const responseError = data;\r\n            return `  Message: ${responseError.message}\\n  Code: ${responseError.code} ${responseError.data ? '\\n' + responseError.data.toString() : ''}`;\r\n        }\r\n        if (data instanceof Error) {\r\n            if (Is.string(data.stack)) {\r\n                return data.stack;\r\n            }\r\n            return data.message;\r\n        }\r\n        if (Is.string(data)) {\r\n            return data;\r\n        }\r\n        return data.toString();\r\n    }\r\n    info(message, data) {\r\n        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);\r\n        if (data) {\r\n            this.outputChannel.appendLine(this.data2String(data));\r\n        }\r\n        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {\r\n            this.outputChannel.show(true);\r\n        }\r\n    }\r\n    warn(message, data) {\r\n        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);\r\n        if (data) {\r\n            this.outputChannel.appendLine(this.data2String(data));\r\n        }\r\n        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {\r\n            this.outputChannel.show(true);\r\n        }\r\n    }\r\n    error(message, data) {\r\n        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);\r\n        if (data) {\r\n            this.outputChannel.appendLine(this.data2String(data));\r\n        }\r\n        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {\r\n            this.outputChannel.show(true);\r\n        }\r\n    }\r\n    logTrace(message, data) {\r\n        this.outputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);\r\n        if (data) {\r\n            this.outputChannel.appendLine(this.data2String(data));\r\n        }\r\n    }\r\n    logObjectTrace(data) {\r\n        if (data.isLSPMessage && data.type) {\r\n            this.outputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);\r\n        }\r\n        else {\r\n            this.outputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);\r\n        }\r\n        if (data) {\r\n            this.outputChannel.appendLine(`${JSON.stringify(data)}`);\r\n        }\r\n    }\r\n    needsStart() {\r\n        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;\r\n    }\r\n    needsStop() {\r\n        return this.state === ClientState.Starting || this.state === ClientState.Running;\r\n    }\r\n    onReady() {\r\n        return this._onReady;\r\n    }\r\n    isConnectionActive() {\r\n        return this.state === ClientState.Running && !!this._resolvedConnection;\r\n    }\r\n    start() {\r\n        if (this._onReadyCallbacks.isUsed) {\r\n            this._onReady = new Promise((resolve, reject) => {\r\n                this._onReadyCallbacks = new OnReady(resolve, reject);\r\n            });\r\n        }\r\n        this._listeners = [];\r\n        this._providers = [];\r\n        // If we restart then the diagnostics collection is reused.\r\n        if (!this._diagnostics) {\r\n            this._diagnostics = this._clientOptions.diagnosticCollectionName\r\n                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)\r\n                : vscode_1.languages.createDiagnosticCollection();\r\n        }\r\n        this.state = ClientState.Starting;\r\n        this.resolveConnection().then((connection) => {\r\n            connection.onLogMessage((message) => {\r\n                switch (message.type) {\r\n                    case vscode_languageserver_protocol_1.MessageType.Error:\r\n                        this.error(message.message);\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\r\n                        this.warn(message.message);\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Info:\r\n                        this.info(message.message);\r\n                        break;\r\n                    default:\r\n                        this.outputChannel.appendLine(message.message);\r\n                }\r\n            });\r\n            connection.onShowMessage((message) => {\r\n                switch (message.type) {\r\n                    case vscode_languageserver_protocol_1.MessageType.Error:\r\n                        vscode_1.window.showErrorMessage(message.message);\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\r\n                        vscode_1.window.showWarningMessage(message.message);\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Info:\r\n                        vscode_1.window.showInformationMessage(message.message);\r\n                        break;\r\n                    default:\r\n                        vscode_1.window.showInformationMessage(message.message);\r\n                }\r\n            });\r\n            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {\r\n                let messageFunc;\r\n                switch (params.type) {\r\n                    case vscode_languageserver_protocol_1.MessageType.Error:\r\n                        messageFunc = vscode_1.window.showErrorMessage;\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Warning:\r\n                        messageFunc = vscode_1.window.showWarningMessage;\r\n                        break;\r\n                    case vscode_languageserver_protocol_1.MessageType.Info:\r\n                        messageFunc = vscode_1.window.showInformationMessage;\r\n                        break;\r\n                    default:\r\n                        messageFunc = vscode_1.window.showInformationMessage;\r\n                }\r\n                let actions = params.actions || [];\r\n                return messageFunc(params.message, ...actions);\r\n            });\r\n            connection.onTelemetry((data) => {\r\n                this._telemetryEmitter.fire(data);\r\n            });\r\n            connection.listen();\r\n            // Error is handled in the intialize call.\r\n            return this.initialize(connection);\r\n        }).then(undefined, (error) => {\r\n            this.state = ClientState.StartFailed;\r\n            this._onReadyCallbacks.reject(error);\r\n            this.error('Starting client failed', error);\r\n            vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);\r\n        });\r\n        return new vscode_1.Disposable(() => {\r\n            if (this.needsStop()) {\r\n                this.stop();\r\n            }\r\n        });\r\n    }\r\n    resolveConnection() {\r\n        if (!this._connectionPromise) {\r\n            this._connectionPromise = this.createConnection();\r\n        }\r\n        return this._connectionPromise;\r\n    }\r\n    initialize(connection) {\r\n        this.refreshTrace(connection, false);\r\n        let initOption = this._clientOptions.initializationOptions;\r\n        let rootPath = this._clientOptions.workspaceFolder\r\n            ? this._clientOptions.workspaceFolder.uri.fsPath\r\n            : this._clientGetRootPath();\r\n        let initParams = {\r\n            processId: process.pid,\r\n            rootPath: rootPath ? rootPath : null,\r\n            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,\r\n            capabilities: this.computeClientCapabilities(),\r\n            initializationOptions: Is.func(initOption) ? initOption() : initOption,\r\n            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),\r\n            workspaceFolders: null\r\n        };\r\n        this.fillInitializeParams(initParams);\r\n        return connection.initialize(initParams).then((result) => {\r\n            this._resolvedConnection = connection;\r\n            this._initializeResult = result;\r\n            this.state = ClientState.Running;\r\n            let textDocumentSyncOptions = undefined;\r\n            if (Is.number(result.capabilities.textDocumentSync)) {\r\n                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {\r\n                    textDocumentSyncOptions = {\r\n                        openClose: false,\r\n                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,\r\n                        save: undefined\r\n                    };\r\n                }\r\n                else {\r\n                    textDocumentSyncOptions = {\r\n                        openClose: true,\r\n                        change: result.capabilities.textDocumentSync,\r\n                        save: {\r\n                            includeText: false\r\n                        }\r\n                    };\r\n                }\r\n            }\r\n            else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {\r\n                textDocumentSyncOptions = result.capabilities.textDocumentSync;\r\n            }\r\n            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });\r\n            connection.onDiagnostics(params => this.handleDiagnostics(params));\r\n            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));\r\n            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199\r\n            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));\r\n            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));\r\n            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199\r\n            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));\r\n            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));\r\n            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});\r\n            this.hookFileEvents(connection);\r\n            this.hookConfigurationChanged(connection);\r\n            this.initializeFeatures(connection);\r\n            this._onReadyCallbacks.resolve();\r\n            return result;\r\n        }).then(undefined, (error) => {\r\n            if (this._clientOptions.initializationFailedHandler) {\r\n                if (this._clientOptions.initializationFailedHandler(error)) {\r\n                    this.initialize(connection);\r\n                }\r\n                else {\r\n                    this.stop();\r\n                    this._onReadyCallbacks.reject(error);\r\n                }\r\n            }\r\n            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {\r\n                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: \"retry\" }).then(item => {\r\n                    if (item && item.id === 'retry') {\r\n                        this.initialize(connection);\r\n                    }\r\n                    else {\r\n                        this.stop();\r\n                        this._onReadyCallbacks.reject(error);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                if (error && error.message) {\r\n                    vscode_1.window.showErrorMessage(error.message);\r\n                }\r\n                this.error('Server initialization failed.', error);\r\n                this.stop();\r\n                this._onReadyCallbacks.reject(error);\r\n            }\r\n        });\r\n    }\r\n    _clientGetRootPath() {\r\n        let folders = vscode_1.workspace.workspaceFolders;\r\n        if (!folders || folders.length === 0) {\r\n            return undefined;\r\n        }\r\n        let folder = folders[0];\r\n        if (folder.uri.scheme === 'file') {\r\n            return folder.uri.fsPath;\r\n        }\r\n        return undefined;\r\n    }\r\n    stop() {\r\n        this._initializeResult = undefined;\r\n        if (!this._connectionPromise) {\r\n            this.state = ClientState.Stopped;\r\n            return Promise.resolve();\r\n        }\r\n        if (this.state === ClientState.Stopping && this._onStop) {\r\n            return this._onStop;\r\n        }\r\n        this.state = ClientState.Stopping;\r\n        this.cleanUp();\r\n        // unkook listeners\r\n        return this._onStop = this.resolveConnection().then(connection => {\r\n            return connection.shutdown().then(() => {\r\n                connection.exit();\r\n                connection.dispose();\r\n                this.state = ClientState.Stopped;\r\n                this._onStop = undefined;\r\n                this._connectionPromise = undefined;\r\n                this._resolvedConnection = undefined;\r\n            });\r\n        });\r\n    }\r\n    cleanUp(channel = true, diagnostics = true) {\r\n        if (this._listeners) {\r\n            this._listeners.forEach(listener => listener.dispose());\r\n            this._listeners = undefined;\r\n        }\r\n        if (this._providers) {\r\n            this._providers.forEach(provider => provider.dispose());\r\n            this._providers = undefined;\r\n        }\r\n        if (this._syncedDocuments) {\r\n            this._syncedDocuments.clear();\r\n        }\r\n        for (let handler of this._dynamicFeatures.values()) {\r\n            handler.dispose();\r\n        }\r\n        if (channel && this._outputChannel && this._disposeOutputChannel) {\r\n            this._outputChannel.dispose();\r\n            this._outputChannel = undefined;\r\n        }\r\n        if (diagnostics && this._diagnostics) {\r\n            this._diagnostics.dispose();\r\n            this._diagnostics = undefined;\r\n        }\r\n    }\r\n    notifyFileEvent(event) {\r\n        this._fileEvents.push(event);\r\n        this._fileEventDelayer.trigger(() => {\r\n            this.onReady().then(() => {\r\n                this.resolveConnection().then(connection => {\r\n                    if (this.isConnectionActive()) {\r\n                        connection.didChangeWatchedFiles({ changes: this._fileEvents });\r\n                    }\r\n                    this._fileEvents = [];\r\n                });\r\n            }, (error) => {\r\n                this.error(`Notify file events failed.`, error);\r\n            });\r\n        });\r\n    }\r\n    forceDocumentSync() {\r\n        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();\r\n    }\r\n    handleDiagnostics(params) {\r\n        if (!this._diagnostics) {\r\n            return;\r\n        }\r\n        let uri = this._p2c.asUri(params.uri);\r\n        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);\r\n        let middleware = this.clientOptions.middleware.handleDiagnostics;\r\n        if (middleware) {\r\n            middleware(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));\r\n        }\r\n        else {\r\n            this.setDiagnostics(uri, diagnostics);\r\n        }\r\n    }\r\n    setDiagnostics(uri, diagnostics) {\r\n        if (!this._diagnostics) {\r\n            return;\r\n        }\r\n        this._diagnostics.set(uri, diagnostics);\r\n    }\r\n    createConnection() {\r\n        let errorHandler = (error, message, count) => {\r\n            this.handleConnectionError(error, message, count);\r\n        };\r\n        let closeHandler = () => {\r\n            this.handleConnectionClosed();\r\n        };\r\n        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then((transports) => {\r\n            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);\r\n        });\r\n    }\r\n    handleConnectionClosed() {\r\n        // Check whether this is a normal shutdown in progress or the client stopped normally.\r\n        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {\r\n            return;\r\n        }\r\n        try {\r\n            if (this._resolvedConnection) {\r\n                this._resolvedConnection.dispose();\r\n            }\r\n        }\r\n        catch (error) {\r\n            // Disposing a connection could fail if error cases.\r\n        }\r\n        let action = CloseAction.DoNotRestart;\r\n        try {\r\n            action = this._clientOptions.errorHandler.closed();\r\n        }\r\n        catch (error) {\r\n            // Ignore errors coming from the error handler.\r\n        }\r\n        this._connectionPromise = undefined;\r\n        this._resolvedConnection = undefined;\r\n        if (action === CloseAction.DoNotRestart) {\r\n            this.error('Connection to server got closed. Server will not be restarted.');\r\n            this.state = ClientState.Stopped;\r\n            this.cleanUp(false, true);\r\n        }\r\n        else if (action === CloseAction.Restart) {\r\n            this.info('Connection to server got closed. Server will restart.');\r\n            this.cleanUp(false, false);\r\n            this.state = ClientState.Initial;\r\n            this.start();\r\n        }\r\n    }\r\n    handleConnectionError(error, message, count) {\r\n        let action = this._clientOptions.errorHandler.error(error, message, count);\r\n        if (action === ErrorAction.Shutdown) {\r\n            this.error('Connection to server is erroring. Shutting down server.');\r\n            this.stop();\r\n        }\r\n    }\r\n    hookConfigurationChanged(connection) {\r\n        vscode_1.workspace.onDidChangeConfiguration(() => {\r\n            this.refreshTrace(connection, true);\r\n        });\r\n    }\r\n    refreshTrace(connection, sendNotification = false) {\r\n        let config = vscode_1.workspace.getConfiguration(this._id);\r\n        let trace = vscode_languageserver_protocol_1.Trace.Off;\r\n        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;\r\n        if (config) {\r\n            const traceConfig = config.get('trace.server', 'off');\r\n            if (typeof traceConfig === 'string') {\r\n                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);\r\n            }\r\n            else {\r\n                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));\r\n                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));\r\n            }\r\n        }\r\n        this._trace = trace;\r\n        this._traceFormat = traceFormat;\r\n        connection.trace(this._trace, this._tracer, {\r\n            sendNotification,\r\n            traceFormat: this._traceFormat\r\n        });\r\n    }\r\n    hookFileEvents(_connection) {\r\n        let fileEvents = this._clientOptions.synchronize.fileEvents;\r\n        if (!fileEvents) {\r\n            return;\r\n        }\r\n        let watchers;\r\n        if (Is.array(fileEvents)) {\r\n            watchers = fileEvents;\r\n        }\r\n        else {\r\n            watchers = [fileEvents];\r\n        }\r\n        if (!watchers) {\r\n            return;\r\n        }\r\n        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);\r\n    }\r\n    registerFeatures(features) {\r\n        for (let feature of features) {\r\n            this.registerFeature(feature);\r\n        }\r\n    }\r\n    registerFeature(feature) {\r\n        this._features.push(feature);\r\n        if (DynamicFeature.is(feature)) {\r\n            let messages = feature.messages;\r\n            if (Array.isArray(messages)) {\r\n                for (let message of messages) {\r\n                    this._method2Message.set(message.method, message);\r\n                    this._dynamicFeatures.set(message.method, feature);\r\n                }\r\n            }\r\n            else {\r\n                this._method2Message.set(messages.method, messages);\r\n                this._dynamicFeatures.set(messages.method, feature);\r\n            }\r\n        }\r\n    }\r\n    registerBuiltinFeatures() {\r\n        this.registerFeature(new ConfigurationFeature(this));\r\n        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));\r\n        this.registerFeature(new DidChangeTextDocumentFeature(this));\r\n        this.registerFeature(new WillSaveFeature(this));\r\n        this.registerFeature(new WillSaveWaitUntilFeature(this));\r\n        this.registerFeature(new DidSaveTextDocumentFeature(this));\r\n        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));\r\n        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));\r\n        this.registerFeature(new CompletionItemFeature(this));\r\n        this.registerFeature(new HoverFeature(this));\r\n        this.registerFeature(new SignatureHelpFeature(this));\r\n        this.registerFeature(new DefinitionFeature(this));\r\n        this.registerFeature(new ReferencesFeature(this));\r\n        this.registerFeature(new DocumentHighlightFeature(this));\r\n        this.registerFeature(new DocumentSymbolFeature(this));\r\n        this.registerFeature(new WorkspaceSymbolFeature(this));\r\n        this.registerFeature(new CodeActionFeature(this));\r\n        this.registerFeature(new CodeLensFeature(this));\r\n        this.registerFeature(new DocumentFormattingFeature(this));\r\n        this.registerFeature(new DocumentRangeFormattingFeature(this));\r\n        this.registerFeature(new DocumentOnTypeFormattingFeature(this));\r\n        this.registerFeature(new RenameFeature(this));\r\n        this.registerFeature(new DocumentLinkFeature(this));\r\n        this.registerFeature(new ExecuteCommandFeature(this));\r\n    }\r\n    fillInitializeParams(params) {\r\n        for (let feature of this._features) {\r\n            if (Is.func(feature.fillInitializeParams)) {\r\n                feature.fillInitializeParams(params);\r\n            }\r\n        }\r\n    }\r\n    computeClientCapabilities() {\r\n        let result = {};\r\n        ensure(result, 'workspace').applyEdit = true;\r\n        let workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');\r\n        workspaceEdit.documentChanges = true;\r\n        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];\r\n        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;\r\n        ensure(ensure(result, 'textDocument'), 'publishDiagnostics').relatedInformation = true;\r\n        for (let feature of this._features) {\r\n            feature.fillClientCapabilities(result);\r\n        }\r\n        return result;\r\n    }\r\n    initializeFeatures(_connection) {\r\n        let documentSelector = this._clientOptions.documentSelector;\r\n        for (let feature of this._features) {\r\n            feature.initialize(this._capabilities, documentSelector);\r\n        }\r\n    }\r\n    handleRegistrationRequest(params) {\r\n        return new Promise((resolve, reject) => {\r\n            for (let registration of params.registrations) {\r\n                const feature = this._dynamicFeatures.get(registration.method);\r\n                if (!feature) {\r\n                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));\r\n                    return;\r\n                }\r\n                const options = registration.registerOptions || {};\r\n                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;\r\n                const data = {\r\n                    id: registration.id,\r\n                    registerOptions: options\r\n                };\r\n                feature.register(this._method2Message.get(registration.method), data);\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n    handleUnregistrationRequest(params) {\r\n        return new Promise((resolve, reject) => {\r\n            for (let unregistration of params.unregisterations) {\r\n                const feature = this._dynamicFeatures.get(unregistration.method);\r\n                if (!feature) {\r\n                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));\r\n                    return;\r\n                }\r\n                feature.unregister(unregistration.id);\r\n            }\r\n            ;\r\n            resolve();\r\n        });\r\n    }\r\n    handleApplyWorkspaceEdit(params) {\r\n        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.\r\n        // However doing it here adds some safety since the server can lag more behind then an extension.\r\n        let workspaceEdit = params.edit;\r\n        let openTextDocuments = new Map();\r\n        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));\r\n        let versionMismatch = false;\r\n        if (workspaceEdit.documentChanges) {\r\n            for (const change of workspaceEdit.documentChanges) {\r\n                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {\r\n                    let textDocument = openTextDocuments.get(change.textDocument.uri);\r\n                    if (textDocument && textDocument.version !== change.textDocument.version) {\r\n                        versionMismatch = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (versionMismatch) {\r\n            return Promise.resolve({ applied: false });\r\n        }\r\n        return vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => { return { applied: value }; });\r\n    }\r\n    ;\r\n    logFailedRequest(type, error) {\r\n        // If we get a request cancel don't log anything.\r\n        if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled) {\r\n            return;\r\n        }\r\n        this.error(`Request ${type.method} failed.`, error);\r\n    }\r\n}\r\nexports.BaseLanguageClient = BaseLanguageClient;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9jbGllbnQuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZWNsaWVudC9saWIvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGVfMSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xID0gcmVxdWlyZShcInZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbFwiKTtcclxuY29uc3QgYzJwID0gcmVxdWlyZShcIi4vY29kZUNvbnZlcnRlclwiKTtcclxuY29uc3QgcDJjID0gcmVxdWlyZShcIi4vcHJvdG9jb2xDb252ZXJ0ZXJcIik7XHJcbmNvbnN0IElzID0gcmVxdWlyZShcIi4vdXRpbHMvaXNcIik7XHJcbmNvbnN0IGFzeW5jXzEgPSByZXF1aXJlKFwiLi91dGlscy9hc3luY1wiKTtcclxuY29uc3QgVVVJRCA9IHJlcXVpcmUoXCIuL3V0aWxzL3V1aWRcIik7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2xcIikpO1xyXG5jbGFzcyBDb25zb2xlTG9nZ2VyIHtcclxuICAgIGVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgd2FybihtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgaW5mbyhtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgbG9nKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGVycm9ySGFuZGxlciwgY2xvc2VIYW5kbGVyKSB7XHJcbiAgICBsZXQgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoKTtcclxuICAgIGxldCBjb25uZWN0aW9uID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGxvZ2dlcik7XHJcbiAgICBjb25uZWN0aW9uLm9uRXJyb3IoKGRhdGEpID0+IHsgZXJyb3JIYW5kbGVyKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pOyB9KTtcclxuICAgIGNvbm5lY3Rpb24ub25DbG9zZShjbG9zZUhhbmRsZXIpO1xyXG4gICAgbGV0IHJlc3VsdCA9IHtcclxuICAgICAgICBsaXN0ZW46ICgpID0+IGNvbm5lY3Rpb24ubGlzdGVuKCksXHJcbiAgICAgICAgc2VuZFJlcXVlc3Q6ICh0eXBlLCAuLi5wYXJhbXMpID0+IGNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoSXMuc3RyaW5nKHR5cGUpID8gdHlwZSA6IHR5cGUubWV0aG9kLCAuLi5wYXJhbXMpLFxyXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IGNvbm5lY3Rpb24ub25SZXF1ZXN0KElzLnN0cmluZyh0eXBlKSA/IHR5cGUgOiB0eXBlLm1ldGhvZCwgaGFuZGxlciksXHJcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIHBhcmFtcykgPT4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKElzLnN0cmluZyh0eXBlKSA/IHR5cGUgOiB0eXBlLm1ldGhvZCwgcGFyYW1zKSxcclxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oSXMuc3RyaW5nKHR5cGUpID8gdHlwZSA6IHR5cGUubWV0aG9kLCBoYW5kbGVyKSxcclxuICAgICAgICB0cmFjZTogKHZhbHVlLCB0cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VHJhY2VPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0cmFjZUZvcm1hdDogdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVHJhY2VGb3JtYXQuVGV4dFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24udHJhY2UodmFsdWUsIHRyYWNlciwgZGVmYXVsdFRyYWNlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnRyYWNlKHZhbHVlLCB0cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnRyYWNlKHZhbHVlLCB0cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGluaXRpYWxpemU6IChwYXJhbXMpID0+IGNvbm5lY3Rpb24uc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSwgcGFyYW1zKSxcclxuICAgICAgICBzaHV0ZG93bjogKCkgPT4gY29ubmVjdGlvbi5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TaHV0ZG93blJlcXVlc3QudHlwZSwgdW5kZWZpbmVkKSxcclxuICAgICAgICBleGl0OiAoKSA9PiBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRXhpdE5vdGlmaWNhdGlvbi50eXBlKSxcclxuICAgICAgICBvbkxvZ01lc3NhZ2U6IChoYW5kbGVyKSA9PiBjb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSwgaGFuZGxlciksXHJcbiAgICAgICAgb25TaG93TWVzc2FnZTogKGhhbmRsZXIpID0+IGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSwgaGFuZGxlciksXHJcbiAgICAgICAgb25UZWxlbWV0cnk6IChoYW5kbGVyKSA9PiBjb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLnR5cGUsIGhhbmRsZXIpLFxyXG4gICAgICAgIGRpZENoYW5nZUNvbmZpZ3VyYXRpb246IChwYXJhbXMpID0+IGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGUsIHBhcmFtcyksXHJcbiAgICAgICAgZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzOiAocGFyYW1zKSA9PiBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLnR5cGUsIHBhcmFtcyksXHJcbiAgICAgICAgZGlkT3BlblRleHREb2N1bWVudDogKHBhcmFtcykgPT4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgcGFyYW1zKSxcclxuICAgICAgICBkaWRDaGFuZ2VUZXh0RG9jdW1lbnQ6IChwYXJhbXMpID0+IGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgcGFyYW1zKSxcclxuICAgICAgICBkaWRDbG9zZVRleHREb2N1bWVudDogKHBhcmFtcykgPT4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUsIHBhcmFtcyksXHJcbiAgICAgICAgZGlkU2F2ZVRleHREb2N1bWVudDogKHBhcmFtcykgPT4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgcGFyYW1zKSxcclxuICAgICAgICBvbkRpYWdub3N0aWNzOiAoaGFuZGxlcikgPT4gY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24udHlwZSwgaGFuZGxlciksXHJcbiAgICAgICAgZGlzcG9zZTogKCkgPT4gY29ubmVjdGlvbi5kaXNwb3NlKClcclxuICAgIH07XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgcHJvZHVjaW5nIGVycm9ycy5cclxuICovXHJcbnZhciBFcnJvckFjdGlvbjtcclxuKGZ1bmN0aW9uIChFcnJvckFjdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51ZSBydW5uaW5nIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIEVycm9yQWN0aW9uW0Vycm9yQWN0aW9uW1wiQ29udGludWVcIl0gPSAxXSA9IFwiQ29udGludWVcIjtcclxuICAgIC8qKlxyXG4gICAgICogU2h1dGRvd24gdGhlIHNlcnZlci5cclxuICAgICAqL1xyXG4gICAgRXJyb3JBY3Rpb25bRXJyb3JBY3Rpb25bXCJTaHV0ZG93blwiXSA9IDJdID0gXCJTaHV0ZG93blwiO1xyXG59KShFcnJvckFjdGlvbiA9IGV4cG9ydHMuRXJyb3JBY3Rpb24gfHwgKGV4cG9ydHMuRXJyb3JBY3Rpb24gPSB7fSkpO1xyXG4vKipcclxuICogQW4gYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCB3aGVuIHRoZSBjb25uZWN0aW9uIHRvIGEgc2VydmVyIGdvdCBjbG9zZWQuXHJcbiAqL1xyXG52YXIgQ2xvc2VBY3Rpb247XHJcbihmdW5jdGlvbiAoQ2xvc2VBY3Rpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogRG9uJ3QgcmVzdGFydCB0aGUgc2VydmVyLiBUaGUgY29ubmVjdGlvbiBzdGF5cyBjbG9zZWQuXHJcbiAgICAgKi9cclxuICAgIENsb3NlQWN0aW9uW0Nsb3NlQWN0aW9uW1wiRG9Ob3RSZXN0YXJ0XCJdID0gMV0gPSBcIkRvTm90UmVzdGFydFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN0YXJ0IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIENsb3NlQWN0aW9uW0Nsb3NlQWN0aW9uW1wiUmVzdGFydFwiXSA9IDJdID0gXCJSZXN0YXJ0XCI7XHJcbn0pKENsb3NlQWN0aW9uID0gZXhwb3J0cy5DbG9zZUFjdGlvbiB8fCAoZXhwb3J0cy5DbG9zZUFjdGlvbiA9IHt9KSk7XHJcbmNsYXNzIERlZmF1bHRFcnJvckhhbmRsZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0cyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoX2Vycm9yLCBfbWVzc2FnZSwgY291bnQpIHtcclxuICAgICAgICBpZiAoY291bnQgJiYgY291bnQgPD0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JBY3Rpb24uQ29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFcnJvckFjdGlvbi5TaHV0ZG93bjtcclxuICAgIH1cclxuICAgIGNsb3NlZCgpIHtcclxuICAgICAgICB0aGlzLnJlc3RhcnRzLnB1c2goRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdGFydHMubGVuZ3RoIDwgNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VBY3Rpb24uUmVzdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBkaWZmID0gdGhpcy5yZXN0YXJ0c1t0aGlzLnJlc3RhcnRzLmxlbmd0aCAtIDFdIC0gdGhpcy5yZXN0YXJ0c1swXTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gMyAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgdnNjb2RlXzEud2luZG93LnNob3dFcnJvck1lc3NhZ2UoYFRoZSAke3RoaXMubmFtZX0gc2VydmVyIGNyYXNoZWQgNSB0aW1lcyBpbiB0aGUgbGFzdCAzIG1pbnV0ZXMuIFRoZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcmVzdGFydGVkLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENsb3NlQWN0aW9uLkRvTm90UmVzdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDbG9zZUFjdGlvbi5SZXN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBSZXZlYWxPdXRwdXRDaGFubmVsT247XHJcbihmdW5jdGlvbiAoUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uKSB7XHJcbiAgICBSZXZlYWxPdXRwdXRDaGFubmVsT25bUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uW1wiSW5mb1wiXSA9IDFdID0gXCJJbmZvXCI7XHJcbiAgICBSZXZlYWxPdXRwdXRDaGFubmVsT25bUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uW1wiV2FyblwiXSA9IDJdID0gXCJXYXJuXCI7XHJcbiAgICBSZXZlYWxPdXRwdXRDaGFubmVsT25bUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcclxuICAgIFJldmVhbE91dHB1dENoYW5uZWxPbltSZXZlYWxPdXRwdXRDaGFubmVsT25bXCJOZXZlclwiXSA9IDRdID0gXCJOZXZlclwiO1xyXG59KShSZXZlYWxPdXRwdXRDaGFubmVsT24gPSBleHBvcnRzLlJldmVhbE91dHB1dENoYW5uZWxPbiB8fCAoZXhwb3J0cy5SZXZlYWxPdXRwdXRDaGFubmVsT24gPSB7fSkpO1xyXG52YXIgU3RhdGU7XHJcbihmdW5jdGlvbiAoU3RhdGUpIHtcclxuICAgIFN0YXRlW1N0YXRlW1wiU3RvcHBlZFwiXSA9IDFdID0gXCJTdG9wcGVkXCI7XHJcbiAgICBTdGF0ZVtTdGF0ZVtcIlN0YXJ0aW5nXCJdID0gM10gPSBcIlN0YXJ0aW5nXCI7XHJcbiAgICBTdGF0ZVtTdGF0ZVtcIlJ1bm5pbmdcIl0gPSAyXSA9IFwiUnVubmluZ1wiO1xyXG59KShTdGF0ZSA9IGV4cG9ydHMuU3RhdGUgfHwgKGV4cG9ydHMuU3RhdGUgPSB7fSkpO1xyXG52YXIgQ2xpZW50U3RhdGU7XHJcbihmdW5jdGlvbiAoQ2xpZW50U3RhdGUpIHtcclxuICAgIENsaWVudFN0YXRlW0NsaWVudFN0YXRlW1wiSW5pdGlhbFwiXSA9IDBdID0gXCJJbml0aWFsXCI7XHJcbiAgICBDbGllbnRTdGF0ZVtDbGllbnRTdGF0ZVtcIlN0YXJ0aW5nXCJdID0gMV0gPSBcIlN0YXJ0aW5nXCI7XHJcbiAgICBDbGllbnRTdGF0ZVtDbGllbnRTdGF0ZVtcIlN0YXJ0RmFpbGVkXCJdID0gMl0gPSBcIlN0YXJ0RmFpbGVkXCI7XHJcbiAgICBDbGllbnRTdGF0ZVtDbGllbnRTdGF0ZVtcIlJ1bm5pbmdcIl0gPSAzXSA9IFwiUnVubmluZ1wiO1xyXG4gICAgQ2xpZW50U3RhdGVbQ2xpZW50U3RhdGVbXCJTdG9wcGluZ1wiXSA9IDRdID0gXCJTdG9wcGluZ1wiO1xyXG4gICAgQ2xpZW50U3RhdGVbQ2xpZW50U3RhdGVbXCJTdG9wcGVkXCJdID0gNV0gPSBcIlN0b3BwZWRcIjtcclxufSkoQ2xpZW50U3RhdGUgfHwgKENsaWVudFN0YXRlID0ge30pKTtcclxuY29uc3QgU3VwcG9yZWRTeW1ib2xLaW5kcyA9IFtcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuRmlsZSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuTW9kdWxlLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5OYW1lc3BhY2UsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLlBhY2thZ2UsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLkNsYXNzLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5NZXRob2QsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLlByb3BlcnR5LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5GaWVsZCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuQ29uc3RydWN0b3IsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLkVudW0sXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLkludGVyZmFjZSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuRnVuY3Rpb24sXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLlZhcmlhYmxlLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5Db25zdGFudCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuU3RyaW5nLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5OdW1iZXIsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLkJvb2xlYW4sXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLkFycmF5LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5PYmplY3QsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLktleSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuTnVsbCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuRW51bU1lbWJlcixcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuU3RydWN0LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3ltYm9sS2luZC5FdmVudCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN5bWJvbEtpbmQuT3BlcmF0b3IsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXJcclxuXTtcclxuY29uc3QgU3VwcG9ydGVkQ29tcGxldGlvbkl0ZW1LaW5kcyA9IFtcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5UZXh0LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbixcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvcixcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5GaWVsZCxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5DbGFzcyxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuVmFsdWUsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuRW51bSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuQ29sb3IsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuRmlsZSxcclxuICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQsXHJcbiAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21wbGV0aW9uSXRlbUtpbmQuU3RydWN0LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50LFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yLFxyXG4gICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXJcclxuXTtcclxuZnVuY3Rpb24gZW5zdXJlKHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAodGFyZ2V0W2tleV0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbn1cclxudmFyIER5bmFtaWNGZWF0dXJlO1xyXG4oZnVuY3Rpb24gKER5bmFtaWNGZWF0dXJlKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnJlZ2lzdGVyKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS51bnJlZ2lzdGVyKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJiBjYW5kaWRhdGUubWVzc2FnZXMgIT09IHZvaWQgMDtcclxuICAgIH1cclxuICAgIER5bmFtaWNGZWF0dXJlLmlzID0gaXM7XHJcbn0pKER5bmFtaWNGZWF0dXJlIHx8IChEeW5hbWljRmVhdHVyZSA9IHt9KSk7XHJcbmNsYXNzIERvY3VtZW50Tm90aWZpYWN0aW9ucyB7XHJcbiAgICBjb25zdHJ1Y3RvcihfY2xpZW50LCBfZXZlbnQsIF90eXBlLCBfbWlkZGxld2FyZSwgX2NyZWF0ZVBhcmFtcywgX3NlbGVjdG9yRmlsdGVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gX2NsaWVudDtcclxuICAgICAgICB0aGlzLl9ldmVudCA9IF9ldmVudDtcclxuICAgICAgICB0aGlzLl90eXBlID0gX3R5cGU7XHJcbiAgICAgICAgdGhpcy5fbWlkZGxld2FyZSA9IF9taWRkbGV3YXJlO1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVBhcmFtcyA9IF9jcmVhdGVQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JGaWx0ZXIgPSBfc2VsZWN0b3JGaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRleHREb2N1bWVudEZpbHRlcihzZWxlY3RvcnMsIHRleHREb2N1bWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGlmICh2c2NvZGVfMS5sYW5ndWFnZXMubWF0Y2goc2VsZWN0b3IsIHRleHREb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyKF9tZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhLnJlZ2lzdGVyT3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lciA9IHRoaXMuX2V2ZW50KHRoaXMuY2FsbGJhY2ssIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZWxlY3RvcnMuc2V0KGRhdGEuaWQsIGRhdGEucmVnaXN0ZXJPcHRpb25zLmRvY3VtZW50U2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgY2FsbGJhY2soZGF0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2VsZWN0b3JGaWx0ZXIgfHwgdGhpcy5fc2VsZWN0b3JGaWx0ZXIodGhpcy5fc2VsZWN0b3JzLnZhbHVlcygpLCBkYXRhKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZShkYXRhLCAoZGF0YSkgPT4gdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odGhpcy5fdHlwZSwgdGhpcy5fY3JlYXRlUGFyYW1zKGRhdGEpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE5vdGlmaWNhdGlvbih0aGlzLl90eXBlLCB0aGlzLl9jcmVhdGVQYXJhbXMoZGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uU2VudChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBub3RpZmljYXRpb25TZW50KF9kYXRhKSB7XHJcbiAgICB9XHJcbiAgICB1bnJlZ2lzdGVyKGlkKSB7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdG9ycy5zaXplID09PSAwICYmIHRoaXMuX2xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLl9zZWxlY3RvcnMuY2xlYXIoKTtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGlkT3BlblRleHREb2N1bWVudEZlYXR1cmUgZXh0ZW5kcyBEb2N1bWVudE5vdGlmaWFjdGlvbnMge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBfc3luY2VkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfMS53b3Jrc3BhY2Uub25EaWRPcGVuVGV4dERvY3VtZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUsIGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmUuZGlkT3BlbiwgKHRleHREb2N1bWVudCkgPT4gY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNPcGVuVGV4dERvY3VtZW50UGFyYW1zKHRleHREb2N1bWVudCksIERvY3VtZW50Tm90aWZpYWN0aW9ucy50ZXh0RG9jdW1lbnRGaWx0ZXIpO1xyXG4gICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IF9zeW5jZWREb2N1bWVudHM7XHJcbiAgICB9XHJcbiAgICBnZXQgbWVzc2FnZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRpZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ3N5bmNocm9uaXphdGlvbicpLmR5bmFtaWNSZWdpc3RyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBsZXQgdGV4dERvY3VtZW50U3luY09wdGlvbnMgPSBjYXBhYmlsaXRpZXMucmVzb2x2ZWRUZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgICAgIGlmIChkb2N1bWVudFNlbGVjdG9yICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zLm9wZW5DbG9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHsgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksIHJlZ2lzdGVyT3B0aW9uczogeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXIobWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKG1lc3NhZ2UsIGRhdGEpO1xyXG4gICAgICAgIGlmICghZGF0YS5yZWdpc3Rlck9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkb2N1bWVudFNlbGVjdG9yID0gZGF0YS5yZWdpc3Rlck9wdGlvbnMuZG9jdW1lbnRTZWxlY3RvcjtcclxuICAgICAgICB2c2NvZGVfMS53b3Jrc3BhY2UudGV4dERvY3VtZW50cy5mb3JFYWNoKCh0ZXh0RG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHVyaSA9IHRleHREb2N1bWVudC51cmkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N5bmNlZERvY3VtZW50cy5oYXModXJpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2c2NvZGVfMS5sYW5ndWFnZXMubWF0Y2goZG9jdW1lbnRTZWxlY3RvciwgdGV4dERvY3VtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSB0aGlzLl9jbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpZE9wZW4gPSAodGV4dERvY3VtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odGhpcy5fdHlwZSwgdGhpcy5fY3JlYXRlUGFyYW1zKHRleHREb2N1bWVudCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLmRpZE9wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGV3YXJlLmRpZE9wZW4odGV4dERvY3VtZW50LCBkaWRPcGVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpZE9wZW4odGV4dERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cy5zZXQodXJpLCB0ZXh0RG9jdW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBub3RpZmljYXRpb25TZW50KHRleHREb2N1bWVudCkge1xyXG4gICAgICAgIHN1cGVyLm5vdGlmaWNhdGlvblNlbnQodGV4dERvY3VtZW50KTtcclxuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMuc2V0KHRleHREb2N1bWVudC51cmkudG9TdHJpbmcoKSwgdGV4dERvY3VtZW50KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEaWRDbG9zZVRleHREb2N1bWVudEZlYXR1cmUgZXh0ZW5kcyBEb2N1bWVudE5vdGlmaWFjdGlvbnMge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBfc3luY2VkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfMS53b3Jrc3BhY2Uub25EaWRDbG9zZVRleHREb2N1bWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZS5kaWRDbG9zZSwgKHRleHREb2N1bWVudCkgPT4gY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDbG9zZVRleHREb2N1bWVudFBhcmFtcyh0ZXh0RG9jdW1lbnQpLCBEb2N1bWVudE5vdGlmaWFjdGlvbnMudGV4dERvY3VtZW50RmlsdGVyKTtcclxuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMgPSBfc3luY2VkRG9jdW1lbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGllcywgJ3RleHREb2N1bWVudCcpLCAnc3luY2hyb25pemF0aW9uJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGxldCB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyA9IGNhcGFiaWxpdGllcy5yZXNvbHZlZFRleHREb2N1bWVudFN5bmM7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50U2VsZWN0b3IgJiYgdGV4dERvY3VtZW50U3luY09wdGlvbnMgJiYgdGV4dERvY3VtZW50U3luY09wdGlvbnMub3BlbkNsb3NlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywgeyBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSwgcmVnaXN0ZXJPcHRpb25zOiB7IGRvY3VtZW50U2VsZWN0b3I6IGRvY3VtZW50U2VsZWN0b3IgfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBub3RpZmljYXRpb25TZW50KHRleHREb2N1bWVudCkge1xyXG4gICAgICAgIHN1cGVyLm5vdGlmaWNhdGlvblNlbnQodGV4dERvY3VtZW50KTtcclxuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMuZGVsZXRlKHRleHREb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICB1bnJlZ2lzdGVyKGlkKSB7XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3JzLmdldChpZCk7XHJcbiAgICAgICAgLy8gVGhlIHN1cGVyIGNhbGwgcmVtb3ZlZCB0aGUgc2VsZWN0b3IgZnJvbSB0aGUgbWFwXHJcbiAgICAgICAgLy8gb2Ygc2VsZWN0b3JzLlxyXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoaWQpO1xyXG4gICAgICAgIGxldCBzZWxlY3RvcnMgPSB0aGlzLl9zZWxlY3RvcnMudmFsdWVzKCk7XHJcbiAgICAgICAgdGhpcy5fc3luY2VkRG9jdW1lbnRzLmZvckVhY2goKHRleHREb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodnNjb2RlXzEubGFuZ3VhZ2VzLm1hdGNoKHNlbGVjdG9yLCB0ZXh0RG9jdW1lbnQpICYmICF0aGlzLl9zZWxlY3RvckZpbHRlcihzZWxlY3RvcnMsIHRleHREb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtaWRkbGV3YXJlID0gdGhpcy5fY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICAgICAgICAgIGxldCBkaWRDbG9zZSA9ICh0ZXh0RG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE5vdGlmaWNhdGlvbih0aGlzLl90eXBlLCB0aGlzLl9jcmVhdGVQYXJhbXModGV4dERvY3VtZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3luY2VkRG9jdW1lbnRzLmRlbGV0ZSh0ZXh0RG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUuZGlkQ2xvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGV3YXJlLmRpZENsb3NlKHRleHREb2N1bWVudCwgZGlkQ2xvc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlkQ2xvc2UodGV4dERvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERpZENoYW5nZVRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlRGF0YSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9mb3JjaW5nRGVsaXZlcnkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBtZXNzYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGU7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0aWVzLCAndGV4dERvY3VtZW50JyksICdzeW5jaHJvbml6YXRpb24nKS5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgbGV0IHRleHREb2N1bWVudFN5bmNPcHRpb25zID0gY2FwYWJpbGl0aWVzLnJlc29sdmVkVGV4dERvY3VtZW50U3luYztcclxuICAgICAgICBpZiAoZG9jdW1lbnRTZWxlY3RvciAmJiB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyAmJiB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucy5jaGFuZ2UgIT09IHZvaWQgMCAmJiB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucy5jaGFuZ2UgIT09IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0sIHsgc3luY0tpbmQ6IHRleHREb2N1bWVudFN5bmNPcHRpb25zLmNoYW5nZSB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihfbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghZGF0YS5yZWdpc3Rlck9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSB2c2NvZGVfMS53b3Jrc3BhY2Uub25EaWRDaGFuZ2VUZXh0RG9jdW1lbnQodGhpcy5jYWxsYmFjaywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NoYW5nZURhdGEuc2V0KGRhdGEuaWQsIHtcclxuICAgICAgICAgICAgZG9jdW1lbnRTZWxlY3RvcjogZGF0YS5yZWdpc3Rlck9wdGlvbnMuZG9jdW1lbnRTZWxlY3RvcixcclxuICAgICAgICAgICAgc3luY0tpbmQ6IGRhdGEucmVnaXN0ZXJPcHRpb25zLnN5bmNLaW5kXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYWxsYmFjayhldmVudCkge1xyXG4gICAgICAgIC8vIFRleHQgZG9jdW1lbnQgY2hhbmdlcyBhcmUgc2VuZCBmb3IgZGlydHkgY2hhbmdlcyBhcyB3ZWxsLiBXZSBkb24ndFxyXG4gICAgICAgIC8vIGhhdmUgZGlydHkgLyB1bmRpcnR5IGV2ZW50cyBpbiB0aGUgTFNQIHNvIHdlIGlnbm9yZSBjb250ZW50IGNoYW5nZXNcclxuICAgICAgICAvLyB3aXRoIGxlbmd0aCB6ZXJvLlxyXG4gICAgICAgIGlmIChldmVudC5jb250ZW50Q2hhbmdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZURhdGEgb2YgdGhpcy5fY2hhbmdlRGF0YS52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodnNjb2RlXzEubGFuZ3VhZ2VzLm1hdGNoKGNoYW5nZURhdGEuZG9jdW1lbnRTZWxlY3RvciwgZXZlbnQuZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWlkZGxld2FyZSA9IHRoaXMuX2NsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlRGF0YS5zeW5jS2luZCA9PT0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDaGFuZ2VUZXh0RG9jdW1lbnRQYXJhbXMoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLmRpZENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRkbGV3YXJlLmRpZENoYW5nZShldmVudCwgKCkgPT4gdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUsIHBhcmFtcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlRGF0YS5zeW5jS2luZCA9PT0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZURlbGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VEZWxheWVyLnVyaSAhPT0gZXZlbnQuZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhpcyBmb3JjZSBkZWxpdmVyeSB0byB0cmFjayBib29sZWFuIHN0YXRlLiBPdGhlcndpc2Ugd2UgbWlnaHQgY2FsbCB0d28gdGltZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZURlbGl2ZXJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGVsYXllci51cmkgPSBldmVudC5kb2N1bWVudC51cmkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURlbGF5ZXIuZGVsYXllci50cmlnZ2VyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE5vdGlmaWNhdGlvbih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDaGFuZ2VUZXh0RG9jdW1lbnRQYXJhbXMoZXZlbnQuZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGVsYXllciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGV2ZW50LmRvY3VtZW50LnVyaS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ZXI6IG5ldyBhc3luY18xLkRlbGF5ZXIoMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURlbGF5ZXIuZGVsYXllci50cmlnZ2VyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZE5vdGlmaWNhdGlvbih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSwgdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDaGFuZ2VUZXh0RG9jdW1lbnRQYXJhbXMoZXZlbnQuZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUuZGlkQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZGRsZXdhcmUuZGlkQ2hhbmdlKGV2ZW50LCBkaWRDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkQ2hhbmdlKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1bnJlZ2lzdGVyKGlkKSB7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlRGF0YS5kZWxldGUoaWQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VEYXRhLnNpemUgPT09IDAgJiYgdGhpcy5fbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZURlbGF5ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZm9yY2luZ0RlbGl2ZXJ5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY2hhbmdlRGF0YS5jbGVhcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcmNlRGVsaXZlcnkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmNpbmdEZWxpdmVyeSB8fCAhdGhpcy5fY2hhbmdlRGVsYXllcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNpbmdEZWxpdmVyeSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURlbGF5ZXIuZGVsYXllci5mb3JjZURlbGl2ZXJ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JjaW5nRGVsaXZlcnkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgV2lsbFNhdmVGZWF0dXJlIGV4dGVuZHMgRG9jdW1lbnROb3RpZmlhY3Rpb25zIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlXzEud29ya3NwYWNlLm9uV2lsbFNhdmVUZXh0RG9jdW1lbnQsIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUsIGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmUud2lsbFNhdmUsICh3aWxsU2F2ZUV2ZW50KSA9PiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1dpbGxTYXZlVGV4dERvY3VtZW50UGFyYW1zKHdpbGxTYXZlRXZlbnQpLCAoc2VsZWN0b3JzLCB3aWxsU2F2ZUV2ZW50KSA9PiBEb2N1bWVudE5vdGlmaWFjdGlvbnMudGV4dERvY3VtZW50RmlsdGVyKHNlbGVjdG9ycywgd2lsbFNhdmVFdmVudC5kb2N1bWVudCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5XaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGllcywgJ3RleHREb2N1bWVudCcpLCAnc3luY2hyb25pemF0aW9uJyk7XHJcbiAgICAgICAgdmFsdWUud2lsbFNhdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBsZXQgdGV4dERvY3VtZW50U3luY09wdGlvbnMgPSBjYXBhYmlsaXRpZXMucmVzb2x2ZWRUZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgICAgIGlmIChkb2N1bWVudFNlbGVjdG9yICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zLndpbGxTYXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IHsgZG9jdW1lbnRTZWxlY3RvcjogZG9jdW1lbnRTZWxlY3RvciB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBXaWxsU2F2ZVdhaXRVbnRpbEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QudHlwZTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRpZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ3N5bmNocm9uaXphdGlvbicpO1xyXG4gICAgICAgIHZhbHVlLndpbGxTYXZlV2FpdFVudGlsID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgbGV0IHRleHREb2N1bWVudFN5bmNPcHRpb25zID0gY2FwYWJpbGl0aWVzLnJlc29sdmVkVGV4dERvY3VtZW50U3luYztcclxuICAgICAgICBpZiAoZG9jdW1lbnRTZWxlY3RvciAmJiB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyAmJiB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucy53aWxsU2F2ZVdhaXRVbnRpbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiB7IGRvY3VtZW50U2VsZWN0b3I6IGRvY3VtZW50U2VsZWN0b3IgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihfbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghZGF0YS5yZWdpc3Rlck9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSB2c2NvZGVfMS53b3Jrc3BhY2Uub25XaWxsU2F2ZVRleHREb2N1bWVudCh0aGlzLmNhbGxiYWNrLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzLnNldChkYXRhLmlkLCBkYXRhLnJlZ2lzdGVyT3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yKTtcclxuICAgIH1cclxuICAgIGNhbGxiYWNrKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKERvY3VtZW50Tm90aWZpYWN0aW9ucy50ZXh0RG9jdW1lbnRGaWx0ZXIodGhpcy5fc2VsZWN0b3JzLnZhbHVlcygpLCBldmVudC5kb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSB0aGlzLl9jbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgICAgICBsZXQgd2lsbFNhdmVXYWl0VW50aWwgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0LnR5cGUsIHRoaXMuX2NsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzV2lsbFNhdmVUZXh0RG9jdW1lbnRQYXJhbXMoZXZlbnQpKS50aGVuKChlZGl0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2RWRpdHMgPSB0aGlzLl9jbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1RleHRFZGl0cyhlZGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZFZGl0cyA9PT0gdm9pZCAwID8gW10gOiB2RWRpdHM7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKG1pZGRsZXdhcmUud2lsbFNhdmVXYWl0VW50aWxcclxuICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS53aWxsU2F2ZVdhaXRVbnRpbChldmVudCwgd2lsbFNhdmVXYWl0VW50aWwpXHJcbiAgICAgICAgICAgICAgICA6IHdpbGxTYXZlV2FpdFVudGlsKGV2ZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdW5yZWdpc3RlcihpZCkge1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdG9ycy5kZWxldGUoaWQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RvcnMuc2l6ZSA9PT0gMCAmJiB0aGlzLl9saXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIERpZFNhdmVUZXh0RG9jdW1lbnRGZWF0dXJlIGV4dGVuZHMgRG9jdW1lbnROb3RpZmlhY3Rpb25zIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlXzEud29ya3NwYWNlLm9uRGlkU2F2ZVRleHREb2N1bWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlLCBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlLmRpZFNhdmUsICh0ZXh0RG9jdW1lbnQpID0+IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzU2F2ZVRleHREb2N1bWVudFBhcmFtcyh0ZXh0RG9jdW1lbnQsIHRoaXMuX2luY2x1ZGVUZXh0KSwgRG9jdW1lbnROb3RpZmlhY3Rpb25zLnRleHREb2N1bWVudEZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBnZXQgbWVzc2FnZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRpZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ3N5bmNocm9uaXphdGlvbicpLmRpZFNhdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBsZXQgdGV4dERvY3VtZW50U3luY09wdGlvbnMgPSBjYXBhYmlsaXRpZXMucmVzb2x2ZWRUZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgICAgIGlmIChkb2N1bWVudFNlbGVjdG9yICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zICYmIHRleHREb2N1bWVudFN5bmNPcHRpb25zLnNhdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0sIHsgaW5jbHVkZVRleHQ6ICEhdGV4dERvY3VtZW50U3luY09wdGlvbnMuc2F2ZS5pbmNsdWRlVGV4dCB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihtZXRob2QsIGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9pbmNsdWRlVGV4dCA9ICEhZGF0YS5yZWdpc3Rlck9wdGlvbnMuaW5jbHVkZVRleHQ7XHJcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIobWV0aG9kLCBkYXRhKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBGaWxlU3lzdGVtV2F0Y2hlckZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCwgX25vdGlmeUZpbGVFdmVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5RmlsZUV2ZW50ID0gX25vdGlmeUZpbGVFdmVudDtcclxuICAgICAgICB0aGlzLl93YXRjaGVycyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldCBtZXNzYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLnR5cGU7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0aWVzLCAnd29ya3NwYWNlJyksICdkaWRDaGFuZ2VXYXRjaGVkRmlsZXMnKS5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoX2NhcGFiaWxpdGllcywgX2RvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyKF9tZXRob2QsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yZWdpc3Rlck9wdGlvbnMud2F0Y2hlcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpc3Bvc2VhYmxlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHdhdGNoZXIgb2YgZGF0YS5yZWdpc3Rlck9wdGlvbnMud2F0Y2hlcnMpIHtcclxuICAgICAgICAgICAgaWYgKCFJcy5zdHJpbmcod2F0Y2hlci5nbG9iUGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB3YXRjaENyZWF0ZSA9IHRydWUsIHdhdGNoQ2hhbmdlID0gdHJ1ZSwgd2F0Y2hEZWxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAod2F0Y2hlci5raW5kICE9PSB2b2lkIDAgJiYgd2F0Y2hlci5raW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaENyZWF0ZSA9ICh3YXRjaGVyLmtpbmQgJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5XYXRjaEtpbmQuQ3JlYXRlKSAhPT0gMDtcclxuICAgICAgICAgICAgICAgIHdhdGNoQ2hhbmdlID0gKHdhdGNoZXIua2luZCAmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLldhdGNoS2luZC5DaGFuZ2UpICE9IDA7XHJcbiAgICAgICAgICAgICAgICB3YXRjaERlbGV0ZSA9ICh3YXRjaGVyLmtpbmQgJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5XYXRjaEtpbmQuRGVsZXRlKSAhPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmaWxlU3lzdGVtV2F0Y2hlciA9IHZzY29kZV8xLndvcmtzcGFjZS5jcmVhdGVGaWxlU3lzdGVtV2F0Y2hlcih3YXRjaGVyLmdsb2JQYXR0ZXJuLCAhd2F0Y2hDcmVhdGUsICF3YXRjaENoYW5nZSwgIXdhdGNoRGVsZXRlKTtcclxuICAgICAgICAgICAgdGhpcy5ob29rTGlzdGVuZXJzKGZpbGVTeXN0ZW1XYXRjaGVyLCB3YXRjaENyZWF0ZSwgd2F0Y2hDaGFuZ2UsIHdhdGNoRGVsZXRlKTtcclxuICAgICAgICAgICAgZGlzcG9zZWFibGVzLnB1c2goZmlsZVN5c3RlbVdhdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93YXRjaGVycy5zZXQoZGF0YS5pZCwgZGlzcG9zZWFibGVzKTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyUmF3KGlkLCBmaWxlU3lzdGVtV2F0Y2hlcnMpIHtcclxuICAgICAgICBsZXQgZGlzcG9zZWFibGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZmlsZVN5c3RlbVdhdGNoZXIgb2YgZmlsZVN5c3RlbVdhdGNoZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9va0xpc3RlbmVycyhmaWxlU3lzdGVtV2F0Y2hlciwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgZGlzcG9zZWFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd2F0Y2hlcnMuc2V0KGlkLCBkaXNwb3NlYWJsZXMpO1xyXG4gICAgfVxyXG4gICAgaG9va0xpc3RlbmVycyhmaWxlU3lzdGVtV2F0Y2hlciwgd2F0Y2hDcmVhdGUsIHdhdGNoQ2hhbmdlLCB3YXRjaERlbGV0ZSwgbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgaWYgKHdhdGNoQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgIGZpbGVTeXN0ZW1XYXRjaGVyLm9uRGlkQ3JlYXRlKChyZXNvdXJjZSkgPT4gdGhpcy5fbm90aWZ5RmlsZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIHVyaTogdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNVcmkocmVzb3VyY2UpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZFxyXG4gICAgICAgICAgICB9KSwgbnVsbCwgbGlzdGVuZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdhdGNoQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGZpbGVTeXN0ZW1XYXRjaGVyLm9uRGlkQ2hhbmdlKChyZXNvdXJjZSkgPT4gdGhpcy5fbm90aWZ5RmlsZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIHVyaTogdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNVcmkocmVzb3VyY2UpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZFxyXG4gICAgICAgICAgICB9KSwgbnVsbCwgbGlzdGVuZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdhdGNoRGVsZXRlKSB7XHJcbiAgICAgICAgICAgIGZpbGVTeXN0ZW1XYXRjaGVyLm9uRGlkRGVsZXRlKChyZXNvdXJjZSkgPT4gdGhpcy5fbm90aWZ5RmlsZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIHVyaTogdGhpcy5fY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNVcmkocmVzb3VyY2UpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRmlsZUNoYW5nZVR5cGUuRGVsZXRlZFxyXG4gICAgICAgICAgICB9KSwgbnVsbCwgbGlzdGVuZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1bnJlZ2lzdGVyKGlkKSB7XHJcbiAgICAgICAgbGV0IGRpc3Bvc2VhYmxlcyA9IHRoaXMuX3dhdGNoZXJzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKGRpc3Bvc2VhYmxlcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkaXNwb3NhYmxlIG9mIGRpc3Bvc2VhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX3dhdGNoZXJzLmZvckVhY2goKGRpc3Bvc2VhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkaXNwb3NhYmxlIG9mIGRpc3Bvc2VhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl93YXRjaGVycy5jbGVhcigpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCwgX21lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBfY2xpZW50O1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBfbWVzc2FnZTtcclxuICAgICAgICB0aGlzLl9wcm92aWRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWVzc2FnZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihtZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kICE9PSB0aGlzLm1lc3NhZ2VzLm1ldGhvZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyIGNhbGxlZCBvbiB3cm9uZyBmZWF0dXJlLiBSZXF1ZXN0ZWQgJHttZXNzYWdlLm1ldGhvZH0gYnV0IHJlYWNoZWQgZmVhdHVyZSAke3RoaXMubWVzc2FnZXMubWV0aG9kfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRhdGEucmVnaXN0ZXJPcHRpb25zLmRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJvdmlkZXIgPSB0aGlzLnJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihkYXRhLnJlZ2lzdGVyT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVycy5zZXQoZGF0YS5pZCwgcHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVucmVnaXN0ZXIoaWQpIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlcnMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wcm92aWRlcnMuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRleHREb2N1bWVudEZlYXR1cmUgPSBUZXh0RG9jdW1lbnRGZWF0dXJlO1xyXG5jbGFzcyBXb3Jrc3BhY2VGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKF9jbGllbnQsIF9tZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gX2NsaWVudDtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlID0gX21lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXIobWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCAhPT0gdGhpcy5tZXNzYWdlcy5tZXRob2QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlciBjYWxsZWQgb24gd3JvbiBmZWF0dXJlLiBSZXF1ZXN0ZWQgJHttZXNzYWdlLm1ldGhvZH0gYnV0IHJlYWNoZWQgZmVhdHVyZSAke3RoaXMubWVzc2FnZXMubWV0aG9kfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJvdmlkZXIgPSB0aGlzLnJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihkYXRhLnJlZ2lzdGVyT3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVycy5zZXQoZGF0YS5pZCwgcHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVucmVnaXN0ZXIoaWQpIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlcnMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wcm92aWRlcnMuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb21wbGV0aW9uSXRlbUZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvblJlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgbGV0IGNvbXBsZXRpb24gPSBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGVzLCAndGV4dERvY3VtZW50JyksICdjb21wbGV0aW9uJyk7XHJcbiAgICAgICAgY29tcGxldGlvbi5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBjb21wbGV0aW9uLmNvbnRleHRTdXBwb3J0ID0gdHJ1ZTtcclxuICAgICAgICBjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtID0ge1xyXG4gICAgICAgICAgICBzbmlwcGV0U3VwcG9ydDogdHJ1ZSxcclxuICAgICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFt2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NYXJrdXBLaW5kLk1hcmtkb3duLCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NYXJrdXBLaW5kLlBsYWluVGV4dF0sXHJcbiAgICAgICAgICAgIGRlcHJlY2F0ZWRTdXBwb3J0OiB0cnVlLFxyXG4gICAgICAgICAgICBwcmVzZWxlY3RTdXBwb3J0OiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtS2luZCA9IHsgdmFsdWVTZXQ6IFN1cHBvcnRlZENvbXBsZXRpb25JdGVtS2luZHMgfTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyIHx8ICFkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3RvcjogZG9jdW1lbnRTZWxlY3RvciB9LCBjYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgdHJpZ2dlckNoYXJhY3RlcnMgPSBvcHRpb25zLnRyaWdnZXJDaGFyYWN0ZXJzIHx8IFtdO1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVDb21wbGV0aW9uSXRlbXMgPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCBjb250ZXh0LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25SZXF1ZXN0LnR5cGUsIGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzQ29tcGxldGlvblBhcmFtcyhkb2N1bWVudCwgcG9zaXRpb24sIGNvbnRleHQpLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc0NvbXBsZXRpb25SZXN1bHQsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29tcGxldGlvblJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlc29sdmVDb21wbGV0aW9uSXRlbSA9IChpdGVtLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc0NvbXBsZXRpb25JdGVtKGl0ZW0pLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc0NvbXBsZXRpb25JdGVtLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGl0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gdGhpcy5fY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyQ29tcGxldGlvbkl0ZW1Qcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZUNvbXBsZXRpb25JdGVtczogKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4sIGNvbnRleHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVDb21wbGV0aW9uSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlQ29tcGxldGlvbkl0ZW0oZG9jdW1lbnQsIHBvc2l0aW9uLCBjb250ZXh0LCB0b2tlbiwgcHJvdmlkZUNvbXBsZXRpb25JdGVtcylcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVDb21wbGV0aW9uSXRlbXMoZG9jdW1lbnQsIHBvc2l0aW9uLCBjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc29sdmVDb21wbGV0aW9uSXRlbTogb3B0aW9ucy5yZXNvbHZlUHJvdmlkZXJcclxuICAgICAgICAgICAgICAgID8gKGl0ZW0sIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucmVzb2x2ZUNvbXBsZXRpb25JdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5yZXNvbHZlQ29tcGxldGlvbkl0ZW0oaXRlbSwgdG9rZW4sIHJlc29sdmVDb21wbGV0aW9uSXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHZlQ29tcGxldGlvbkl0ZW0oaXRlbSwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICB9LCAuLi50cmlnZ2VyQ2hhcmFjdGVycyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgSG92ZXJGZWF0dXJlIGV4dGVuZHMgVGV4dERvY3VtZW50RmVhdHVyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcclxuICAgICAgICBzdXBlcihjbGllbnQsIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkhvdmVyUmVxdWVzdC50eXBlKTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0ZXMpIHtcclxuICAgICAgICBjb25zdCBob3ZlckNhcGFiaWxpdHkgPSAoZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnaG92ZXInKSk7XHJcbiAgICAgICAgaG92ZXJDYXBhYmlsaXR5LmR5bmFtaWNSZWdpc3RyYXRpb24gPSB0cnVlO1xyXG4gICAgICAgIGhvdmVyQ2FwYWJpbGl0eS5jb250ZW50Rm9ybWF0ID0gW3ZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLk1hcmt1cEtpbmQuTWFya2Rvd24sIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLk1hcmt1cEtpbmQuUGxhaW5UZXh0XTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlciB8fCAhZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCB7IGRvY3VtZW50U2VsZWN0b3I6IGRvY3VtZW50U2VsZWN0b3IgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZUhvdmVyID0gKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Ib3ZlclJlcXVlc3QudHlwZSwgY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhkb2N1bWVudCwgcG9zaXRpb24pLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc0hvdmVyLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkhvdmVyUmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVySG92ZXJQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZUhvdmVyOiAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucHJvdmlkZUhvdmVyXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVIb3Zlcihkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuLCBwcm92aWRlSG92ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTaWduYXR1cmVIZWxwRmVhdHVyZSBleHRlbmRzIFRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TaWduYXR1cmVIZWxwUmVxdWVzdC50eXBlKTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0ZXMpIHtcclxuICAgICAgICBsZXQgY29uZmlnID0gZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnc2lnbmF0dXJlSGVscCcpO1xyXG4gICAgICAgIGNvbmZpZy5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBjb25maWcuc2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7IGRvY3VtZW50YXRpb25Gb3JtYXQ6IFt2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NYXJrdXBLaW5kLk1hcmtkb3duLCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NYXJrdXBLaW5kLlBsYWluVGV4dF0gfTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMuc2lnbmF0dXJlSGVscFByb3ZpZGVyIHx8ICFkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3RvcjogZG9jdW1lbnRTZWxlY3RvciB9LCBjYXBhYmlsaXRpZXMuc2lnbmF0dXJlSGVscFByb3ZpZGVyKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlclNpZ25hdHVyZUhlbHAgPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlNpZ25hdHVyZUhlbHBSZXF1ZXN0LnR5cGUsIGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZG9jdW1lbnQsIHBvc2l0aW9uKSwgdG9rZW4pLnRoZW4oY2xpZW50LnByb3RvY29sMkNvZGVDb252ZXJ0ZXIuYXNTaWduYXR1cmVIZWxwLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlNpZ25hdHVyZUhlbHBSZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIGxldCB0cmlnZ2VyQ2hhcmFjdGVycyA9IG9wdGlvbnMudHJpZ2dlckNoYXJhY3RlcnMgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV8xLmxhbmd1YWdlcy5yZWdpc3RlclNpZ25hdHVyZUhlbHBQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZVNpZ25hdHVyZUhlbHA6IChkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlU2lnbmF0dXJlSGVscFxyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlU2lnbmF0dXJlSGVscChkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuLCBwcm92aWRlclNpZ25hdHVyZUhlbHApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlclNpZ25hdHVyZUhlbHAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAuLi50cmlnZ2VyQ2hhcmFjdGVycyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmaW5pdGlvbkZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGVmaW5pdGlvblJlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnZGVmaW5pdGlvbicpLmR5bmFtaWNSZWdpc3RyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcy5kZWZpbml0aW9uUHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlckxhbmd1YWdlUHJvdmlkZXIob3B0aW9ucykge1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVEZWZpbml0aW9uID0gKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EZWZpbml0aW9uUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGRvY3VtZW50LCBwb3NpdGlvbiksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRGVmaW5pdGlvblJlc3VsdCwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EZWZpbml0aW9uUmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyRGVmaW5pdGlvblByb3ZpZGVyKG9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICBwcm92aWRlRGVmaW5pdGlvbjogKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVEZWZpbml0aW9uKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4sIHByb3ZpZGVEZWZpbml0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZURlZmluaXRpb24oZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZWZlcmVuY2VzRmVhdHVyZSBleHRlbmRzIFRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5SZWZlcmVuY2VzUmVxdWVzdC50eXBlKTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0ZXMpIHtcclxuICAgICAgICBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGVzLCAndGV4dERvY3VtZW50JyksICdyZWZlcmVuY2VzJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLnJlZmVyZW5jZXNQcm92aWRlciB8fCAhZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCB7IGRvY3VtZW50U2VsZWN0b3I6IGRvY3VtZW50U2VsZWN0b3IgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZXJSZWZlcmVuY2VzID0gKGRvY3VtZW50LCBwb3NpdGlvbiwgb3B0aW9ucywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5SZWZlcmVuY2VzUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1JlZmVyZW5jZVBhcmFtcyhkb2N1bWVudCwgcG9zaXRpb24sIG9wdGlvbnMpLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1JlZmVyZW5jZXMsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVmZXJlbmNlc1JlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJSZWZlcmVuY2VQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZVJlZmVyZW5jZXM6IChkb2N1bWVudCwgcG9zaXRpb24sIG9wdGlvbnMsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlUmVmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlUmVmZXJlbmNlcyhkb2N1bWVudCwgcG9zaXRpb24sIG9wdGlvbnMsIHRva2VuLCBwcm92aWRlclJlZmVyZW5jZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlclJlZmVyZW5jZXMoZG9jdW1lbnQsIHBvc2l0aW9uLCBvcHRpb25zLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEb2N1bWVudEhpZ2hsaWdodEZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ2RvY3VtZW50SGlnaGxpZ2h0JykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlckxhbmd1YWdlUHJvdmlkZXIob3B0aW9ucykge1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVEb2N1bWVudEhpZ2hsaWdodHMgPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGRvY3VtZW50LCBwb3NpdGlvbiksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRG9jdW1lbnRIaWdobGlnaHRzLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWlkZGxld2FyZSA9IGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmU7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV8xLmxhbmd1YWdlcy5yZWdpc3RlckRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIob3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVEb2N1bWVudEhpZ2hsaWdodHM6IChkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRIaWdobGlnaHRzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVEb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbiwgcHJvdmlkZURvY3VtZW50SGlnaGxpZ2h0cylcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEb2N1bWVudFN5bWJvbEZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGxldCBzeW1ib2xDYXBhYmlsaXRpZXMgPSBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGVzLCAndGV4dERvY3VtZW50JyksICdkb2N1bWVudFN5bWJvbCcpO1xyXG4gICAgICAgIHN5bWJvbENhcGFiaWxpdGllcy5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBzeW1ib2xDYXBhYmlsaXRpZXMuc3ltYm9sS2luZCA9IHtcclxuICAgICAgICAgICAgdmFsdWVTZXQ6IFN1cHBvcmVkU3ltYm9sS2luZHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN5bWJvbENhcGFiaWxpdGllcy5oaWVyYXJjaGljYWxEb2N1bWVudFN5bWJvbFN1cHBvcnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyIHx8ICFkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3RvcjogZG9jdW1lbnRTZWxlY3RvciB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlRG9jdW1lbnRTeW1ib2xzID0gKGRvY3VtZW50LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50U3ltYm9sUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc0RvY3VtZW50U3ltYm9sUGFyYW1zKGRvY3VtZW50KSwgdG9rZW4pLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZGF0YVswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRTeW1ib2wuaXMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRG9jdW1lbnRTeW1ib2xzKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzU3ltYm9sSW5mb3JtYXRpb25zKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJEb2N1bWVudFN5bWJvbFByb3ZpZGVyKG9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICBwcm92aWRlRG9jdW1lbnRTeW1ib2xzOiAoZG9jdW1lbnQsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRTeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVEb2N1bWVudFN5bWJvbHMoZG9jdW1lbnQsIHRva2VuLCBwcm92aWRlRG9jdW1lbnRTeW1ib2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZURvY3VtZW50U3ltYm9scyhkb2N1bWVudCwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgV29ya3NwYWNlU3ltYm9sRmVhdHVyZSBleHRlbmRzIFdvcmtzcGFjZUZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGxldCBzeW1ib2xDYXBhYmlsaXRpZXMgPSBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGVzLCAnd29ya3NwYWNlJyksICdzeW1ib2wnKTtcclxuICAgICAgICBzeW1ib2xDYXBhYmlsaXRpZXMuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgc3ltYm9sQ2FwYWJpbGl0aWVzLnN5bWJvbEtpbmQgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlU2V0OiBTdXBwb3JlZFN5bWJvbEtpbmRzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMud29ya3NwYWNlU3ltYm9sUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlckxhbmd1YWdlUHJvdmlkZXIoX29wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlV29ya3NwYWNlU3ltYm9scyA9IChxdWVyeSwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0LnR5cGUsIHsgcXVlcnkgfSwgdG9rZW4pLnRoZW4oY2xpZW50LnByb3RvY29sMkNvZGVDb252ZXJ0ZXIuYXNTeW1ib2xJbmZvcm1hdGlvbnMsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuV29ya3NwYWNlU3ltYm9sUmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWlkZGxld2FyZSA9IGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmU7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV8xLmxhbmd1YWdlcy5yZWdpc3RlcldvcmtzcGFjZVN5bWJvbFByb3ZpZGVyKHtcclxuICAgICAgICAgICAgcHJvdmlkZVdvcmtzcGFjZVN5bWJvbHM6IChxdWVyeSwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVXb3Jrc3BhY2VTeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVXb3Jrc3BhY2VTeW1ib2xzKHF1ZXJ5LCB0b2tlbiwgcHJvdmlkZVdvcmtzcGFjZVN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlV29ya3NwYWNlU3ltYm9scyhxdWVyeSwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29kZUFjdGlvbkZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29kZUFjdGlvblJlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgY29uc3QgY2FwID0gZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnY29kZUFjdGlvbicpO1xyXG4gICAgICAgIGNhcC5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBjYXAuY29kZUFjdGlvbkxpdGVyYWxTdXBwb3J0ID0ge1xyXG4gICAgICAgICAgICBjb2RlQWN0aW9uS2luZDoge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVTZXQ6IFtcclxuICAgICAgICAgICAgICAgICAgICAnJyxcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlQWN0aW9uS2luZC5RdWlja0ZpeCxcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlQWN0aW9uS2luZC5SZWZhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlQWN0aW9uS2luZC5SZWZhY3RvckV4dHJhY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JSZXdyaXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvZGVBY3Rpb25LaW5kLlNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmNvZGVBY3Rpb25Qcm92aWRlciB8fCAhZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2RlQWN0aW9uS2luZHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCFJcy5ib29sZWFuKGNhcGFiaWxpdGllcy5jb2RlQWN0aW9uUHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvZGVBY3Rpb25LaW5kcyA9IGNhcGFiaWxpdGllcy5jb2RlQWN0aW9uUHJvdmlkZXIuY29kZUFjdGlvbktpbmRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yLCBjb2RlQWN0aW9uS2luZHMgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlQ29kZUFjdGlvbnMgPSAoZG9jdW1lbnQsIHJhbmdlLCBjb250ZXh0LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudElkZW50aWZpZXIoZG9jdW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzUmFuZ2UocmFuZ2UpLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dDogY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDb2RlQWN0aW9uQ29udGV4dChjb250ZXh0KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvZGVBY3Rpb25SZXF1ZXN0LnR5cGUsIHBhcmFtcywgdG9rZW4pLnRoZW4oKHZhbHVlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db21tYW5kLmlzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzQ29tbWFuZChpdGVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc0NvZGVBY3Rpb24oaXRlbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvZGVBY3Rpb25SZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyQ29kZUFjdGlvbnNQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZUNvZGVBY3Rpb25zOiAoZG9jdW1lbnQsIHJhbmdlLCBjb250ZXh0LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucHJvdmlkZUNvZGVBY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQsIHRva2VuLCBwcm92aWRlQ29kZUFjdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlQ29kZUFjdGlvbnMoZG9jdW1lbnQsIHJhbmdlLCBjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvcHRpb25zLmNvZGVBY3Rpb25LaW5kc1xyXG4gICAgICAgICAgICA/IHsgcHJvdmlkZWRDb2RlQWN0aW9uS2luZHM6IGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzQ29kZUFjdGlvbktpbmRzKG9wdGlvbnMuY29kZUFjdGlvbktpbmRzKSB9XHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb2RlTGVuc0ZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29kZUxlbnNSZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ2NvZGVMZW5zJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmNvZGVMZW5zUHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0sIGNhcGFiaWxpdGllcy5jb2RlTGVuc1Byb3ZpZGVyKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlQ29kZUxlbnNlcyA9IChkb2N1bWVudCwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlTGVuc1JlcXVlc3QudHlwZSwgY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNDb2RlTGVuc1BhcmFtcyhkb2N1bWVudCksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzQ29kZUxlbnNlcywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlTGVuc1JlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlc29sdmVDb2RlTGVucyA9IChjb2RlTGVucywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUsIGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzQ29kZUxlbnMoY29kZUxlbnMpLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc0NvZGVMZW5zLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVMZW5zO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyQ29kZUxlbnNQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZUNvZGVMZW5zZXM6IChkb2N1bWVudCwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVDb2RlTGVuc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVDb2RlTGVuc2VzKGRvY3VtZW50LCB0b2tlbiwgcHJvdmlkZUNvZGVMZW5zZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlQ29kZUxlbnNlcyhkb2N1bWVudCwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNvbHZlQ29kZUxlbnM6IChvcHRpb25zLnJlc29sdmVQcm92aWRlcilcclxuICAgICAgICAgICAgICAgID8gKGNvZGVMZW5zLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnJlc29sdmVDb2RlTGVuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUucmVzb2x2ZUNvZGVMZW5zKGNvZGVMZW5zLCB0b2tlbiwgcmVzb2x2ZUNvZGVMZW5zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmVDb2RlTGVucyhjb2RlTGVucywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEb2N1bWVudEZvcm1hdHRpbmdGZWF0dXJlIGV4dGVuZHMgVGV4dERvY3VtZW50RmVhdHVyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcclxuICAgICAgICBzdXBlcihjbGllbnQsIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnZm9ybWF0dGluZycpLmR5bmFtaWNSZWdpc3RyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciB8fCAhZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCB7IGRvY3VtZW50U2VsZWN0b3I6IGRvY3VtZW50U2VsZWN0b3IgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZURvY3VtZW50Rm9ybWF0dGluZ0VkaXRzID0gKGRvY3VtZW50LCBvcHRpb25zLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudElkZW50aWZpZXIoZG9jdW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSwgcGFyYW1zLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1RleHRFZGl0cywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKG9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICBwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHM6IChkb2N1bWVudCwgb3B0aW9ucywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVEb2N1bWVudEZvcm1hdHRpbmdFZGl0c1xyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMoZG9jdW1lbnQsIG9wdGlvbnMsIHRva2VuLCBwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMoZG9jdW1lbnQsIG9wdGlvbnMsIHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRmVhdHVyZSBleHRlbmRzIFRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAncmFuZ2VGb3JtYXR0aW5nJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlckxhbmd1YWdlUHJvdmlkZXIob3B0aW9ucykge1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRzID0gKGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKGRvY3VtZW50KSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1JhbmdlKHJhbmdlKSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSwgcGFyYW1zLCB0b2tlbikudGhlbihjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1RleHRFZGl0cywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdHM6IChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0c1xyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMsIHRva2VuLCBwcm92aWRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0cylcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRzKGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucywgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nRmVhdHVyZSBleHRlbmRzIFRleHREb2N1bWVudEZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XHJcbiAgICAgICAgc3VwZXIoY2xpZW50LCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ29uVHlwZUZvcm1hdHRpbmcnKS5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMuZG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0sIGNhcGFiaWxpdGllcy5kb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQcm92aWRlcilcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgbW9yZVRyaWdnZXJDaGFyYWN0ZXIgPSBvcHRpb25zLm1vcmVUcmlnZ2VyQ2hhcmFjdGVyIHx8IFtdO1xyXG4gICAgICAgIGxldCBwcm92aWRlT25UeXBlRm9ybWF0dGluZ0VkaXRzID0gKGRvY3VtZW50LCBwb3NpdGlvbiwgY2gsIG9wdGlvbnMsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzVGV4dERvY3VtZW50SWRlbnRpZmllcihkb2N1bWVudCksXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNQb3NpdGlvbihwb3NpdGlvbiksXHJcbiAgICAgICAgICAgICAgICBjaDogY2gsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc0Zvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC50eXBlLCBwYXJhbXMsIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzVGV4dEVkaXRzLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJPblR5cGVGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKG9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICBwcm92aWRlT25UeXBlRm9ybWF0dGluZ0VkaXRzOiAoZG9jdW1lbnQsIHBvc2l0aW9uLCBjaCwgb3B0aW9ucywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVPblR5cGVGb3JtYXR0aW5nRWRpdHNcclxuICAgICAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUucHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgcG9zaXRpb24sIGNoLCBvcHRpb25zLCB0b2tlbiwgcHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0cylcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVPblR5cGVGb3JtYXR0aW5nRWRpdHMoZG9jdW1lbnQsIHBvc2l0aW9uLCBjaCwgb3B0aW9ucywgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgb3B0aW9ucy5maXJzdFRyaWdnZXJDaGFyYWN0ZXIsIC4uLm1vcmVUcmlnZ2VyQ2hhcmFjdGVyKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZW5hbWVGZWF0dXJlIGV4dGVuZHMgVGV4dERvY3VtZW50RmVhdHVyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcclxuICAgICAgICBzdXBlcihjbGllbnQsIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlJlbmFtZVJlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgbGV0IHJlbmFtZSA9IGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ3JlbmFtZScpO1xyXG4gICAgICAgIHJlbmFtZS5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICByZW5hbWUucHJlcGFyZVN1cHBvcnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcy5yZW5hbWVQcm92aWRlciB8fCAhZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pO1xyXG4gICAgICAgIGlmIChJcy5ib29sZWFuKGNhcGFiaWxpdGllcy5yZW5hbWVQcm92aWRlcikpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wcmVwYXJlUHJvdmlkZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucHJlcGFyZVByb3ZpZGVyID0gY2FwYWJpbGl0aWVzLnJlbmFtZVByb3ZpZGVyLnByZXBhcmVQcm92aWRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZVJlbmFtZUVkaXRzID0gKGRvY3VtZW50LCBwb3NpdGlvbiwgbmV3TmFtZSwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKGRvY3VtZW50KSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1Bvc2l0aW9uKHBvc2l0aW9uKSxcclxuICAgICAgICAgICAgICAgIG5ld05hbWU6IG5ld05hbWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5SZW5hbWVSZXF1ZXN0LnR5cGUsIHBhcmFtcywgdG9rZW4pLnRoZW4oY2xpZW50LnByb3RvY29sMkNvZGVDb252ZXJ0ZXIuYXNXb3Jrc3BhY2VFZGl0LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlJlbmFtZVJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHByZXBhcmVSZW5hbWUgPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudElkZW50aWZpZXIoZG9jdW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzUG9zaXRpb24ocG9zaXRpb24pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlByZXBhcmVSZW5hbWVSZXF1ZXN0LnR5cGUsIHBhcmFtcywgdG9rZW4pLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlJhbmdlLmlzKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LnByb3RvY29sMkNvZGVDb252ZXJ0ZXIuYXNSYW5nZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0ICYmIHJlc3VsdC5yYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1JhbmdlKHJlc3VsdC5yYW5nZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiByZXN1bHQucGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJSZW5hbWVQcm92aWRlcihvcHRpb25zLmRvY3VtZW50U2VsZWN0b3IsIHtcclxuICAgICAgICAgICAgcHJvdmlkZVJlbmFtZUVkaXRzOiAoZG9jdW1lbnQsIHBvc2l0aW9uLCBuZXdOYW1lLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucHJvdmlkZVJlbmFtZUVkaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVSZW5hbWVFZGl0cyhkb2N1bWVudCwgcG9zaXRpb24sIG5ld05hbWUsIHRva2VuLCBwcm92aWRlUmVuYW1lRWRpdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlUmVuYW1lRWRpdHMoZG9jdW1lbnQsIHBvc2l0aW9uLCBuZXdOYW1lLCB0b2tlbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByZXBhcmVSZW5hbWU6IG9wdGlvbnMucHJlcGFyZVByb3ZpZGVyXHJcbiAgICAgICAgICAgICAgICA/IChkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucHJlcGFyZVJlbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUucHJlcGFyZVJlbmFtZShkb2N1bWVudCwgcG9zaXRpb24sIHRva2VuLCBwcmVwYXJlUmVuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZXBhcmVSZW5hbWUoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERvY3VtZW50TGlua0ZlYXR1cmUgZXh0ZW5kcyBUZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRMaW5rUmVxdWVzdC50eXBlKTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0ZXMpIHtcclxuICAgICAgICBlbnN1cmUoZW5zdXJlKGNhcGFiaWxpdGVzLCAndGV4dERvY3VtZW50JyksICdkb2N1bWVudExpbmsnKS5keW5hbWljUmVnaXN0cmF0aW9uID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFjYXBhYmlsaXRpZXMuZG9jdW1lbnRMaW5rUHJvdmlkZXIgfHwgIWRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0sIGNhcGFiaWxpdGllcy5kb2N1bWVudExpbmtQcm92aWRlcilcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZURvY3VtZW50TGlua3MgPSAoZG9jdW1lbnQsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRMaW5rUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc0RvY3VtZW50TGlua1BhcmFtcyhkb2N1bWVudCksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRG9jdW1lbnRMaW5rcywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Eb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZXNvbHZlRG9jdW1lbnRMaW5rID0gKGxpbmssIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QudHlwZSwgY2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNEb2N1bWVudExpbmsobGluayksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRG9jdW1lbnRMaW5rLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5sb2dGYWlsZWRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRMaW5rUHJvdmlkZXIob3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVEb2N1bWVudExpbmtzOiAoZG9jdW1lbnQsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRMaW5rc1xyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRMaW5rcyhkb2N1bWVudCwgdG9rZW4sIHByb3ZpZGVEb2N1bWVudExpbmtzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZURvY3VtZW50TGlua3MoZG9jdW1lbnQsIHRva2VuKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzb2x2ZURvY3VtZW50TGluazogb3B0aW9ucy5yZXNvbHZlUHJvdmlkZXJcclxuICAgICAgICAgICAgICAgID8gKGxpbmssIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucmVzb2x2ZURvY3VtZW50TGlua1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUucmVzb2x2ZURvY3VtZW50TGluayhsaW5rLCB0b2tlbiwgcmVzb2x2ZURvY3VtZW50TGluaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHZlRG9jdW1lbnRMaW5rKGxpbmssIHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29uZmlndXJhdGlvbkZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGU7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGllcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0aWVzLCAnd29ya3NwYWNlJyksICdkaWRDaGFuZ2VDb25maWd1cmF0aW9uJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGxldCBzZWN0aW9uID0gdGhpcy5fY2xpZW50LmNsaWVudE9wdGlvbnMuc3luY2hyb25pemUuY29uZmlndXJhdGlvblNlY3Rpb247XHJcbiAgICAgICAgaWYgKHNlY3Rpb24gIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgICAgIGlkOiBVVUlELmdlbmVyYXRlVXVpZCgpLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihfbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIGxldCBkaXNwb3NhYmxlID0gdnNjb2RlXzEud29ya3NwYWNlLm9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbigoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oZGF0YS5yZWdpc3Rlck9wdGlvbnMuc2VjdGlvbiwgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQoZGF0YS5pZCwgZGlzcG9zYWJsZSk7XHJcbiAgICAgICAgaWYgKGRhdGEucmVnaXN0ZXJPcHRpb25zLnNlY3Rpb24gIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbihkYXRhLnJlZ2lzdGVyT3B0aW9ucy5zZWN0aW9uLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVucmVnaXN0ZXIoaWQpIHtcclxuICAgICAgICBsZXQgZGlzcG9zYWJsZSA9IHRoaXMuX2xpc3RlbmVycy5nZXQoaWQpO1xyXG4gICAgICAgIGlmIChkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGZvciAobGV0IGRpc3Bvc2FibGUgb2YgdGhpcy5fbGlzdGVuZXJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIG9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uU2VjdGlvbiwgZXZlbnQpIHtcclxuICAgICAgICBsZXQgc2VjdGlvbnM7XHJcbiAgICAgICAgaWYgKElzLnN0cmluZyhjb25maWd1cmF0aW9uU2VjdGlvbikpIHtcclxuICAgICAgICAgICAgc2VjdGlvbnMgPSBbY29uZmlndXJhdGlvblNlY3Rpb25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VjdGlvbnMgPSBjb25maWd1cmF0aW9uU2VjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlY3Rpb25zICE9PSB2b2lkIDAgJiYgZXZlbnQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBsZXQgYWZmZWN0ZWQgPSBzZWN0aW9ucy5zb21lKChzZWN0aW9uKSA9PiBldmVudC5hZmZlY3RzQ29uZmlndXJhdGlvbihzZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIGlmICghYWZmZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbiA9IChzZWN0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VjdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlLCB7IHNldHRpbmdzOiBudWxsIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24udHlwZSwgeyBzZXR0aW5nczogdGhpcy5leHRyYWN0U2V0dGluZ3NJbmZvcm1hdGlvbihzZWN0aW9ucykgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWlkZGxld2FyZSA9IHRoaXMuZ2V0TWlkZGxld2FyZSgpO1xyXG4gICAgICAgIG1pZGRsZXdhcmVcclxuICAgICAgICAgICAgPyBtaWRkbGV3YXJlKHNlY3Rpb25zLCBkaWRDaGFuZ2VDb25maWd1cmF0aW9uKVxyXG4gICAgICAgICAgICA6IGRpZENoYW5nZUNvbmZpZ3VyYXRpb24oc2VjdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZXh0cmFjdFNldHRpbmdzSW5mb3JtYXRpb24oa2V5cykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGVuc3VyZVBhdGgoY29uZmlnLCBwYXRoKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY29uZmlnO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gY3VycmVudFtwYXRoW2ldXTtcclxuICAgICAgICAgICAgICAgIGlmICghb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhdGhbaV1dID0gb2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc291cmNlID0gdGhpcy5fY2xpZW50LmNsaWVudE9wdGlvbnMud29ya3NwYWNlRm9sZGVyXHJcbiAgICAgICAgICAgID8gdGhpcy5fY2xpZW50LmNsaWVudE9wdGlvbnMud29ya3NwYWNlRm9sZGVyLnVyaVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGtleS5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnID0gdnNjb2RlXzEud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24oa2V5LnN1YnN0cigwLCBpbmRleCksIHJlc291cmNlKS5nZXQoa2V5LnN1YnN0cihpbmRleCArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHZzY29kZV8xLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKGtleSwgcmVzb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwYXRoID0ga2V5c1tpXS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAgICAgZW5zdXJlUGF0aChyZXN1bHQsIHBhdGgpW3BhdGhbcGF0aC5sZW5ndGggLSAxXV0gPSBjb25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldE1pZGRsZXdhcmUoKSB7XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSB0aGlzLl9jbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIGlmIChtaWRkbGV3YXJlLndvcmtzcGFjZSAmJiBtaWRkbGV3YXJlLndvcmtzcGFjZS5kaWRDaGFuZ2VDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLndvcmtzcGFjZS5kaWRDaGFuZ2VDb25maWd1cmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXhlY3V0ZUNvbW1hbmRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKF9jbGllbnQpIHtcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBfY2xpZW50O1xyXG4gICAgICAgIHRoaXMuX2NvbW1hbmRzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5FeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRpZXMsICd3b3Jrc3BhY2UnKSwgJ2V4ZWN1dGVDb21tYW5kJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcykge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmV4ZWN1dGVDb21tYW5kUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgaWQ6IFVVSUQuZ2VuZXJhdGVVdWlkKCksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgY2FwYWJpbGl0aWVzLmV4ZWN1dGVDb21tYW5kUHJvdmlkZXIpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlcihfbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgaWYgKGRhdGEucmVnaXN0ZXJPcHRpb25zLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIGxldCBkaXNwb3NlYWJsZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb21tYW5kIG9mIGRhdGEucmVnaXN0ZXJPcHRpb25zLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlYWJsZXMucHVzaCh2c2NvZGVfMS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0LnR5cGUsIHBhcmFtcykudGhlbih1bmRlZmluZWQsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5FeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmRzLnNldChkYXRhLmlkLCBkaXNwb3NlYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVucmVnaXN0ZXIoaWQpIHtcclxuICAgICAgICBsZXQgZGlzcG9zZWFibGVzID0gdGhpcy5fY29tbWFuZHMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoZGlzcG9zZWFibGVzKSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2VhYmxlcy5mb3JFYWNoKGRpc3Bvc2FibGUgPT4gZGlzcG9zYWJsZS5kaXNwb3NlKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fY29tbWFuZHMuZm9yRWFjaCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChkaXNwb3NhYmxlID0+IGRpc3Bvc2FibGUuZGlzcG9zZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9jb21tYW5kcy5jbGVhcigpO1xyXG4gICAgfVxyXG59XHJcbnZhciBNZXNzYWdlVHJhbnNwb3J0cztcclxuKGZ1bmN0aW9uIChNZXNzYWdlVHJhbnNwb3J0cykge1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NZXNzYWdlUmVhZGVyLmlzKHZhbHVlLnJlYWRlcikgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuTWVzc2FnZVdyaXRlci5pcyh2YWx1ZS53cml0ZXIpO1xyXG4gICAgfVxyXG4gICAgTWVzc2FnZVRyYW5zcG9ydHMuaXMgPSBpcztcclxufSkoTWVzc2FnZVRyYW5zcG9ydHMgPSBleHBvcnRzLk1lc3NhZ2VUcmFuc3BvcnRzIHx8IChleHBvcnRzLk1lc3NhZ2VUcmFuc3BvcnRzID0ge30pKTtcclxuY2xhc3MgT25SZWFkeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfcmVzb2x2ZSwgX3JlamVjdCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBfcmVzb2x2ZTtcclxuICAgICAgICB0aGlzLl9yZWplY3QgPSBfcmVqZWN0O1xyXG4gICAgICAgIHRoaXMuX3VzZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBpc1VzZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZWQ7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlKCkge1xyXG4gICAgICAgIHRoaXMuX3VzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHJlamVjdChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX3VzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQmFzZUxhbmd1YWdlQ2xpZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGlkLCBuYW1lLCBjbGllbnRPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhY2VGb3JtYXQgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UcmFjZUZvcm1hdC5UZXh0O1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kMk1lc3NhZ2UgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0ZlYXR1cmVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgY2xpZW50T3B0aW9ucyA9IGNsaWVudE9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdGhpcy5fY2xpZW50T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZG9jdW1lbnRTZWxlY3RvcjogY2xpZW50T3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yIHx8IFtdLFxyXG4gICAgICAgICAgICBzeW5jaHJvbml6ZTogY2xpZW50T3B0aW9ucy5zeW5jaHJvbml6ZSB8fCB7fSxcclxuICAgICAgICAgICAgZGlhZ25vc3RpY0NvbGxlY3Rpb25OYW1lOiBjbGllbnRPcHRpb25zLmRpYWdub3N0aWNDb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbE5hbWU6IGNsaWVudE9wdGlvbnMub3V0cHV0Q2hhbm5lbE5hbWUgfHwgdGhpcy5fbmFtZSxcclxuICAgICAgICAgICAgcmV2ZWFsT3V0cHV0Q2hhbm5lbE9uOiBjbGllbnRPcHRpb25zLnJldmVhbE91dHB1dENoYW5uZWxPbiB8fCBSZXZlYWxPdXRwdXRDaGFubmVsT24uRXJyb3IsXHJcbiAgICAgICAgICAgIHN0ZGlvRW5jb2Rpbmc6IGNsaWVudE9wdGlvbnMuc3RkaW9FbmNvZGluZyB8fCAndXRmOCcsXHJcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT3B0aW9uczogY2xpZW50T3B0aW9ucy5pbml0aWFsaXphdGlvbk9wdGlvbnMsXHJcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uRmFpbGVkSGFuZGxlcjogY2xpZW50T3B0aW9ucy5pbml0aWFsaXphdGlvbkZhaWxlZEhhbmRsZXIsXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogY2xpZW50T3B0aW9ucy5lcnJvckhhbmRsZXIgfHwgbmV3IERlZmF1bHRFcnJvckhhbmRsZXIodGhpcy5fbmFtZSksXHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmU6IGNsaWVudE9wdGlvbnMubWlkZGxld2FyZSB8fCB7fSxcclxuICAgICAgICAgICAgdXJpQ29udmVydGVyczogY2xpZW50T3B0aW9ucy51cmlDb252ZXJ0ZXJzLFxyXG4gICAgICAgICAgICB3b3Jrc3BhY2VGb2xkZXI6IGNsaWVudE9wdGlvbnMud29ya3NwYWNlRm9sZGVyXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9jbGllbnRPcHRpb25zLnN5bmNocm9uaXplID0gdGhpcy5fY2xpZW50T3B0aW9ucy5zeW5jaHJvbml6ZSB8fCB7fTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50U3RhdGUuSW5pdGlhbDtcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlZENvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5vdXRwdXRDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dENoYW5uZWwgPSBjbGllbnRPcHRpb25zLm91dHB1dENoYW5uZWw7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VPdXRwdXRDaGFubmVsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRDaGFubmVsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlT3V0cHV0Q2hhbm5lbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wcm92aWRlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZmlsZUV2ZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2ZpbGVFdmVudERlbGF5ZXIgPSBuZXcgYXN5bmNfMS5EZWxheWVyKDI1MCk7XHJcbiAgICAgICAgdGhpcy5fb25SZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fb25SZWFkeUNhbGxiYWNrcyA9IG5ldyBPblJlYWR5KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fb25TdG9wID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3RlbGVtZXRyeUVtaXR0ZXIgPSBuZXcgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlRW1pdHRlciA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5FbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdHJhY2VyID0ge1xyXG4gICAgICAgICAgICBsb2c6IChtZXNzYWdlT3JEYXRhT2JqZWN0LCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKG1lc3NhZ2VPckRhdGFPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dUcmFjZShtZXNzYWdlT3JEYXRhT2JqZWN0LCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nT2JqZWN0VHJhY2UobWVzc2FnZU9yRGF0YU9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9jMnAgPSBjMnAuY3JlYXRlQ29udmVydGVyKGNsaWVudE9wdGlvbnMudXJpQ29udmVydGVycyA/IGNsaWVudE9wdGlvbnMudXJpQ29udmVydGVycy5jb2RlMlByb3RvY29sIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLl9wMmMgPSBwMmMuY3JlYXRlQ29udmVydGVyKGNsaWVudE9wdGlvbnMudXJpQ29udmVydGVycyA/IGNsaWVudE9wdGlvbnMudXJpQ29udmVydGVycy5wcm90b2NvbDJDb2RlIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckJ1aWx0aW5GZWF0dXJlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICAgIH1cclxuICAgIHNldCBzdGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBvbGRTdGF0ZSA9IHRoaXMuZ2V0UHVibGljU3RhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHRoaXMuZ2V0UHVibGljU3RhdGUoKTtcclxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IG9sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlRW1pdHRlci5maXJlKHsgb2xkU3RhdGUsIG5ld1N0YXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFB1YmxpY1N0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDbGllbnRTdGF0ZS5SdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdGF0ZS5SdW5uaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDbGllbnRTdGF0ZS5TdGFydGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RhdGUuU3RhcnRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RhdGUuU3RvcHBlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaW5pdGlhbGl6ZVJlc3VsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZVJlc3VsdDtcclxuICAgIH1cclxuICAgIHNlbmRSZXF1ZXN0KHR5cGUsIC4uLnBhcmFtcykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3Rpb25BY3RpdmUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhbmd1YWdlIGNsaWVudCBpcyBub3QgcmVhZHkgeWV0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZm9yY2VEb2N1bWVudFN5bmMoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uLnNlbmRSZXF1ZXN0KHR5cGUsIC4uLnBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yKGBTZW5kaW5nIHJlcXVlc3QgJHtJcy5zdHJpbmcodHlwZSkgPyB0eXBlIDogdHlwZS5tZXRob2R9IGZhaWxlZC5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVxdWVzdCh0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGlvbkFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGFuZ3VhZ2UgY2xpZW50IGlzIG5vdCByZWFkeSB5ZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uLm9uUmVxdWVzdCh0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoYFJlZ2lzdGVyaW5nIHJlcXVlc3QgaGFuZGxlciAke0lzLnN0cmluZyh0eXBlKSA/IHR5cGUgOiB0eXBlLm1ldGhvZH0gZmFpbGVkLmAsIGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZE5vdGlmaWNhdGlvbih0eXBlLCBwYXJhbXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0aW9uQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYW5ndWFnZSBjbGllbnQgaXMgbm90IHJlYWR5IHlldCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvcmNlRG9jdW1lbnRTeW5jKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24odHlwZSwgcGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uICR7SXMuc3RyaW5nKHR5cGUpID8gdHlwZSA6IHR5cGUubWV0aG9kfSBmYWlsZWQuYCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbk5vdGlmaWNhdGlvbih0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGlvbkFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGFuZ3VhZ2UgY2xpZW50IGlzIG5vdCByZWFkeSB5ZXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcihgUmVnaXN0ZXJpbmcgbm90aWZpY2F0aW9uIGhhbmRsZXIgJHtJcy5zdHJpbmcodHlwZSkgPyB0eXBlIDogdHlwZS5tZXRob2R9IGZhaWxlZC5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjbGllbnRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnRPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByb3RvY29sMkNvZGVDb252ZXJ0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3AyYztcclxuICAgIH1cclxuICAgIGdldCBjb2RlMlByb3RvY29sQ29udmVydGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jMnA7XHJcbiAgICB9XHJcbiAgICBnZXQgb25UZWxlbWV0cnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbGVtZXRyeUVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgb25EaWRDaGFuZ2VTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVDaGFuZ2VFbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IG91dHB1dENoYW5uZWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vdXRwdXRDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dENoYW5uZWwgPSB2c2NvZGVfMS53aW5kb3cuY3JlYXRlT3V0cHV0Q2hhbm5lbCh0aGlzLl9jbGllbnRPcHRpb25zLm91dHB1dENoYW5uZWxOYW1lID8gdGhpcy5fY2xpZW50T3B0aW9ucy5vdXRwdXRDaGFubmVsTmFtZSA6IHRoaXMuX25hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0Q2hhbm5lbDtcclxuICAgIH1cclxuICAgIGdldCBkaWFnbm9zdGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlhZ25vc3RpY3M7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVEZWZhdWx0RXJyb3JIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVycm9ySGFuZGxlcih0aGlzLl9uYW1lKTtcclxuICAgIH1cclxuICAgIHNldCB0cmFjZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RyYWNlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vblJlYWR5KCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb24oKS50aGVuKChjb25uZWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnRyYWNlKHRoaXMuX3RyYWNlLCB0aGlzLl90cmFjZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICBzZW5kTm90aWZpY2F0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFjZUZvcm1hdDogdGhpcy5fdHJhY2VGb3JtYXRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkYXRhMlN0cmluZyhkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5SZXNwb25zZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBkYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gYCAgTWVzc2FnZTogJHtyZXNwb25zZUVycm9yLm1lc3NhZ2V9XFxuICBDb2RlOiAke3Jlc3BvbnNlRXJyb3IuY29kZX0gJHtyZXNwb25zZUVycm9yLmRhdGEgPyAnXFxuJyArIHJlc3BvbnNlRXJyb3IuZGF0YS50b1N0cmluZygpIDogJyd9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGRhdGEuc3RhY2spKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zdGFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSXMuc3RyaW5nKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgaW5mbyhtZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZExpbmUoYFtJbmZvICAtICR7KG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpfV0gJHttZXNzYWdlfWApO1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKHRoaXMuZGF0YTJTdHJpbmcoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY2xpZW50T3B0aW9ucy5yZXZlYWxPdXRwdXRDaGFubmVsT24gPD0gUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uLkluZm8pIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLnNob3codHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2FybihtZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZExpbmUoYFtXYXJuICAtICR7KG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpfV0gJHttZXNzYWdlfWApO1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKHRoaXMuZGF0YTJTdHJpbmcoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY2xpZW50T3B0aW9ucy5yZXZlYWxPdXRwdXRDaGFubmVsT24gPD0gUmV2ZWFsT3V0cHV0Q2hhbm5lbE9uLldhcm4pIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLnNob3codHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXJyb3IobWVzc2FnZSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKGBbRXJyb3IgLSAkeyhuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpKX1dICR7bWVzc2FnZX1gKTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kTGluZSh0aGlzLmRhdGEyU3RyaW5nKGRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NsaWVudE9wdGlvbnMucmV2ZWFsT3V0cHV0Q2hhbm5lbE9uIDw9IFJldmVhbE91dHB1dENoYW5uZWxPbi5FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuc2hvdyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2dUcmFjZShtZXNzYWdlLCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZExpbmUoYFtUcmFjZSAtICR7KG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpfV0gJHttZXNzYWdlfWApO1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKHRoaXMuZGF0YTJTdHJpbmcoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvZ09iamVjdFRyYWNlKGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YS5pc0xTUE1lc3NhZ2UgJiYgZGF0YS50eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoYFtMU1AgICAtICR7KG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkpfV0gYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kKGBbVHJhY2UgLSAkeyhuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpKX1dIGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kTGluZShgJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZWVkc1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDbGllbnRTdGF0ZS5Jbml0aWFsIHx8IHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlN0b3BwaW5nIHx8IHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlN0b3BwZWQ7XHJcbiAgICB9XHJcbiAgICBuZWVkc1N0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlN0YXJ0aW5nIHx8IHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlJ1bm5pbmc7XHJcbiAgICB9XHJcbiAgICBvblJlYWR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vblJlYWR5O1xyXG4gICAgfVxyXG4gICAgaXNDb25uZWN0aW9uQWN0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDbGllbnRTdGF0ZS5SdW5uaW5nICYmICEhdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uUmVhZHlDYWxsYmFja3MuaXNVc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlYWR5Q2FsbGJhY2tzID0gbmV3IE9uUmVhZHkocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVycyA9IFtdO1xyXG4gICAgICAgIC8vIElmIHdlIHJlc3RhcnQgdGhlbiB0aGUgZGlhZ25vc3RpY3MgY29sbGVjdGlvbiBpcyByZXVzZWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaWFnbm9zdGljcykge1xyXG4gICAgICAgICAgICB0aGlzLl9kaWFnbm9zdGljcyA9IHRoaXMuX2NsaWVudE9wdGlvbnMuZGlhZ25vc3RpY0NvbGxlY3Rpb25OYW1lXHJcbiAgICAgICAgICAgICAgICA/IHZzY29kZV8xLmxhbmd1YWdlcy5jcmVhdGVEaWFnbm9zdGljQ29sbGVjdGlvbih0aGlzLl9jbGllbnRPcHRpb25zLmRpYWdub3N0aWNDb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgIDogdnNjb2RlXzEubGFuZ3VhZ2VzLmNyZWF0ZURpYWdub3N0aWNDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRTdGF0ZS5TdGFydGluZztcclxuICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uKCkudGhlbigoY29ubmVjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uTG9nTWVzc2FnZSgobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLk1lc3NhZ2VUeXBlLkVycm9yOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKG1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuTWVzc2FnZVR5cGUuV2FybmluZzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuKG1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuTWVzc2FnZVR5cGUuSW5mbzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvKG1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKG1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uU2hvd01lc3NhZ2UoKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NZXNzYWdlVHlwZS5FcnJvcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlXzEud2luZG93LnNob3dFcnJvck1lc3NhZ2UobWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NZXNzYWdlVHlwZS5XYXJuaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGVfMS53aW5kb3cuc2hvd1dhcm5pbmdNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuTWVzc2FnZVR5cGUuSW5mbzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlXzEud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UobWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlXzEud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UobWVzc2FnZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25SZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlNob3dNZXNzYWdlUmVxdWVzdC50eXBlLCAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZUZ1bmM7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NZXNzYWdlVHlwZS5FcnJvcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUZ1bmMgPSB2c2NvZGVfMS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5NZXNzYWdlVHlwZS5XYXJuaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRnVuYyA9IHZzY29kZV8xLndpbmRvdy5zaG93V2FybmluZ01lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuTWVzc2FnZVR5cGUuSW5mbzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUZ1bmMgPSB2c2NvZGVfMS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUZ1bmMgPSB2c2NvZGVfMS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBhY3Rpb25zID0gcGFyYW1zLmFjdGlvbnMgfHwgW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZUZ1bmMocGFyYW1zLm1lc3NhZ2UsIC4uLmFjdGlvbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblRlbGVtZXRyeSgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVsZW1ldHJ5RW1pdHRlci5maXJlKGRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5saXN0ZW4oKTtcclxuICAgICAgICAgICAgLy8gRXJyb3IgaXMgaGFuZGxlZCBpbiB0aGUgaW50aWFsaXplIGNhbGwuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemUoY29ubmVjdGlvbik7XHJcbiAgICAgICAgfSkudGhlbih1bmRlZmluZWQsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50U3RhdGUuU3RhcnRGYWlsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX29uUmVhZHlDYWxsYmFja3MucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcignU3RhcnRpbmcgY2xpZW50IGZhaWxlZCcsIGVycm9yKTtcclxuICAgICAgICAgICAgdnNjb2RlXzEud2luZG93LnNob3dFcnJvck1lc3NhZ2UoYENvdWxkbid0IHN0YXJ0IGNsaWVudCAke3RoaXMuX25hbWV9YCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2c2NvZGVfMS5EaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNTdG9wKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlQ29ubmVjdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5jcmVhdGVDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY29ubmVjdGlvbikge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRyYWNlKGNvbm5lY3Rpb24sIGZhbHNlKTtcclxuICAgICAgICBsZXQgaW5pdE9wdGlvbiA9IHRoaXMuX2NsaWVudE9wdGlvbnMuaW5pdGlhbGl6YXRpb25PcHRpb25zO1xyXG4gICAgICAgIGxldCByb290UGF0aCA9IHRoaXMuX2NsaWVudE9wdGlvbnMud29ya3NwYWNlRm9sZGVyXHJcbiAgICAgICAgICAgID8gdGhpcy5fY2xpZW50T3B0aW9ucy53b3Jrc3BhY2VGb2xkZXIudXJpLmZzUGF0aFxyXG4gICAgICAgICAgICA6IHRoaXMuX2NsaWVudEdldFJvb3RQYXRoKCk7XHJcbiAgICAgICAgbGV0IGluaXRQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NJZDogcHJvY2Vzcy5waWQsXHJcbiAgICAgICAgICAgIHJvb3RQYXRoOiByb290UGF0aCA/IHJvb3RQYXRoIDogbnVsbCxcclxuICAgICAgICAgICAgcm9vdFVyaTogcm9vdFBhdGggPyB0aGlzLl9jMnAuYXNVcmkodnNjb2RlXzEuVXJpLmZpbGUocm9vdFBhdGgpKSA6IG51bGwsXHJcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczogdGhpcy5jb21wdXRlQ2xpZW50Q2FwYWJpbGl0aWVzKCksXHJcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT3B0aW9uczogSXMuZnVuYyhpbml0T3B0aW9uKSA/IGluaXRPcHRpb24oKSA6IGluaXRPcHRpb24sXHJcbiAgICAgICAgICAgIHRyYWNlOiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UcmFjZS50b1N0cmluZyh0aGlzLl90cmFjZSksXHJcbiAgICAgICAgICAgIHdvcmtzcGFjZUZvbGRlcnM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZmlsbEluaXRpYWxpemVQYXJhbXMoaW5pdFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShpbml0UGFyYW1zKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVJlc3VsdCA9IHJlc3VsdDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudFN0YXRlLlJ1bm5pbmc7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKElzLm51bWJlcihyZXN1bHQuY2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jID09PSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UZXh0RG9jdW1lbnRTeW5jS2luZC5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50U3luY09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5DbG9zZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudFN5bmNPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuQ2xvc2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogcmVzdWx0LmNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVGV4dDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jICE9PSB2b2lkIDAgJiYgcmVzdWx0LmNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyA9IHJlc3VsdC5jYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQuY2FwYWJpbGl0aWVzLCB7IHJlc29sdmVkVGV4dERvY3VtZW50U3luYzogdGV4dERvY3VtZW50U3luY09wdGlvbnMgfSk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25EaWFnbm9zdGljcyhwYXJhbXMgPT4gdGhpcy5oYW5kbGVEaWFnbm9zdGljcyhwYXJhbXMpKTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVnaXN0cmF0aW9uUmVxdWVzdC50eXBlLCBwYXJhbXMgPT4gdGhpcy5oYW5kbGVSZWdpc3RyYXRpb25SZXF1ZXN0KHBhcmFtcykpO1xyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItbm9kZS9pc3N1ZXMvMTk5XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25SZXF1ZXN0KCdjbGllbnQvcmVnaXN0ZXJGZWF0dXJlJywgcGFyYW1zID0+IHRoaXMuaGFuZGxlUmVnaXN0cmF0aW9uUmVxdWVzdChwYXJhbXMpKTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUsIHBhcmFtcyA9PiB0aGlzLmhhbmRsZVVucmVnaXN0cmF0aW9uUmVxdWVzdChwYXJhbXMpKTtcclxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvdnNjb2RlLWxhbmd1YWdlc2VydmVyLW5vZGUvaXNzdWVzLzE5OVxyXG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uUmVxdWVzdCgnY2xpZW50L3VucmVnaXN0ZXJGZWF0dXJlJywgcGFyYW1zID0+IHRoaXMuaGFuZGxlVW5yZWdpc3RyYXRpb25SZXF1ZXN0KHBhcmFtcykpO1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0LnR5cGUsIHBhcmFtcyA9PiB0aGlzLmhhbmRsZUFwcGx5V29ya3NwYWNlRWRpdChwYXJhbXMpKTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkluaXRpYWxpemVkTm90aWZpY2F0aW9uLnR5cGUsIHt9KTtcclxuICAgICAgICAgICAgdGhpcy5ob29rRmlsZUV2ZW50cyhjb25uZWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5ob29rQ29uZmlndXJhdGlvbkNoYW5nZWQoY29ubmVjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZlYXR1cmVzKGNvbm5lY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9vblJlYWR5Q2FsbGJhY2tzLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KS50aGVuKHVuZGVmaW5lZCwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGllbnRPcHRpb25zLmluaXRpYWxpemF0aW9uRmFpbGVkSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NsaWVudE9wdGlvbnMuaW5pdGlhbGl6YXRpb25GYWlsZWRIYW5kbGVyKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25uZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVhZHlDYWxsYmFja3MucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlJlc3BvbnNlRXJyb3IgJiYgZXJyb3IuZGF0YSAmJiBlcnJvci5kYXRhLnJldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2c2NvZGVfMS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZShlcnJvci5tZXNzYWdlLCB7IHRpdGxlOiAnUmV0cnknLCBpZDogXCJyZXRyeVwiIH0pLnRoZW4oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5pZCA9PT0gJ3JldHJ5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoY29ubmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25SZWFkeUNhbGxiYWNrcy5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGVfMS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZShlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1NlcnZlciBpbml0aWFsaXphdGlvbiBmYWlsZWQuJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlYWR5Q2FsbGJhY2tzLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9jbGllbnRHZXRSb290UGF0aCgpIHtcclxuICAgICAgICBsZXQgZm9sZGVycyA9IHZzY29kZV8xLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzO1xyXG4gICAgICAgIGlmICghZm9sZGVycyB8fCBmb2xkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZm9sZGVyID0gZm9sZGVyc1swXTtcclxuICAgICAgICBpZiAoZm9sZGVyLnVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9sZGVyLnVyaS5mc1BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVSZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50U3RhdGUuU3RvcHBlZDtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ2xpZW50U3RhdGUuU3RvcHBpbmcgJiYgdGhpcy5fb25TdG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblN0b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRTdGF0ZS5TdG9wcGluZztcclxuICAgICAgICB0aGlzLmNsZWFuVXAoKTtcclxuICAgICAgICAvLyB1bmtvb2sgbGlzdGVuZXJzXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uU3RvcCA9IHRoaXMucmVzb2x2ZUNvbm5lY3Rpb24oKS50aGVuKGNvbm5lY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zaHV0ZG93bigpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5leGl0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRTdGF0ZS5TdG9wcGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdG9wID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZENvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2xlYW5VcChjaGFubmVsID0gdHJ1ZSwgZGlhZ25vc3RpY3MgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lci5kaXNwb3NlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wcm92aWRlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXJzLmZvckVhY2gocHJvdmlkZXIgPT4gcHJvdmlkZXIuZGlzcG9zZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvdmlkZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc3luY2VkRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNlZERvY3VtZW50cy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMuX2R5bmFtaWNGZWF0dXJlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5uZWwgJiYgdGhpcy5fb3V0cHV0Q2hhbm5lbCAmJiB0aGlzLl9kaXNwb3NlT3V0cHV0Q2hhbm5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRDaGFubmVsLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0Q2hhbm5lbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzICYmIHRoaXMuX2RpYWdub3N0aWNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpYWdub3N0aWNzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlhZ25vc3RpY3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm90aWZ5RmlsZUV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5fZmlsZUV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICB0aGlzLl9maWxlRXZlbnREZWxheWVyLnRyaWdnZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHkoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb24oKS50aGVuKGNvbm5lY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGlvbkFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHsgY2hhbmdlczogdGhpcy5fZmlsZUV2ZW50cyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZUV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgTm90aWZ5IGZpbGUgZXZlbnRzIGZhaWxlZC5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZm9yY2VEb2N1bWVudFN5bmMoKSB7XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0ZlYXR1cmVzLmdldCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZS5tZXRob2QpLmZvcmNlRGVsaXZlcnkoKTtcclxuICAgIH1cclxuICAgIGhhbmRsZURpYWdub3N0aWNzKHBhcmFtcykge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlhZ25vc3RpY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdXJpID0gdGhpcy5fcDJjLmFzVXJpKHBhcmFtcy51cmkpO1xyXG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IHRoaXMuX3AyYy5hc0RpYWdub3N0aWNzKHBhcmFtcy5kaWFnbm9zdGljcyk7XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSB0aGlzLmNsaWVudE9wdGlvbnMubWlkZGxld2FyZS5oYW5kbGVEaWFnbm9zdGljcztcclxuICAgICAgICBpZiAobWlkZGxld2FyZSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlKHVyaSwgZGlhZ25vc3RpY3MsICh1cmksIGRpYWdub3N0aWNzKSA9PiB0aGlzLnNldERpYWdub3N0aWNzKHVyaSwgZGlhZ25vc3RpY3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RGlhZ25vc3RpY3ModXJpLCBkaWFnbm9zdGljcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0RGlhZ25vc3RpY3ModXJpLCBkaWFnbm9zdGljcykge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlhZ25vc3RpY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaWFnbm9zdGljcy5zZXQodXJpLCBkaWFnbm9zdGljcyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDb25uZWN0aW9uKCkge1xyXG4gICAgICAgIGxldCBlcnJvckhhbmRsZXIgPSAoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdGlvbkVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY2xvc2VIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbm5lY3Rpb25DbG9zZWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU1lc3NhZ2VUcmFuc3BvcnRzKHRoaXMuX2NsaWVudE9wdGlvbnMuc3RkaW9FbmNvZGluZyB8fCAndXRmOCcpLnRoZW4oKHRyYW5zcG9ydHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbm5lY3Rpb24odHJhbnNwb3J0cy5yZWFkZXIsIHRyYW5zcG9ydHMud3JpdGVyLCBlcnJvckhhbmRsZXIsIGNsb3NlSGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDb25uZWN0aW9uQ2xvc2VkKCkge1xyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBpcyBhIG5vcm1hbCBzaHV0ZG93biBpbiBwcm9ncmVzcyBvciB0aGUgY2xpZW50IHN0b3BwZWQgbm9ybWFsbHkuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlN0b3BwaW5nIHx8IHRoaXMuc3RhdGUgPT09IENsaWVudFN0YXRlLlN0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZWRDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZENvbm5lY3Rpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBEaXNwb3NpbmcgYSBjb25uZWN0aW9uIGNvdWxkIGZhaWwgaWYgZXJyb3IgY2FzZXMuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhY3Rpb24gPSBDbG9zZUFjdGlvbi5Eb05vdFJlc3RhcnQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5fY2xpZW50T3B0aW9ucy5lcnJvckhhbmRsZXIuY2xvc2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGNvbWluZyBmcm9tIHRoZSBlcnJvciBoYW5kbGVyLlxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlZENvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gQ2xvc2VBY3Rpb24uRG9Ob3RSZXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIGdvdCBjbG9zZWQuIFNlcnZlciB3aWxsIG5vdCBiZSByZXN0YXJ0ZWQuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRTdGF0ZS5TdG9wcGVkO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09IENsb3NlQWN0aW9uLlJlc3RhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmZvKCdDb25uZWN0aW9uIHRvIHNlcnZlciBnb3QgY2xvc2VkLiBTZXJ2ZXIgd2lsbCByZXN0YXJ0LicpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudFN0YXRlLkluaXRpYWw7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDb25uZWN0aW9uRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSB7XHJcbiAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuX2NsaWVudE9wdGlvbnMuZXJyb3JIYW5kbGVyLmVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCk7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gRXJyb3JBY3Rpb24uU2h1dGRvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcignQ29ubmVjdGlvbiB0byBzZXJ2ZXIgaXMgZXJyb3JpbmcuIFNodXR0aW5nIGRvd24gc2VydmVyLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBob29rQ29uZmlndXJhdGlvbkNoYW5nZWQoY29ubmVjdGlvbikge1xyXG4gICAgICAgIHZzY29kZV8xLndvcmtzcGFjZS5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUcmFjZShjb25uZWN0aW9uLCB0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZnJlc2hUcmFjZShjb25uZWN0aW9uLCBzZW5kTm90aWZpY2F0aW9uID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgY29uZmlnID0gdnNjb2RlXzEud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24odGhpcy5faWQpO1xyXG4gICAgICAgIGxldCB0cmFjZSA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlRyYWNlLk9mZjtcclxuICAgICAgICBsZXQgdHJhY2VGb3JtYXQgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UcmFjZUZvcm1hdC5UZXh0O1xyXG4gICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2VDb25maWcgPSBjb25maWcuZ2V0KCd0cmFjZS5zZXJ2ZXInLCAnb2ZmJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2VDb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZSA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlRyYWNlLmZyb21TdHJpbmcodHJhY2VDb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UcmFjZS5mcm9tU3RyaW5nKGNvbmZpZy5nZXQoJ3RyYWNlLnNlcnZlci52ZXJib3NpdHknLCAnb2ZmJykpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2VGb3JtYXQgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UcmFjZUZvcm1hdC5mcm9tU3RyaW5nKGNvbmZpZy5nZXQoJ3RyYWNlLnNlcnZlci5mb3JtYXQnLCAndGV4dCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFjZSA9IHRyYWNlO1xyXG4gICAgICAgIHRoaXMuX3RyYWNlRm9ybWF0ID0gdHJhY2VGb3JtYXQ7XHJcbiAgICAgICAgY29ubmVjdGlvbi50cmFjZSh0aGlzLl90cmFjZSwgdGhpcy5fdHJhY2VyLCB7XHJcbiAgICAgICAgICAgIHNlbmROb3RpZmljYXRpb24sXHJcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0OiB0aGlzLl90cmFjZUZvcm1hdFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaG9va0ZpbGVFdmVudHMoX2Nvbm5lY3Rpb24pIHtcclxuICAgICAgICBsZXQgZmlsZUV2ZW50cyA9IHRoaXMuX2NsaWVudE9wdGlvbnMuc3luY2hyb25pemUuZmlsZUV2ZW50cztcclxuICAgICAgICBpZiAoIWZpbGVFdmVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgd2F0Y2hlcnM7XHJcbiAgICAgICAgaWYgKElzLmFycmF5KGZpbGVFdmVudHMpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXJzID0gZmlsZUV2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXJzID0gW2ZpbGVFdmVudHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXdhdGNoZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0ZlYXR1cmVzLmdldCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24udHlwZS5tZXRob2QpLnJlZ2lzdGVyUmF3KFVVSUQuZ2VuZXJhdGVVdWlkKCksIHdhdGNoZXJzKTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyRmVhdHVyZXMoZmVhdHVyZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBmZWF0dXJlIG9mIGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKGZlYXR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyRmVhdHVyZShmZWF0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcclxuICAgICAgICBpZiAoRHluYW1pY0ZlYXR1cmUuaXMoZmVhdHVyZSkpIHtcclxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VzID0gZmVhdHVyZS5tZXNzYWdlcztcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0aG9kMk1lc3NhZ2Uuc2V0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljRmVhdHVyZXMuc2V0KG1lc3NhZ2UubWV0aG9kLCBmZWF0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZDJNZXNzYWdlLnNldChtZXNzYWdlcy5tZXRob2QsIG1lc3NhZ2VzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNGZWF0dXJlcy5zZXQobWVzc2FnZXMubWV0aG9kLCBmZWF0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyQnVpbHRpbkZlYXR1cmVzKCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBDb25maWd1cmF0aW9uRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IERpZE9wZW5UZXh0RG9jdW1lbnRGZWF0dXJlKHRoaXMsIHRoaXMuX3N5bmNlZERvY3VtZW50cykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEaWRDaGFuZ2VUZXh0RG9jdW1lbnRGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgV2lsbFNhdmVGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgV2lsbFNhdmVXYWl0VW50aWxGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgRGlkU2F2ZVRleHREb2N1bWVudEZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEaWRDbG9zZVRleHREb2N1bWVudEZlYXR1cmUodGhpcywgdGhpcy5fc3luY2VkRG9jdW1lbnRzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IEZpbGVTeXN0ZW1XYXRjaGVyRmVhdHVyZSh0aGlzLCAoZXZlbnQpID0+IHRoaXMubm90aWZ5RmlsZUV2ZW50KGV2ZW50KSkpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBDb21wbGV0aW9uSXRlbUZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBIb3ZlckZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBTaWduYXR1cmVIZWxwRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IERlZmluaXRpb25GZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgUmVmZXJlbmNlc0ZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEb2N1bWVudEhpZ2hsaWdodEZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEb2N1bWVudFN5bWJvbEZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBXb3Jrc3BhY2VTeW1ib2xGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgQ29kZUFjdGlvbkZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBDb2RlTGVuc0ZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEb2N1bWVudEZvcm1hdHRpbmdGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IFJlbmFtZUZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBEb2N1bWVudExpbmtGZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgRXhlY3V0ZUNvbW1hbmRGZWF0dXJlKHRoaXMpKTtcclxuICAgIH1cclxuICAgIGZpbGxJbml0aWFsaXplUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgdGhpcy5fZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgaWYgKElzLmZ1bmMoZmVhdHVyZS5maWxsSW5pdGlhbGl6ZVBhcmFtcykpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuZmlsbEluaXRpYWxpemVQYXJhbXMocGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXB1dGVDbGllbnRDYXBhYmlsaXRpZXMoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGVuc3VyZShyZXN1bHQsICd3b3Jrc3BhY2UnKS5hcHBseUVkaXQgPSB0cnVlO1xyXG4gICAgICAgIGxldCB3b3Jrc3BhY2VFZGl0ID0gZW5zdXJlKGVuc3VyZShyZXN1bHQsICd3b3Jrc3BhY2UnKSwgJ3dvcmtzcGFjZUVkaXQnKTtcclxuICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgd29ya3NwYWNlRWRpdC5yZXNvdXJjZU9wZXJhdGlvbnMgPSBbdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVzb3VyY2VPcGVyYXRpb25LaW5kLkNyZWF0ZSwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVzb3VyY2VPcGVyYXRpb25LaW5kLkRlbGV0ZV07XHJcbiAgICAgICAgd29ya3NwYWNlRWRpdC5mYWlsdXJlSGFuZGxpbmcgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5GYWlsdXJlSGFuZGxpbmdLaW5kLlRleHRPbmx5VHJhbnNhY3Rpb25hbDtcclxuICAgICAgICBlbnN1cmUoZW5zdXJlKHJlc3VsdCwgJ3RleHREb2N1bWVudCcpLCAncHVibGlzaERpYWdub3N0aWNzJykucmVsYXRlZEluZm9ybWF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBmZWF0dXJlIG9mIHRoaXMuX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuZmlsbENsaWVudENhcGFiaWxpdGllcyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZUZlYXR1cmVzKF9jb25uZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGRvY3VtZW50U2VsZWN0b3IgPSB0aGlzLl9jbGllbnRPcHRpb25zLmRvY3VtZW50U2VsZWN0b3I7XHJcbiAgICAgICAgZm9yIChsZXQgZmVhdHVyZSBvZiB0aGlzLl9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICBmZWF0dXJlLmluaXRpYWxpemUodGhpcy5fY2FwYWJpbGl0aWVzLCBkb2N1bWVudFNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVSZWdpc3RyYXRpb25SZXF1ZXN0KHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJlZ2lzdHJhdGlvbiBvZiBwYXJhbXMucmVnaXN0cmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuX2R5bmFtaWNGZWF0dXJlcy5nZXQocmVnaXN0cmF0aW9uLm1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBObyBmZWF0dXJlIGltcGxlbWVudGF0aW9uIGZvciAke3JlZ2lzdHJhdGlvbi5tZXRob2R9IGZvdW5kLiBSZWdpc3RyYXRpb24gZmFpbGVkLmApKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcmVnaXN0cmF0aW9uLnJlZ2lzdGVyT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZG9jdW1lbnRTZWxlY3RvciA9IG9wdGlvbnMuZG9jdW1lbnRTZWxlY3RvciB8fCB0aGlzLl9jbGllbnRPcHRpb25zLmRvY3VtZW50U2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiByZWdpc3RyYXRpb24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5yZWdpc3Rlcih0aGlzLl9tZXRob2QyTWVzc2FnZS5nZXQocmVnaXN0cmF0aW9uLm1ldGhvZCksIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZVVucmVnaXN0cmF0aW9uUmVxdWVzdChwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB1bnJlZ2lzdHJhdGlvbiBvZiBwYXJhbXMudW5yZWdpc3RlcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuX2R5bmFtaWNGZWF0dXJlcy5nZXQodW5yZWdpc3RyYXRpb24ubWV0aG9kKTtcclxuICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vIGZlYXR1cmUgaW1wbGVtZW50YXRpb24gZm9yICR7dW5yZWdpc3RyYXRpb24ubWV0aG9kfSBmb3VuZC4gVW5yZWdpc3RyYXRpb24gZmFpbGVkLmApKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnVucmVnaXN0ZXIodW5yZWdpc3RyYXRpb24uaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQXBwbHlXb3Jrc3BhY2VFZGl0KHBhcmFtcykge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgc29tZSBzb3J0IG9mIHdvcmthcm91bmQgc2luY2UgdGhlIHZlcnNpb24gY2hlY2sgc2hvdWxkIGJlIGRvbmUgYnkgVlMgQ29kZSBpbiB0aGUgV29ya3NwYWNlLmFwcGx5RWRpdC5cclxuICAgICAgICAvLyBIb3dldmVyIGRvaW5nIGl0IGhlcmUgYWRkcyBzb21lIHNhZmV0eSBzaW5jZSB0aGUgc2VydmVyIGNhbiBsYWcgbW9yZSBiZWhpbmQgdGhlbiBhbiBleHRlbnNpb24uXHJcbiAgICAgICAgbGV0IHdvcmtzcGFjZUVkaXQgPSBwYXJhbXMuZWRpdDtcclxuICAgICAgICBsZXQgb3BlblRleHREb2N1bWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdnNjb2RlXzEud29ya3NwYWNlLnRleHREb2N1bWVudHMuZm9yRWFjaCgoZG9jdW1lbnQpID0+IG9wZW5UZXh0RG9jdW1lbnRzLnNldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSwgZG9jdW1lbnQpKTtcclxuICAgICAgICBsZXQgdmVyc2lvbk1pc21hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpICYmIGNoYW5nZS50ZXh0RG9jdW1lbnQudmVyc2lvbiAmJiBjaGFuZ2UudGV4dERvY3VtZW50LnZlcnNpb24gPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0RG9jdW1lbnQgPSBvcGVuVGV4dERvY3VtZW50cy5nZXQoY2hhbmdlLnRleHREb2N1bWVudC51cmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0RG9jdW1lbnQgJiYgdGV4dERvY3VtZW50LnZlcnNpb24gIT09IGNoYW5nZS50ZXh0RG9jdW1lbnQudmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXBwbGllZDogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS53b3Jrc3BhY2UuYXBwbHlFZGl0KHRoaXMuX3AyYy5hc1dvcmtzcGFjZUVkaXQocGFyYW1zLmVkaXQpKS50aGVuKCh2YWx1ZSkgPT4geyByZXR1cm4geyBhcHBsaWVkOiB2YWx1ZSB9OyB9KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGxvZ0ZhaWxlZFJlcXVlc3QodHlwZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBJZiB3ZSBnZXQgYSByZXF1ZXN0IGNhbmNlbCBkb24ndCBsb2cgYW55dGhpbmcuXHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuUmVzcG9uc2VFcnJvciAmJiBlcnJvci5jb2RlID09PSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5FcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVycm9yKGBSZXF1ZXN0ICR7dHlwZS5tZXRob2R9IGZhaWxlZC5gLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYXNlTGFuZ3VhZ2VDbGllbnQgPSBCYXNlTGFuZ3VhZ2VDbGllbnQ7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/client.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/codeConverter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/codeConverter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst code = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst proto = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ \"./node_modules/vscode-languageclient/lib/protocolCompletionItem.js\");\r\nconst protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ \"./node_modules/vscode-languageclient/lib/protocolCodeLens.js\");\r\nconst protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ \"./node_modules/vscode-languageclient/lib/protocolDocumentLink.js\");\r\nfunction createConverter(uriConverter) {\r\n    const nullConverter = (value) => value.toString();\r\n    const _uriConverter = uriConverter || nullConverter;\r\n    function asUri(value) {\r\n        return _uriConverter(value);\r\n    }\r\n    function asTextDocumentIdentifier(textDocument) {\r\n        return {\r\n            uri: _uriConverter(textDocument.uri)\r\n        };\r\n    }\r\n    function asVersionedTextDocumentIdentifier(textDocument) {\r\n        return {\r\n            uri: _uriConverter(textDocument.uri),\r\n            version: textDocument.version\r\n        };\r\n    }\r\n    function asOpenTextDocumentParams(textDocument) {\r\n        return {\r\n            textDocument: {\r\n                uri: _uriConverter(textDocument.uri),\r\n                languageId: textDocument.languageId,\r\n                version: textDocument.version,\r\n                text: textDocument.getText()\r\n            }\r\n        };\r\n    }\r\n    function isTextDocumentChangeEvent(value) {\r\n        let candidate = value;\r\n        return !!candidate.document && !!candidate.contentChanges;\r\n    }\r\n    function isTextDocument(value) {\r\n        let candidate = value;\r\n        return !!candidate.uri && !!candidate.version;\r\n    }\r\n    function asChangeTextDocumentParams(arg) {\r\n        if (isTextDocument(arg)) {\r\n            let result = {\r\n                textDocument: {\r\n                    uri: _uriConverter(arg.uri),\r\n                    version: arg.version\r\n                },\r\n                contentChanges: [{ text: arg.getText() }]\r\n            };\r\n            return result;\r\n        }\r\n        else if (isTextDocumentChangeEvent(arg)) {\r\n            let document = arg.document;\r\n            let result = {\r\n                textDocument: {\r\n                    uri: _uriConverter(document.uri),\r\n                    version: document.version\r\n                },\r\n                contentChanges: arg.contentChanges.map((change) => {\r\n                    let range = change.range;\r\n                    return {\r\n                        range: {\r\n                            start: { line: range.start.line, character: range.start.character },\r\n                            end: { line: range.end.line, character: range.end.character }\r\n                        },\r\n                        rangeLength: change.rangeLength,\r\n                        text: change.text\r\n                    };\r\n                })\r\n            };\r\n            return result;\r\n        }\r\n        else {\r\n            throw Error('Unsupported text document change parameter');\r\n        }\r\n    }\r\n    function asCloseTextDocumentParams(textDocument) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument)\r\n        };\r\n    }\r\n    function asSaveTextDocumentParams(textDocument, includeContent = false) {\r\n        let result = {\r\n            textDocument: asVersionedTextDocumentIdentifier(textDocument)\r\n        };\r\n        if (includeContent) {\r\n            result.text = textDocument.getText();\r\n        }\r\n        return result;\r\n    }\r\n    function asTextDocumentSaveReason(reason) {\r\n        switch (reason) {\r\n            case code.TextDocumentSaveReason.Manual:\r\n                return proto.TextDocumentSaveReason.Manual;\r\n            case code.TextDocumentSaveReason.AfterDelay:\r\n                return proto.TextDocumentSaveReason.AfterDelay;\r\n            case code.TextDocumentSaveReason.FocusOut:\r\n                return proto.TextDocumentSaveReason.FocusOut;\r\n        }\r\n        return proto.TextDocumentSaveReason.Manual;\r\n    }\r\n    function asWillSaveTextDocumentParams(event) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(event.document),\r\n            reason: asTextDocumentSaveReason(event.reason)\r\n        };\r\n    }\r\n    function asTextDocumentPositionParams(textDocument, position) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument),\r\n            position: asWorkerPosition(position)\r\n        };\r\n    }\r\n    function asTriggerKind(triggerKind) {\r\n        switch (triggerKind) {\r\n            case code.CompletionTriggerKind.TriggerCharacter:\r\n                return proto.CompletionTriggerKind.TriggerCharacter;\r\n            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:\r\n                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;\r\n            default:\r\n                return proto.CompletionTriggerKind.Invoked;\r\n        }\r\n    }\r\n    function asCompletionParams(textDocument, position, context) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument),\r\n            position: asWorkerPosition(position),\r\n            context: {\r\n                triggerKind: asTriggerKind(context.triggerKind),\r\n                triggerCharacter: context.triggerCharacter\r\n            }\r\n        };\r\n    }\r\n    function asWorkerPosition(position) {\r\n        return { line: position.line, character: position.character };\r\n    }\r\n    function asPosition(value) {\r\n        if (value === void 0) {\r\n            return undefined;\r\n        }\r\n        else if (value === null) {\r\n            return null;\r\n        }\r\n        return { line: value.line, character: value.character };\r\n    }\r\n    function asRange(value) {\r\n        if (value === void 0 || value === null) {\r\n            return value;\r\n        }\r\n        return { start: asPosition(value.start), end: asPosition(value.end) };\r\n    }\r\n    function asDiagnosticSeverity(value) {\r\n        switch (value) {\r\n            case code.DiagnosticSeverity.Error:\r\n                return proto.DiagnosticSeverity.Error;\r\n            case code.DiagnosticSeverity.Warning:\r\n                return proto.DiagnosticSeverity.Warning;\r\n            case code.DiagnosticSeverity.Information:\r\n                return proto.DiagnosticSeverity.Information;\r\n            case code.DiagnosticSeverity.Hint:\r\n                return proto.DiagnosticSeverity.Hint;\r\n        }\r\n    }\r\n    function asDiagnostic(item) {\r\n        let result = proto.Diagnostic.create(asRange(item.range), item.message);\r\n        if (Is.number(item.severity)) {\r\n            result.severity = asDiagnosticSeverity(item.severity);\r\n        }\r\n        if (Is.number(item.code) || Is.string(item.code)) {\r\n            result.code = item.code;\r\n        }\r\n        if (item.source) {\r\n            result.source = item.source;\r\n        }\r\n        return result;\r\n    }\r\n    function asDiagnostics(items) {\r\n        if (items === void 0 || items === null) {\r\n            return items;\r\n        }\r\n        return items.map(asDiagnostic);\r\n    }\r\n    function asDocumentation(format, documentation) {\r\n        switch (format) {\r\n            case '$string':\r\n                return documentation;\r\n            case proto.MarkupKind.PlainText:\r\n                return { kind: format, value: documentation };\r\n            case proto.MarkupKind.Markdown:\r\n                return { kind: format, value: documentation.value };\r\n            default:\r\n                return `Unsupported Markup content received. Kind is: ${format}`;\r\n        }\r\n    }\r\n    function asCompletionItemKind(value, original) {\r\n        if (original !== void 0) {\r\n            return original;\r\n        }\r\n        return value + 1;\r\n    }\r\n    function asCompletionItem(item) {\r\n        let result = { label: item.label };\r\n        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;\r\n        if (item.detail) {\r\n            result.detail = item.detail;\r\n        }\r\n        // We only send items back we created. So this can't be something else than\r\n        // a string right now.\r\n        if (item.documentation) {\r\n            if (!protocolItem || protocolItem.documentationFormat === '$string') {\r\n                result.documentation = item.documentation;\r\n            }\r\n            else {\r\n                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);\r\n            }\r\n        }\r\n        if (item.filterText) {\r\n            result.filterText = item.filterText;\r\n        }\r\n        fillPrimaryInsertText(result, item);\r\n        if (Is.number(item.kind)) {\r\n            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);\r\n        }\r\n        if (item.sortText) {\r\n            result.sortText = item.sortText;\r\n        }\r\n        if (item.additionalTextEdits) {\r\n            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);\r\n        }\r\n        if (item.commitCharacters) {\r\n            result.commitCharacters = item.commitCharacters.slice();\r\n        }\r\n        if (item.command) {\r\n            result.command = asCommand(item.command);\r\n        }\r\n        if (item.preselect === true || item.preselect === false) {\r\n            result.preselect = item.preselect;\r\n        }\r\n        if (protocolItem) {\r\n            if (protocolItem.data !== void 0) {\r\n                result.data = protocolItem.data;\r\n            }\r\n            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {\r\n                result.deprecated = protocolItem.deprecated;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    function fillPrimaryInsertText(target, source) {\r\n        let format = proto.InsertTextFormat.PlainText;\r\n        let text;\r\n        let range = undefined;\r\n        if (source.textEdit) {\r\n            text = source.textEdit.newText;\r\n            range = asRange(source.textEdit.range);\r\n        }\r\n        else if (source.insertText instanceof code.SnippetString) {\r\n            format = proto.InsertTextFormat.Snippet;\r\n            text = source.insertText.value;\r\n        }\r\n        else {\r\n            text = source.insertText;\r\n        }\r\n        if (source.range) {\r\n            range = asRange(source.range);\r\n        }\r\n        target.insertTextFormat = format;\r\n        if (source.fromEdit && text && range) {\r\n            target.textEdit = { newText: text, range: range };\r\n        }\r\n        else {\r\n            target.insertText = text;\r\n        }\r\n    }\r\n    function asTextEdit(edit) {\r\n        return { range: asRange(edit.range), newText: edit.newText };\r\n    }\r\n    function asTextEdits(edits) {\r\n        if (edits === void 0 || edits === null) {\r\n            return edits;\r\n        }\r\n        return edits.map(asTextEdit);\r\n    }\r\n    function asReferenceParams(textDocument, position, options) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument),\r\n            position: asWorkerPosition(position),\r\n            context: { includeDeclaration: options.includeDeclaration }\r\n        };\r\n    }\r\n    function asCodeActionContext(context) {\r\n        if (context === void 0 || context === null) {\r\n            return context;\r\n        }\r\n        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), Is.string(context.only) ? [context.only] : undefined);\r\n    }\r\n    function asCommand(item) {\r\n        let result = proto.Command.create(item.title, item.command);\r\n        if (item.arguments) {\r\n            result.arguments = item.arguments;\r\n        }\r\n        return result;\r\n    }\r\n    function asCodeLens(item) {\r\n        let result = proto.CodeLens.create(asRange(item.range));\r\n        if (item.command) {\r\n            result.command = asCommand(item.command);\r\n        }\r\n        if (item instanceof protocolCodeLens_1.default) {\r\n            if (item.data) {\r\n                result.data = item.data;\r\n            }\r\n            ;\r\n        }\r\n        return result;\r\n    }\r\n    function asFormattingOptions(item) {\r\n        return { tabSize: item.tabSize, insertSpaces: item.insertSpaces };\r\n    }\r\n    function asDocumentSymbolParams(textDocument) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument)\r\n        };\r\n    }\r\n    function asCodeLensParams(textDocument) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument)\r\n        };\r\n    }\r\n    function asDocumentLink(item) {\r\n        let result = proto.DocumentLink.create(asRange(item.range));\r\n        if (item.target) {\r\n            result.target = asUri(item.target);\r\n        }\r\n        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;\r\n        if (protocolItem && protocolItem.data) {\r\n            result.data = protocolItem.data;\r\n        }\r\n        return result;\r\n    }\r\n    function asDocumentLinkParams(textDocument) {\r\n        return {\r\n            textDocument: asTextDocumentIdentifier(textDocument)\r\n        };\r\n    }\r\n    return {\r\n        asUri,\r\n        asTextDocumentIdentifier,\r\n        asOpenTextDocumentParams,\r\n        asChangeTextDocumentParams,\r\n        asCloseTextDocumentParams,\r\n        asSaveTextDocumentParams,\r\n        asWillSaveTextDocumentParams,\r\n        asTextDocumentPositionParams,\r\n        asCompletionParams,\r\n        asWorkerPosition,\r\n        asRange,\r\n        asPosition,\r\n        asDiagnosticSeverity,\r\n        asDiagnostic,\r\n        asDiagnostics,\r\n        asCompletionItem,\r\n        asTextEdit,\r\n        asReferenceParams,\r\n        asCodeActionContext,\r\n        asCommand,\r\n        asCodeLens,\r\n        asFormattingOptions,\r\n        asDocumentSymbolParams,\r\n        asCodeLensParams,\r\n        asDocumentLink,\r\n        asDocumentLinkParams\r\n    };\r\n}\r\nexports.createConverter = createConverter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9jb2RlQ29udmVydGVyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL2NvZGVDb252ZXJ0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHByb3RvID0gcmVxdWlyZShcInZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbFwiKTtcclxuY29uc3QgSXMgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcclxuY29uc3QgcHJvdG9jb2xDb21wbGV0aW9uSXRlbV8xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xDb21wbGV0aW9uSXRlbVwiKTtcclxuY29uc3QgcHJvdG9jb2xDb2RlTGVuc18xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xDb2RlTGVuc1wiKTtcclxuY29uc3QgcHJvdG9jb2xEb2N1bWVudExpbmtfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sRG9jdW1lbnRMaW5rXCIpO1xyXG5mdW5jdGlvbiBjcmVhdGVDb252ZXJ0ZXIodXJpQ29udmVydGVyKSB7XHJcbiAgICBjb25zdCBudWxsQ29udmVydGVyID0gKHZhbHVlKSA9PiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgY29uc3QgX3VyaUNvbnZlcnRlciA9IHVyaUNvbnZlcnRlciB8fCBudWxsQ29udmVydGVyO1xyXG4gICAgZnVuY3Rpb24gYXNVcmkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gX3VyaUNvbnZlcnRlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1RleHREb2N1bWVudElkZW50aWZpZXIodGV4dERvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXJpOiBfdXJpQ29udmVydGVyKHRleHREb2N1bWVudC51cmkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcih0ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cmk6IF91cmlDb252ZXJ0ZXIodGV4dERvY3VtZW50LnVyaSksXHJcbiAgICAgICAgICAgIHZlcnNpb246IHRleHREb2N1bWVudC52ZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzT3BlblRleHREb2N1bWVudFBhcmFtcyh0ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgIHVyaTogX3VyaUNvbnZlcnRlcih0ZXh0RG9jdW1lbnQudXJpKSxcclxuICAgICAgICAgICAgICAgIGxhbmd1YWdlSWQ6IHRleHREb2N1bWVudC5sYW5ndWFnZUlkLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGV4dERvY3VtZW50LnZlcnNpb24sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNUZXh0RG9jdW1lbnRDaGFuZ2VFdmVudCh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUuZG9jdW1lbnQgJiYgISFjYW5kaWRhdGUuY29udGVudENoYW5nZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1RleHREb2N1bWVudCh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUudXJpICYmICEhY2FuZGlkYXRlLnZlcnNpb247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NoYW5nZVRleHREb2N1bWVudFBhcmFtcyhhcmcpIHtcclxuICAgICAgICBpZiAoaXNUZXh0RG9jdW1lbnQoYXJnKSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBfdXJpQ29udmVydGVyKGFyZy51cmkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGFyZy52ZXJzaW9uXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY29udGVudENoYW5nZXM6IFt7IHRleHQ6IGFyZy5nZXRUZXh0KCkgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNUZXh0RG9jdW1lbnRDaGFuZ2VFdmVudChhcmcpKSB7XHJcbiAgICAgICAgICAgIGxldCBkb2N1bWVudCA9IGFyZy5kb2N1bWVudDtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVyaTogX3VyaUNvbnZlcnRlcihkb2N1bWVudC51cmkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGRvY3VtZW50LnZlcnNpb25cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50Q2hhbmdlczogYXJnLmNvbnRlbnRDaGFuZ2VzLm1hcCgoY2hhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gY2hhbmdlLnJhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogeyBsaW5lOiByYW5nZS5zdGFydC5saW5lLCBjaGFyYWN0ZXI6IHJhbmdlLnN0YXJ0LmNoYXJhY3RlciB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7IGxpbmU6IHJhbmdlLmVuZC5saW5lLCBjaGFyYWN0ZXI6IHJhbmdlLmVuZC5jaGFyYWN0ZXIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZUxlbmd0aDogY2hhbmdlLnJhbmdlTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGFuZ2UudGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRleHQgZG9jdW1lbnQgY2hhbmdlIHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ2xvc2VUZXh0RG9jdW1lbnRQYXJhbXModGV4dERvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dERvY3VtZW50OiBhc1RleHREb2N1bWVudElkZW50aWZpZXIodGV4dERvY3VtZW50KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1NhdmVUZXh0RG9jdW1lbnRQYXJhbXModGV4dERvY3VtZW50LCBpbmNsdWRlQ29udGVudCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdGV4dERvY3VtZW50OiBhc1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIodGV4dERvY3VtZW50KVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50ZXh0ID0gdGV4dERvY3VtZW50LmdldFRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzVGV4dERvY3VtZW50U2F2ZVJlYXNvbihyZWFzb24pIHtcclxuICAgICAgICBzd2l0Y2ggKHJlYXNvbikge1xyXG4gICAgICAgICAgICBjYXNlIGNvZGUuVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWw7XHJcbiAgICAgICAgICAgIGNhc2UgY29kZS5UZXh0RG9jdW1lbnRTYXZlUmVhc29uLkFmdGVyRGVsYXk6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5O1xyXG4gICAgICAgICAgICBjYXNlIGNvZGUuVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5Gb2N1c091dDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5UZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvdG8uVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1dpbGxTYXZlVGV4dERvY3VtZW50UGFyYW1zKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dERvY3VtZW50OiBhc1RleHREb2N1bWVudElkZW50aWZpZXIoZXZlbnQuZG9jdW1lbnQpLFxyXG4gICAgICAgICAgICByZWFzb246IGFzVGV4dERvY3VtZW50U2F2ZVJlYXNvbihldmVudC5yZWFzb24pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXModGV4dERvY3VtZW50LCBwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHREb2N1bWVudDogYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKHRleHREb2N1bWVudCksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhc1dvcmtlclBvc2l0aW9uKHBvc2l0aW9uKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1RyaWdnZXJLaW5kKHRyaWdnZXJLaW5kKSB7XHJcbiAgICAgICAgc3dpdGNoICh0cmlnZ2VyS2luZCkge1xyXG4gICAgICAgICAgICBjYXNlIGNvZGUuQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8uQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXI7XHJcbiAgICAgICAgICAgIGNhc2UgY29kZS5Db21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9uczpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5Db21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5Db21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvbXBsZXRpb25QYXJhbXModGV4dERvY3VtZW50LCBwb3NpdGlvbiwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHREb2N1bWVudDogYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKHRleHREb2N1bWVudCksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhc1dvcmtlclBvc2l0aW9uKHBvc2l0aW9uKSxcclxuICAgICAgICAgICAgY29udGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcktpbmQ6IGFzVHJpZ2dlcktpbmQoY29udGV4dC50cmlnZ2VyS2luZCksXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyOiBjb250ZXh0LnRyaWdnZXJDaGFyYWN0ZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1dvcmtlclBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbGluZTogcG9zaXRpb24ubGluZSwgY2hhcmFjdGVyOiBwb3NpdGlvbi5jaGFyYWN0ZXIgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUG9zaXRpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbGluZTogdmFsdWUubGluZSwgY2hhcmFjdGVyOiB2YWx1ZS5jaGFyYWN0ZXIgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUmFuZ2UodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBhc1Bvc2l0aW9uKHZhbHVlLnN0YXJ0KSwgZW5kOiBhc1Bvc2l0aW9uKHZhbHVlLmVuZCkgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRGlhZ25vc3RpY1NldmVyaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIGNvZGUuRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLkRpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcclxuICAgICAgICAgICAgY2FzZSBjb2RlLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xyXG4gICAgICAgICAgICBjYXNlIGNvZGUuRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLkRpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbjtcclxuICAgICAgICAgICAgY2FzZSBjb2RlLkRpYWdub3N0aWNTZXZlcml0eS5IaW50OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLkRpYWdub3N0aWNTZXZlcml0eS5IaW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRGlhZ25vc3RpYyhpdGVtKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHByb3RvLkRpYWdub3N0aWMuY3JlYXRlKGFzUmFuZ2UoaXRlbS5yYW5nZSksIGl0ZW0ubWVzc2FnZSk7XHJcbiAgICAgICAgaWYgKElzLm51bWJlcihpdGVtLnNldmVyaXR5KSkge1xyXG4gICAgICAgICAgICByZXN1bHQuc2V2ZXJpdHkgPSBhc0RpYWdub3N0aWNTZXZlcml0eShpdGVtLnNldmVyaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKElzLm51bWJlcihpdGVtLmNvZGUpIHx8IElzLnN0cmluZyhpdGVtLmNvZGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gaXRlbS5jb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5zb3VyY2UpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IGl0ZW0uc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEaWFnbm9zdGljcyhpdGVtcykge1xyXG4gICAgICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwIHx8IGl0ZW1zID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChhc0RpYWdub3N0aWMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEb2N1bWVudGF0aW9uKGZvcm1hdCwgZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJyRzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb247XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG8uTWFya3VwS2luZC5QbGFpblRleHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiBmb3JtYXQsIHZhbHVlOiBkb2N1bWVudGF0aW9uIH07XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG8uTWFya3VwS2luZC5NYXJrZG93bjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IGZvcm1hdCwgdmFsdWU6IGRvY3VtZW50YXRpb24udmFsdWUgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgVW5zdXBwb3J0ZWQgTWFya3VwIGNvbnRlbnQgcmVjZWl2ZWQuIEtpbmQgaXM6ICR7Zm9ybWF0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb21wbGV0aW9uSXRlbUtpbmQodmFsdWUsIG9yaWdpbmFsKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUgKyAxO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb21wbGV0aW9uSXRlbShpdGVtKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgbGFiZWw6IGl0ZW0ubGFiZWwgfTtcclxuICAgICAgICBsZXQgcHJvdG9jb2xJdGVtID0gaXRlbSBpbnN0YW5jZW9mIHByb3RvY29sQ29tcGxldGlvbkl0ZW1fMS5kZWZhdWx0ID8gaXRlbSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoaXRlbS5kZXRhaWwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRldGFpbCA9IGl0ZW0uZGV0YWlsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBvbmx5IHNlbmQgaXRlbXMgYmFjayB3ZSBjcmVhdGVkLiBTbyB0aGlzIGNhbid0IGJlIHNvbWV0aGluZyBlbHNlIHRoYW5cclxuICAgICAgICAvLyBhIHN0cmluZyByaWdodCBub3cuXHJcbiAgICAgICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIXByb3RvY29sSXRlbSB8fCBwcm90b2NvbEl0ZW0uZG9jdW1lbnRhdGlvbkZvcm1hdCA9PT0gJyRzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGl0ZW0uZG9jdW1lbnRhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gYXNEb2N1bWVudGF0aW9uKHByb3RvY29sSXRlbS5kb2N1bWVudGF0aW9uRm9ybWF0LCBpdGVtLmRvY3VtZW50YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmZpbHRlclRleHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmZpbHRlclRleHQgPSBpdGVtLmZpbHRlclRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbGxQcmltYXJ5SW5zZXJ0VGV4dChyZXN1bHQsIGl0ZW0pO1xyXG4gICAgICAgIGlmIChJcy5udW1iZXIoaXRlbS5raW5kKSkge1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGFzQ29tcGxldGlvbkl0ZW1LaW5kKGl0ZW0ua2luZCwgcHJvdG9jb2xJdGVtICYmIHByb3RvY29sSXRlbS5vcmlnaW5hbEl0ZW1LaW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uc29ydFRleHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNvcnRUZXh0ID0gaXRlbS5zb3J0VGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uYWRkaXRpb25hbFRleHRFZGl0cykge1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkaXRpb25hbFRleHRFZGl0cyA9IGFzVGV4dEVkaXRzKGl0ZW0uYWRkaXRpb25hbFRleHRFZGl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmNvbW1pdENoYXJhY3RlcnMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNvbW1pdENoYXJhY3RlcnMgPSBpdGVtLmNvbW1pdENoYXJhY3RlcnMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uY29tbWFuZCkge1xyXG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGFzQ29tbWFuZChpdGVtLmNvbW1hbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5wcmVzZWxlY3QgPT09IHRydWUgfHwgaXRlbS5wcmVzZWxlY3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wcmVzZWxlY3QgPSBpdGVtLnByZXNlbGVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3RvY29sSXRlbSkge1xyXG4gICAgICAgICAgICBpZiAocHJvdG9jb2xJdGVtLmRhdGEgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBwcm90b2NvbEl0ZW0uZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvdG9jb2xJdGVtLmRlcHJlY2F0ZWQgPT09IHRydWUgfHwgcHJvdG9jb2xJdGVtLmRlcHJlY2F0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZGVwcmVjYXRlZCA9IHByb3RvY29sSXRlbS5kZXByZWNhdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWxsUHJpbWFyeUluc2VydFRleHQodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgICAgICBsZXQgZm9ybWF0ID0gcHJvdG8uSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQ7XHJcbiAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChzb3VyY2UudGV4dEVkaXQpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHNvdXJjZS50ZXh0RWRpdC5uZXdUZXh0O1xyXG4gICAgICAgICAgICByYW5nZSA9IGFzUmFuZ2Uoc291cmNlLnRleHRFZGl0LnJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc291cmNlLmluc2VydFRleHQgaW5zdGFuY2VvZiBjb2RlLlNuaXBwZXRTdHJpbmcpIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gcHJvdG8uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0O1xyXG4gICAgICAgICAgICB0ZXh0ID0gc291cmNlLmluc2VydFRleHQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gc291cmNlLmluc2VydFRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzb3VyY2UucmFuZ2UpIHtcclxuICAgICAgICAgICAgcmFuZ2UgPSBhc1JhbmdlKHNvdXJjZS5yYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldC5pbnNlcnRUZXh0Rm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgIGlmIChzb3VyY2UuZnJvbUVkaXQgJiYgdGV4dCAmJiByYW5nZSkge1xyXG4gICAgICAgICAgICB0YXJnZXQudGV4dEVkaXQgPSB7IG5ld1RleHQ6IHRleHQsIHJhbmdlOiByYW5nZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0Lmluc2VydFRleHQgPSB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzVGV4dEVkaXQoZWRpdCkge1xyXG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBhc1JhbmdlKGVkaXQucmFuZ2UpLCBuZXdUZXh0OiBlZGl0Lm5ld1RleHQgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzVGV4dEVkaXRzKGVkaXRzKSB7XHJcbiAgICAgICAgaWYgKGVkaXRzID09PSB2b2lkIDAgfHwgZWRpdHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVkaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWRpdHMubWFwKGFzVGV4dEVkaXQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSZWZlcmVuY2VQYXJhbXModGV4dERvY3VtZW50LCBwb3NpdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHREb2N1bWVudDogYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKHRleHREb2N1bWVudCksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhc1dvcmtlclBvc2l0aW9uKHBvc2l0aW9uKSxcclxuICAgICAgICAgICAgY29udGV4dDogeyBpbmNsdWRlRGVjbGFyYXRpb246IG9wdGlvbnMuaW5jbHVkZURlY2xhcmF0aW9uIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb2RlQWN0aW9uQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCB8fCBjb250ZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvdG8uQ29kZUFjdGlvbkNvbnRleHQuY3JlYXRlKGFzRGlhZ25vc3RpY3MoY29udGV4dC5kaWFnbm9zdGljcyksIElzLnN0cmluZyhjb250ZXh0Lm9ubHkpID8gW2NvbnRleHQub25seV0gOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb21tYW5kKGl0ZW0pIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gcHJvdG8uQ29tbWFuZC5jcmVhdGUoaXRlbS50aXRsZSwgaXRlbS5jb21tYW5kKTtcclxuICAgICAgICBpZiAoaXRlbS5hcmd1bWVudHMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGl0ZW0uYXJndW1lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb2RlTGVucyhpdGVtKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHByb3RvLkNvZGVMZW5zLmNyZWF0ZShhc1JhbmdlKGl0ZW0ucmFuZ2UpKTtcclxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb21tYW5kID0gYXNDb21tYW5kKGl0ZW0uY29tbWFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgcHJvdG9jb2xDb2RlTGVuc18xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBpdGVtLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNGb3JtYXR0aW5nT3B0aW9ucyhpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZTogaXRlbS50YWJTaXplLCBpbnNlcnRTcGFjZXM6IGl0ZW0uaW5zZXJ0U3BhY2VzIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0RvY3VtZW50U3ltYm9sUGFyYW1zKHRleHREb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHREb2N1bWVudDogYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKHRleHREb2N1bWVudClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb2RlTGVuc1BhcmFtcyh0ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGFzVGV4dERvY3VtZW50SWRlbnRpZmllcih0ZXh0RG9jdW1lbnQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRG9jdW1lbnRMaW5rKGl0ZW0pIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gcHJvdG8uRG9jdW1lbnRMaW5rLmNyZWF0ZShhc1JhbmdlKGl0ZW0ucmFuZ2UpKTtcclxuICAgICAgICBpZiAoaXRlbS50YXJnZXQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnRhcmdldCA9IGFzVXJpKGl0ZW0udGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHByb3RvY29sSXRlbSA9IGl0ZW0gaW5zdGFuY2VvZiBwcm90b2NvbERvY3VtZW50TGlua18xLmRlZmF1bHQgPyBpdGVtIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChwcm90b2NvbEl0ZW0gJiYgcHJvdG9jb2xJdGVtLmRhdGEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBwcm90b2NvbEl0ZW0uZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRG9jdW1lbnRMaW5rUGFyYW1zKHRleHREb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHREb2N1bWVudDogYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKHRleHREb2N1bWVudClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhc1VyaSxcclxuICAgICAgICBhc1RleHREb2N1bWVudElkZW50aWZpZXIsXHJcbiAgICAgICAgYXNPcGVuVGV4dERvY3VtZW50UGFyYW1zLFxyXG4gICAgICAgIGFzQ2hhbmdlVGV4dERvY3VtZW50UGFyYW1zLFxyXG4gICAgICAgIGFzQ2xvc2VUZXh0RG9jdW1lbnRQYXJhbXMsXHJcbiAgICAgICAgYXNTYXZlVGV4dERvY3VtZW50UGFyYW1zLFxyXG4gICAgICAgIGFzV2lsbFNhdmVUZXh0RG9jdW1lbnRQYXJhbXMsXHJcbiAgICAgICAgYXNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyxcclxuICAgICAgICBhc0NvbXBsZXRpb25QYXJhbXMsXHJcbiAgICAgICAgYXNXb3JrZXJQb3NpdGlvbixcclxuICAgICAgICBhc1JhbmdlLFxyXG4gICAgICAgIGFzUG9zaXRpb24sXHJcbiAgICAgICAgYXNEaWFnbm9zdGljU2V2ZXJpdHksXHJcbiAgICAgICAgYXNEaWFnbm9zdGljLFxyXG4gICAgICAgIGFzRGlhZ25vc3RpY3MsXHJcbiAgICAgICAgYXNDb21wbGV0aW9uSXRlbSxcclxuICAgICAgICBhc1RleHRFZGl0LFxyXG4gICAgICAgIGFzUmVmZXJlbmNlUGFyYW1zLFxyXG4gICAgICAgIGFzQ29kZUFjdGlvbkNvbnRleHQsXHJcbiAgICAgICAgYXNDb21tYW5kLFxyXG4gICAgICAgIGFzQ29kZUxlbnMsXHJcbiAgICAgICAgYXNGb3JtYXR0aW5nT3B0aW9ucyxcclxuICAgICAgICBhc0RvY3VtZW50U3ltYm9sUGFyYW1zLFxyXG4gICAgICAgIGFzQ29kZUxlbnNQYXJhbXMsXHJcbiAgICAgICAgYXNEb2N1bWVudExpbmssXHJcbiAgICAgICAgYXNEb2N1bWVudExpbmtQYXJhbXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVDb252ZXJ0ZXIgPSBjcmVhdGVDb252ZXJ0ZXI7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/codeConverter.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/colorProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/colorProvider.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\");\r\nfunction ensure(target, key) {\r\n    if (target[key] === void 0) {\r\n        target[key] = {};\r\n    }\r\n    return target[key];\r\n}\r\nclass ColorProviderFeature extends client_1.TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'colorProvider').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.colorProvider) {\r\n            return;\r\n        }\r\n        const implCapabilities = capabilities.colorProvider;\r\n        const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();\r\n        const selector = implCapabilities.documentSelector || documentSelector;\r\n        if (selector) {\r\n            this.register(this.messages, {\r\n                id,\r\n                registerOptions: Object.assign({}, { documentSelector: selector })\r\n            });\r\n        }\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideColorPresentations = (color, context, token) => {\r\n            const requestParams = {\r\n                color,\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),\r\n                range: client.code2ProtocolConverter.asRange(context.range)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(this.asColorPresentations.bind(this), (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let provideDocumentColors = (document, token) => {\r\n            const requestParams = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(this.asColorInformations.bind(this), (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerColorProvider(options.documentSelector, {\r\n            provideColorPresentations: (color, context, token) => {\r\n                return middleware.provideColorPresentations\r\n                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)\r\n                    : provideColorPresentations(color, context, token);\r\n            },\r\n            provideDocumentColors: (document, token) => {\r\n                return middleware.provideDocumentColors\r\n                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)\r\n                    : provideDocumentColors(document, token);\r\n            }\r\n        });\r\n    }\r\n    asColor(color) {\r\n        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);\r\n    }\r\n    asColorInformations(colorInformation) {\r\n        if (Array.isArray(colorInformation)) {\r\n            return colorInformation.map(ci => {\r\n                return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n    asColorPresentations(colorPresentations) {\r\n        if (Array.isArray(colorPresentations)) {\r\n            return colorPresentations.map(cp => {\r\n                let presentation = new vscode_1.ColorPresentation(cp.label);\r\n                presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);\r\n                presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);\r\n                return presentation;\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n}\r\nexports.ColorProviderFeature = ColorProviderFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9jb2xvclByb3ZpZGVyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL2NvbG9yUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVVVJRCA9IHJlcXVpcmUoXCIuL3V0aWxzL3V1aWRcIik7XHJcbmNvbnN0IElzID0gcmVxdWlyZShcIi4vdXRpbHMvaXNcIik7XHJcbmNvbnN0IHZzY29kZV8xID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEgPSByZXF1aXJlKFwidnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sXCIpO1xyXG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcclxuZnVuY3Rpb24gZW5zdXJlKHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAodGFyZ2V0W2tleV0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbn1cclxuY2xhc3MgQ29sb3JQcm92aWRlckZlYXR1cmUgZXh0ZW5kcyBjbGllbnRfMS5UZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSk7XHJcbiAgICB9XHJcbiAgICBmaWxsQ2xpZW50Q2FwYWJpbGl0aWVzKGNhcGFiaWxpdGVzKSB7XHJcbiAgICAgICAgZW5zdXJlKGVuc3VyZShjYXBhYmlsaXRlcywgJ3RleHREb2N1bWVudCcpLCAnY29sb3JQcm92aWRlcicpLmR5bmFtaWNSZWdpc3RyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShjYXBhYmlsaXRpZXMsIGRvY3VtZW50U2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWNhcGFiaWxpdGllcy5jb2xvclByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1wbENhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcy5jb2xvclByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnN0IGlkID0gSXMuc3RyaW5nKGltcGxDYXBhYmlsaXRpZXMuaWQpICYmIGltcGxDYXBhYmlsaXRpZXMuaWQubGVuZ3RoID4gMCA/IGltcGxDYXBhYmlsaXRpZXMuaWQgOiBVVUlELmdlbmVyYXRlVXVpZCgpO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaW1wbENhcGFiaWxpdGllcy5kb2N1bWVudFNlbGVjdG9yIHx8IGRvY3VtZW50U2VsZWN0b3I7XHJcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3Rvcjogc2VsZWN0b3IgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlQ29sb3JQcmVzZW50YXRpb25zID0gKGNvbG9yLCBjb250ZXh0LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzVGV4dERvY3VtZW50SWRlbnRpZmllcihjb250ZXh0LmRvY3VtZW50KSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1JhbmdlKGNvbnRleHQucmFuZ2UpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0LnR5cGUsIHJlcXVlc3RQYXJhbXMsIHRva2VuKS50aGVuKHRoaXMuYXNDb2xvclByZXNlbnRhdGlvbnMuYmluZCh0aGlzKSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcHJvdmlkZURvY3VtZW50Q29sb3JzID0gKGRvY3VtZW50LCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudElkZW50aWZpZXIoZG9jdW1lbnQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2VuZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSwgcmVxdWVzdFBhcmFtcywgdG9rZW4pLnRoZW4odGhpcy5hc0NvbG9ySW5mb3JtYXRpb25zLmJpbmQodGhpcyksIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0LnR5cGUsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfMS5sYW5ndWFnZXMucmVnaXN0ZXJDb2xvclByb3ZpZGVyKG9wdGlvbnMuZG9jdW1lbnRTZWxlY3Rvciwge1xyXG4gICAgICAgICAgICBwcm92aWRlQ29sb3JQcmVzZW50YXRpb25zOiAoY29sb3IsIGNvbnRleHQsIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkZGxld2FyZS5wcm92aWRlQ29sb3JQcmVzZW50YXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLnByb3ZpZGVDb2xvclByZXNlbnRhdGlvbnMoY29sb3IsIGNvbnRleHQsIHRva2VuLCBwcm92aWRlQ29sb3JQcmVzZW50YXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZUNvbG9yUHJlc2VudGF0aW9ucyhjb2xvciwgY29udGV4dCwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm92aWRlRG9jdW1lbnRDb2xvcnM6IChkb2N1bWVudCwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVEb2N1bWVudENvbG9yc1xyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlRG9jdW1lbnRDb2xvcnMoZG9jdW1lbnQsIHRva2VuLCBwcm92aWRlRG9jdW1lbnRDb2xvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlRG9jdW1lbnRDb2xvcnMoZG9jdW1lbnQsIHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXNDb2xvcihjb2xvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgdnNjb2RlXzEuQ29sb3IoY29sb3IucmVkLCBjb2xvci5ncmVlbiwgY29sb3IuYmx1ZSwgY29sb3IuYWxwaGEpO1xyXG4gICAgfVxyXG4gICAgYXNDb2xvckluZm9ybWF0aW9ucyhjb2xvckluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JJbmZvcm1hdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9ySW5mb3JtYXRpb24ubWFwKGNpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdnNjb2RlXzEuQ29sb3JJbmZvcm1hdGlvbih0aGlzLl9jbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1JhbmdlKGNpLnJhbmdlKSwgdGhpcy5hc0NvbG9yKGNpLmNvbG9yKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBhc0NvbG9yUHJlc2VudGF0aW9ucyhjb2xvclByZXNlbnRhdGlvbnMpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvclByZXNlbnRhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvclByZXNlbnRhdGlvbnMubWFwKGNwID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwcmVzZW50YXRpb24gPSBuZXcgdnNjb2RlXzEuQ29sb3JQcmVzZW50YXRpb24oY3AubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgcHJlc2VudGF0aW9uLmFkZGl0aW9uYWxUZXh0RWRpdHMgPSB0aGlzLl9jbGllbnQucHJvdG9jb2wyQ29kZUNvbnZlcnRlci5hc1RleHRFZGl0cyhjcC5hZGRpdGlvbmFsVGV4dEVkaXRzKTtcclxuICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbi50ZXh0RWRpdCA9IHRoaXMuX2NsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzVGV4dEVkaXQoY3AudGV4dEVkaXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbnRhdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbG9yUHJvdmlkZXJGZWF0dXJlID0gQ29sb3JQcm92aWRlckZlYXR1cmU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/colorProvider.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/configuration.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/configuration.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nclass ConfigurationFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        capabilities.workspace = capabilities.workspace || {};\r\n        capabilities.workspace.configuration = true;\r\n    }\r\n    initialize() {\r\n        let client = this._client;\r\n        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {\r\n            let configuration = (params) => {\r\n                let result = [];\r\n                for (let item of params.items) {\r\n                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;\r\n                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));\r\n                }\r\n                return result;\r\n            };\r\n            let middleware = client.clientOptions.middleware.workspace;\r\n            return middleware && middleware.configuration\r\n                ? middleware.configuration(params, token, configuration)\r\n                : configuration(params, token);\r\n        });\r\n    }\r\n    getConfiguration(resource, section) {\r\n        let result = null;\r\n        if (section) {\r\n            let index = section.lastIndexOf('.');\r\n            if (index === -1) {\r\n                result = vscode_1.workspace.getConfiguration(undefined, resource).get(section);\r\n            }\r\n            else {\r\n                let config = vscode_1.workspace.getConfiguration(section.substr(0, index));\r\n                if (config) {\r\n                    result = config.get(section.substr(index + 1));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            let config = vscode_1.workspace.getConfiguration(undefined, resource);\r\n            result = {};\r\n            for (let key of Object.keys(config)) {\r\n                if (config.has(key)) {\r\n                    result[key] = config.get(key);\r\n                }\r\n            }\r\n        }\r\n        if (!result) {\r\n            return null;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.ConfigurationFeature = ConfigurationFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9jb25maWd1cmF0aW9uLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL2NvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2xcIik7XHJcbmNsYXNzIENvbmZpZ3VyYXRpb25GZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKF9jbGllbnQpIHtcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBfY2xpZW50O1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpIHtcclxuICAgICAgICBjYXBhYmlsaXRpZXMud29ya3NwYWNlID0gY2FwYWJpbGl0aWVzLndvcmtzcGFjZSB8fCB7fTtcclxuICAgICAgICBjYXBhYmlsaXRpZXMud29ya3NwYWNlLmNvbmZpZ3VyYXRpb24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGNsaWVudC5vblJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuQ29uZmlndXJhdGlvblJlcXVlc3QudHlwZSwgKHBhcmFtcywgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHBhcmFtcy5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IGl0ZW0uc2NvcGVVcmkgIT09IHZvaWQgMCAmJiBpdGVtLnNjb3BlVXJpICE9PSBudWxsID8gdGhpcy5fY2xpZW50LnByb3RvY29sMkNvZGVDb252ZXJ0ZXIuYXNVcmkoaXRlbS5zY29wZVVyaSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZXRDb25maWd1cmF0aW9uKHJlc291cmNlLCBpdGVtLnNlY3Rpb24gIT09IG51bGwgPyBpdGVtLnNlY3Rpb24gOiB1bmRlZmluZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZS53b3Jrc3BhY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlICYmIG1pZGRsZXdhcmUuY29uZmlndXJhdGlvblxyXG4gICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLmNvbmZpZ3VyYXRpb24ocGFyYW1zLCB0b2tlbiwgY29uZmlndXJhdGlvbilcclxuICAgICAgICAgICAgICAgIDogY29uZmlndXJhdGlvbihwYXJhbXMsIHRva2VuKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENvbmZpZ3VyYXRpb24ocmVzb3VyY2UsIHNlY3Rpb24pIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBpZiAoc2VjdGlvbikge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBzZWN0aW9uLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZzY29kZV8xLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKHVuZGVmaW5lZCwgcmVzb3VyY2UpLmdldChzZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSB2c2NvZGVfMS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihzZWN0aW9uLnN1YnN0cigwLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbmZpZy5nZXQoc2VjdGlvbi5zdWJzdHIoaW5kZXggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSB2c2NvZGVfMS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbih1bmRlZmluZWQsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb25maWcuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db25maWd1cmF0aW9uRmVhdHVyZSA9IENvbmZpZ3VyYXRpb25GZWF0dXJlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/configuration.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/foldingRange.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/foldingRange.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\");\r\nfunction ensure(target, key) {\r\n    if (target[key] === void 0) {\r\n        target[key] = {};\r\n    }\r\n    return target[key];\r\n}\r\nclass FoldingRangeFeature extends client_1.TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        let capability = ensure(ensure(capabilites, 'textDocument'), 'foldingRange');\r\n        capability.dynamicRegistration = true;\r\n        capability.rangeLimit = 5000;\r\n        capability.lineFoldingOnly = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.foldingRangeProvider) {\r\n            return;\r\n        }\r\n        const implCapabilities = capabilities.foldingRangeProvider;\r\n        const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();\r\n        const selector = implCapabilities.documentSelector || documentSelector;\r\n        if (selector) {\r\n            this.register(this.messages, {\r\n                id,\r\n                registerOptions: Object.assign({}, { documentSelector: selector })\r\n            });\r\n        }\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideFoldingRanges = (document, _, token) => {\r\n            const requestParams = {\r\n                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)\r\n            };\r\n            return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(this.asFoldingRanges.bind(this), (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, {\r\n            provideFoldingRanges(document, context, token) {\r\n                return middleware.provideFoldingRanges\r\n                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)\r\n                    : provideFoldingRanges(document, context, token);\r\n            }\r\n        });\r\n    }\r\n    asFoldingRangeKind(kind) {\r\n        if (kind) {\r\n            switch (kind) {\r\n                case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:\r\n                    return vscode_1.FoldingRangeKind.Comment;\r\n                case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:\r\n                    return vscode_1.FoldingRangeKind.Imports;\r\n                case vscode_languageserver_protocol_1.FoldingRangeKind.Region:\r\n                    return vscode_1.FoldingRangeKind.Region;\r\n            }\r\n        }\r\n        return void 0;\r\n    }\r\n    asFoldingRanges(foldingRanges) {\r\n        if (Array.isArray(foldingRanges)) {\r\n            return foldingRanges.map(r => {\r\n                return new vscode_1.FoldingRange(r.startLine, r.endLine, this.asFoldingRangeKind(r.kind));\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n}\r\nexports.FoldingRangeFeature = FoldingRangeFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9mb2xkaW5nUmFuZ2UuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZWNsaWVudC9saWIvZm9sZGluZ1JhbmdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFVVSUQgPSByZXF1aXJlKFwiLi91dGlscy91dWlkXCIpO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xyXG5jb25zdCB2c2NvZGVfMSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xID0gcmVxdWlyZShcInZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbFwiKTtcclxuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XHJcbmZ1bmN0aW9uIGVuc3VyZSh0YXJnZXQsIGtleSkge1xyXG4gICAgaWYgKHRhcmdldFtrZXldID09PSB2b2lkIDApIHtcclxuICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG59XHJcbmNsYXNzIEZvbGRpbmdSYW5nZUZlYXR1cmUgZXh0ZW5kcyBjbGllbnRfMS5UZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRm9sZGluZ1JhbmdlUmVxdWVzdC50eXBlKTtcclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0ZXMpIHtcclxuICAgICAgICBsZXQgY2FwYWJpbGl0eSA9IGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ2ZvbGRpbmdSYW5nZScpO1xyXG4gICAgICAgIGNhcGFiaWxpdHkuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgY2FwYWJpbGl0eS5yYW5nZUxpbWl0ID0gNTAwMDtcclxuICAgICAgICBjYXBhYmlsaXR5LmxpbmVGb2xkaW5nT25seSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmZvbGRpbmdSYW5nZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1wbENhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcy5mb2xkaW5nUmFuZ2VQcm92aWRlcjtcclxuICAgICAgICBjb25zdCBpZCA9IElzLnN0cmluZyhpbXBsQ2FwYWJpbGl0aWVzLmlkKSAmJiBpbXBsQ2FwYWJpbGl0aWVzLmlkLmxlbmd0aCA+IDAgPyBpbXBsQ2FwYWJpbGl0aWVzLmlkIDogVVVJRC5nZW5lcmF0ZVV1aWQoKTtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGltcGxDYXBhYmlsaXRpZXMuZG9jdW1lbnRTZWxlY3RvciB8fCBkb2N1bWVudFNlbGVjdG9yO1xyXG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCB7IGRvY3VtZW50U2VsZWN0b3I6IHNlbGVjdG9yIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGFuZ3VhZ2VQcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBsZXQgcHJvdmlkZUZvbGRpbmdSYW5nZXMgPSAoZG9jdW1lbnQsIF8sIHRva2VuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IGNsaWVudC5jb2RlMlByb3RvY29sQ29udmVydGVyLmFzVGV4dERvY3VtZW50SWRlbnRpZmllcihkb2N1bWVudClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUsIHJlcXVlc3RQYXJhbXMsIHRva2VuKS50aGVuKHRoaXMuYXNGb2xkaW5nUmFuZ2VzLmJpbmQodGhpcyksIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LmxvZ0ZhaWxlZFJlcXVlc3QodnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRm9sZGluZ1JhbmdlUmVxdWVzdC50eXBlLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtaWRkbGV3YXJlID0gY2xpZW50LmNsaWVudE9wdGlvbnMubWlkZGxld2FyZTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlXzEubGFuZ3VhZ2VzLnJlZ2lzdGVyRm9sZGluZ1JhbmdlUHJvdmlkZXIob3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVGb2xkaW5nUmFuZ2VzKGRvY3VtZW50LCBjb250ZXh0LCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUucHJvdmlkZUZvbGRpbmdSYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUucHJvdmlkZUZvbGRpbmdSYW5nZXMoZG9jdW1lbnQsIGNvbnRleHQsIHRva2VuLCBwcm92aWRlRm9sZGluZ1JhbmdlcylcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVGb2xkaW5nUmFuZ2VzKGRvY3VtZW50LCBjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzRm9sZGluZ1JhbmdlS2luZChraW5kKSB7XHJcbiAgICAgICAgaWYgKGtpbmQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnNjb2RlXzEuRm9sZGluZ1JhbmdlS2luZC5Db21tZW50O1xyXG4gICAgICAgICAgICAgICAgY2FzZSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5Gb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZzY29kZV8xLkZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cztcclxuICAgICAgICAgICAgICAgIGNhc2UgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRm9sZGluZ1JhbmdlS2luZC5SZWdpb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZzY29kZV8xLkZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBhc0ZvbGRpbmdSYW5nZXMoZm9sZGluZ1Jhbmdlcykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRpbmdSYW5nZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb2xkaW5nUmFuZ2VzLm1hcChyID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdnNjb2RlXzEuRm9sZGluZ1JhbmdlKHIuc3RhcnRMaW5lLCByLmVuZExpbmUsIHRoaXMuYXNGb2xkaW5nUmFuZ2VLaW5kKHIua2luZCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRm9sZGluZ1JhbmdlRmVhdHVyZSA9IEZvbGRpbmdSYW5nZUZlYXR1cmU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/foldingRange.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/implementation.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/implementation.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\");\r\nfunction ensure(target, key) {\r\n    if (target[key] === void 0) {\r\n        target[key] = {};\r\n    }\r\n    return target[key];\r\n}\r\nclass ImplementationFeature extends client_1.TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'implementation').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.implementationProvider) {\r\n            return;\r\n        }\r\n        if (capabilities.implementationProvider === true) {\r\n            if (!documentSelector) {\r\n                return;\r\n            }\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n            });\r\n        }\r\n        else {\r\n            const implCapabilities = capabilities.implementationProvider;\r\n            const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();\r\n            const selector = implCapabilities.documentSelector || documentSelector;\r\n            if (selector) {\r\n                this.register(this.messages, {\r\n                    id,\r\n                    registerOptions: Object.assign({}, { documentSelector: selector })\r\n                });\r\n            }\r\n        }\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideImplementation = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerImplementationProvider(options.documentSelector, {\r\n            provideImplementation: (document, position, token) => {\r\n                return middleware.provideImplementation\r\n                    ? middleware.provideImplementation(document, position, token, provideImplementation)\r\n                    : provideImplementation(document, position, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.ImplementationFeature = ImplementationFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9pbXBsZW1lbnRhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9pbXBsZW1lbnRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBVVUlEID0gcmVxdWlyZShcIi4vdXRpbHMvdXVpZFwiKTtcclxuY29uc3QgSXMgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2xcIik7XHJcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xyXG5mdW5jdGlvbiBlbnN1cmUodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmICh0YXJnZXRba2V5XSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxufVxyXG5jbGFzcyBJbXBsZW1lbnRhdGlvbkZlYXR1cmUgZXh0ZW5kcyBjbGllbnRfMS5UZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ2ltcGxlbWVudGF0aW9uJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLmltcGxlbWVudGF0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLmltcGxlbWVudGF0aW9uUHJvdmlkZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW1wbENhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcy5pbXBsZW1lbnRhdGlvblByb3ZpZGVyO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IElzLnN0cmluZyhpbXBsQ2FwYWJpbGl0aWVzLmlkKSAmJiBpbXBsQ2FwYWJpbGl0aWVzLmlkLmxlbmd0aCA+IDAgPyBpbXBsQ2FwYWJpbGl0aWVzLmlkIDogVVVJRC5nZW5lcmF0ZVV1aWQoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBpbXBsQ2FwYWJpbGl0aWVzLmRvY3VtZW50U2VsZWN0b3IgfHwgZG9jdW1lbnRTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3Rvcjogc2VsZWN0b3IgfSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlSW1wbGVtZW50YXRpb24gPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLkltcGxlbWVudGF0aW9uUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGRvY3VtZW50LCBwb3NpdGlvbiksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRGVmaW5pdGlvblJlc3VsdCwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5JbXBsZW1lbnRhdGlvblJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWlkZGxld2FyZSA9IGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmU7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV8xLmxhbmd1YWdlcy5yZWdpc3RlckltcGxlbWVudGF0aW9uUHJvdmlkZXIob3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVJbXBsZW1lbnRhdGlvbjogKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVJbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlSW1wbGVtZW50YXRpb24oZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbiwgcHJvdmlkZUltcGxlbWVudGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZUltcGxlbWVudGF0aW9uKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JbXBsZW1lbnRhdGlvbkZlYXR1cmUgPSBJbXBsZW1lbnRhdGlvbkZlYXR1cmU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/implementation.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/main.js":
/*!********************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/main.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst SemVer = __webpack_require__(/*! semver */ \"./node_modules/vscode-languageclient/node_modules/semver/semver.js\");\r\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst colorProvider_1 = __webpack_require__(/*! ./colorProvider */ \"./node_modules/vscode-languageclient/lib/colorProvider.js\");\r\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./node_modules/vscode-languageclient/lib/configuration.js\");\r\nconst implementation_1 = __webpack_require__(/*! ./implementation */ \"./node_modules/vscode-languageclient/lib/implementation.js\");\r\nconst typeDefinition_1 = __webpack_require__(/*! ./typeDefinition */ \"./node_modules/vscode-languageclient/lib/typeDefinition.js\");\r\nconst workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ \"./node_modules/vscode-languageclient/lib/workspaceFolders.js\");\r\nconst foldingRange_1 = __webpack_require__(/*! ./foldingRange */ \"./node_modules/vscode-languageclient/lib/foldingRange.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst processes_1 = __webpack_require__(/*! ./utils/processes */ \"./node_modules/vscode-languageclient/lib/utils/processes.js\");\r\n__export(__webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\"));\r\nconst REQUIRED_VSCODE_VERSION = '^1.26'; // do not change format, updated by `updateVSCode` script\r\nvar Executable;\r\n(function (Executable) {\r\n    function is(value) {\r\n        return Is.string(value.command);\r\n    }\r\n    Executable.is = is;\r\n})(Executable || (Executable = {}));\r\nvar TransportKind;\r\n(function (TransportKind) {\r\n    TransportKind[TransportKind[\"stdio\"] = 0] = \"stdio\";\r\n    TransportKind[TransportKind[\"ipc\"] = 1] = \"ipc\";\r\n    TransportKind[TransportKind[\"pipe\"] = 2] = \"pipe\";\r\n    TransportKind[TransportKind[\"socket\"] = 3] = \"socket\";\r\n})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));\r\nvar Transport;\r\n(function (Transport) {\r\n    function isSocket(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);\r\n    }\r\n    Transport.isSocket = isSocket;\r\n})(Transport || (Transport = {}));\r\nvar NodeModule;\r\n(function (NodeModule) {\r\n    function is(value) {\r\n        return Is.string(value.module);\r\n    }\r\n    NodeModule.is = is;\r\n})(NodeModule || (NodeModule = {}));\r\nvar StreamInfo;\r\n(function (StreamInfo) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;\r\n    }\r\n    StreamInfo.is = is;\r\n})(StreamInfo || (StreamInfo = {}));\r\nvar ChildProcessInfo;\r\n(function (ChildProcessInfo) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.process !== void 0 && typeof candidate.detached === 'boolean';\r\n    }\r\n    ChildProcessInfo.is = is;\r\n})(ChildProcessInfo || (ChildProcessInfo = {}));\r\nclass LanguageClient extends client_1.BaseLanguageClient {\r\n    constructor(arg1, arg2, arg3, arg4, arg5) {\r\n        let id;\r\n        let name;\r\n        let serverOptions;\r\n        let clientOptions;\r\n        let forceDebug;\r\n        if (Is.string(arg2)) {\r\n            id = arg1;\r\n            name = arg2;\r\n            serverOptions = arg3;\r\n            clientOptions = arg4;\r\n            forceDebug = !!arg5;\r\n        }\r\n        else {\r\n            id = arg1.toLowerCase();\r\n            name = arg1;\r\n            serverOptions = arg2;\r\n            clientOptions = arg3;\r\n            forceDebug = arg4;\r\n        }\r\n        if (forceDebug === void 0) {\r\n            forceDebug = false;\r\n        }\r\n        super(id, name, clientOptions);\r\n        this._serverOptions = serverOptions;\r\n        this._forceDebug = forceDebug;\r\n        try {\r\n            this.checkVersion();\r\n        }\r\n        catch (error) {\r\n            if (Is.string(error.message)) {\r\n                this.outputChannel.appendLine(error.message);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    checkVersion() {\r\n        let codeVersion = SemVer.parse(vscode_1.version);\r\n        if (!codeVersion) {\r\n            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);\r\n        }\r\n        // Remove the insider pre-release since we stay API compatible.\r\n        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {\r\n            codeVersion.prerelease = [];\r\n        }\r\n        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {\r\n            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);\r\n        }\r\n    }\r\n    stop() {\r\n        return super.stop().then(() => {\r\n            if (this._serverProcess) {\r\n                let toCheck = this._serverProcess;\r\n                this._serverProcess = undefined;\r\n                if (this._isDetached === void 0 || !this._isDetached) {\r\n                    this.checkProcessDied(toCheck);\r\n                }\r\n                this._isDetached = undefined;\r\n            }\r\n        });\r\n    }\r\n    checkProcessDied(childProcess) {\r\n        if (!childProcess) {\r\n            return;\r\n        }\r\n        setTimeout(() => {\r\n            // Test if the process is still alive. Throws an exception if not\r\n            try {\r\n                process.kill(childProcess.pid, 0);\r\n                processes_1.terminate(childProcess);\r\n            }\r\n            catch (error) {\r\n                // All is fine.\r\n            }\r\n        }, 2000);\r\n    }\r\n    handleConnectionClosed() {\r\n        this._serverProcess = undefined;\r\n        super.handleConnectionClosed();\r\n    }\r\n    createMessageTransports(encoding) {\r\n        function getEnvironment(env) {\r\n            if (!env) {\r\n                return process.env;\r\n            }\r\n            let result = Object.create(null);\r\n            Object.keys(process.env).forEach(key => result[key] = process.env[key]);\r\n            Object.keys(env).forEach(key => result[key] = env[key]);\r\n            return result;\r\n        }\r\n        function startedInDebugMode() {\r\n            let args = process.execArgv;\r\n            if (args) {\r\n                return args.some((arg) => /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg) || /^--inspect=?/.test(arg) || /^--inspect-brk=?/.test(arg));\r\n            }\r\n            ;\r\n            return false;\r\n        }\r\n        let server = this._serverOptions;\r\n        // We got a function.\r\n        if (Is.func(server)) {\r\n            return server().then((result) => {\r\n                if (client_1.MessageTransports.is(result)) {\r\n                    this._isDetached = !!result.detached;\r\n                    return result;\r\n                }\r\n                else if (StreamInfo.is(result)) {\r\n                    this._isDetached = !!result.detached;\r\n                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer) };\r\n                }\r\n                else {\r\n                    let cp;\r\n                    if (ChildProcessInfo.is(result)) {\r\n                        cp = result.process;\r\n                        this._isDetached = result.detached;\r\n                    }\r\n                    else {\r\n                        cp = result;\r\n                        this._isDetached = false;\r\n                    }\r\n                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp.stdin) };\r\n                }\r\n            });\r\n        }\r\n        let json;\r\n        let runDebug = server;\r\n        if (runDebug.run || runDebug.debug) {\r\n            // We are under debugging. So use debug as well.\r\n            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {\r\n                json = runDebug.debug;\r\n            }\r\n            else {\r\n                json = runDebug.run;\r\n            }\r\n        }\r\n        else {\r\n            json = server;\r\n        }\r\n        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {\r\n            if (NodeModule.is(json) && json.module) {\r\n                let node = json;\r\n                let transport = node.transport || TransportKind.stdio;\r\n                if (node.runtime) {\r\n                    let args = [];\r\n                    let options = node.options || Object.create(null);\r\n                    if (options.execArgv) {\r\n                        options.execArgv.forEach(element => args.push(element));\r\n                    }\r\n                    args.push(node.module);\r\n                    if (node.args) {\r\n                        node.args.forEach(element => args.push(element));\r\n                    }\r\n                    let execOptions = Object.create(null);\r\n                    execOptions.cwd = serverWorkingDir;\r\n                    execOptions.env = getEnvironment(options.env);\r\n                    let pipeName = undefined;\r\n                    if (transport === TransportKind.ipc) {\r\n                        // exec options not correctly typed in lib\r\n                        execOptions.stdio = [null, null, null, 'ipc'];\r\n                        args.push('--node-ipc');\r\n                    }\r\n                    else if (transport === TransportKind.stdio) {\r\n                        args.push('--stdio');\r\n                    }\r\n                    else if (transport === TransportKind.pipe) {\r\n                        pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();\r\n                        args.push(`--pipe=${pipeName}`);\r\n                    }\r\n                    else if (Transport.isSocket(transport)) {\r\n                        args.push(`--socket=${transport.port}`);\r\n                    }\r\n                    args.push(`--clientProcessId=${process.pid.toString()}`);\r\n                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {\r\n                        let serverProcess = cp.spawn(node.runtime, args, execOptions);\r\n                        if (!serverProcess || !serverProcess.pid) {\r\n                            return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);\r\n                        }\r\n                        this._serverProcess = serverProcess;\r\n                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                        if (transport === TransportKind.ipc) {\r\n                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess) });\r\n                        }\r\n                        else {\r\n                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });\r\n                        }\r\n                    }\r\n                    else if (transport == TransportKind.pipe) {\r\n                        return vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {\r\n                            let process = cp.spawn(node.runtime, args, execOptions);\r\n                            if (!process || !process.pid) {\r\n                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);\r\n                            }\r\n                            this._serverProcess = process;\r\n                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            return transport.onConnected().then((protocol) => {\r\n                                return { reader: protocol[0], writer: protocol[1] };\r\n                            });\r\n                        });\r\n                    }\r\n                    else if (Transport.isSocket(transport)) {\r\n                        return vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {\r\n                            let process = cp.spawn(node.runtime, args, execOptions);\r\n                            if (!process || !process.pid) {\r\n                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);\r\n                            }\r\n                            this._serverProcess = process;\r\n                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            return transport.onConnected().then((protocol) => {\r\n                                return { reader: protocol[0], writer: protocol[1] };\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    let pipeName = undefined;\r\n                    return new Promise((resolve, _reject) => {\r\n                        let args = node.args && node.args.slice() || [];\r\n                        if (transport === TransportKind.ipc) {\r\n                            args.push('--node-ipc');\r\n                        }\r\n                        else if (transport === TransportKind.stdio) {\r\n                            args.push('--stdio');\r\n                        }\r\n                        else if (transport === TransportKind.pipe) {\r\n                            pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();\r\n                            args.push(`--pipe=${pipeName}`);\r\n                        }\r\n                        else if (Transport.isSocket(transport)) {\r\n                            args.push(`--socket=${transport.port}`);\r\n                        }\r\n                        args.push(`--clientProcessId=${process.pid.toString()}`);\r\n                        let options = node.options || Object.create(null);\r\n                        options.execArgv = options.execArgv || [];\r\n                        options.cwd = serverWorkingDir;\r\n                        options.silent = true;\r\n                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {\r\n                            let sp = cp.fork(node.module, args || [], options);\r\n                            this._serverProcess = sp;\r\n                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                            if (transport === TransportKind.ipc) {\r\n                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                                resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(this._serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(this._serverProcess) });\r\n                            }\r\n                            else {\r\n                                resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(sp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(sp.stdin) });\r\n                            }\r\n                        }\r\n                        else if (transport === TransportKind.pipe) {\r\n                            vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {\r\n                                let sp = cp.fork(node.module, args || [], options);\r\n                                this._serverProcess = sp;\r\n                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                                transport.onConnected().then((protocol) => {\r\n                                    resolve({ reader: protocol[0], writer: protocol[1] });\r\n                                });\r\n                            });\r\n                        }\r\n                        else if (Transport.isSocket(transport)) {\r\n                            vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {\r\n                                let sp = cp.fork(node.module, args || [], options);\r\n                                this._serverProcess = sp;\r\n                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                                transport.onConnected().then((protocol) => {\r\n                                    resolve({ reader: protocol[0], writer: protocol[1] });\r\n                                });\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else if (Executable.is(json) && json.command) {\r\n                let command = json;\r\n                let args = command.args || [];\r\n                let options = Object.assign({}, command.options);\r\n                options.cwd = options.cwd || serverWorkingDir;\r\n                let serverProcess = cp.spawn(command.command, args, options);\r\n                if (!serverProcess || !serverProcess.pid) {\r\n                    return Promise.reject(`Launching server using command ${command.command} failed.`);\r\n                }\r\n                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));\r\n                this._serverProcess = serverProcess;\r\n                this._isDetached = !!options.detached;\r\n                return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });\r\n            }\r\n            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));\r\n        });\r\n    }\r\n    registerProposedFeatures() {\r\n        this.registerFeatures(ProposedFeatures.createAll(this));\r\n    }\r\n    registerBuiltinFeatures() {\r\n        super.registerBuiltinFeatures();\r\n        this.registerFeature(new configuration_1.ConfigurationFeature(this));\r\n        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));\r\n        this.registerFeature(new implementation_1.ImplementationFeature(this));\r\n        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));\r\n        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));\r\n        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));\r\n    }\r\n    _mainGetRootPath() {\r\n        let folders = vscode_1.workspace.workspaceFolders;\r\n        if (!folders || folders.length === 0) {\r\n            return undefined;\r\n        }\r\n        let folder = folders[0];\r\n        if (folder.uri.scheme === 'file') {\r\n            return folder.uri.fsPath;\r\n        }\r\n        return undefined;\r\n    }\r\n    _getServerWorkingDir(options) {\r\n        let cwd = options && options.cwd;\r\n        if (!cwd) {\r\n            cwd = this.clientOptions.workspaceFolder\r\n                ? this.clientOptions.workspaceFolder.uri.fsPath\r\n                : this._mainGetRootPath();\r\n        }\r\n        if (cwd) {\r\n            // make sure the folder exists otherwise creating the process will fail\r\n            return new Promise(s => {\r\n                fs.lstat(cwd, (err, stats) => {\r\n                    s(!err && stats.isDirectory() ? cwd : undefined);\r\n                });\r\n            });\r\n        }\r\n        return Promise.resolve(undefined);\r\n    }\r\n}\r\nexports.LanguageClient = LanguageClient;\r\nclass SettingMonitor {\r\n    constructor(_client, _setting) {\r\n        this._client = _client;\r\n        this._setting = _setting;\r\n        this._listeners = [];\r\n    }\r\n    start() {\r\n        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);\r\n        this.onDidChangeConfiguration();\r\n        return new vscode_1.Disposable(() => {\r\n            if (this._client.needsStop()) {\r\n                this._client.stop();\r\n            }\r\n        });\r\n    }\r\n    onDidChangeConfiguration() {\r\n        let index = this._setting.indexOf('.');\r\n        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;\r\n        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;\r\n        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);\r\n        if (enabled && this._client.needsStart()) {\r\n            this._client.start();\r\n        }\r\n        else if (!enabled && this._client.needsStop()) {\r\n            this._client.stop();\r\n        }\r\n    }\r\n}\r\nexports.SettingMonitor = SettingMonitor;\r\n// Exporting proposed protocol.\r\nvar ProposedFeatures;\r\n(function (ProposedFeatures) {\r\n    function createAll(_client) {\r\n        let result = [];\r\n        return result;\r\n    }\r\n    ProposedFeatures.createAll = createAll;\r\n})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9tYWluLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNwID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xyXG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2xcIik7XHJcbmNvbnN0IGNvbG9yUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2NvbG9yUHJvdmlkZXJcIik7XHJcbmNvbnN0IGNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb25cIik7XHJcbmNvbnN0IGltcGxlbWVudGF0aW9uXzEgPSByZXF1aXJlKFwiLi9pbXBsZW1lbnRhdGlvblwiKTtcclxuY29uc3QgdHlwZURlZmluaXRpb25fMSA9IHJlcXVpcmUoXCIuL3R5cGVEZWZpbml0aW9uXCIpO1xyXG5jb25zdCB3b3Jrc3BhY2VGb2xkZXJzXzEgPSByZXF1aXJlKFwiLi93b3Jrc3BhY2VGb2xkZXJzXCIpO1xyXG5jb25zdCBmb2xkaW5nUmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2ZvbGRpbmdSYW5nZVwiKTtcclxuY29uc3QgSXMgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcclxuY29uc3QgcHJvY2Vzc2VzXzEgPSByZXF1aXJlKFwiLi91dGlscy9wcm9jZXNzZXNcIik7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NsaWVudFwiKSk7XHJcbmNvbnN0IFJFUVVJUkVEX1ZTQ09ERV9WRVJTSU9OID0gJ14xLjI2JzsgLy8gZG8gbm90IGNoYW5nZSBmb3JtYXQsIHVwZGF0ZWQgYnkgYHVwZGF0ZVZTQ29kZWAgc2NyaXB0XHJcbnZhciBFeGVjdXRhYmxlO1xyXG4oZnVuY3Rpb24gKEV4ZWN1dGFibGUpIHtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyh2YWx1ZS5jb21tYW5kKTtcclxuICAgIH1cclxuICAgIEV4ZWN1dGFibGUuaXMgPSBpcztcclxufSkoRXhlY3V0YWJsZSB8fCAoRXhlY3V0YWJsZSA9IHt9KSk7XHJcbnZhciBUcmFuc3BvcnRLaW5kO1xyXG4oZnVuY3Rpb24gKFRyYW5zcG9ydEtpbmQpIHtcclxuICAgIFRyYW5zcG9ydEtpbmRbVHJhbnNwb3J0S2luZFtcInN0ZGlvXCJdID0gMF0gPSBcInN0ZGlvXCI7XHJcbiAgICBUcmFuc3BvcnRLaW5kW1RyYW5zcG9ydEtpbmRbXCJpcGNcIl0gPSAxXSA9IFwiaXBjXCI7XHJcbiAgICBUcmFuc3BvcnRLaW5kW1RyYW5zcG9ydEtpbmRbXCJwaXBlXCJdID0gMl0gPSBcInBpcGVcIjtcclxuICAgIFRyYW5zcG9ydEtpbmRbVHJhbnNwb3J0S2luZFtcInNvY2tldFwiXSA9IDNdID0gXCJzb2NrZXRcIjtcclxufSkoVHJhbnNwb3J0S2luZCA9IGV4cG9ydHMuVHJhbnNwb3J0S2luZCB8fCAoZXhwb3J0cy5UcmFuc3BvcnRLaW5kID0ge30pKTtcclxudmFyIFRyYW5zcG9ydDtcclxuKGZ1bmN0aW9uIChUcmFuc3BvcnQpIHtcclxuICAgIGZ1bmN0aW9uIGlzU29ja2V0KHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09IFRyYW5zcG9ydEtpbmQuc29ja2V0ICYmIElzLm51bWJlcihjYW5kaWRhdGUucG9ydCk7XHJcbiAgICB9XHJcbiAgICBUcmFuc3BvcnQuaXNTb2NrZXQgPSBpc1NvY2tldDtcclxufSkoVHJhbnNwb3J0IHx8IChUcmFuc3BvcnQgPSB7fSkpO1xyXG52YXIgTm9kZU1vZHVsZTtcclxuKGZ1bmN0aW9uIChOb2RlTW9kdWxlKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcodmFsdWUubW9kdWxlKTtcclxuICAgIH1cclxuICAgIE5vZGVNb2R1bGUuaXMgPSBpcztcclxufSkoTm9kZU1vZHVsZSB8fCAoTm9kZU1vZHVsZSA9IHt9KSk7XHJcbnZhciBTdHJlYW1JbmZvO1xyXG4oZnVuY3Rpb24gKFN0cmVhbUluZm8pIHtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLndyaXRlciAhPT0gdm9pZCAwICYmIGNhbmRpZGF0ZS5yZWFkZXIgIT09IHZvaWQgMDtcclxuICAgIH1cclxuICAgIFN0cmVhbUluZm8uaXMgPSBpcztcclxufSkoU3RyZWFtSW5mbyB8fCAoU3RyZWFtSW5mbyA9IHt9KSk7XHJcbnZhciBDaGlsZFByb2Nlc3NJbmZvO1xyXG4oZnVuY3Rpb24gKENoaWxkUHJvY2Vzc0luZm8pIHtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLnByb2Nlc3MgIT09IHZvaWQgMCAmJiB0eXBlb2YgY2FuZGlkYXRlLmRldGFjaGVkID09PSAnYm9vbGVhbic7XHJcbiAgICB9XHJcbiAgICBDaGlsZFByb2Nlc3NJbmZvLmlzID0gaXM7XHJcbn0pKENoaWxkUHJvY2Vzc0luZm8gfHwgKENoaWxkUHJvY2Vzc0luZm8gPSB7fSkpO1xyXG5jbGFzcyBMYW5ndWFnZUNsaWVudCBleHRlbmRzIGNsaWVudF8xLkJhc2VMYW5ndWFnZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XHJcbiAgICAgICAgbGV0IGlkO1xyXG4gICAgICAgIGxldCBuYW1lO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJPcHRpb25zO1xyXG4gICAgICAgIGxldCBjbGllbnRPcHRpb25zO1xyXG4gICAgICAgIGxldCBmb3JjZURlYnVnO1xyXG4gICAgICAgIGlmIChJcy5zdHJpbmcoYXJnMikpIHtcclxuICAgICAgICAgICAgaWQgPSBhcmcxO1xyXG4gICAgICAgICAgICBuYW1lID0gYXJnMjtcclxuICAgICAgICAgICAgc2VydmVyT3B0aW9ucyA9IGFyZzM7XHJcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMgPSBhcmc0O1xyXG4gICAgICAgICAgICBmb3JjZURlYnVnID0gISFhcmc1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWQgPSBhcmcxLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIG5hbWUgPSBhcmcxO1xyXG4gICAgICAgICAgICBzZXJ2ZXJPcHRpb25zID0gYXJnMjtcclxuICAgICAgICAgICAgY2xpZW50T3B0aW9ucyA9IGFyZzM7XHJcbiAgICAgICAgICAgIGZvcmNlRGVidWcgPSBhcmc0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9yY2VEZWJ1ZyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGZvcmNlRGVidWcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIoaWQsIG5hbWUsIGNsaWVudE9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3NlcnZlck9wdGlvbnMgPSBzZXJ2ZXJPcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2ZvcmNlRGVidWcgPSBmb3JjZURlYnVnO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWZXJzaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kTGluZShlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVja1ZlcnNpb24oKSB7XHJcbiAgICAgICAgbGV0IGNvZGVWZXJzaW9uID0gU2VtVmVyLnBhcnNlKHZzY29kZV8xLnZlcnNpb24pO1xyXG4gICAgICAgIGlmICghY29kZVZlcnNpb24pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB2YWxpZCBWUyBDb2RlIHZlcnNpb24gZGV0ZWN0ZWQuIFZlcnNpb24gc3RyaW5nIGlzOiAke3ZzY29kZV8xLnZlcnNpb259YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaW5zaWRlciBwcmUtcmVsZWFzZSBzaW5jZSB3ZSBzdGF5IEFQSSBjb21wYXRpYmxlLlxyXG4gICAgICAgIGlmIChjb2RlVmVyc2lvbi5wcmVyZWxlYXNlICYmIGNvZGVWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb2RlVmVyc2lvbi5wcmVyZWxlYXNlID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghU2VtVmVyLnNhdGlzZmllcyhjb2RlVmVyc2lvbiwgUkVRVUlSRURfVlNDT0RFX1ZFUlNJT04pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxhbmd1YWdlIGNsaWVudCByZXF1aXJlcyBWUyBDb2RlIHZlcnNpb24gJHtSRVFVSVJFRF9WU0NPREVfVkVSU0lPTn0gYnV0IHJlY2VpdmVkIHZlcnNpb24gJHt2c2NvZGVfMS52ZXJzaW9ufWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnN0b3AoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlclByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0b0NoZWNrID0gdGhpcy5fc2VydmVyUHJvY2VzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlclByb2Nlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNEZXRhY2hlZCA9PT0gdm9pZCAwIHx8ICF0aGlzLl9pc0RldGFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1Byb2Nlc3NEaWVkKHRvQ2hlY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNEZXRhY2hlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2hlY2tQcm9jZXNzRGllZChjaGlsZFByb2Nlc3MpIHtcclxuICAgICAgICBpZiAoIWNoaWxkUHJvY2Vzcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBwcm9jZXNzIGlzIHN0aWxsIGFsaXZlLiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIG5vdFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5raWxsKGNoaWxkUHJvY2Vzcy5waWQsIDApO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VzXzEudGVybWluYXRlKGNoaWxkUHJvY2Vzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgaXMgZmluZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMDApO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQ29ubmVjdGlvbkNsb3NlZCgpIHtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXJQcm9jZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHN1cGVyLmhhbmRsZUNvbm5lY3Rpb25DbG9zZWQoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZU1lc3NhZ2VUcmFuc3BvcnRzKGVuY29kaW5nKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnQoZW52KSB7XHJcbiAgICAgICAgICAgIGlmICghZW52KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5mb3JFYWNoKGtleSA9PiByZXN1bHRba2V5XSA9IHByb2Nlc3MuZW52W2tleV0pO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHJlc3VsdFtrZXldID0gZW52W2tleV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzdGFydGVkSW5EZWJ1Z01vZGUoKSB7XHJcbiAgICAgICAgICAgIGxldCBhcmdzID0gcHJvY2Vzcy5leGVjQXJndjtcclxuICAgICAgICAgICAgaWYgKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzLnNvbWUoKGFyZykgPT4gL14tLWRlYnVnPT8vLnRlc3QoYXJnKSB8fCAvXi0tZGVidWctYnJrPT8vLnRlc3QoYXJnKSB8fCAvXi0taW5zcGVjdD0/Ly50ZXN0KGFyZykgfHwgL14tLWluc3BlY3QtYnJrPT8vLnRlc3QoYXJnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXJPcHRpb25zO1xyXG4gICAgICAgIC8vIFdlIGdvdCBhIGZ1bmN0aW9uLlxyXG4gICAgICAgIGlmIChJcy5mdW5jKHNlcnZlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlcigpLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudF8xLk1lc3NhZ2VUcmFuc3BvcnRzLmlzKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0RldGFjaGVkID0gISFyZXN1bHQuZGV0YWNoZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFN0cmVhbUluZm8uaXMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRGV0YWNoZWQgPSAhIXJlc3VsdC5kZXRhY2hlZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZWFkZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TdHJlYW1NZXNzYWdlUmVhZGVyKHJlc3VsdC5yZWFkZXIpLCB3cml0ZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TdHJlYW1NZXNzYWdlV3JpdGVyKHJlc3VsdC53cml0ZXIpIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3A7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENoaWxkUHJvY2Vzc0luZm8uaXMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcCA9IHJlc3VsdC5wcm9jZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0RldGFjaGVkID0gcmVzdWx0LmRldGFjaGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRGV0YWNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3Auc3RkZXJyLm9uKCdkYXRhJywgZGF0YSA9PiB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kKElzLnN0cmluZyhkYXRhKSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlYWRlcjogbmV3IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN0cmVhbU1lc3NhZ2VSZWFkZXIoY3Auc3Rkb3V0KSwgd3JpdGVyOiBuZXcgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3RyZWFtTWVzc2FnZVdyaXRlcihjcC5zdGRpbikgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBqc29uO1xyXG4gICAgICAgIGxldCBydW5EZWJ1ZyA9IHNlcnZlcjtcclxuICAgICAgICBpZiAocnVuRGVidWcucnVuIHx8IHJ1bkRlYnVnLmRlYnVnKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGFyZSB1bmRlciBkZWJ1Z2dpbmcuIFNvIHVzZSBkZWJ1ZyBhcyB3ZWxsLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHY4ZGVidWcgPT09ICdvYmplY3QnIHx8IHRoaXMuX2ZvcmNlRGVidWcgfHwgc3RhcnRlZEluRGVidWdNb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIGpzb24gPSBydW5EZWJ1Zy5kZWJ1ZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGpzb24gPSBydW5EZWJ1Zy5ydW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGpzb24gPSBzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTZXJ2ZXJXb3JraW5nRGlyKGpzb24ub3B0aW9ucykudGhlbihzZXJ2ZXJXb3JraW5nRGlyID0+IHtcclxuICAgICAgICAgICAgaWYgKE5vZGVNb2R1bGUuaXMoanNvbikgJiYganNvbi5tb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0ganNvbjtcclxuICAgICAgICAgICAgICAgIGxldCB0cmFuc3BvcnQgPSBub2RlLnRyYW5zcG9ydCB8fCBUcmFuc3BvcnRLaW5kLnN0ZGlvO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucnVudGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBub2RlLm9wdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5leGVjQXJndikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmV4ZWNBcmd2LmZvckVhY2goZWxlbWVudCA9PiBhcmdzLnB1c2goZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobm9kZS5tb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmdzLmZvckVhY2goZWxlbWVudCA9PiBhcmdzLnB1c2goZWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXhlY09wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWNPcHRpb25zLmN3ZCA9IHNlcnZlcldvcmtpbmdEaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY09wdGlvbnMuZW52ID0gZ2V0RW52aXJvbm1lbnQob3B0aW9ucy5lbnYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwaXBlTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLmlwYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjIG9wdGlvbnMgbm90IGNvcnJlY3RseSB0eXBlZCBpbiBsaWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY09wdGlvbnMuc3RkaW8gPSBbbnVsbCwgbnVsbCwgbnVsbCwgJ2lwYyddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJy0tbm9kZS1pcGMnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLnN0ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnLS1zdGRpbycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc3BvcnQgPT09IFRyYW5zcG9ydEtpbmQucGlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXBlTmFtZSA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLmdlbmVyYXRlUmFuZG9tUGlwZU5hbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGAtLXBpcGU9JHtwaXBlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoVHJhbnNwb3J0LmlzU29ja2V0KHRyYW5zcG9ydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGAtLXNvY2tldD0ke3RyYW5zcG9ydC5wb3J0fWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYC0tY2xpZW50UHJvY2Vzc0lkPSR7cHJvY2Vzcy5waWQudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLmlwYyB8fCB0cmFuc3BvcnQgPT09IFRyYW5zcG9ydEtpbmQuc3RkaW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnZlclByb2Nlc3MgPSBjcC5zcGF3bihub2RlLnJ1bnRpbWUsIGFyZ3MsIGV4ZWNPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJ2ZXJQcm9jZXNzIHx8ICFzZXJ2ZXJQcm9jZXNzLnBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBMYXVuY2hpbmcgc2VydmVyIHVzaW5nIHJ1bnRpbWUgJHtub2RlLnJ1bnRpbWV9IGZhaWxlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXJQcm9jZXNzID0gc2VydmVyUHJvY2VzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoSXMuc3RyaW5nKGRhdGEpID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgPT09IFRyYW5zcG9ydEtpbmQuaXBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZChJcy5zdHJpbmcoZGF0YSkgPyBkYXRhIDogZGF0YS50b1N0cmluZyhlbmNvZGluZykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyByZWFkZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5JUENNZXNzYWdlUmVhZGVyKHNlcnZlclByb2Nlc3MpLCB3cml0ZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5JUENNZXNzYWdlV3JpdGVyKHNlcnZlclByb2Nlc3MpIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHJlYWRlcjogbmV3IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN0cmVhbU1lc3NhZ2VSZWFkZXIoc2VydmVyUHJvY2Vzcy5zdGRvdXQpLCB3cml0ZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5TdHJlYW1NZXNzYWdlV3JpdGVyKHNlcnZlclByb2Nlc3Muc3RkaW4pIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zcG9ydCA9PSBUcmFuc3BvcnRLaW5kLnBpcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLmNyZWF0ZUNsaWVudFBpcGVUcmFuc3BvcnQocGlwZU5hbWUpLnRoZW4oKHRyYW5zcG9ydCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2Nlc3MgPSBjcC5zcGF3bihub2RlLnJ1bnRpbWUsIGFyZ3MsIGV4ZWNPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvY2VzcyB8fCAhcHJvY2Vzcy5waWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYExhdW5jaGluZyBzZXJ2ZXIgdXNpbmcgcnVudGltZSAke25vZGUucnVudGltZX0gZmFpbGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VydmVyUHJvY2VzcyA9IHByb2Nlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZChJcy5zdHJpbmcoZGF0YSkgPyBkYXRhIDogZGF0YS50b1N0cmluZyhlbmNvZGluZykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kKElzLnN0cmluZyhkYXRhKSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydC5vbkNvbm5lY3RlZCgpLnRoZW4oKHByb3RvY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVhZGVyOiBwcm90b2NvbFswXSwgd3JpdGVyOiBwcm90b2NvbFsxXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChUcmFuc3BvcnQuaXNTb2NrZXQodHJhbnNwb3J0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuY3JlYXRlQ2xpZW50U29ja2V0VHJhbnNwb3J0KHRyYW5zcG9ydC5wb3J0KS50aGVuKCh0cmFuc3BvcnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzID0gY3Auc3Bhd24obm9kZS5ydW50aW1lLCBhcmdzLCBleGVjT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3MgfHwgIXByb2Nlc3MucGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBMYXVuY2hpbmcgc2VydmVyIHVzaW5nIHJ1bnRpbWUgJHtub2RlLnJ1bnRpbWV9IGZhaWxlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlclByb2Nlc3MgPSBwcm9jZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoSXMuc3RyaW5nKGRhdGEpID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZChJcy5zdHJpbmcoZGF0YSkgPyBkYXRhIDogZGF0YS50b1N0cmluZyhlbmNvZGluZykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQub25Db25uZWN0ZWQoKS50aGVuKChwcm90b2NvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlYWRlcjogcHJvdG9jb2xbMF0sIHdyaXRlcjogcHJvdG9jb2xbMV0gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGlwZU5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmdzID0gbm9kZS5hcmdzICYmIG5vZGUuYXJncy5zbGljZSgpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLmlwYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKCctLW5vZGUtaXBjJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLnN0ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goJy0tc3RkaW8nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc3BvcnQgPT09IFRyYW5zcG9ydEtpbmQucGlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlwZU5hbWUgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5nZW5lcmF0ZVJhbmRvbVBpcGVOYW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYC0tcGlwZT0ke3BpcGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFRyYW5zcG9ydC5pc1NvY2tldCh0cmFuc3BvcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYC0tc29ja2V0PSR7dHJhbnNwb3J0LnBvcnR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGAtLWNsaWVudFByb2Nlc3NJZD0ke3Byb2Nlc3MucGlkLnRvU3RyaW5nKCl9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0gbm9kZS5vcHRpb25zIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXhlY0FyZ3YgPSBvcHRpb25zLmV4ZWNBcmd2IHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmN3ZCA9IHNlcnZlcldvcmtpbmdEaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lsZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gVHJhbnNwb3J0S2luZC5pcGMgfHwgdHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLnN0ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3AgPSBjcC5mb3JrKG5vZGUubW9kdWxlLCBhcmdzIHx8IFtdLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlclByb2Nlc3MgPSBzcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwLnN0ZGVyci5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZChJcy5zdHJpbmcoZGF0YSkgPyBkYXRhIDogZGF0YS50b1N0cmluZyhlbmNvZGluZykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgPT09IFRyYW5zcG9ydEtpbmQuaXBjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Auc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kKElzLnN0cmluZyhkYXRhKSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyByZWFkZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5JUENNZXNzYWdlUmVhZGVyKHRoaXMuX3NlcnZlclByb2Nlc3MpLCB3cml0ZXI6IG5ldyB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5JUENNZXNzYWdlV3JpdGVyKHRoaXMuX3NlcnZlclByb2Nlc3MpIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHJlYWRlcjogbmV3IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN0cmVhbU1lc3NhZ2VSZWFkZXIoc3Auc3Rkb3V0KSwgd3JpdGVyOiBuZXcgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3RyZWFtTWVzc2FnZVdyaXRlcihzcC5zdGRpbikgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNwb3J0ID09PSBUcmFuc3BvcnRLaW5kLnBpcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLmNyZWF0ZUNsaWVudFBpcGVUcmFuc3BvcnQocGlwZU5hbWUpLnRoZW4oKHRyYW5zcG9ydCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcCA9IGNwLmZvcmsobm9kZS5tb2R1bGUsIGFyZ3MgfHwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlclByb2Nlc3MgPSBzcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcC5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoSXMuc3RyaW5nKGRhdGEpID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Auc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kKElzLnN0cmluZyhkYXRhKSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vbkNvbm5lY3RlZCgpLnRoZW4oKHByb3RvY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyByZWFkZXI6IHByb3RvY29sWzBdLCB3cml0ZXI6IHByb3RvY29sWzFdIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoVHJhbnNwb3J0LmlzU29ja2V0KHRyYW5zcG9ydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLmNyZWF0ZUNsaWVudFNvY2tldFRyYW5zcG9ydCh0cmFuc3BvcnQucG9ydCkudGhlbigodHJhbnNwb3J0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwID0gY3AuZm9yayhub2RlLm1vZHVsZSwgYXJncyB8fCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VydmVyUHJvY2VzcyA9IHNwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwLnN0ZGVyci5vbignZGF0YScsIGRhdGEgPT4gdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZChJcy5zdHJpbmcoZGF0YSkgPyBkYXRhIDogZGF0YS50b1N0cmluZyhlbmNvZGluZykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcC5zdGRvdXQub24oJ2RhdGEnLCBkYXRhID0+IHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoSXMuc3RyaW5nKGRhdGEpID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9uQ29ubmVjdGVkKCkudGhlbigocHJvdG9jb2wpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHJlYWRlcjogcHJvdG9jb2xbMF0sIHdyaXRlcjogcHJvdG9jb2xbMV0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEV4ZWN1dGFibGUuaXMoanNvbikgJiYganNvbi5jb21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGpzb247XHJcbiAgICAgICAgICAgICAgICBsZXQgYXJncyA9IGNvbW1hbmQuYXJncyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgY29tbWFuZC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gb3B0aW9ucy5jd2QgfHwgc2VydmVyV29ya2luZ0RpcjtcclxuICAgICAgICAgICAgICAgIGxldCBzZXJ2ZXJQcm9jZXNzID0gY3Auc3Bhd24oY29tbWFuZC5jb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICghc2VydmVyUHJvY2VzcyB8fCAhc2VydmVyUHJvY2Vzcy5waWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYExhdW5jaGluZyBzZXJ2ZXIgdXNpbmcgY29tbWFuZCAke2NvbW1hbmQuY29tbWFuZH0gZmFpbGVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VydmVyUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmQoSXMuc3RyaW5nKGRhdGEpID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXJQcm9jZXNzID0gc2VydmVyUHJvY2VzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRGV0YWNoZWQgPSAhIW9wdGlvbnMuZGV0YWNoZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcmVhZGVyOiBuZXcgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuU3RyZWFtTWVzc2FnZVJlYWRlcihzZXJ2ZXJQcm9jZXNzLnN0ZG91dCksIHdyaXRlcjogbmV3IHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlN0cmVhbU1lc3NhZ2VXcml0ZXIoc2VydmVyUHJvY2Vzcy5zdGRpbikgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2VydmVyIGNvbmZpZ3VyYXRpb24gYCArIEpTT04uc3RyaW5naWZ5KHNlcnZlciwgbnVsbCwgNCkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyUHJvcG9zZWRGZWF0dXJlcygpIHtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZXMoUHJvcG9zZWRGZWF0dXJlcy5jcmVhdGVBbGwodGhpcykpO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJCdWlsdGluRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJCdWlsdGluRmVhdHVyZXMoKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25GZWF0dXJlKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmVhdHVyZShuZXcgdHlwZURlZmluaXRpb25fMS5UeXBlRGVmaW5pdGlvbkZlYXR1cmUodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGZWF0dXJlKG5ldyBpbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IGNvbG9yUHJvdmlkZXJfMS5Db2xvclByb3ZpZGVyRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IHdvcmtzcGFjZUZvbGRlcnNfMS5Xb3Jrc3BhY2VGb2xkZXJzRmVhdHVyZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmUobmV3IGZvbGRpbmdSYW5nZV8xLkZvbGRpbmdSYW5nZUZlYXR1cmUodGhpcykpO1xyXG4gICAgfVxyXG4gICAgX21haW5HZXRSb290UGF0aCgpIHtcclxuICAgICAgICBsZXQgZm9sZGVycyA9IHZzY29kZV8xLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzO1xyXG4gICAgICAgIGlmICghZm9sZGVycyB8fCBmb2xkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZm9sZGVyID0gZm9sZGVyc1swXTtcclxuICAgICAgICBpZiAoZm9sZGVyLnVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9sZGVyLnVyaS5mc1BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBfZ2V0U2VydmVyV29ya2luZ0RpcihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGN3ZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jd2Q7XHJcbiAgICAgICAgaWYgKCFjd2QpIHtcclxuICAgICAgICAgICAgY3dkID0gdGhpcy5jbGllbnRPcHRpb25zLndvcmtzcGFjZUZvbGRlclxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNsaWVudE9wdGlvbnMud29ya3NwYWNlRm9sZGVyLnVyaS5mc1BhdGhcclxuICAgICAgICAgICAgICAgIDogdGhpcy5fbWFpbkdldFJvb3RQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjd2QpIHtcclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmb2xkZXIgZXhpc3RzIG90aGVyd2lzZSBjcmVhdGluZyB0aGUgcHJvY2VzcyB3aWxsIGZhaWxcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgZnMubHN0YXQoY3dkLCAoZXJyLCBzdGF0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHMoIWVyciAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpID8gY3dkIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTGFuZ3VhZ2VDbGllbnQgPSBMYW5ndWFnZUNsaWVudDtcclxuY2xhc3MgU2V0dGluZ01vbml0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCwgX3NldHRpbmcpIHtcclxuICAgICAgICB0aGlzLl9jbGllbnQgPSBfY2xpZW50O1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmcgPSBfc2V0dGluZztcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHZzY29kZV8xLndvcmtzcGFjZS5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24odGhpcy5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24sIHRoaXMsIHRoaXMuX2xpc3RlbmVycyk7XHJcbiAgICAgICAgdGhpcy5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICByZXR1cm4gbmV3IHZzY29kZV8xLkRpc3Bvc2FibGUoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2xpZW50Lm5lZWRzU3RvcCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fc2V0dGluZy5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgbGV0IHByaW1hcnkgPSBpbmRleCA+PSAwID8gdGhpcy5fc2V0dGluZy5zdWJzdHIoMCwgaW5kZXgpIDogdGhpcy5fc2V0dGluZztcclxuICAgICAgICBsZXQgcmVzdCA9IGluZGV4ID49IDAgPyB0aGlzLl9zZXR0aW5nLnN1YnN0cihpbmRleCArIDEpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBlbmFibGVkID0gcmVzdCA/IHZzY29kZV8xLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKHByaW1hcnkpLmdldChyZXN0LCBmYWxzZSkgOiB2c2NvZGVfMS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihwcmltYXJ5KTtcclxuICAgICAgICBpZiAoZW5hYmxlZCAmJiB0aGlzLl9jbGllbnQubmVlZHNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghZW5hYmxlZCAmJiB0aGlzLl9jbGllbnQubmVlZHNTdG9wKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TZXR0aW5nTW9uaXRvciA9IFNldHRpbmdNb25pdG9yO1xyXG4vLyBFeHBvcnRpbmcgcHJvcG9zZWQgcHJvdG9jb2wuXHJcbnZhciBQcm9wb3NlZEZlYXR1cmVzO1xyXG4oZnVuY3Rpb24gKFByb3Bvc2VkRmVhdHVyZXMpIHtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFsbChfY2xpZW50KSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBQcm9wb3NlZEZlYXR1cmVzLmNyZWF0ZUFsbCA9IGNyZWF0ZUFsbDtcclxufSkoUHJvcG9zZWRGZWF0dXJlcyA9IGV4cG9ydHMuUHJvcG9zZWRGZWF0dXJlcyB8fCAoZXhwb3J0cy5Qcm9wb3NlZEZlYXR1cmVzID0ge30pKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/main.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/protocolCodeLens.js":
/*!********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/protocolCodeLens.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst code = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass ProtocolCodeLens extends code.CodeLens {\r\n    constructor(range) {\r\n        super(range);\r\n    }\r\n}\r\nexports.default = ProtocolCodeLens;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbENvZGVMZW5zLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL3Byb3RvY29sQ29kZUxlbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNsYXNzIFByb3RvY29sQ29kZUxlbnMgZXh0ZW5kcyBjb2RlLkNvZGVMZW5zIHtcclxuICAgIGNvbnN0cnVjdG9yKHJhbmdlKSB7XHJcbiAgICAgICAgc3VwZXIocmFuZ2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sQ29kZUxlbnM7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/protocolCodeLens.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/protocolCompletionItem.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/protocolCompletionItem.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst code = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass ProtocolCompletionItem extends code.CompletionItem {\r\n    constructor(label) {\r\n        super(label);\r\n    }\r\n}\r\nexports.default = ProtocolCompletionItem;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbENvbXBsZXRpb25JdGVtLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL3Byb3RvY29sQ29tcGxldGlvbkl0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNsYXNzIFByb3RvY29sQ29tcGxldGlvbkl0ZW0gZXh0ZW5kcyBjb2RlLkNvbXBsZXRpb25JdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XHJcbiAgICAgICAgc3VwZXIobGFiZWwpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sQ29tcGxldGlvbkl0ZW07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/protocolCompletionItem.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/protocolConverter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/protocolConverter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst code = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst ls = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ \"./node_modules/vscode-languageclient/lib/protocolCompletionItem.js\");\r\nconst protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ \"./node_modules/vscode-languageclient/lib/protocolCodeLens.js\");\r\nconst protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ \"./node_modules/vscode-languageclient/lib/protocolDocumentLink.js\");\r\nvar CodeBlock;\r\n(function (CodeBlock) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.string(candidate.language) && Is.string(candidate.value);\r\n    }\r\n    CodeBlock.is = is;\r\n})(CodeBlock || (CodeBlock = {}));\r\nfunction createConverter(uriConverter) {\r\n    const nullConverter = (value) => code.Uri.parse(value);\r\n    const _uriConverter = uriConverter || nullConverter;\r\n    function asUri(value) {\r\n        return _uriConverter(value);\r\n    }\r\n    function asDiagnostics(diagnostics) {\r\n        return diagnostics.map(asDiagnostic);\r\n    }\r\n    function asDiagnostic(diagnostic) {\r\n        let result = new code.Diagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity));\r\n        if (Is.number(diagnostic.code) || Is.string(diagnostic.code)) {\r\n            result.code = diagnostic.code;\r\n        }\r\n        if (diagnostic.source) {\r\n            result.source = diagnostic.source;\r\n        }\r\n        if (diagnostic.relatedInformation) {\r\n            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);\r\n        }\r\n        return result;\r\n    }\r\n    function asRelatedInformation(relatedInformation) {\r\n        return relatedInformation.map(asDiagnosticRelatedInformation);\r\n    }\r\n    function asDiagnosticRelatedInformation(information) {\r\n        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);\r\n    }\r\n    function asPosition(value) {\r\n        if (!value) {\r\n            return undefined;\r\n        }\r\n        return new code.Position(value.line, value.character);\r\n    }\r\n    function asRange(value) {\r\n        if (!value) {\r\n            return undefined;\r\n        }\r\n        return new code.Range(asPosition(value.start), asPosition(value.end));\r\n    }\r\n    function asDiagnosticSeverity(value) {\r\n        if (value === void 0 || value === null) {\r\n            return code.DiagnosticSeverity.Error;\r\n        }\r\n        switch (value) {\r\n            case ls.DiagnosticSeverity.Error:\r\n                return code.DiagnosticSeverity.Error;\r\n            case ls.DiagnosticSeverity.Warning:\r\n                return code.DiagnosticSeverity.Warning;\r\n            case ls.DiagnosticSeverity.Information:\r\n                return code.DiagnosticSeverity.Information;\r\n            case ls.DiagnosticSeverity.Hint:\r\n                return code.DiagnosticSeverity.Hint;\r\n        }\r\n        return code.DiagnosticSeverity.Error;\r\n    }\r\n    function asHoverContent(value) {\r\n        if (Is.string(value)) {\r\n            return new code.MarkdownString(value);\r\n        }\r\n        else if (CodeBlock.is(value)) {\r\n            let result = new code.MarkdownString();\r\n            return result.appendCodeblock(value.value, value.language);\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            let result = [];\r\n            for (let element of value) {\r\n                let item = new code.MarkdownString();\r\n                if (CodeBlock.is(element)) {\r\n                    item.appendCodeblock(element.value, element.language);\r\n                }\r\n                else {\r\n                    item.appendMarkdown(element);\r\n                }\r\n                result.push(item);\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            let result;\r\n            switch (value.kind) {\r\n                case ls.MarkupKind.Markdown:\r\n                    return new code.MarkdownString(value.value);\r\n                case ls.MarkupKind.PlainText:\r\n                    result = new code.MarkdownString();\r\n                    result.appendText(value.value);\r\n                    return result;\r\n                default:\r\n                    result = new code.MarkdownString();\r\n                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);\r\n                    return result;\r\n            }\r\n        }\r\n    }\r\n    function asDocumentation(value) {\r\n        if (Is.string(value)) {\r\n            return value;\r\n        }\r\n        else {\r\n            switch (value.kind) {\r\n                case ls.MarkupKind.Markdown:\r\n                    return new code.MarkdownString(value.value);\r\n                case ls.MarkupKind.PlainText:\r\n                    return value.value;\r\n                default:\r\n                    return `Unsupported Markup content received. Kind is: ${value.kind}`;\r\n            }\r\n        }\r\n    }\r\n    function asHover(hover) {\r\n        if (!hover) {\r\n            return undefined;\r\n        }\r\n        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));\r\n    }\r\n    function asCompletionResult(result) {\r\n        if (!result) {\r\n            return undefined;\r\n        }\r\n        if (Array.isArray(result)) {\r\n            let items = result;\r\n            return items.map(asCompletionItem);\r\n        }\r\n        let list = result;\r\n        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);\r\n    }\r\n    function asCompletionItemKind(value) {\r\n        // Protocol item kind is 1 based, codes item kind is zero based.\r\n        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {\r\n            return [value - 1, undefined];\r\n        }\r\n        ;\r\n        return [code.CompletionItemKind.Text, value];\r\n    }\r\n    function asCompletionItem(item) {\r\n        let result = new protocolCompletionItem_1.default(item.label);\r\n        if (item.detail) {\r\n            result.detail = item.detail;\r\n        }\r\n        if (item.documentation) {\r\n            result.documentation = asDocumentation(item.documentation);\r\n            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;\r\n        }\r\n        ;\r\n        if (item.filterText) {\r\n            result.filterText = item.filterText;\r\n        }\r\n        let insertText = asCompletionInsertText(item);\r\n        if (insertText) {\r\n            result.insertText = insertText.text;\r\n            result.range = insertText.range;\r\n            result.fromEdit = insertText.fromEdit;\r\n        }\r\n        if (Is.number(item.kind)) {\r\n            let [itemKind, original] = asCompletionItemKind(item.kind);\r\n            result.kind = itemKind;\r\n            if (original) {\r\n                result.originalItemKind = original;\r\n            }\r\n        }\r\n        if (item.sortText) {\r\n            result.sortText = item.sortText;\r\n        }\r\n        if (item.additionalTextEdits) {\r\n            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);\r\n        }\r\n        if (Is.stringArray(item.commitCharacters)) {\r\n            result.commitCharacters = item.commitCharacters.slice();\r\n        }\r\n        if (item.command) {\r\n            result.command = asCommand(item.command);\r\n        }\r\n        if (item.deprecated === true || item.deprecated === false) {\r\n            result.deprecated = item.deprecated;\r\n        }\r\n        if (item.preselect === true || item.preselect === false) {\r\n            result.preselect = item.preselect;\r\n        }\r\n        if (item.data !== void 0) {\r\n            result.data = item.data;\r\n        }\r\n        return result;\r\n    }\r\n    function asCompletionInsertText(item) {\r\n        if (item.textEdit) {\r\n            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {\r\n                return { text: new code.SnippetString(item.textEdit.newText), range: asRange(item.textEdit.range), fromEdit: true };\r\n            }\r\n            else {\r\n                return { text: item.textEdit.newText, range: asRange(item.textEdit.range), fromEdit: true };\r\n            }\r\n        }\r\n        else if (item.insertText) {\r\n            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {\r\n                return { text: new code.SnippetString(item.insertText), fromEdit: false };\r\n            }\r\n            else {\r\n                return { text: item.insertText, fromEdit: false };\r\n            }\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    function asTextEdit(edit) {\r\n        if (!edit) {\r\n            return undefined;\r\n        }\r\n        return new code.TextEdit(asRange(edit.range), edit.newText);\r\n    }\r\n    function asTextEdits(items) {\r\n        if (!items) {\r\n            return undefined;\r\n        }\r\n        return items.map(asTextEdit);\r\n    }\r\n    function asSignatureHelp(item) {\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        let result = new code.SignatureHelp();\r\n        if (Is.number(item.activeSignature)) {\r\n            result.activeSignature = item.activeSignature;\r\n        }\r\n        else {\r\n            // activeSignature was optional in the past\r\n            result.activeSignature = 0;\r\n        }\r\n        if (Is.number(item.activeParameter)) {\r\n            result.activeParameter = item.activeParameter;\r\n        }\r\n        else {\r\n            // activeParameter was optional in the past\r\n            result.activeParameter = 0;\r\n        }\r\n        if (item.signatures) {\r\n            result.signatures = asSignatureInformations(item.signatures);\r\n        }\r\n        return result;\r\n    }\r\n    function asSignatureInformations(items) {\r\n        return items.map(asSignatureInformation);\r\n    }\r\n    function asSignatureInformation(item) {\r\n        let result = new code.SignatureInformation(item.label);\r\n        if (item.documentation) {\r\n            result.documentation = asDocumentation(item.documentation);\r\n        }\r\n        if (item.parameters) {\r\n            result.parameters = asParameterInformations(item.parameters);\r\n        }\r\n        return result;\r\n    }\r\n    function asParameterInformations(item) {\r\n        return item.map(asParameterInformation);\r\n    }\r\n    function asParameterInformation(item) {\r\n        let result = new code.ParameterInformation(item.label);\r\n        if (item.documentation) {\r\n            result.documentation = asDocumentation(item.documentation);\r\n        }\r\n        ;\r\n        return result;\r\n    }\r\n    function asDefinitionResult(item) {\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        if (Is.array(item)) {\r\n            return item.map((location) => asLocation(location));\r\n        }\r\n        else {\r\n            return asLocation(item);\r\n        }\r\n    }\r\n    function asLocation(item) {\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        return new code.Location(_uriConverter(item.uri), asRange(item.range));\r\n    }\r\n    function asReferences(values) {\r\n        if (!values) {\r\n            return undefined;\r\n        }\r\n        return values.map(location => asLocation(location));\r\n    }\r\n    function asDocumentHighlights(values) {\r\n        if (!values) {\r\n            return undefined;\r\n        }\r\n        return values.map(asDocumentHighlight);\r\n    }\r\n    function asDocumentHighlight(item) {\r\n        let result = new code.DocumentHighlight(asRange(item.range));\r\n        if (Is.number(item.kind)) {\r\n            result.kind = asDocumentHighlightKind(item.kind);\r\n        }\r\n        return result;\r\n    }\r\n    function asDocumentHighlightKind(item) {\r\n        switch (item) {\r\n            case ls.DocumentHighlightKind.Text:\r\n                return code.DocumentHighlightKind.Text;\r\n            case ls.DocumentHighlightKind.Read:\r\n                return code.DocumentHighlightKind.Read;\r\n            case ls.DocumentHighlightKind.Write:\r\n                return code.DocumentHighlightKind.Write;\r\n        }\r\n        return code.DocumentHighlightKind.Text;\r\n    }\r\n    function asSymbolInformations(values, uri) {\r\n        if (!values) {\r\n            return undefined;\r\n        }\r\n        return values.map(information => asSymbolInformation(information, uri));\r\n    }\r\n    function asSymbolKind(item) {\r\n        if (item <= ls.SymbolKind.TypeParameter) {\r\n            // Symbol kind is one based in the protocol and zero based in code.\r\n            return item - 1;\r\n        }\r\n        return code.SymbolKind.Property;\r\n    }\r\n    function asSymbolInformation(item, uri) {\r\n        // Symbol kind is one based in the protocol and zero based in code.\r\n        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);\r\n        if (item.containerName) {\r\n            result.containerName = item.containerName;\r\n        }\r\n        return result;\r\n    }\r\n    function asDocumentSymbols(values) {\r\n        if (values === void 0 || values === null) {\r\n            return undefined;\r\n        }\r\n        return values.map(asDocumentSymbol);\r\n    }\r\n    function asDocumentSymbol(value) {\r\n        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));\r\n        if (value.children !== void 0 && value.children.length > 0) {\r\n            let children = [];\r\n            for (let child of value.children) {\r\n                children.push(asDocumentSymbol(child));\r\n            }\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    function asCommand(item) {\r\n        let result = { title: item.title, command: item.command };\r\n        if (item.arguments) {\r\n            result.arguments = item.arguments;\r\n        }\r\n        return result;\r\n    }\r\n    function asCommands(items) {\r\n        if (!items) {\r\n            return undefined;\r\n        }\r\n        return items.map(asCommand);\r\n    }\r\n    const kindMapping = new Map();\r\n    kindMapping.set('', code.CodeActionKind.Empty);\r\n    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);\r\n    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);\r\n    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);\r\n    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);\r\n    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);\r\n    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);\r\n    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);\r\n    function asCodeActionKind(item) {\r\n        if (item === void 0 || item === null) {\r\n            return undefined;\r\n        }\r\n        let result = kindMapping.get(item);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        let parts = item.split('.');\r\n        result = code.CodeActionKind.Empty;\r\n        for (let part of parts) {\r\n            result = result.append(part);\r\n        }\r\n        return result;\r\n    }\r\n    function asCodeActionKinds(items) {\r\n        if (items === void 0 || items === null) {\r\n            return undefined;\r\n        }\r\n        return items.map(kind => asCodeActionKind(kind));\r\n    }\r\n    function asCodeAction(item) {\r\n        if (item === void 0 || item === null) {\r\n            return undefined;\r\n        }\r\n        let result = new code.CodeAction(item.title);\r\n        if (item.kind !== void 0) {\r\n            result.kind = asCodeActionKind(item.kind);\r\n        }\r\n        if (item.diagnostics) {\r\n            result.diagnostics = asDiagnostics(item.diagnostics);\r\n        }\r\n        if (item.edit) {\r\n            result.edit = asWorkspaceEdit(item.edit);\r\n        }\r\n        if (item.command) {\r\n            result.command = asCommand(item.command);\r\n        }\r\n        return result;\r\n    }\r\n    function asCodeLens(item) {\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        let result = new protocolCodeLens_1.default(asRange(item.range));\r\n        if (item.command) {\r\n            result.command = asCommand(item.command);\r\n        }\r\n        if (item.data !== void 0 && item.data !== null) {\r\n            result.data = item.data;\r\n        }\r\n        return result;\r\n    }\r\n    function asCodeLenses(items) {\r\n        if (!items) {\r\n            return undefined;\r\n        }\r\n        return items.map((codeLens) => asCodeLens(codeLens));\r\n    }\r\n    function asWorkspaceEdit(item) {\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        let result = new code.WorkspaceEdit();\r\n        if (item.documentChanges) {\r\n            item.documentChanges.forEach(change => {\r\n                if (ls.CreateFile.is(change)) {\r\n                    result.createFile(_uriConverter(change.uri), change.options);\r\n                }\r\n                else if (ls.RenameFile.is(change)) {\r\n                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options);\r\n                }\r\n                else if (ls.DeleteFile.is(change)) {\r\n                    result.deleteFile(_uriConverter(change.uri), change.options);\r\n                }\r\n                else if (ls.TextDocumentEdit.is(change)) {\r\n                    result.set(_uriConverter(change.textDocument.uri), asTextEdits(change.edits));\r\n                }\r\n                else {\r\n                    console.error(`Unknown workspace edit change received:\\n${JSON.stringify(change, undefined, 4)}`);\r\n                }\r\n            });\r\n        }\r\n        else if (item.changes) {\r\n            Object.keys(item.changes).forEach(key => {\r\n                result.set(_uriConverter(key), asTextEdits(item.changes[key]));\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    function asDocumentLink(item) {\r\n        let range = asRange(item.range);\r\n        let target = item.target ? asUri(item.target) : undefined;\r\n        // target must be optional in DocumentLink\r\n        let link = new protocolDocumentLink_1.default(range, target);\r\n        if (item.data !== void 0 && item.data !== null) {\r\n            link.data = item.data;\r\n        }\r\n        return link;\r\n    }\r\n    function asDocumentLinks(items) {\r\n        if (!items) {\r\n            return undefined;\r\n        }\r\n        return items.map(asDocumentLink);\r\n    }\r\n    function asColor(color) {\r\n        return new code.Color(color.red, color.green, color.blue, color.alpha);\r\n    }\r\n    function asColorInformation(ci) {\r\n        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));\r\n    }\r\n    function asColorInformations(colorInformation) {\r\n        if (Array.isArray(colorInformation)) {\r\n            return colorInformation.map(asColorInformation);\r\n        }\r\n        return undefined;\r\n    }\r\n    function asColorPresentation(cp) {\r\n        let presentation = new code.ColorPresentation(cp.label);\r\n        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);\r\n        if (cp.textEdit) {\r\n            presentation.textEdit = asTextEdit(cp.textEdit);\r\n        }\r\n        return presentation;\r\n    }\r\n    function asColorPresentations(colorPresentations) {\r\n        if (Array.isArray(colorPresentations)) {\r\n            return colorPresentations.map(asColorPresentation);\r\n        }\r\n        return undefined;\r\n    }\r\n    function asFoldingRangeKind(kind) {\r\n        if (kind) {\r\n            switch (kind) {\r\n                case ls.FoldingRangeKind.Comment:\r\n                    return code.FoldingRangeKind.Comment;\r\n                case ls.FoldingRangeKind.Imports:\r\n                    return code.FoldingRangeKind.Imports;\r\n                case ls.FoldingRangeKind.Region:\r\n                    return code.FoldingRangeKind.Region;\r\n            }\r\n        }\r\n        return void 0;\r\n    }\r\n    function asFoldingRange(r) {\r\n        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));\r\n    }\r\n    function asFoldingRanges(foldingRanges) {\r\n        if (Array.isArray(foldingRanges)) {\r\n            return foldingRanges.map(asFoldingRange);\r\n        }\r\n        return void 0;\r\n    }\r\n    return {\r\n        asUri,\r\n        asDiagnostics,\r\n        asDiagnostic,\r\n        asRange,\r\n        asPosition,\r\n        asDiagnosticSeverity,\r\n        asHover,\r\n        asCompletionResult,\r\n        asCompletionItem,\r\n        asTextEdit,\r\n        asTextEdits,\r\n        asSignatureHelp,\r\n        asSignatureInformations,\r\n        asSignatureInformation,\r\n        asParameterInformations,\r\n        asParameterInformation,\r\n        asDefinitionResult,\r\n        asLocation,\r\n        asReferences,\r\n        asDocumentHighlights,\r\n        asDocumentHighlight,\r\n        asDocumentHighlightKind,\r\n        asSymbolInformations,\r\n        asSymbolInformation,\r\n        asDocumentSymbols,\r\n        asDocumentSymbol,\r\n        asCommand,\r\n        asCommands,\r\n        asCodeAction,\r\n        asCodeActionKind,\r\n        asCodeActionKinds,\r\n        asCodeLens,\r\n        asCodeLenses,\r\n        asWorkspaceEdit,\r\n        asDocumentLink,\r\n        asDocumentLinks,\r\n        asFoldingRangeKind,\r\n        asFoldingRange,\r\n        asFoldingRanges,\r\n        asColor,\r\n        asColorInformation,\r\n        asColorInformations,\r\n        asColorPresentation,\r\n        asColorPresentations\r\n    };\r\n}\r\nexports.createConverter = createConverter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbENvbnZlcnRlci5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbENvbnZlcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgbHMgPSByZXF1aXJlKFwidnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sXCIpO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xyXG5jb25zdCBwcm90b2NvbENvbXBsZXRpb25JdGVtXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbENvbXBsZXRpb25JdGVtXCIpO1xyXG5jb25zdCBwcm90b2NvbENvZGVMZW5zXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbENvZGVMZW5zXCIpO1xyXG5jb25zdCBwcm90b2NvbERvY3VtZW50TGlua18xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xEb2N1bWVudExpbmtcIik7XHJcbnZhciBDb2RlQmxvY2s7XHJcbihmdW5jdGlvbiAoQ29kZUJsb2NrKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgQ29kZUJsb2NrLmlzID0gaXM7XHJcbn0pKENvZGVCbG9jayB8fCAoQ29kZUJsb2NrID0ge30pKTtcclxuZnVuY3Rpb24gY3JlYXRlQ29udmVydGVyKHVyaUNvbnZlcnRlcikge1xyXG4gICAgY29uc3QgbnVsbENvbnZlcnRlciA9ICh2YWx1ZSkgPT4gY29kZS5VcmkucGFyc2UodmFsdWUpO1xyXG4gICAgY29uc3QgX3VyaUNvbnZlcnRlciA9IHVyaUNvbnZlcnRlciB8fCBudWxsQ29udmVydGVyO1xyXG4gICAgZnVuY3Rpb24gYXNVcmkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gX3VyaUNvbnZlcnRlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0RpYWdub3N0aWNzKGRpYWdub3N0aWNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzLm1hcChhc0RpYWdub3N0aWMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEaWFnbm9zdGljKGRpYWdub3N0aWMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGNvZGUuRGlhZ25vc3RpYyhhc1JhbmdlKGRpYWdub3N0aWMucmFuZ2UpLCBkaWFnbm9zdGljLm1lc3NhZ2UsIGFzRGlhZ25vc3RpY1NldmVyaXR5KGRpYWdub3N0aWMuc2V2ZXJpdHkpKTtcclxuICAgICAgICBpZiAoSXMubnVtYmVyKGRpYWdub3N0aWMuY29kZSkgfHwgSXMuc3RyaW5nKGRpYWdub3N0aWMuY29kZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSBkaWFnbm9zdGljLmNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaWFnbm9zdGljLnNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gZGlhZ25vc3RpYy5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaWFnbm9zdGljLnJlbGF0ZWRJbmZvcm1hdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gYXNSZWxhdGVkSW5mb3JtYXRpb24oZGlhZ25vc3RpYy5yZWxhdGVkSW5mb3JtYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSZWxhdGVkSW5mb3JtYXRpb24ocmVsYXRlZEluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbGF0ZWRJbmZvcm1hdGlvbi5tYXAoYXNEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbihpbmZvcm1hdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgY29kZS5EaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKGFzTG9jYXRpb24oaW5mb3JtYXRpb24ubG9jYXRpb24pLCBpbmZvcm1hdGlvbi5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUG9zaXRpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgY29kZS5Qb3NpdGlvbih2YWx1ZS5saW5lLCB2YWx1ZS5jaGFyYWN0ZXIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSYW5nZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlLlJhbmdlKGFzUG9zaXRpb24odmFsdWUuc3RhcnQpLCBhc1Bvc2l0aW9uKHZhbHVlLmVuZCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEaWFnbm9zdGljU2V2ZXJpdHkodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29kZS5EaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgY2FzZSBscy5EaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5EaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XHJcbiAgICAgICAgICAgIGNhc2UgbHMuRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcclxuICAgICAgICAgICAgY2FzZSBscy5EaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5EaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb247XHJcbiAgICAgICAgICAgIGNhc2UgbHMuRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5EaWFnbm9zdGljU2V2ZXJpdHkuSGludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGUuRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNIb3ZlckNvbnRlbnQodmFsdWUpIHtcclxuICAgICAgICBpZiAoSXMuc3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvZGUuTWFya2Rvd25TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChDb2RlQmxvY2suaXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgY29kZS5NYXJrZG93blN0cmluZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFwcGVuZENvZGVibG9jayh2YWx1ZS52YWx1ZSwgdmFsdWUubGFuZ3VhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IGNvZGUuTWFya2Rvd25TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChDb2RlQmxvY2suaXMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFwcGVuZENvZGVibG9jayhlbGVtZW50LnZhbHVlLCBlbGVtZW50Lmxhbmd1YWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXBwZW5kTWFya2Rvd24oZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5raW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGxzLk1hcmt1cEtpbmQuTWFya2Rvd246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb2RlLk1hcmtkb3duU3RyaW5nKHZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgbHMuTWFya3VwS2luZC5QbGFpblRleHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGNvZGUuTWFya2Rvd25TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kVGV4dCh2YWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGNvZGUuTWFya2Rvd25TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kVGV4dChgVW5zdXBwb3J0ZWQgTWFya3VwIGNvbnRlbnQgcmVjZWl2ZWQuIEtpbmQgaXM6ICR7dmFsdWUua2luZH1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEb2N1bWVudGF0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKElzLnN0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5raW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGxzLk1hcmt1cEtpbmQuTWFya2Rvd246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb2RlLk1hcmtkb3duU3RyaW5nKHZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgbHMuTWFya3VwS2luZC5QbGFpblRleHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFVuc3VwcG9ydGVkIE1hcmt1cCBjb250ZW50IHJlY2VpdmVkLiBLaW5kIGlzOiAke3ZhbHVlLmtpbmR9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzSG92ZXIoaG92ZXIpIHtcclxuICAgICAgICBpZiAoIWhvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgY29kZS5Ib3Zlcihhc0hvdmVyQ29udGVudChob3Zlci5jb250ZW50cyksIGFzUmFuZ2UoaG92ZXIucmFuZ2UpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ29tcGxldGlvblJlc3VsdChyZXN1bHQpIHtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGxldCBpdGVtcyA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChhc0NvbXBsZXRpb25JdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxpc3QgPSByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlLkNvbXBsZXRpb25MaXN0KGxpc3QuaXRlbXMubWFwKGFzQ29tcGxldGlvbkl0ZW0pLCBsaXN0LmlzSW5jb21wbGV0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvbXBsZXRpb25JdGVtS2luZCh2YWx1ZSkge1xyXG4gICAgICAgIC8vIFByb3RvY29sIGl0ZW0ga2luZCBpcyAxIGJhc2VkLCBjb2RlcyBpdGVtIGtpbmQgaXMgemVybyBiYXNlZC5cclxuICAgICAgICBpZiAobHMuQ29tcGxldGlvbkl0ZW1LaW5kLlRleHQgPD0gdmFsdWUgJiYgdmFsdWUgPD0gbHMuQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZSAtIDEsIHVuZGVmaW5lZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4gW2NvZGUuQ29tcGxldGlvbkl0ZW1LaW5kLlRleHQsIHZhbHVlXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ29tcGxldGlvbkl0ZW0oaXRlbSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgcHJvdG9jb2xDb21wbGV0aW9uSXRlbV8xLmRlZmF1bHQoaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgaWYgKGl0ZW0uZGV0YWlsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kZXRhaWwgPSBpdGVtLmRldGFpbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGFzRG9jdW1lbnRhdGlvbihpdGVtLmRvY3VtZW50YXRpb24pO1xyXG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbkZvcm1hdCA9IElzLnN0cmluZyhpdGVtLmRvY3VtZW50YXRpb24pID8gJyRzdHJpbmcnIDogaXRlbS5kb2N1bWVudGF0aW9uLmtpbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBpZiAoaXRlbS5maWx0ZXJUZXh0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5maWx0ZXJUZXh0ID0gaXRlbS5maWx0ZXJUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW5zZXJ0VGV4dCA9IGFzQ29tcGxldGlvbkluc2VydFRleHQoaXRlbSk7XHJcbiAgICAgICAgaWYgKGluc2VydFRleHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lmluc2VydFRleHQgPSBpbnNlcnRUZXh0LnRleHQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yYW5nZSA9IGluc2VydFRleHQucmFuZ2U7XHJcbiAgICAgICAgICAgIHJlc3VsdC5mcm9tRWRpdCA9IGluc2VydFRleHQuZnJvbUVkaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJcy5udW1iZXIoaXRlbS5raW5kKSkge1xyXG4gICAgICAgICAgICBsZXQgW2l0ZW1LaW5kLCBvcmlnaW5hbF0gPSBhc0NvbXBsZXRpb25JdGVtS2luZChpdGVtLmtpbmQpO1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGl0ZW1LaW5kO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5vcmlnaW5hbEl0ZW1LaW5kID0gb3JpZ2luYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uc29ydFRleHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNvcnRUZXh0ID0gaXRlbS5zb3J0VGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uYWRkaXRpb25hbFRleHRFZGl0cykge1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkaXRpb25hbFRleHRFZGl0cyA9IGFzVGV4dEVkaXRzKGl0ZW0uYWRkaXRpb25hbFRleHRFZGl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJcy5zdHJpbmdBcnJheShpdGVtLmNvbW1pdENoYXJhY3RlcnMpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb21taXRDaGFyYWN0ZXJzID0gaXRlbS5jb21taXRDaGFyYWN0ZXJzLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBhc0NvbW1hbmQoaXRlbS5jb21tYW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZGVwcmVjYXRlZCA9PT0gdHJ1ZSB8fCBpdGVtLmRlcHJlY2F0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kZXByZWNhdGVkID0gaXRlbS5kZXByZWNhdGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5wcmVzZWxlY3QgPT09IHRydWUgfHwgaXRlbS5wcmVzZWxlY3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wcmVzZWxlY3QgPSBpdGVtLnByZXNlbGVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZGF0YSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gaXRlbS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb21wbGV0aW9uSW5zZXJ0VGV4dChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0udGV4dEVkaXQpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uaW5zZXJ0VGV4dEZvcm1hdCA9PT0gbHMuSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBuZXcgY29kZS5TbmlwcGV0U3RyaW5nKGl0ZW0udGV4dEVkaXQubmV3VGV4dCksIHJhbmdlOiBhc1JhbmdlKGl0ZW0udGV4dEVkaXQucmFuZ2UpLCBmcm9tRWRpdDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogaXRlbS50ZXh0RWRpdC5uZXdUZXh0LCByYW5nZTogYXNSYW5nZShpdGVtLnRleHRFZGl0LnJhbmdlKSwgZnJvbUVkaXQ6IHRydWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpdGVtLmluc2VydFRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uaW5zZXJ0VGV4dEZvcm1hdCA9PT0gbHMuSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBuZXcgY29kZS5TbmlwcGV0U3RyaW5nKGl0ZW0uaW5zZXJ0VGV4dCksIGZyb21FZGl0OiBmYWxzZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogaXRlbS5pbnNlcnRUZXh0LCBmcm9tRWRpdDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1RleHRFZGl0KGVkaXQpIHtcclxuICAgICAgICBpZiAoIWVkaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlLlRleHRFZGl0KGFzUmFuZ2UoZWRpdC5yYW5nZSksIGVkaXQubmV3VGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1RleHRFZGl0cyhpdGVtcykge1xyXG4gICAgICAgIGlmICghaXRlbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChhc1RleHRFZGl0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzU2lnbmF0dXJlSGVscChpdGVtKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgY29kZS5TaWduYXR1cmVIZWxwKCk7XHJcbiAgICAgICAgaWYgKElzLm51bWJlcihpdGVtLmFjdGl2ZVNpZ25hdHVyZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2ZVNpZ25hdHVyZSA9IGl0ZW0uYWN0aXZlU2lnbmF0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWN0aXZlU2lnbmF0dXJlIHdhcyBvcHRpb25hbCBpbiB0aGUgcGFzdFxyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZlU2lnbmF0dXJlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKElzLm51bWJlcihpdGVtLmFjdGl2ZVBhcmFtZXRlcikpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2ZVBhcmFtZXRlciA9IGl0ZW0uYWN0aXZlUGFyYW1ldGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWN0aXZlUGFyYW1ldGVyIHdhcyBvcHRpb25hbCBpbiB0aGUgcGFzdFxyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZlUGFyYW1ldGVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uc2lnbmF0dXJlcykge1xyXG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlcyA9IGFzU2lnbmF0dXJlSW5mb3JtYXRpb25zKGl0ZW0uc2lnbmF0dXJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1NpZ25hdHVyZUluZm9ybWF0aW9ucyhpdGVtcykge1xyXG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoYXNTaWduYXR1cmVJbmZvcm1hdGlvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1NpZ25hdHVyZUluZm9ybWF0aW9uKGl0ZW0pIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGNvZGUuU2lnbmF0dXJlSW5mb3JtYXRpb24oaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGFzRG9jdW1lbnRhdGlvbihpdGVtLmRvY3VtZW50YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5wYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gYXNQYXJhbWV0ZXJJbmZvcm1hdGlvbnMoaXRlbS5wYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUGFyYW1ldGVySW5mb3JtYXRpb25zKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5tYXAoYXNQYXJhbWV0ZXJJbmZvcm1hdGlvbik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1BhcmFtZXRlckluZm9ybWF0aW9uKGl0ZW0pIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGNvZGUuUGFyYW1ldGVySW5mb3JtYXRpb24oaXRlbS5sYWJlbCk7XHJcbiAgICAgICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGFzRG9jdW1lbnRhdGlvbihpdGVtLmRvY3VtZW50YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRGVmaW5pdGlvblJlc3VsdChpdGVtKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJcy5hcnJheShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5tYXAoKGxvY2F0aW9uKSA9PiBhc0xvY2F0aW9uKGxvY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYXNMb2NhdGlvbihpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0xvY2F0aW9uKGl0ZW0pIHtcclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlLkxvY2F0aW9uKF91cmlDb252ZXJ0ZXIoaXRlbS51cmkpLCBhc1JhbmdlKGl0ZW0ucmFuZ2UpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUmVmZXJlbmNlcyh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChsb2NhdGlvbiA9PiBhc0xvY2F0aW9uKGxvY2F0aW9uKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0RvY3VtZW50SGlnaGxpZ2h0cyh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChhc0RvY3VtZW50SGlnaGxpZ2h0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRG9jdW1lbnRIaWdobGlnaHQoaXRlbSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgY29kZS5Eb2N1bWVudEhpZ2hsaWdodChhc1JhbmdlKGl0ZW0ucmFuZ2UpKTtcclxuICAgICAgICBpZiAoSXMubnVtYmVyKGl0ZW0ua2luZCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBhc0RvY3VtZW50SGlnaGxpZ2h0S2luZChpdGVtLmtpbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEb2N1bWVudEhpZ2hsaWdodEtpbmQoaXRlbSkge1xyXG4gICAgICAgIHN3aXRjaCAoaXRlbSkge1xyXG4gICAgICAgICAgICBjYXNlIGxzLkRvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQ7XHJcbiAgICAgICAgICAgIGNhc2UgbHMuRG9jdW1lbnRIaWdobGlnaHRLaW5kLlJlYWQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5Eb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZDtcclxuICAgICAgICAgICAgY2FzZSBscy5Eb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZS5Eb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlLkRvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNTeW1ib2xJbmZvcm1hdGlvbnModmFsdWVzLCB1cmkpIHtcclxuICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChpbmZvcm1hdGlvbiA9PiBhc1N5bWJvbEluZm9ybWF0aW9uKGluZm9ybWF0aW9uLCB1cmkpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzU3ltYm9sS2luZChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gPD0gbHMuU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFN5bWJvbCBraW5kIGlzIG9uZSBiYXNlZCBpbiB0aGUgcHJvdG9jb2wgYW5kIHplcm8gYmFzZWQgaW4gY29kZS5cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZS5TeW1ib2xLaW5kLlByb3BlcnR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNTeW1ib2xJbmZvcm1hdGlvbihpdGVtLCB1cmkpIHtcclxuICAgICAgICAvLyBTeW1ib2wga2luZCBpcyBvbmUgYmFzZWQgaW4gdGhlIHByb3RvY29sIGFuZCB6ZXJvIGJhc2VkIGluIGNvZGUuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBjb2RlLlN5bWJvbEluZm9ybWF0aW9uKGl0ZW0ubmFtZSwgYXNTeW1ib2xLaW5kKGl0ZW0ua2luZCksIGFzUmFuZ2UoaXRlbS5sb2NhdGlvbi5yYW5nZSksIGl0ZW0ubG9jYXRpb24udXJpID8gX3VyaUNvbnZlcnRlcihpdGVtLmxvY2F0aW9uLnVyaSkgOiB1cmkpO1xyXG4gICAgICAgIGlmIChpdGVtLmNvbnRhaW5lck5hbWUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBpdGVtLmNvbnRhaW5lck5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0RvY3VtZW50U3ltYm9scyh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDAgfHwgdmFsdWVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGFzRG9jdW1lbnRTeW1ib2wpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEb2N1bWVudFN5bWJvbCh2YWx1ZSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgY29kZS5Eb2N1bWVudFN5bWJvbCh2YWx1ZS5uYW1lLCB2YWx1ZS5kZXRhaWwgfHwgJycsIGFzU3ltYm9sS2luZCh2YWx1ZS5raW5kKSwgYXNSYW5nZSh2YWx1ZS5yYW5nZSksIGFzUmFuZ2UodmFsdWUuc2VsZWN0aW9uUmFuZ2UpKTtcclxuICAgICAgICBpZiAodmFsdWUuY2hpbGRyZW4gIT09IHZvaWQgMCAmJiB2YWx1ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB2YWx1ZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChhc0RvY3VtZW50U3ltYm9sKGNoaWxkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvbW1hbmQoaXRlbSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlOiBpdGVtLnRpdGxlLCBjb21tYW5kOiBpdGVtLmNvbW1hbmQgfTtcclxuICAgICAgICBpZiAoaXRlbS5hcmd1bWVudHMpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGl0ZW0uYXJndW1lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb21tYW5kcyhpdGVtcykge1xyXG4gICAgICAgIGlmICghaXRlbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChhc0NvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2luZE1hcHBpbmcgPSBuZXcgTWFwKCk7XHJcbiAgICBraW5kTWFwcGluZy5zZXQoJycsIGNvZGUuQ29kZUFjdGlvbktpbmQuRW1wdHkpO1xyXG4gICAga2luZE1hcHBpbmcuc2V0KGxzLkNvZGVBY3Rpb25LaW5kLlF1aWNrRml4LCBjb2RlLkNvZGVBY3Rpb25LaW5kLlF1aWNrRml4KTtcclxuICAgIGtpbmRNYXBwaW5nLnNldChscy5Db2RlQWN0aW9uS2luZC5SZWZhY3RvciwgY29kZS5Db2RlQWN0aW9uS2luZC5SZWZhY3Rvcik7XHJcbiAgICBraW5kTWFwcGluZy5zZXQobHMuQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0LCBjb2RlLkNvZGVBY3Rpb25LaW5kLlJlZmFjdG9yRXh0cmFjdCk7XHJcbiAgICBraW5kTWFwcGluZy5zZXQobHMuQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUsIGNvZGUuQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUpO1xyXG4gICAga2luZE1hcHBpbmcuc2V0KGxzLkNvZGVBY3Rpb25LaW5kLlJlZmFjdG9yUmV3cml0ZSwgY29kZS5Db2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUpO1xyXG4gICAga2luZE1hcHBpbmcuc2V0KGxzLkNvZGVBY3Rpb25LaW5kLlNvdXJjZSwgY29kZS5Db2RlQWN0aW9uS2luZC5Tb3VyY2UpO1xyXG4gICAga2luZE1hcHBpbmcuc2V0KGxzLkNvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cywgY29kZS5Db2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMpO1xyXG4gICAgZnVuY3Rpb24gYXNDb2RlQWN0aW9uS2luZChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gPT09IHZvaWQgMCB8fCBpdGVtID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBraW5kTWFwcGluZy5nZXQoaXRlbSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGFydHMgPSBpdGVtLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgcmVzdWx0ID0gY29kZS5Db2RlQWN0aW9uS2luZC5FbXB0eTtcclxuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hcHBlbmQocGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvZGVBY3Rpb25LaW5kcyhpdGVtcykge1xyXG4gICAgICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwIHx8IGl0ZW1zID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoa2luZCA9PiBhc0NvZGVBY3Rpb25LaW5kKGtpbmQpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ29kZUFjdGlvbihpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gPT09IHZvaWQgMCB8fCBpdGVtID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgY29kZS5Db2RlQWN0aW9uKGl0ZW0udGl0bGUpO1xyXG4gICAgICAgIGlmIChpdGVtLmtpbmQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGFzQ29kZUFjdGlvbktpbmQoaXRlbS5raW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZGlhZ25vc3RpY3MpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRpYWdub3N0aWNzID0gYXNEaWFnbm9zdGljcyhpdGVtLmRpYWdub3N0aWNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZWRpdCkge1xyXG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGFzV29ya3NwYWNlRWRpdChpdGVtLmVkaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb21tYW5kID0gYXNDb21tYW5kKGl0ZW0uY29tbWFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvZGVMZW5zKGl0ZW0pIHtcclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBwcm90b2NvbENvZGVMZW5zXzEuZGVmYXVsdChhc1JhbmdlKGl0ZW0ucmFuZ2UpKTtcclxuICAgICAgICBpZiAoaXRlbS5jb21tYW5kKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb21tYW5kID0gYXNDb21tYW5kKGl0ZW0uY29tbWFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmRhdGEgIT09IHZvaWQgMCAmJiBpdGVtLmRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBpdGVtLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvZGVMZW5zZXMoaXRlbXMpIHtcclxuICAgICAgICBpZiAoIWl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGNvZGVMZW5zKSA9PiBhc0NvZGVMZW5zKGNvZGVMZW5zKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1dvcmtzcGFjZUVkaXQoaXRlbSkge1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGNvZGUuV29ya3NwYWNlRWRpdCgpO1xyXG4gICAgICAgIGlmIChpdGVtLmRvY3VtZW50Q2hhbmdlcykge1xyXG4gICAgICAgICAgICBpdGVtLmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobHMuQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNyZWF0ZUZpbGUoX3VyaUNvbnZlcnRlcihjaGFuZ2UudXJpKSwgY2hhbmdlLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobHMuUmVuYW1lRmlsZS5pcyhjaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbmFtZUZpbGUoX3VyaUNvbnZlcnRlcihjaGFuZ2Uub2xkVXJpKSwgX3VyaUNvbnZlcnRlcihjaGFuZ2UubmV3VXJpKSwgY2hhbmdlLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobHMuRGVsZXRlRmlsZS5pcyhjaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZUZpbGUoX3VyaUNvbnZlcnRlcihjaGFuZ2UudXJpKSwgY2hhbmdlLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobHMuVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChfdXJpQ29udmVydGVyKGNoYW5nZS50ZXh0RG9jdW1lbnQudXJpKSwgYXNUZXh0RWRpdHMoY2hhbmdlLmVkaXRzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmtub3duIHdvcmtzcGFjZSBlZGl0IGNoYW5nZSByZWNlaXZlZDpcXG4ke0pTT04uc3RyaW5naWZ5KGNoYW5nZSwgdW5kZWZpbmVkLCA0KX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uY2hhbmdlcykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpdGVtLmNoYW5nZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoX3VyaUNvbnZlcnRlcihrZXkpLCBhc1RleHRFZGl0cyhpdGVtLmNoYW5nZXNba2V5XSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRG9jdW1lbnRMaW5rKGl0ZW0pIHtcclxuICAgICAgICBsZXQgcmFuZ2UgPSBhc1JhbmdlKGl0ZW0ucmFuZ2UpO1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBpdGVtLnRhcmdldCA/IGFzVXJpKGl0ZW0udGFyZ2V0KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyB0YXJnZXQgbXVzdCBiZSBvcHRpb25hbCBpbiBEb2N1bWVudExpbmtcclxuICAgICAgICBsZXQgbGluayA9IG5ldyBwcm90b2NvbERvY3VtZW50TGlua18xLmRlZmF1bHQocmFuZ2UsIHRhcmdldCk7XHJcbiAgICAgICAgaWYgKGl0ZW0uZGF0YSAhPT0gdm9pZCAwICYmIGl0ZW0uZGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsaW5rLmRhdGEgPSBpdGVtLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5rO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNEb2N1bWVudExpbmtzKGl0ZW1zKSB7XHJcbiAgICAgICAgaWYgKCFpdGVtcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXRlbXMubWFwKGFzRG9jdW1lbnRMaW5rKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ29sb3IoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGNvZGUuQ29sb3IoY29sb3IucmVkLCBjb2xvci5ncmVlbiwgY29sb3IuYmx1ZSwgY29sb3IuYWxwaGEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb2xvckluZm9ybWF0aW9uKGNpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlLkNvbG9ySW5mb3JtYXRpb24oYXNSYW5nZShjaS5yYW5nZSksIGFzQ29sb3IoY2kuY29sb3IpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzQ29sb3JJbmZvcm1hdGlvbnMoY29sb3JJbmZvcm1hdGlvbikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9ySW5mb3JtYXRpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvckluZm9ybWF0aW9uLm1hcChhc0NvbG9ySW5mb3JtYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDb2xvclByZXNlbnRhdGlvbihjcCkge1xyXG4gICAgICAgIGxldCBwcmVzZW50YXRpb24gPSBuZXcgY29kZS5Db2xvclByZXNlbnRhdGlvbihjcC5sYWJlbCk7XHJcbiAgICAgICAgcHJlc2VudGF0aW9uLmFkZGl0aW9uYWxUZXh0RWRpdHMgPSBhc1RleHRFZGl0cyhjcC5hZGRpdGlvbmFsVGV4dEVkaXRzKTtcclxuICAgICAgICBpZiAoY3AudGV4dEVkaXQpIHtcclxuICAgICAgICAgICAgcHJlc2VudGF0aW9uLnRleHRFZGl0ID0gYXNUZXh0RWRpdChjcC50ZXh0RWRpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmVzZW50YXRpb247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc0NvbG9yUHJlc2VudGF0aW9ucyhjb2xvclByZXNlbnRhdGlvbnMpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvclByZXNlbnRhdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvclByZXNlbnRhdGlvbnMubWFwKGFzQ29sb3JQcmVzZW50YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNGb2xkaW5nUmFuZ2VLaW5kKGtpbmQpIHtcclxuICAgICAgICBpZiAoa2luZCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgbHMuRm9sZGluZ1JhbmdlS2luZC5Db21tZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLkZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudDtcclxuICAgICAgICAgICAgICAgIGNhc2UgbHMuRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlLkZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cztcclxuICAgICAgICAgICAgICAgIGNhc2UgbHMuRm9sZGluZ1JhbmdlS2luZC5SZWdpb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuRm9sZGluZ1JhbmdlS2luZC5SZWdpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRm9sZGluZ1JhbmdlKHIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGNvZGUuRm9sZGluZ1JhbmdlKHIuc3RhcnRMaW5lLCByLmVuZExpbmUsIGFzRm9sZGluZ1JhbmdlS2luZChyLmtpbmQpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzRm9sZGluZ1Jhbmdlcyhmb2xkaW5nUmFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGluZ1JhbmdlcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvbGRpbmdSYW5nZXMubWFwKGFzRm9sZGluZ1JhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXNVcmksXHJcbiAgICAgICAgYXNEaWFnbm9zdGljcyxcclxuICAgICAgICBhc0RpYWdub3N0aWMsXHJcbiAgICAgICAgYXNSYW5nZSxcclxuICAgICAgICBhc1Bvc2l0aW9uLFxyXG4gICAgICAgIGFzRGlhZ25vc3RpY1NldmVyaXR5LFxyXG4gICAgICAgIGFzSG92ZXIsXHJcbiAgICAgICAgYXNDb21wbGV0aW9uUmVzdWx0LFxyXG4gICAgICAgIGFzQ29tcGxldGlvbkl0ZW0sXHJcbiAgICAgICAgYXNUZXh0RWRpdCxcclxuICAgICAgICBhc1RleHRFZGl0cyxcclxuICAgICAgICBhc1NpZ25hdHVyZUhlbHAsXHJcbiAgICAgICAgYXNTaWduYXR1cmVJbmZvcm1hdGlvbnMsXHJcbiAgICAgICAgYXNTaWduYXR1cmVJbmZvcm1hdGlvbixcclxuICAgICAgICBhc1BhcmFtZXRlckluZm9ybWF0aW9ucyxcclxuICAgICAgICBhc1BhcmFtZXRlckluZm9ybWF0aW9uLFxyXG4gICAgICAgIGFzRGVmaW5pdGlvblJlc3VsdCxcclxuICAgICAgICBhc0xvY2F0aW9uLFxyXG4gICAgICAgIGFzUmVmZXJlbmNlcyxcclxuICAgICAgICBhc0RvY3VtZW50SGlnaGxpZ2h0cyxcclxuICAgICAgICBhc0RvY3VtZW50SGlnaGxpZ2h0LFxyXG4gICAgICAgIGFzRG9jdW1lbnRIaWdobGlnaHRLaW5kLFxyXG4gICAgICAgIGFzU3ltYm9sSW5mb3JtYXRpb25zLFxyXG4gICAgICAgIGFzU3ltYm9sSW5mb3JtYXRpb24sXHJcbiAgICAgICAgYXNEb2N1bWVudFN5bWJvbHMsXHJcbiAgICAgICAgYXNEb2N1bWVudFN5bWJvbCxcclxuICAgICAgICBhc0NvbW1hbmQsXHJcbiAgICAgICAgYXNDb21tYW5kcyxcclxuICAgICAgICBhc0NvZGVBY3Rpb24sXHJcbiAgICAgICAgYXNDb2RlQWN0aW9uS2luZCxcclxuICAgICAgICBhc0NvZGVBY3Rpb25LaW5kcyxcclxuICAgICAgICBhc0NvZGVMZW5zLFxyXG4gICAgICAgIGFzQ29kZUxlbnNlcyxcclxuICAgICAgICBhc1dvcmtzcGFjZUVkaXQsXHJcbiAgICAgICAgYXNEb2N1bWVudExpbmssXHJcbiAgICAgICAgYXNEb2N1bWVudExpbmtzLFxyXG4gICAgICAgIGFzRm9sZGluZ1JhbmdlS2luZCxcclxuICAgICAgICBhc0ZvbGRpbmdSYW5nZSxcclxuICAgICAgICBhc0ZvbGRpbmdSYW5nZXMsXHJcbiAgICAgICAgYXNDb2xvcixcclxuICAgICAgICBhc0NvbG9ySW5mb3JtYXRpb24sXHJcbiAgICAgICAgYXNDb2xvckluZm9ybWF0aW9ucyxcclxuICAgICAgICBhc0NvbG9yUHJlc2VudGF0aW9uLFxyXG4gICAgICAgIGFzQ29sb3JQcmVzZW50YXRpb25zXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlQ29udmVydGVyID0gY3JlYXRlQ29udmVydGVyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/protocolConverter.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/protocolDocumentLink.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/protocolDocumentLink.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst code = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass ProtocolDocumentLink extends code.DocumentLink {\r\n    constructor(range, target) {\r\n        super(range, target);\r\n    }\r\n}\r\nexports.default = ProtocolDocumentLink;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbERvY3VtZW50TGluay5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi9wcm90b2NvbERvY3VtZW50TGluay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY2xhc3MgUHJvdG9jb2xEb2N1bWVudExpbmsgZXh0ZW5kcyBjb2RlLkRvY3VtZW50TGluayB7XHJcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIocmFuZ2UsIHRhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gUHJvdG9jb2xEb2N1bWVudExpbms7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/protocolDocumentLink.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/typeDefinition.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/typeDefinition.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageclient/lib/utils/is.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nconst client_1 = __webpack_require__(/*! ./client */ \"./node_modules/vscode-languageclient/lib/client.js\");\r\nfunction ensure(target, key) {\r\n    if (target[key] === void 0) {\r\n        target[key] = {};\r\n    }\r\n    return target[key];\r\n}\r\nclass TypeDefinitionFeature extends client_1.TextDocumentFeature {\r\n    constructor(client) {\r\n        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);\r\n    }\r\n    fillClientCapabilities(capabilites) {\r\n        ensure(ensure(capabilites, 'textDocument'), 'typeDefinition').dynamicRegistration = true;\r\n    }\r\n    initialize(capabilities, documentSelector) {\r\n        if (!capabilities.typeDefinitionProvider) {\r\n            return;\r\n        }\r\n        if (capabilities.typeDefinitionProvider === true) {\r\n            if (!documentSelector) {\r\n                return;\r\n            }\r\n            this.register(this.messages, {\r\n                id: UUID.generateUuid(),\r\n                registerOptions: Object.assign({}, { documentSelector: documentSelector })\r\n            });\r\n        }\r\n        else {\r\n            const implCapabilities = capabilities.typeDefinitionProvider;\r\n            const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();\r\n            const selector = implCapabilities.documentSelector || documentSelector;\r\n            if (selector) {\r\n                this.register(this.messages, {\r\n                    id,\r\n                    registerOptions: Object.assign({}, { documentSelector: selector })\r\n                });\r\n            }\r\n        }\r\n    }\r\n    registerLanguageProvider(options) {\r\n        let client = this._client;\r\n        let provideTypeDefinition = (document, position, token) => {\r\n            return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {\r\n                client.logFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error);\r\n                return Promise.resolve(null);\r\n            });\r\n        };\r\n        let middleware = client.clientOptions.middleware;\r\n        return vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, {\r\n            provideTypeDefinition: (document, position, token) => {\r\n                return middleware.provideTypeDefinition\r\n                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)\r\n                    : provideTypeDefinition(document, position, token);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.TypeDefinitionFeature = TypeDefinitionFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi90eXBlRGVmaW5pdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi90eXBlRGVmaW5pdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBVVUlEID0gcmVxdWlyZShcIi4vdXRpbHMvdXVpZFwiKTtcclxuY29uc3QgSXMgPSByZXF1aXJlKFwiLi91dGlscy9pc1wiKTtcclxuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2xcIik7XHJcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xyXG5mdW5jdGlvbiBlbnN1cmUodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmICh0YXJnZXRba2V5XSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxufVxyXG5jbGFzcyBUeXBlRGVmaW5pdGlvbkZlYXR1cmUgZXh0ZW5kcyBjbGllbnRfMS5UZXh0RG9jdW1lbnRGZWF0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNsaWVudCwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgZmlsbENsaWVudENhcGFiaWxpdGllcyhjYXBhYmlsaXRlcykge1xyXG4gICAgICAgIGVuc3VyZShlbnN1cmUoY2FwYWJpbGl0ZXMsICd0ZXh0RG9jdW1lbnQnKSwgJ3R5cGVEZWZpbml0aW9uJykuZHluYW1pY1JlZ2lzdHJhdGlvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGNhcGFiaWxpdGllcywgZG9jdW1lbnRTZWxlY3Rvcikge1xyXG4gICAgICAgIGlmICghY2FwYWJpbGl0aWVzLnR5cGVEZWZpbml0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnR5cGVEZWZpbml0aW9uUHJvdmlkZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih0aGlzLm1lc3NhZ2VzLCB7XHJcbiAgICAgICAgICAgICAgICBpZDogVVVJRC5nZW5lcmF0ZVV1aWQoKSxcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgeyBkb2N1bWVudFNlbGVjdG9yOiBkb2N1bWVudFNlbGVjdG9yIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW1wbENhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcy50eXBlRGVmaW5pdGlvblByb3ZpZGVyO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IElzLnN0cmluZyhpbXBsQ2FwYWJpbGl0aWVzLmlkKSAmJiBpbXBsQ2FwYWJpbGl0aWVzLmlkLmxlbmd0aCA+IDAgPyBpbXBsQ2FwYWJpbGl0aWVzLmlkIDogVVVJRC5nZW5lcmF0ZVV1aWQoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBpbXBsQ2FwYWJpbGl0aWVzLmRvY3VtZW50U2VsZWN0b3IgfHwgZG9jdW1lbnRTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoaXMubWVzc2FnZXMsIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICByZWdpc3Rlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHsgZG9jdW1lbnRTZWxlY3Rvcjogc2VsZWN0b3IgfSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMYW5ndWFnZVByb3ZpZGVyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xyXG4gICAgICAgIGxldCBwcm92aWRlVHlwZURlZmluaXRpb24gPSAoZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRSZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLlR5cGVEZWZpbml0aW9uUmVxdWVzdC50eXBlLCBjbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGRvY3VtZW50LCBwb3NpdGlvbiksIHRva2VuKS50aGVuKGNsaWVudC5wcm90b2NvbDJDb2RlQ29udmVydGVyLmFzRGVmaW5pdGlvblJlc3VsdCwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQubG9nRmFpbGVkUmVxdWVzdCh2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5UeXBlRGVmaW5pdGlvblJlcXVlc3QudHlwZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWlkZGxld2FyZSA9IGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmU7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZV8xLmxhbmd1YWdlcy5yZWdpc3RlclR5cGVEZWZpbml0aW9uUHJvdmlkZXIob3B0aW9ucy5kb2N1bWVudFNlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVUeXBlRGVmaW5pdGlvbjogKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnByb3ZpZGVUeXBlRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgICAgICAgID8gbWlkZGxld2FyZS5wcm92aWRlVHlwZURlZmluaXRpb24oZG9jdW1lbnQsIHBvc2l0aW9uLCB0b2tlbiwgcHJvdmlkZVR5cGVEZWZpbml0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZVR5cGVEZWZpbml0aW9uKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UeXBlRGVmaW5pdGlvbkZlYXR1cmUgPSBUeXBlRGVmaW5pdGlvbkZlYXR1cmU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/typeDefinition.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/utils/async.js":
/*!***************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/utils/async.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Delayer {\r\n    constructor(defaultDelay) {\r\n        this.defaultDelay = defaultDelay;\r\n        this.timeout = undefined;\r\n        this.completionPromise = undefined;\r\n        this.onSuccess = undefined;\r\n        this.task = undefined;\r\n    }\r\n    trigger(task, delay = this.defaultDelay) {\r\n        this.task = task;\r\n        if (delay >= 0) {\r\n            this.cancelTimeout();\r\n        }\r\n        if (!this.completionPromise) {\r\n            this.completionPromise = new Promise((resolve) => {\r\n                this.onSuccess = resolve;\r\n            }).then(() => {\r\n                this.completionPromise = undefined;\r\n                this.onSuccess = undefined;\r\n                var result = this.task();\r\n                this.task = undefined;\r\n                return result;\r\n            });\r\n        }\r\n        if (delay >= 0 || this.timeout === void 0) {\r\n            this.timeout = setTimeout(() => {\r\n                this.timeout = undefined;\r\n                this.onSuccess(undefined);\r\n            }, delay >= 0 ? delay : this.defaultDelay);\r\n        }\r\n        return this.completionPromise;\r\n    }\r\n    forceDelivery() {\r\n        if (!this.completionPromise) {\r\n            return undefined;\r\n        }\r\n        this.cancelTimeout();\r\n        let result = this.task();\r\n        this.completionPromise = undefined;\r\n        this.onSuccess = undefined;\r\n        this.task = undefined;\r\n        return result;\r\n    }\r\n    isTriggered() {\r\n        return this.timeout !== void 0;\r\n    }\r\n    cancel() {\r\n        this.cancelTimeout();\r\n        this.completionPromise = undefined;\r\n    }\r\n    cancelTimeout() {\r\n        if (this.timeout !== void 0) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = undefined;\r\n        }\r\n    }\r\n}\r\nexports.Delayer = Delayer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy9hc3luYy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy9hc3luYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBEZWxheWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHREZWxheSkge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdERlbGF5ID0gZGVmYXVsdERlbGF5O1xyXG4gICAgICAgIHRoaXMudGltZW91dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMub25TdWNjZXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRyaWdnZXIodGFzaywgZGVsYXkgPSB0aGlzLmRlZmF1bHREZWxheSkge1xyXG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XHJcbiAgICAgICAgaWYgKGRlbGF5ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jb21wbGV0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50YXNrKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlbGF5ID49IDAgfHwgdGhpcy50aW1lb3V0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzcyh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9LCBkZWxheSA+PSAwID8gZGVsYXkgOiB0aGlzLmRlZmF1bHREZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRpb25Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZm9yY2VEZWxpdmVyeSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcGxldGlvblByb21pc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMudGFzaygpO1xyXG4gICAgICAgIHRoaXMuY29tcGxldGlvblByb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50YXNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpc1RyaWdnZXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lb3V0ICE9PSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XHJcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNhbmNlbFRpbWVvdXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRGVsYXllciA9IERlbGF5ZXI7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/utils/async.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/utils/is.js":
/*!************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/utils/is.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\nfunction typedArray(value, check) {\r\n    return Array.isArray(value) && value.every(check);\r\n}\r\nexports.typedArray = typedArray;\r\nfunction thenable(value) {\r\n    return value && func(value.then);\r\n}\r\nexports.thenable = thenable;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy9pcy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy9pcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XHJcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbn1cclxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XHJcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XHJcbn1cclxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XHJcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcclxufVxyXG5leHBvcnRzLmVycm9yID0gZXJyb3I7XHJcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZXhwb3J0cy5mdW5jID0gZnVuYztcclxuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XHJcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcclxufVxyXG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XHJcbmZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xyXG59XHJcbmV4cG9ydHMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XHJcbmZ1bmN0aW9uIHRoZW5hYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgZnVuYyh2YWx1ZS50aGVuKTtcclxufVxyXG5leHBvcnRzLnRoZW5hYmxlID0gdGhlbmFibGU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/utils/is.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/utils/processes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/utils/processes.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cp = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst path_1 = __webpack_require__(/*! path */ \"path\");\r\nconst isWindows = (process.platform === 'win32');\r\nconst isMacintosh = (process.platform === 'darwin');\r\nconst isLinux = (process.platform === 'linux');\r\nfunction terminate(process, cwd) {\r\n    if (isWindows) {\r\n        try {\r\n            // This we run in Atom execFileSync is available.\r\n            // Ignore stderr since this is otherwise piped to parent.stderr\r\n            // which might be already closed.\r\n            let options = {\r\n                stdio: ['pipe', 'pipe', 'ignore']\r\n            };\r\n            if (cwd) {\r\n                options.cwd = cwd;\r\n            }\r\n            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\r\n            return true;\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n    else if (isLinux || isMacintosh) {\r\n        try {\r\n            var cmd = path_1.join(__dirname, 'terminateProcess.sh');\r\n            var result = cp.spawnSync(cmd, [process.pid.toString()]);\r\n            return result.error ? false : true;\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        process.kill('SIGKILL');\r\n        return true;\r\n    }\r\n}\r\nexports.terminate = terminate;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy9wcm9jZXNzZXMuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZWNsaWVudC9saWIvdXRpbHMvcHJvY2Vzc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNwID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XHJcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XHJcbmNvbnN0IGlzTWFjaW50b3NoID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcclxuY29uc3QgaXNMaW51eCA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKTtcclxuZnVuY3Rpb24gdGVybWluYXRlKHByb2Nlc3MsIGN3ZCkge1xyXG4gICAgaWYgKGlzV2luZG93cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgd2UgcnVuIGluIEF0b20gZXhlY0ZpbGVTeW5jIGlzIGF2YWlsYWJsZS5cclxuICAgICAgICAgICAgLy8gSWdub3JlIHN0ZGVyciBzaW5jZSB0aGlzIGlzIG90aGVyd2lzZSBwaXBlZCB0byBwYXJlbnQuc3RkZXJyXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIG1pZ2h0IGJlIGFscmVhZHkgY2xvc2VkLlxyXG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHN0ZGlvOiBbJ3BpcGUnLCAncGlwZScsICdpZ25vcmUnXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoY3dkKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmN3ZCA9IGN3ZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjcC5leGVjRmlsZVN5bmMoJ3Rhc2traWxsJywgWycvVCcsICcvRicsICcvUElEJywgcHJvY2Vzcy5waWQudG9TdHJpbmcoKV0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNMaW51eCB8fCBpc01hY2ludG9zaCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjbWQgPSBwYXRoXzEuam9pbihfX2Rpcm5hbWUsICd0ZXJtaW5hdGVQcm9jZXNzLnNoJyk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjcC5zcGF3blN5bmMoY21kLCBbcHJvY2Vzcy5waWQudG9TdHJpbmcoKV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmVycm9yID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwcm9jZXNzLmtpbGwoJ1NJR0tJTEwnKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRlcm1pbmF0ZSA9IHRlcm1pbmF0ZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/utils/processes.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/utils/uuid.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/utils/uuid.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass ValueUUID {\r\n    constructor(_value) {\r\n        this._value = _value;\r\n        // empty\r\n    }\r\n    asHex() {\r\n        return this._value;\r\n    }\r\n    equals(other) {\r\n        return this.asHex() === other.asHex();\r\n    }\r\n}\r\nclass V4UUID extends ValueUUID {\r\n    constructor() {\r\n        super([\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            '-',\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            '-',\r\n            '4',\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            '-',\r\n            V4UUID._oneOf(V4UUID._timeHighBits),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            '-',\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n            V4UUID._randomHex(),\r\n        ].join(''));\r\n    }\r\n    static _oneOf(array) {\r\n        return array[Math.floor(array.length * Math.random())];\r\n    }\r\n    static _randomHex() {\r\n        return V4UUID._oneOf(V4UUID._chars);\r\n    }\r\n}\r\nV4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\r\nV4UUID._timeHighBits = ['8', '9', 'a', 'b'];\r\n/**\r\n * An empty UUID that contains only zeros.\r\n */\r\nexports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');\r\nfunction v4() {\r\n    return new V4UUID();\r\n}\r\nexports.v4 = v4;\r\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\r\nfunction isUUID(value) {\r\n    return _UUIDPattern.test(value);\r\n}\r\nexports.isUUID = isUUID;\r\n/**\r\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\r\n * @param value A uuid string.\r\n */\r\nfunction parse(value) {\r\n    if (!isUUID(value)) {\r\n        throw new Error('invalid uuid');\r\n    }\r\n    return new ValueUUID(value);\r\n}\r\nexports.parse = parse;\r\nfunction generateUuid() {\r\n    return v4().asHex();\r\n}\r\nexports.generateUuid = generateUuid;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi91dGlscy91dWlkLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL3V0aWxzL3V1aWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBWYWx1ZVVVSUQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgLy8gZW1wdHlcclxuICAgIH1cclxuICAgIGFzSGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzSGV4KCkgPT09IG90aGVyLmFzSGV4KCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVjRVVUlEIGV4dGVuZHMgVmFsdWVVVUlEIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFtcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgJy0nLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICAnLScsXHJcbiAgICAgICAgICAgICc0JyxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgJy0nLFxyXG4gICAgICAgICAgICBWNFVVSUQuX29uZU9mKFY0VVVJRC5fdGltZUhpZ2hCaXRzKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgVjRVVUlELl9yYW5kb21IZXgoKSxcclxuICAgICAgICAgICAgJy0nLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgICAgICBWNFVVSUQuX3JhbmRvbUhleCgpLFxyXG4gICAgICAgIF0uam9pbignJykpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9vbmVPZihhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVtNYXRoLmZsb29yKGFycmF5Lmxlbmd0aCAqIE1hdGgucmFuZG9tKCkpXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfcmFuZG9tSGV4KCkge1xyXG4gICAgICAgIHJldHVybiBWNFVVSUQuX29uZU9mKFY0VVVJRC5fY2hhcnMpO1xyXG4gICAgfVxyXG59XHJcblY0VVVJRC5fY2hhcnMgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNicsICc3JywgJzgnLCAnOScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZiddO1xyXG5WNFVVSUQuX3RpbWVIaWdoQml0cyA9IFsnOCcsICc5JywgJ2EnLCAnYiddO1xyXG4vKipcclxuICogQW4gZW1wdHkgVVVJRCB0aGF0IGNvbnRhaW5zIG9ubHkgemVyb3MuXHJcbiAqL1xyXG5leHBvcnRzLmVtcHR5ID0gbmV3IFZhbHVlVVVJRCgnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJyk7XHJcbmZ1bmN0aW9uIHY0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBWNFVVSUQoKTtcclxufVxyXG5leHBvcnRzLnY0ID0gdjQ7XHJcbmNvbnN0IF9VVUlEUGF0dGVybiA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC9pO1xyXG5mdW5jdGlvbiBpc1VVSUQodmFsdWUpIHtcclxuICAgIHJldHVybiBfVVVJRFBhdHRlcm4udGVzdCh2YWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pc1VVSUQgPSBpc1VVSUQ7XHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBVVUlEIHRoYXQgaXMgb2YgdGhlIGZvcm1hdCB4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHguXHJcbiAqIEBwYXJhbSB2YWx1ZSBBIHV1aWQgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcclxuICAgIGlmICghaXNVVUlEKHZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1dWlkJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFZhbHVlVVVJRCh2YWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVV1aWQoKSB7XHJcbiAgICByZXR1cm4gdjQoKS5hc0hleCgpO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVVdWlkID0gZ2VuZXJhdGVVdWlkO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/utils/uuid.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/workspaceFolders.js":
/*!********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/workspaceFolders.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageclient/lib/utils/uuid.js\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/main.js\");\r\nfunction access(target, key) {\r\n    if (target === void 0) {\r\n        return undefined;\r\n    }\r\n    return target[key];\r\n}\r\nclass WorkspaceFoldersFeature {\r\n    constructor(_client) {\r\n        this._client = _client;\r\n        this._listeners = new Map();\r\n    }\r\n    get messages() {\r\n        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;\r\n    }\r\n    fillInitializeParams(params) {\r\n        let folders = vscode_1.workspace.workspaceFolders;\r\n        if (folders === void 0) {\r\n            params.workspaceFolders = null;\r\n        }\r\n        else {\r\n            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));\r\n        }\r\n    }\r\n    fillClientCapabilities(capabilities) {\r\n        capabilities.workspace = capabilities.workspace || {};\r\n        capabilities.workspace.workspaceFolders = true;\r\n    }\r\n    initialize(capabilities) {\r\n        let client = this._client;\r\n        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {\r\n            let workspaceFolders = () => {\r\n                let folders = vscode_1.workspace.workspaceFolders;\r\n                if (folders === void 0) {\r\n                    return null;\r\n                }\r\n                let result = folders.map((folder) => {\r\n                    return this.asProtocol(folder);\r\n                });\r\n                return result;\r\n            };\r\n            let middleware = client.clientOptions.middleware.workspace;\r\n            return middleware && middleware.workspaceFolders\r\n                ? middleware.workspaceFolders(token, workspaceFolders)\r\n                : workspaceFolders(token);\r\n        });\r\n        let value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');\r\n        let id;\r\n        if (typeof value === 'string') {\r\n            id = value;\r\n        }\r\n        else if (value === true) {\r\n            id = UUID.generateUuid();\r\n        }\r\n        if (id) {\r\n            this.register(this.messages, {\r\n                id: id,\r\n                registerOptions: undefined\r\n            });\r\n        }\r\n    }\r\n    register(_message, data) {\r\n        let id = data.id;\r\n        let client = this._client;\r\n        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {\r\n            let didChangeWorkspaceFolders = (event) => {\r\n                let params = {\r\n                    event: {\r\n                        added: event.added.map(folder => this.asProtocol(folder)),\r\n                        removed: event.removed.map(folder => this.asProtocol(folder))\r\n                    }\r\n                };\r\n                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);\r\n            };\r\n            let middleware = client.clientOptions.middleware.workspace;\r\n            middleware && middleware.didChangeWorkspaceFolders\r\n                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)\r\n                : didChangeWorkspaceFolders(event);\r\n        });\r\n        this._listeners.set(id, disposable);\r\n    }\r\n    unregister(id) {\r\n        let disposable = this._listeners.get(id);\r\n        if (disposable === void 0) {\r\n            return;\r\n        }\r\n        this._listeners.delete(id);\r\n        disposable.dispose();\r\n    }\r\n    dispose() {\r\n        for (let disposable of this._listeners.values()) {\r\n            disposable.dispose();\r\n        }\r\n        this._listeners.clear();\r\n    }\r\n    asProtocol(workspaceFolder) {\r\n        if (workspaceFolder === void 0) {\r\n            return null;\r\n        }\r\n        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };\r\n    }\r\n}\r\nexports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L2xpYi93b3Jrc3BhY2VGb2xkZXJzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbGliL3dvcmtzcGFjZUZvbGRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVVVJRCA9IHJlcXVpcmUoXCIuL3V0aWxzL3V1aWRcIik7XHJcbmNvbnN0IHZzY29kZV8xID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEgPSByZXF1aXJlKFwidnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sXCIpO1xyXG5mdW5jdGlvbiBhY2Nlc3ModGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbn1cclxuY2xhc3MgV29ya3NwYWNlRm9sZGVyc0ZlYXR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoX2NsaWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IF9jbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfMS5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLnR5cGU7XHJcbiAgICB9XHJcbiAgICBmaWxsSW5pdGlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcclxuICAgICAgICBsZXQgZm9sZGVycyA9IHZzY29kZV8xLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzO1xyXG4gICAgICAgIGlmIChmb2xkZXJzID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcGFyYW1zLndvcmtzcGFjZUZvbGRlcnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLndvcmtzcGFjZUZvbGRlcnMgPSBmb2xkZXJzLm1hcChmb2xkZXIgPT4gdGhpcy5hc1Byb3RvY29sKGZvbGRlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbGxDbGllbnRDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgY2FwYWJpbGl0aWVzLndvcmtzcGFjZSA9IGNhcGFiaWxpdGllcy53b3Jrc3BhY2UgfHwge307XHJcbiAgICAgICAgY2FwYWJpbGl0aWVzLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgbGV0IGNsaWVudCA9IHRoaXMuX2NsaWVudDtcclxuICAgICAgICBjbGllbnQub25SZXF1ZXN0KHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF8xLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUsICh0b2tlbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgd29ya3NwYWNlRm9sZGVycyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBmb2xkZXJzID0gdnNjb2RlXzEud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9sZGVycyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZm9sZGVycy5tYXAoKGZvbGRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzUHJvdG9jb2woZm9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZXdhcmUgPSBjbGllbnQuY2xpZW50T3B0aW9ucy5taWRkbGV3YXJlLndvcmtzcGFjZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUgJiYgbWlkZGxld2FyZS53b3Jrc3BhY2VGb2xkZXJzXHJcbiAgICAgICAgICAgICAgICA/IG1pZGRsZXdhcmUud29ya3NwYWNlRm9sZGVycyh0b2tlbiwgd29ya3NwYWNlRm9sZGVycylcclxuICAgICAgICAgICAgICAgIDogd29ya3NwYWNlRm9sZGVycyh0b2tlbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYWNjZXNzKGFjY2VzcyhhY2Nlc3MoY2FwYWJpbGl0aWVzLCAnd29ya3NwYWNlJyksICd3b3Jrc3BhY2VGb2xkZXJzJyksICdjaGFuZ2VOb3RpZmljYXRpb25zJyk7XHJcbiAgICAgICAgbGV0IGlkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlkID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGlkID0gVVVJRC5nZW5lcmF0ZVV1aWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5tZXNzYWdlcywge1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJPcHRpb25zOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXIoX21lc3NhZ2UsIGRhdGEpIHtcclxuICAgICAgICBsZXQgaWQgPSBkYXRhLmlkO1xyXG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XHJcbiAgICAgICAgbGV0IGRpc3Bvc2FibGUgPSB2c2NvZGVfMS53b3Jrc3BhY2Uub25EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzKChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZDogZXZlbnQuYWRkZWQubWFwKGZvbGRlciA9PiB0aGlzLmFzUHJvdG9jb2woZm9sZGVyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IGV2ZW50LnJlbW92ZWQubWFwKGZvbGRlciA9PiB0aGlzLmFzUHJvdG9jb2woZm9sZGVyKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmROb3RpZmljYXRpb24odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sXzEuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgbWlkZGxld2FyZSA9IGNsaWVudC5jbGllbnRPcHRpb25zLm1pZGRsZXdhcmUud29ya3NwYWNlO1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlICYmIG1pZGRsZXdhcmUuZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc1xyXG4gICAgICAgICAgICAgICAgPyBtaWRkbGV3YXJlLmRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnMoZXZlbnQsIGRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnMpXHJcbiAgICAgICAgICAgICAgICA6IGRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnMoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQoaWQsIGRpc3Bvc2FibGUpO1xyXG4gICAgfVxyXG4gICAgdW5yZWdpc3RlcihpZCkge1xyXG4gICAgICAgIGxldCBkaXNwb3NhYmxlID0gdGhpcy5fbGlzdGVuZXJzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUoaWQpO1xyXG4gICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBmb3IgKGxldCBkaXNwb3NhYmxlIG9mIHRoaXMuX2xpc3RlbmVycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBhc1Byb3RvY29sKHdvcmtzcGFjZUZvbGRlcikge1xyXG4gICAgICAgIGlmICh3b3Jrc3BhY2VGb2xkZXIgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB0aGlzLl9jbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1VyaSh3b3Jrc3BhY2VGb2xkZXIudXJpKSwgbmFtZTogd29ya3NwYWNlRm9sZGVyLm5hbWUgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLldvcmtzcGFjZUZvbGRlcnNGZWF0dXJlID0gV29ya3NwYWNlRm9sZGVyc0ZlYXR1cmU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/lib/workspaceFolders.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageclient/node_modules/semver/semver.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/node_modules/semver/semver.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++;\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, options) {\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = options.loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, options);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, options) {\n  var v = parse(version, options);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, options) {\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, options);\n\n  debug('SemVer', version, options);\n  this.options = options;\n  this.loose = !!options.loose;\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.options, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.options);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.options);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.options);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, options) {\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, options);\n\n  debug('comparator', comp, options);\n  this.options = options;\n  this.loose = !!options.loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.options.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.options.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.options);\n\n  return cmp(version, this.operator, this.semver, this.options);\n};\n\nComparator.prototype.intersects = function(comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options);\n    return satisfies(this.value, rangeTmp, options);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options);\n    return satisfies(comp.semver, rangeTmp, options);\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'));\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'));\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\n\nexports.Range = Range;\nfunction Range(range, options) {\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range;\n    } else {\n      return new Range(range.raw, options);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options);\n  }\n\n  if (!(this instanceof Range))\n    return new Range(range, options);\n\n  this.options = options;\n  this.loose = !!options.loose;\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.options.loose;\n  range = range.trim();\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, this.options);\n  }, this).join(' ').split(/\\s+/);\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, this.options);\n  }, this);\n\n  return set;\n};\n\nRange.prototype.intersects = function(range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function(thisComparators) {\n    return thisComparators.every(function(thisComparator) {\n      return range.set.some(function(rangeComparators) {\n        return rangeComparators.every(function(rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, options) {\n  return new Range(range, options).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, options) {\n  debug('comp', comp, options);\n  comp = replaceCarets(comp, options);\n  debug('caret', comp);\n  comp = replaceTildes(comp, options);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, options);\n  debug('xrange', comp);\n  comp = replaceStars(comp, options);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, options) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, options);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, options) {\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, options) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, options);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, options) {\n  debug('caret', comp, options);\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n  var r = options.loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, options) {\n  debug('replaceXRanges', comp, options);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, options);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, options) {\n  comp = comp.trim();\n  if (!options || typeof options !== 'object')\n    options = { loose: !!options, includePrerelease: false }\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, options) {\n  debug('replaceStars', comp, options);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.options);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (!options)\n    options = {}\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, options) {\n  try {\n    range = new Range(range, options);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, options) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, options);\n      }\n    }\n  })\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, options) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, options);\n      }\n    }\n  })\n  return min;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, options) {\n  return outside(version, range, '<', options);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, options) {\n  return outside(version, range, '>', options);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, options) {\n  version = new SemVer(version, options);\n  range = new Range(range, options);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, options) {\n  var parsed = parse(version, options);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\nfunction intersects(r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce;\nfunction coerce(version) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  var match = version.match(re[COERCE]);\n\n  if (match == null)\n    return null;\n\n  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); \n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlY2xpZW50L25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VjbGllbnQvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xuXG4vLyBUaGUgZGVidWcgZnVuY3Rpb24gaXMgZXhjbHVkZWQgZW50aXJlbHkgZnJvbSB0aGUgbWluaWZpZWQgdmVyc2lvbi5cbi8qIG5vbWluICovIHZhciBkZWJ1Zztcbi8qIG5vbWluICovIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudiAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvKiBub21pbiAqLyAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSlcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBub21pbiAqLyB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgLyogbm9taW4gKi8gYXJncy51bnNoaWZ0KCdTRU1WRVInKTtcbiAgICAvKiBub21pbiAqLyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAvKiBub21pbiAqLyB9O1xuLyogbm9taW4gKi8gZWxzZVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG5cbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG52YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2O1xuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgUiA9IDA7XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKic7XG52YXIgTlVNRVJJQ0lERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnO1xuXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5cblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIE1BSU5WRVJTSU9OTE9PU0UgPSBSKys7XG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7XG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudmFyIFBSRVJFTEVBU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJztcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG52YXIgQlVJTERJREVOVElGSUVSID0gUisrO1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgQlVJTEQgPSBSKys7XG5zcmNbQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tCVUlMRElERU5USUZJRVJdICsgJykqKSknO1xuXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG52YXIgRlVMTCA9IFIrKztcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG5zcmNbRlVMTF0gPSAnXicgKyBGVUxMUExBSU4gKyAnJCc7XG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnZhciBMT09TRVBMQUlOID0gJ1t2PVxcXFxzXSonICsgc3JjW01BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG52YXIgTE9PU0UgPSBSKys7XG5zcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJztcblxudmFyIEdUTFQgPSBSKys7XG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJztcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudmFyIFhSQU5HRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConO1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xuXG52YXIgWFJBTkdFUExBSU4gPSBSKys7XG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRVBMQUlOTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFID0gUisrO1xuc3JjW1hSQU5HRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgWFJBTkdFTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxudmFyIENPRVJDRSA9IFIrKztcbnNyY1tDT0VSQ0VdID0gJyg/Ol58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KScgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OiR8W15cXFxcZF0pJztcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnZhciBMT05FVElMREUgPSBSKys7XG5zcmNbTE9ORVRJTERFXSA9ICcoPzp+Pj8pJztcblxudmFyIFRJTERFVFJJTSA9IFIrKztcbnNyY1tUSUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xcXFxzKyc7XG5yZVtUSUxERVRSSU1dID0gbmV3IFJlZ0V4cChzcmNbVElMREVUUklNXSwgJ2cnKTtcbnZhciB0aWxkZVRyaW1SZXBsYWNlID0gJyQxfic7XG5cbnZhciBUSUxERSA9IFIrKztcbnNyY1tUSUxERV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgVElMREVMT09TRSA9IFIrKztcbnNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxudmFyIExPTkVDQVJFVCA9IFIrKztcbnNyY1tMT05FQ0FSRVRdID0gJyg/OlxcXFxeKSc7XG5cbnZhciBDQVJFVFRSSU0gPSBSKys7XG5zcmNbQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORUNBUkVUXSArICdcXFxccysnO1xucmVbQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NBUkVUVFJJTV0sICdnJyk7XG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xuXG52YXIgQ0FSRVQgPSBSKys7XG5zcmNbQ0FSRVRdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIENBUkVUTE9PU0UgPSBSKys7XG5zcmNbQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbnZhciBDT01QQVJBVE9STE9PU0UgPSBSKys7XG5zcmNbQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnO1xudmFyIENPTVBBUkFUT1IgPSBSKys7XG5zcmNbQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBGVUxMUExBSU4gKyAnKSR8XiQnO1xuXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG52YXIgQ09NUEFSQVRPUlRSSU0gPSBSKys7XG5zcmNbQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1tHVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSc7XG5cbi8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcbnJlW0NPTVBBUkFUT1JUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJztcblxuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxudmFyIEhZUEhFTlJBTkdFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxudmFyIEhZUEhFTlJBTkdFTE9PU0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG52YXIgU1RBUiA9IFIrKztcbnNyY1tTVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcblxuLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4vLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLlxuZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHtcbiAgZGVidWcoaSwgc3JjW2ldKTtcbiAgaWYgKCFyZVtpXSlcbiAgICByZVtpXSA9IG5ldyBSZWdFeHAoc3JjW2ldKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZnVuY3Rpb24gcGFyc2UodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpXG4gICAgcmV0dXJuIHZlcnNpb247XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdO1xuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZDtcbmZ1bmN0aW9uIHZhbGlkKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsO1xufVxuXG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmZ1bmN0aW9uIGNsZWFuKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpO1xuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGw7XG59XG5cbmV4cG9ydHMuU2VtVmVyID0gU2VtVmVyO1xuXG5mdW5jdGlvbiBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IG9wdGlvbnMubG9vc2UpXG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICBlbHNlXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG5cbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcblxuICB0aGlzLnJhdyA9IHZlcnNpb247XG5cbiAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgdGhpcy5tYWpvciA9ICttWzFdO1xuICB0aGlzLm1pbm9yID0gK21bMl07XG4gIHRoaXMucGF0Y2ggPSArbVszXTtcblxuICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcblxuICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgaWYgKCFtWzRdKVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICBlbHNlXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgdmFyIG51bSA9ICtpZDtcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdO1xuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKTtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcblxuICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgaSA9IDA7XG4gIGRvIHtcbiAgICB2YXIgYSA9IHRoaXMucHJlcmVsZWFzZVtpXTtcbiAgICB2YXIgYiA9IG90aGVyLnByZXJlbGVhc2VbaV07XG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEgPT09IGIpXG4gICAgICBjb250aW51ZTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICB9IHdoaWxlICgrK2kpO1xufTtcblxuLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuU2VtVmVyLnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbihyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gIHN3aXRjaCAocmVsZWFzZSkge1xuICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgLy8gcHJlcGF0Y2guXG4gICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21ham9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wYXRjaCsrO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgIC8vIDEuMC4wIFwicHJlXCIgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICBjYXNlICdwcmUnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKys7XG4gICAgICAgICAgICBpID0gLTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAtMSkgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApO1xuICAgICAgfVxuICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAnICsgcmVsZWFzZSk7XG4gIH1cbiAgdGhpcy5mb3JtYXQoKTtcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuZXhwb3J0cy5pbmMgPSBpbmM7XG5mdW5jdGlvbiBpbmModmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHtcbiAgaWYgKHR5cGVvZihsb29zZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IGxvb3NlO1xuICAgIGxvb3NlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb247XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5kaWZmID0gZGlmZjtcbmZ1bmN0aW9uIGRpZmYodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpO1xuICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKTtcbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcmUnK2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAncHJlcmVsZWFzZSc7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVycztcblxudmFyIG51bWVyaWMgPSAvXlswLTldKyQvO1xuZnVuY3Rpb24gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpO1xuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2E7XG4gICAgYiA9ICtiO1xuICB9XG5cbiAgcmV0dXJuIChhbnVtICYmICFibnVtKSA/IC0xIDpcbiAgICAgICAgIChibnVtICYmICFhbnVtKSA/IDEgOlxuICAgICAgICAgYSA8IGIgPyAtMSA6XG4gICAgICAgICBhID4gYiA/IDEgOlxuICAgICAgICAgMDtcbn1cblxuZXhwb3J0cy5yY29tcGFyZUlkZW50aWZpZXJzID0gcmNvbXBhcmVJZGVudGlmaWVycztcbmZ1bmN0aW9uIHJjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpO1xufVxuXG5leHBvcnRzLm1ham9yID0gbWFqb3I7XG5mdW5jdGlvbiBtYWpvcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3I7XG59XG5cbmV4cG9ydHMubWlub3IgPSBtaW5vcjtcbmZ1bmN0aW9uIG1pbm9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vcjtcbn1cblxuZXhwb3J0cy5wYXRjaCA9IHBhdGNoO1xuZnVuY3Rpb24gcGF0Y2goYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoO1xufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuZnVuY3Rpb24gY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSk7XG59XG5cbmV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlO1xuZnVuY3Rpb24gY29tcGFyZUxvb3NlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMucmNvbXBhcmUgPSByY29tcGFyZTtcbmZ1bmN0aW9uIHJjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmZ1bmN0aW9uIHNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5mdW5jdGlvbiByc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmd0ID0gZ3Q7XG5mdW5jdGlvbiBndChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwO1xufVxuXG5leHBvcnRzLmx0ID0gbHQ7XG5mdW5jdGlvbiBsdChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwO1xufVxuXG5leHBvcnRzLmVxID0gZXE7XG5mdW5jdGlvbiBlcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDA7XG59XG5cbmV4cG9ydHMubmVxID0gbmVxO1xuZnVuY3Rpb24gbmVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMDtcbn1cblxuZXhwb3J0cy5ndGUgPSBndGU7XG5mdW5jdGlvbiBndGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDA7XG59XG5cbmV4cG9ydHMubHRlID0gbHRlO1xuZnVuY3Rpb24gbHRlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwO1xufVxuXG5leHBvcnRzLmNtcCA9IGNtcDtcbmZ1bmN0aW9uIGNtcChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgdmFyIHJldDtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgPT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhICE9PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJzogY2FzZSAnPSc6IGNhc2UgJz09JzogcmV0ID0gZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICchPSc6IHJldCA9IG5lcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz4nOiByZXQgPSBndChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz49JzogcmV0ID0gZ3RlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPCc6IHJldCA9IGx0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPD0nOiByZXQgPSBsdGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3I7XG5mdW5jdGlvbiBDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuXG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpXG4gICAgICByZXR1cm4gY29tcDtcbiAgICBlbHNlXG4gICAgICBjb21wID0gY29tcC52YWx1ZTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSlcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucyk7XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgdGhpcy5wYXJzZShjb21wKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICB0aGlzLnZhbHVlID0gJyc7XG4gIGVsc2VcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG5cbiAgZGVidWcoJ2NvbXAnLCB0aGlzKTtcbn1cblxudmFyIEFOWSA9IHt9O1xuQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihjb21wKSB7XG4gIHZhciByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgbSA9IGNvbXAubWF0Y2gocik7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApO1xuXG4gIHRoaXMub3BlcmF0b3IgPSBtWzFdO1xuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKVxuICAgIHRoaXMub3BlcmF0b3IgPSAnJztcblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKVxuICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICBlbHNlXG4gICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcblxuICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG5cbiAgdmFyIHJhbmdlVG1wO1xuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKTtcbiAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uO1xuICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKTtcblxuICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuO1xufTtcblxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5mdW5jdGlvbiBSYW5nZShyYW5nZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS52YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICB0aGlzLnJhdyA9IHJhbmdlO1xuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbihyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKTtcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAvLyB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgcmV0dXJuIGMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgU2VtVmVyIFJhbmdlOiAnICsgcmFuZ2UpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uKGNvbXBzKSB7XG4gICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKCk7XG4gIH0pLmpvaW4oJ3x8JykudHJpbSgpO1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlO1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTtcbiAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gIHZhciBociA9IGxvb3NlID8gcmVbSFlQSEVOUkFOR0VMT09TRV0gOiByZVtIWVBIRU5SQU5HRV07XG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSk7XG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTtcbiAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSk7XG4gIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbQ09NUEFSQVRPUlRSSU1dKTtcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpO1xuXG4gIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSk7XG5cbiAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpO1xuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKTtcbiAgfSwgdGhpcykuam9pbignICcpLnNwbGl0KC9cXHMrLyk7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24oY29tcCkge1xuICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpO1xuICAgIH0pO1xuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gc2V0O1xufTtcblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSwgb3B0aW9ucykge1xuICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9ycykge1xuICAgIHJldHVybiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByYW5nZS5zZXQuc29tZShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9ycztcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMocmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykuc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH0pLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgfSk7XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvcihjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucyk7XG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpO1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpO1xuICBkZWJ1ZygneHJhbmdlJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCdzdGFycycsIGNvbXApO1xuICByZXR1cm4gY29tcDtcbn1cblxuZnVuY3Rpb24gaXNYKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbVElMREVMT09TRV0gOiByZVtUSUxERV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKVxuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9IGVsc2VcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbQ0FSRVRMT09TRV0gOiByZVtDQVJFVF07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJyk7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKTtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtYUkFOR0VMT09TRV0gOiByZVtYUkFOR0VdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHhNID0gaXNYKE0pO1xuICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTtcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7XG4gICAgdmFyIGFueVggPSB4cDtcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WClcbiAgICAgIGd0bHQgPSAnJztcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pXG4gICAgICAgIG0gPSAwO1xuICAgICAgaWYgKHhwKVxuICAgICAgICBwID0gMDtcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjRcbiAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCc7XG4gICAgICAgIGlmICh4bSlcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gZ3RsdCArIE0gKyAnLicgKyBtICsgJy4nICsgcDtcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKTtcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW1NUQVJdLCAnJyk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW0hZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5mdW5jdGlvbiBoeXBoZW5SZXBsYWNlKCQwLFxuICAgICAgICAgICAgICAgICAgICAgICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICAgICAgICAgICAgICAgICAgICAgICB0bywgdE0sIHRtLCB0cCwgdHByLCB0Yikge1xuXG4gIGlmIChpc1goZk0pKVxuICAgIGZyb20gPSAnJztcbiAgZWxzZSBpZiAoaXNYKGZtKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1goZnApKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gIGVsc2VcbiAgICBmcm9tID0gJz49JyArIGZyb207XG5cbiAgaWYgKGlzWCh0TSkpXG4gICAgdG8gPSAnJztcbiAgZWxzZSBpZiAoaXNYKHRtKSlcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKHRwKSlcbiAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJztcbiAgZWxzZSBpZiAodHByKVxuICAgIHRvID0gJzw9JyArIHRNICsgJy4nICsgdG0gKyAnLicgKyB0cCArICctJyArIHRwcjtcbiAgZWxzZVxuICAgIHRvID0gJzw9JyArIHRvO1xuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKCk7XG59XG5cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGlmICghdmVyc2lvbilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHRlc3RTZXQoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge31cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKTtcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBBTlkpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXM7XG5mdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xufVxuXG5leHBvcnRzLm1heFNhdGlzZnlpbmcgPSBtYXhTYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWF4U2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1heCA9IG51bGw7XG4gIHZhciBtYXhTViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHsgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHY7XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heDtcbn1cblxuZXhwb3J0cy5taW5TYXRpc2Z5aW5nID0gbWluU2F0aXNmeWluZztcbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWluU1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHsgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHY7XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pbjtcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZTtcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuZXhwb3J0cy5sdHIgPSBsdHI7XG5mdW5jdGlvbiBsdHIodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucyk7XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmV4cG9ydHMuZ3RyID0gZ3RyO1xuZnVuY3Rpb24gZ3RyKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHQ7XG4gICAgICBsdGVmbiA9IGd0ZTtcbiAgICAgIGx0Zm4gPSBndDtcbiAgICAgIGNvbXAgPSAnPCc7XG4gICAgICBlY29tcCA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuXG4gICAgdmFyIGhpZ2ggPSBudWxsO1xuICAgIHZhciBsb3cgPSBudWxsO1xuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvcjtcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yO1xuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5mdW5jdGlvbiBwcmVyZWxlYXNlKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpO1xuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsO1xufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhyMSwgcjIsIG9wdGlvbnMpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5mdW5jdGlvbiBjb2VyY2UodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbQ09FUkNFXSk7XG5cbiAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHBhcnNlKChtYXRjaFsxXSB8fCAnMCcpICsgJy4nICsgKG1hdGNoWzJdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbM10gfHwgJzAnKSk7IFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageclient/node_modules/semver/semver.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/main.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/main.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nexports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;\r\nexports.ResponseError = vscode_jsonrpc_1.ResponseError;\r\nexports.CancellationToken = vscode_jsonrpc_1.CancellationToken;\r\nexports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;\r\nexports.Disposable = vscode_jsonrpc_1.Disposable;\r\nexports.Event = vscode_jsonrpc_1.Event;\r\nexports.Emitter = vscode_jsonrpc_1.Emitter;\r\nexports.Trace = vscode_jsonrpc_1.Trace;\r\nexports.TraceFormat = vscode_jsonrpc_1.TraceFormat;\r\nexports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;\r\nexports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;\r\nexports.RequestType = vscode_jsonrpc_1.RequestType;\r\nexports.RequestType0 = vscode_jsonrpc_1.RequestType0;\r\nexports.NotificationType = vscode_jsonrpc_1.NotificationType;\r\nexports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;\r\nexports.MessageReader = vscode_jsonrpc_1.MessageReader;\r\nexports.MessageWriter = vscode_jsonrpc_1.MessageWriter;\r\nexports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;\r\nexports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;\r\nexports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;\r\nexports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;\r\nexports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;\r\nexports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;\r\nexports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;\r\nexports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;\r\nexports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;\r\nexports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;\r\n__export(__webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\"));\r\n__export(__webpack_require__(/*! ./protocol */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.js\"));\r\nfunction createProtocolConnection(reader, writer, logger, strategy) {\r\n    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createProtocolConnection = createProtocolConnection;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9tYWluLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSByZXF1aXJlKFwidnNjb2RlLWpzb25ycGNcIik7XHJcbmV4cG9ydHMuRXJyb3JDb2RlcyA9IHZzY29kZV9qc29ucnBjXzEuRXJyb3JDb2RlcztcclxuZXhwb3J0cy5SZXNwb25zZUVycm9yID0gdnNjb2RlX2pzb25ycGNfMS5SZXNwb25zZUVycm9yO1xyXG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdnNjb2RlX2pzb25ycGNfMS5DYW5jZWxsYXRpb25Ub2tlbjtcclxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IHZzY29kZV9qc29ucnBjXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7XHJcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZzY29kZV9qc29ucnBjXzEuRGlzcG9zYWJsZTtcclxuZXhwb3J0cy5FdmVudCA9IHZzY29kZV9qc29ucnBjXzEuRXZlbnQ7XHJcbmV4cG9ydHMuRW1pdHRlciA9IHZzY29kZV9qc29ucnBjXzEuRW1pdHRlcjtcclxuZXhwb3J0cy5UcmFjZSA9IHZzY29kZV9qc29ucnBjXzEuVHJhY2U7XHJcbmV4cG9ydHMuVHJhY2VGb3JtYXQgPSB2c2NvZGVfanNvbnJwY18xLlRyYWNlRm9ybWF0O1xyXG5leHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gdnNjb2RlX2pzb25ycGNfMS5TZXRUcmFjZU5vdGlmaWNhdGlvbjtcclxuZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IHZzY29kZV9qc29ucnBjXzEuTG9nVHJhY2VOb3RpZmljYXRpb247XHJcbmV4cG9ydHMuUmVxdWVzdFR5cGUgPSB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlO1xyXG5leHBvcnRzLlJlcXVlc3RUeXBlMCA9IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUwO1xyXG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGU7XHJcbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUwO1xyXG5leHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB2c2NvZGVfanNvbnJwY18xLk1lc3NhZ2VSZWFkZXI7XHJcbmV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IHZzY29kZV9qc29ucnBjXzEuTWVzc2FnZVdyaXRlcjtcclxuZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSB2c2NvZGVfanNvbnJwY18xLkNvbm5lY3Rpb25TdHJhdGVneTtcclxuZXhwb3J0cy5TdHJlYW1NZXNzYWdlUmVhZGVyID0gdnNjb2RlX2pzb25ycGNfMS5TdHJlYW1NZXNzYWdlUmVhZGVyO1xyXG5leHBvcnRzLlN0cmVhbU1lc3NhZ2VXcml0ZXIgPSB2c2NvZGVfanNvbnJwY18xLlN0cmVhbU1lc3NhZ2VXcml0ZXI7XHJcbmV4cG9ydHMuSVBDTWVzc2FnZVJlYWRlciA9IHZzY29kZV9qc29ucnBjXzEuSVBDTWVzc2FnZVJlYWRlcjtcclxuZXhwb3J0cy5JUENNZXNzYWdlV3JpdGVyID0gdnNjb2RlX2pzb25ycGNfMS5JUENNZXNzYWdlV3JpdGVyO1xyXG5leHBvcnRzLmNyZWF0ZUNsaWVudFBpcGVUcmFuc3BvcnQgPSB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZUNsaWVudFBpcGVUcmFuc3BvcnQ7XHJcbmV4cG9ydHMuY3JlYXRlU2VydmVyUGlwZVRyYW5zcG9ydCA9IHZzY29kZV9qc29ucnBjXzEuY3JlYXRlU2VydmVyUGlwZVRyYW5zcG9ydDtcclxuZXhwb3J0cy5nZW5lcmF0ZVJhbmRvbVBpcGVOYW1lID0gdnNjb2RlX2pzb25ycGNfMS5nZW5lcmF0ZVJhbmRvbVBpcGVOYW1lO1xyXG5leHBvcnRzLmNyZWF0ZUNsaWVudFNvY2tldFRyYW5zcG9ydCA9IHZzY29kZV9qc29ucnBjXzEuY3JlYXRlQ2xpZW50U29ja2V0VHJhbnNwb3J0O1xyXG5leHBvcnRzLmNyZWF0ZVNlcnZlclNvY2tldFRyYW5zcG9ydCA9IHZzY29kZV9qc29ucnBjXzEuY3JlYXRlU2VydmVyU29ja2V0VHJhbnNwb3J0O1xyXG5fX2V4cG9ydChyZXF1aXJlKFwidnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcHJvdG9jb2xcIikpO1xyXG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24ocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgc3RyYXRlZ3kpIHtcclxuICAgIHJldHVybiB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIHN0cmF0ZWd5KTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/main.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * A request to list all color symbols found in a given text document. The request's\r\n * parameter is of type [DocumentColorParams](#DocumentColorParams) the\r\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentColorRequest;\r\n(function (DocumentColorRequest) {\r\n    DocumentColorRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentColor');\r\n})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));\r\n/**\r\n * A request to list all presentation for a color. The request's\r\n * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the\r\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar ColorPresentationRequest;\r\n(function (ColorPresentationRequest) {\r\n    ColorPresentationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/colorPresentation');\r\n})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5jb2xvclByb3ZpZGVyLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL3Byb3RvY29sLmNvbG9yUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtanNvbnJwY1wiKTtcclxuLyoqXHJcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBjb2xvciBzeW1ib2xzIGZvdW5kIGluIGEgZ2l2ZW4gdGV4dCBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xyXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBbRG9jdW1lbnRDb2xvclBhcmFtc10oI0RvY3VtZW50Q29sb3JQYXJhbXMpIHRoZVxyXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIFtDb2xvckluZm9ybWF0aW9uW11dKCNDb2xvckluZm9ybWF0aW9uKSBvciBhIFRoZW5hYmxlXHJcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChEb2N1bWVudENvbG9yUmVxdWVzdCkge1xyXG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRDb2xvcicpO1xyXG59KShEb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHByZXNlbnRhdGlvbiBmb3IgYSBjb2xvci4gVGhlIHJlcXVlc3Qnc1xyXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBbQ29sb3JQcmVzZW50YXRpb25QYXJhbXNdKCNDb2xvclByZXNlbnRhdGlvblBhcmFtcykgdGhlXHJcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUgW0NvbG9ySW5mb3JtYXRpb25bXV0oI0NvbG9ySW5mb3JtYXRpb24pIG9yIGEgVGhlbmFibGVcclxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxyXG4gKi9cclxudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvblJlcXVlc3QpIHtcclxuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC9jb2xvclByZXNlbnRhdGlvbicpO1xyXG59KShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\r\n * configuration setting.\r\n *\r\n * This pull model replaces the old push model were the client signaled configuration change via an\r\n * event. If the server still needs to react to configuration changes (since the server caches the\r\n * result of `workspace/configuration` requests) the server should register for an empty configuration\r\n * change event and empty the cache if such an event is received.\r\n */\r\nvar ConfigurationRequest;\r\n(function (ConfigurationRequest) {\r\n    ConfigurationRequest.type = new vscode_jsonrpc_1.RequestType('workspace/configuration');\r\n})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5jb25maWd1cmF0aW9uLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL3Byb3RvY29sLmNvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtanNvbnJwY1wiKTtcclxuLyoqXHJcbiAqIFRoZSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCBhIGNlcnRhaW5cclxuICogY29uZmlndXJhdGlvbiBzZXR0aW5nLlxyXG4gKlxyXG4gKiBUaGlzIHB1bGwgbW9kZWwgcmVwbGFjZXMgdGhlIG9sZCBwdXNoIG1vZGVsIHdlcmUgdGhlIGNsaWVudCBzaWduYWxlZCBjb25maWd1cmF0aW9uIGNoYW5nZSB2aWEgYW5cclxuICogZXZlbnQuIElmIHRoZSBzZXJ2ZXIgc3RpbGwgbmVlZHMgdG8gcmVhY3QgdG8gY29uZmlndXJhdGlvbiBjaGFuZ2VzIChzaW5jZSB0aGUgc2VydmVyIGNhY2hlcyB0aGVcclxuICogcmVzdWx0IG9mIGB3b3Jrc3BhY2UvY29uZmlndXJhdGlvbmAgcmVxdWVzdHMpIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlZ2lzdGVyIGZvciBhbiBlbXB0eSBjb25maWd1cmF0aW9uXHJcbiAqIGNoYW5nZSBldmVudCBhbmQgZW1wdHkgdGhlIGNhY2hlIGlmIHN1Y2ggYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXHJcbiAqL1xyXG52YXIgQ29uZmlndXJhdGlvblJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoQ29uZmlndXJhdGlvblJlcXVlc3QpIHtcclxuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nKTtcclxufSkoQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0ge30pKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * Enum of known range kinds\r\n */\r\nvar FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));\r\n/**\r\n * A request to provide folding ranges in a document. The request's\r\n * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the\r\n * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar FoldingRangeRequest;\r\n(function (FoldingRangeRequest) {\r\n    FoldingRangeRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/foldingRange');\r\n})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5mb2xkaW5nUmFuZ2UuanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvcHJvdG9jb2wuZm9sZGluZ1JhbmdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gcmVxdWlyZShcInZzY29kZS1qc29ucnBjXCIpO1xyXG4vKipcclxuICogRW51bSBvZiBrbm93biByYW5nZSBraW5kc1xyXG4gKi9cclxudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XHJcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlS2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcclxuICAgICAqL1xyXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIkNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBpbXBvcnRzIG9yIGluY2x1ZGVzXHJcbiAgICAgKi9cclxuICAgIEZvbGRpbmdSYW5nZUtpbmRbXCJJbXBvcnRzXCJdID0gXCJpbXBvcnRzXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcclxuICAgICAqL1xyXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIlJlZ2lvblwiXSA9IFwicmVnaW9uXCI7XHJcbn0pKEZvbGRpbmdSYW5nZUtpbmQgPSBleHBvcnRzLkZvbGRpbmdSYW5nZUtpbmQgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBmb2xkaW5nIHJhbmdlcyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXHJcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtGb2xkaW5nUmFuZ2VQYXJhbXNdKCNGb2xkaW5nUmFuZ2VQYXJhbXMpLCB0aGVcclxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSBbRm9sZGluZ1JhbmdlTGlzdF0oI0ZvbGRpbmdSYW5nZUxpc3QpIG9yIGEgVGhlbmFibGVcclxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxyXG4gKi9cclxudmFyIEZvbGRpbmdSYW5nZVJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xyXG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnKTtcclxufSkoRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * A request to resolve the implementation locations of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPositioParams]\r\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\r\n * Thenable that resolves to such.\r\n */\r\nvar ImplementationRequest;\r\n(function (ImplementationRequest) {\r\n    ImplementationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/implementation');\r\n})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5pbXBsZW1lbnRhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5pbXBsZW1lbnRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gcmVxdWlyZShcInZzY29kZS1qc29ucnBjXCIpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIGltcGxlbWVudGF0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcclxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9QYXJhbXNdXHJcbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIFtEZWZpbml0aW9uXSgjRGVmaW5pdGlvbikgb3IgYVxyXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXHJcbiAqL1xyXG52YXIgSW1wbGVtZW50YXRpb25SZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKEltcGxlbWVudGF0aW9uUmVxdWVzdCkge1xyXG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgndGV4dERvY3VtZW50L2ltcGxlbWVudGF0aW9uJyk7XHJcbn0pKEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageserver-protocol/lib/utils/is.js\");\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\nconst protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js\");\r\nexports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;\r\nconst protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js\");\r\nexports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;\r\nconst protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js\");\r\nexports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;\r\nexports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;\r\nconst protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js\");\r\nexports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;\r\nconst protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js\");\r\nexports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;\r\nexports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;\r\nconst protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ \"./node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js\");\r\nexports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;\r\nvar DocumentFilter;\r\n(function (DocumentFilter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);\r\n    }\r\n    DocumentFilter.is = is;\r\n})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));\r\n/**\r\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\r\n * handler on the client side.\r\n */\r\nvar RegistrationRequest;\r\n(function (RegistrationRequest) {\r\n    RegistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/registerCapability');\r\n})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));\r\n/**\r\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\r\n * handler on the client side.\r\n */\r\nvar UnregistrationRequest;\r\n(function (UnregistrationRequest) {\r\n    UnregistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/unregisterCapability');\r\n})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));\r\nvar ResourceOperationKind;\r\n(function (ResourceOperationKind) {\r\n    /**\r\n     * Supports creating new resources.\r\n     */\r\n    ResourceOperationKind.Create = 'create';\r\n    /**\r\n     * Supports renaming existing resources.\r\n     */\r\n    ResourceOperationKind.Rename = 'rename';\r\n    /**\r\n     * Supports deleting existing resources.\r\n     */\r\n    ResourceOperationKind.Delete = 'delete';\r\n})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));\r\nvar FailureHandlingKind;\r\n(function (FailureHandlingKind) {\r\n    /**\r\n     * Applying the workspace change is simply aborted if one of the changes provided\r\n     * fails. All operations executed before the failing operation stay executed.\r\n     */\r\n    FailureHandlingKind.Abort = 'abort';\r\n    /**\r\n     * All operations are executed transactional. That means they either all\r\n     * succeed or no changes at all are applied to the workspace.\r\n     */\r\n    FailureHandlingKind.Transactional = 'transactional';\r\n    /**\r\n     * If the workspace edit contains only textual file changes they are executed transactional.\r\n     * If resource changes (create, rename or delete file) are part of the change the failure\r\n     * handling startegy is abort.\r\n     */\r\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\r\n    /**\r\n     * The client tries to undo the operations already executed. But there is no\r\n     * guaruntee that this is succeeding.\r\n     */\r\n    FailureHandlingKind.Undo = 'undo';\r\n})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));\r\n/**\r\n * Defines how the host (editor) should sync\r\n * document changes to the language server.\r\n */\r\nvar TextDocumentSyncKind;\r\n(function (TextDocumentSyncKind) {\r\n    /**\r\n     * Documents should not be synced at all.\r\n     */\r\n    TextDocumentSyncKind.None = 0;\r\n    /**\r\n     * Documents are synced by always sending the full content\r\n     * of the document.\r\n     */\r\n    TextDocumentSyncKind.Full = 1;\r\n    /**\r\n     * Documents are synced by sending the full content on open.\r\n     * After that only incremental updates to the document are\r\n     * send.\r\n     */\r\n    TextDocumentSyncKind.Incremental = 2;\r\n})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));\r\n/**\r\n * The initialize request is sent from the client to the server.\r\n * It is sent once as the request after starting up the server.\r\n * The requests parameter is of type [InitializeParams](#InitializeParams)\r\n * the response if of type [InitializeResult](#InitializeResult) of a Thenable that\r\n * resolves to such.\r\n */\r\nvar InitializeRequest;\r\n(function (InitializeRequest) {\r\n    InitializeRequest.type = new vscode_jsonrpc_1.RequestType('initialize');\r\n})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));\r\n/**\r\n * Known error codes for an `InitializeError`;\r\n */\r\nvar InitializeError;\r\n(function (InitializeError) {\r\n    /**\r\n     * If the protocol version provided by the client can't be handled by the server.\r\n     * @deprecated This initialize error got replaced by client capabilities. There is\r\n     * no version handshake in version 3.0x\r\n     */\r\n    InitializeError.unknownProtocolVersion = 1;\r\n})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));\r\n/**\r\n * The intialized notification is sent from the client to the\r\n * server after the client is fully initialized and the server\r\n * is allowed to send requests from the server to the client.\r\n */\r\nvar InitializedNotification;\r\n(function (InitializedNotification) {\r\n    InitializedNotification.type = new vscode_jsonrpc_1.NotificationType('initialized');\r\n})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));\r\n//---- Shutdown Method ----\r\n/**\r\n * A shutdown request is sent from the client to the server.\r\n * It is sent once when the client decides to shutdown the\r\n * server. The only notification that is sent after a shutdown request\r\n * is the exit event.\r\n */\r\nvar ShutdownRequest;\r\n(function (ShutdownRequest) {\r\n    ShutdownRequest.type = new vscode_jsonrpc_1.RequestType0('shutdown');\r\n})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));\r\n//---- Exit Notification ----\r\n/**\r\n * The exit event is sent from the client to the server to\r\n * ask the server to exit its process.\r\n */\r\nvar ExitNotification;\r\n(function (ExitNotification) {\r\n    ExitNotification.type = new vscode_jsonrpc_1.NotificationType0('exit');\r\n})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));\r\n//---- Configuration notification ----\r\n/**\r\n * The configuration change notification is sent from the client to the server\r\n * when the client's configuration has changed. The notification contains\r\n * the changed configuration as defined by the language client.\r\n */\r\nvar DidChangeConfigurationNotification;\r\n(function (DidChangeConfigurationNotification) {\r\n    DidChangeConfigurationNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeConfiguration');\r\n})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));\r\n//---- Message show and log notifications ----\r\n/**\r\n * The message type\r\n */\r\nvar MessageType;\r\n(function (MessageType) {\r\n    /**\r\n     * An error message.\r\n     */\r\n    MessageType.Error = 1;\r\n    /**\r\n     * A warning message.\r\n     */\r\n    MessageType.Warning = 2;\r\n    /**\r\n     * An information message.\r\n     */\r\n    MessageType.Info = 3;\r\n    /**\r\n     * A log message.\r\n     */\r\n    MessageType.Log = 4;\r\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\r\n/**\r\n * The show message notification is sent from a server to a client to ask\r\n * the client to display a particular message in the user interface.\r\n */\r\nvar ShowMessageNotification;\r\n(function (ShowMessageNotification) {\r\n    ShowMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/showMessage');\r\n})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));\r\n/**\r\n * The show message request is sent from the server to the client to show a message\r\n * and a set of options actions to the user.\r\n */\r\nvar ShowMessageRequest;\r\n(function (ShowMessageRequest) {\r\n    ShowMessageRequest.type = new vscode_jsonrpc_1.RequestType('window/showMessageRequest');\r\n})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));\r\n/**\r\n * The log message notification is sent from the server to the client to ask\r\n * the client to log a particular message.\r\n */\r\nvar LogMessageNotification;\r\n(function (LogMessageNotification) {\r\n    LogMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/logMessage');\r\n})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));\r\n//---- Telemetry notification\r\n/**\r\n * The telemetry event notification is sent from the server to the client to ask\r\n * the client to log telemetry data.\r\n */\r\nvar TelemetryEventNotification;\r\n(function (TelemetryEventNotification) {\r\n    TelemetryEventNotification.type = new vscode_jsonrpc_1.NotificationType('telemetry/event');\r\n})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));\r\n/**\r\n * The document open notification is sent from the client to the server to signal\r\n * newly opened text documents. The document's truth is now managed by the client\r\n * and the server must not try to read the document's truth using the document's\r\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\r\n * mean that its content is presented in an editor. An open notification must not\r\n * be sent more than once without a corresponding close notification send before.\r\n * This means open and close notification must be balanced and the max open count\r\n * is one.\r\n */\r\nvar DidOpenTextDocumentNotification;\r\n(function (DidOpenTextDocumentNotification) {\r\n    DidOpenTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didOpen');\r\n})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));\r\n/**\r\n * The document change notification is sent from the client to the server to signal\r\n * changes to a text document.\r\n */\r\nvar DidChangeTextDocumentNotification;\r\n(function (DidChangeTextDocumentNotification) {\r\n    DidChangeTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didChange');\r\n})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));\r\n/**\r\n * The document close notification is sent from the client to the server when\r\n * the document got closed in the client. The document's truth now exists where\r\n * the document's uri points to (e.g. if the document's uri is a file uri the\r\n * truth now exists on disk). As with the open notification the close notification\r\n * is about managing the document's content. Receiving a close notification\r\n * doesn't mean that the document was open in an editor before. A close\r\n * notification requires a previous open notification to be sent.\r\n */\r\nvar DidCloseTextDocumentNotification;\r\n(function (DidCloseTextDocumentNotification) {\r\n    DidCloseTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didClose');\r\n})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));\r\n/**\r\n * The document save notification is sent from the client to the server when\r\n * the document got saved in the client.\r\n */\r\nvar DidSaveTextDocumentNotification;\r\n(function (DidSaveTextDocumentNotification) {\r\n    DidSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didSave');\r\n})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));\r\n/**\r\n * A document will save notification is sent from the client to the server before\r\n * the document is actually saved.\r\n */\r\nvar WillSaveTextDocumentNotification;\r\n(function (WillSaveTextDocumentNotification) {\r\n    WillSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/willSave');\r\n})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));\r\n/**\r\n * A document will save request is sent from the client to the server before\r\n * the document is actually saved. The request can return an array of TextEdits\r\n * which will be applied to the text document before it is saved. Please note that\r\n * clients might drop results if computing the text edits took too long or if a\r\n * server constantly fails on this request. This is done to keep the save fast and\r\n * reliable.\r\n */\r\nvar WillSaveTextDocumentWaitUntilRequest;\r\n(function (WillSaveTextDocumentWaitUntilRequest) {\r\n    WillSaveTextDocumentWaitUntilRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/willSaveWaitUntil');\r\n})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));\r\n//---- File eventing ----\r\n/**\r\n * The watched files notification is sent from the client to the server when\r\n * the client detects changes to file watched by the language client.\r\n */\r\nvar DidChangeWatchedFilesNotification;\r\n(function (DidChangeWatchedFilesNotification) {\r\n    DidChangeWatchedFilesNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWatchedFiles');\r\n})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));\r\n/**\r\n * The file event type\r\n */\r\nvar FileChangeType;\r\n(function (FileChangeType) {\r\n    /**\r\n     * The file got created.\r\n     */\r\n    FileChangeType.Created = 1;\r\n    /**\r\n     * The file got changed.\r\n     */\r\n    FileChangeType.Changed = 2;\r\n    /**\r\n     * The file got deleted.\r\n     */\r\n    FileChangeType.Deleted = 3;\r\n})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\r\nvar WatchKind;\r\n(function (WatchKind) {\r\n    /**\r\n     * Interested in create events.\r\n     */\r\n    WatchKind.Create = 1;\r\n    /**\r\n     * Interested in change events\r\n     */\r\n    WatchKind.Change = 2;\r\n    /**\r\n     * Interested in delete events\r\n     */\r\n    WatchKind.Delete = 4;\r\n})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));\r\n//---- Diagnostic notification ----\r\n/**\r\n * Diagnostics notification are sent from the server to the client to signal\r\n * results of validation runs.\r\n */\r\nvar PublishDiagnosticsNotification;\r\n(function (PublishDiagnosticsNotification) {\r\n    PublishDiagnosticsNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/publishDiagnostics');\r\n})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));\r\n/**\r\n * How a completion was triggered\r\n */\r\nvar CompletionTriggerKind;\r\n(function (CompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered by typing an identifier (24x7 code\r\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\r\n     */\r\n    CompletionTriggerKind.Invoked = 1;\r\n    /**\r\n     * Completion was triggered by a trigger character specified by\r\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\r\n     */\r\n    CompletionTriggerKind.TriggerCharacter = 2;\r\n    /**\r\n     * Completion was re-triggered as current completion list is incomplete\r\n     */\r\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\r\n})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));\r\n/**\r\n * Request to request completion at a given text document position. The request's\r\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response\r\n * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)\r\n * or a Thenable that resolves to such.\r\n *\r\n * The request can delay the computation of the [`detail`](#CompletionItem.detail)\r\n * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`\r\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\r\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\r\n */\r\nvar CompletionRequest;\r\n(function (CompletionRequest) {\r\n    CompletionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/completion');\r\n})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given completion item.The request's\r\n * parameter is of type [CompletionItem](#CompletionItem) the response\r\n * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.\r\n */\r\nvar CompletionResolveRequest;\r\n(function (CompletionResolveRequest) {\r\n    CompletionResolveRequest.type = new vscode_jsonrpc_1.RequestType('completionItem/resolve');\r\n})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));\r\n//---- Hover Support -------------------------------\r\n/**\r\n * Request to request hover information at a given text document position. The request's\r\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of\r\n * type [Hover](#Hover) or a Thenable that resolves to such.\r\n */\r\nvar HoverRequest;\r\n(function (HoverRequest) {\r\n    HoverRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/hover');\r\n})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));\r\nvar SignatureHelpRequest;\r\n(function (SignatureHelpRequest) {\r\n    SignatureHelpRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/signatureHelp');\r\n})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));\r\n//---- Goto Definition -------------------------------------\r\n/**\r\n * A request to resolve the definition location of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPosition]\r\n * (#TextDocumentPosition) the response is of type [Definition](#Definition) or a\r\n * Thenable that resolves to such.\r\n */\r\nvar DefinitionRequest;\r\n(function (DefinitionRequest) {\r\n    DefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/definition');\r\n})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));\r\n/**\r\n * A request to resolve project-wide references for the symbol denoted\r\n * by the given text document position. The request's parameter is of\r\n * type [ReferenceParams](#ReferenceParams) the response is of type\r\n * [Location[]](#Location) or a Thenable that resolves to such.\r\n */\r\nvar ReferencesRequest;\r\n(function (ReferencesRequest) {\r\n    ReferencesRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/references');\r\n})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));\r\n//---- Document Highlight ----------------------------------\r\n/**\r\n * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given\r\n * text document position. The request's parameter is of type [TextDocumentPosition]\r\n * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]\r\n * (#DocumentHighlight) or a Thenable that resolves to such.\r\n */\r\nvar DocumentHighlightRequest;\r\n(function (DocumentHighlightRequest) {\r\n    DocumentHighlightRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentHighlight');\r\n})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));\r\n//---- Document Symbol Provider ---------------------------\r\n/**\r\n * A request to list all symbols found in a given text document. The request's\r\n * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the\r\n * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentSymbolRequest;\r\n(function (DocumentSymbolRequest) {\r\n    DocumentSymbolRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentSymbol');\r\n})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));\r\n//---- Workspace Symbol Provider ---------------------------\r\n/**\r\n * A request to list project-wide symbols matching the query string given\r\n * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is\r\n * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that\r\n * resolves to such.\r\n */\r\nvar WorkspaceSymbolRequest;\r\n(function (WorkspaceSymbolRequest) {\r\n    WorkspaceSymbolRequest.type = new vscode_jsonrpc_1.RequestType('workspace/symbol');\r\n})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));\r\n/**\r\n * A request to provide commands for the given text document and range.\r\n */\r\nvar CodeActionRequest;\r\n(function (CodeActionRequest) {\r\n    CodeActionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeAction');\r\n})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));\r\n/**\r\n * A request to provide code lens for the given text document.\r\n */\r\nvar CodeLensRequest;\r\n(function (CodeLensRequest) {\r\n    CodeLensRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeLens');\r\n})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));\r\n/**\r\n * A request to resolve a command for a given code lens.\r\n */\r\nvar CodeLensResolveRequest;\r\n(function (CodeLensResolveRequest) {\r\n    CodeLensResolveRequest.type = new vscode_jsonrpc_1.RequestType('codeLens/resolve');\r\n})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));\r\n/**\r\n * A request to to format a whole document.\r\n */\r\nvar DocumentFormattingRequest;\r\n(function (DocumentFormattingRequest) {\r\n    DocumentFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/formatting');\r\n})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));\r\n/**\r\n * A request to to format a range in a document.\r\n */\r\nvar DocumentRangeFormattingRequest;\r\n(function (DocumentRangeFormattingRequest) {\r\n    DocumentRangeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rangeFormatting');\r\n})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));\r\n/**\r\n * A request to format a document on type.\r\n */\r\nvar DocumentOnTypeFormattingRequest;\r\n(function (DocumentOnTypeFormattingRequest) {\r\n    DocumentOnTypeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/onTypeFormatting');\r\n})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));\r\n/**\r\n * A request to rename a symbol.\r\n */\r\nvar RenameRequest;\r\n(function (RenameRequest) {\r\n    RenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rename');\r\n})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));\r\n/**\r\n * A request to test and perform the setup necessary for a rename.\r\n */\r\nvar PrepareRenameRequest;\r\n(function (PrepareRenameRequest) {\r\n    PrepareRenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/prepareRename');\r\n})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));\r\n/**\r\n * A request to provide document links\r\n */\r\nvar DocumentLinkRequest;\r\n(function (DocumentLinkRequest) {\r\n    DocumentLinkRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentLink');\r\n})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given document link. The request's\r\n * parameter is of type [DocumentLink](#DocumentLink) the response\r\n * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.\r\n */\r\nvar DocumentLinkResolveRequest;\r\n(function (DocumentLinkResolveRequest) {\r\n    DocumentLinkResolveRequest.type = new vscode_jsonrpc_1.RequestType('documentLink/resolve');\r\n})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));\r\n/**\r\n * A request send from the client to the server to execute a command. The request might return\r\n * a workspace edit which the client will apply to the workspace.\r\n */\r\nvar ExecuteCommandRequest;\r\n(function (ExecuteCommandRequest) {\r\n    ExecuteCommandRequest.type = new vscode_jsonrpc_1.RequestType('workspace/executeCommand');\r\n})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));\r\n/**\r\n * A request sent from the server to the client to modified certain resources.\r\n */\r\nvar ApplyWorkspaceEditRequest;\r\n(function (ApplyWorkspaceEditRequest) {\r\n    ApplyWorkspaceEditRequest.type = new vscode_jsonrpc_1.RequestType('workspace/applyEdit');\r\n})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBJcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzXCIpO1xyXG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gcmVxdWlyZShcInZzY29kZS1qc29ucnBjXCIpO1xyXG5jb25zdCBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIi4vcHJvdG9jb2wuaW1wbGVtZW50YXRpb25cIik7XHJcbmV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0gcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMS5JbXBsZW1lbnRhdGlvblJlcXVlc3Q7XHJcbmNvbnN0IHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbC50eXBlRGVmaW5pdGlvblwiKTtcclxuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xLlR5cGVEZWZpbml0aW9uUmVxdWVzdDtcclxuY29uc3QgcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyc18xID0gcmVxdWlyZShcIi4vcHJvdG9jb2wud29ya3NwYWNlRm9sZGVyc1wiKTtcclxuZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcnNfMS5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdDtcclxuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyc18xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XHJcbmNvbnN0IHByb3RvY29sX2NvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sLmNvbmZpZ3VyYXRpb25cIik7XHJcbmV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvblJlcXVlc3Q7XHJcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sLmNvbG9yUHJvdmlkZXJcIik7XHJcbmV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuRG9jdW1lbnRDb2xvclJlcXVlc3Q7XHJcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcclxuY29uc3QgcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEgPSByZXF1aXJlKFwiLi9wcm90b2NvbC5mb2xkaW5nUmFuZ2VcIik7XHJcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xLkZvbGRpbmdSYW5nZVJlcXVlc3Q7XHJcbnZhciBEb2N1bWVudEZpbHRlcjtcclxuKGZ1bmN0aW9uIChEb2N1bWVudEZpbHRlcikge1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuc2NoZW1lKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnBhdHRlcm4pO1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcclxufSkoRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLkRvY3VtZW50RmlsdGVyIHx8IChleHBvcnRzLkRvY3VtZW50RmlsdGVyID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBgY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHJlZ2lzdGVyIGEgbmV3IGNhcGFiaWxpdHlcclxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXHJcbiAqL1xyXG52YXIgUmVnaXN0cmF0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XHJcbiAgICBSZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eScpO1xyXG59KShSZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlJlZ2lzdHJhdGlvblJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcclxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXHJcbiAqL1xyXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKFVucmVnaXN0cmF0aW9uUmVxdWVzdCkge1xyXG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnY2xpZW50L3VucmVnaXN0ZXJDYXBhYmlsaXR5Jyk7XHJcbn0pKFVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IHt9KSk7XHJcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XHJcbihmdW5jdGlvbiAoUmVzb3VyY2VPcGVyYXRpb25LaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5DcmVhdGUgPSAnY3JlYXRlJztcclxuICAgIC8qKlxyXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuUmVuYW1lID0gJ3JlbmFtZSc7XHJcbiAgICAvKipcclxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLkRlbGV0ZSA9ICdkZWxldGUnO1xyXG59KShSZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSB7fSkpO1xyXG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcclxuKGZ1bmN0aW9uIChGYWlsdXJlSGFuZGxpbmdLaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxyXG4gICAgICogZmFpbHMuIEFsbCBvcGVyYXRpb25zIGV4ZWN1dGVkIGJlZm9yZSB0aGUgZmFpbGluZyBvcGVyYXRpb24gc3RheSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XHJcbiAgICAvKipcclxuICAgICAqIEFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLiBUaGF0IG1lYW5zIHRoZXkgZWl0aGVyIGFsbFxyXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxyXG4gICAgICovXHJcbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlRyYW5zYWN0aW9uYWwgPSAndHJhbnNhY3Rpb25hbCc7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSB3b3Jrc3BhY2UgZWRpdCBjb250YWlucyBvbmx5IHRleHR1YWwgZmlsZSBjaGFuZ2VzIHRoZXkgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuXHJcbiAgICAgKiBJZiByZXNvdXJjZSBjaGFuZ2VzIChjcmVhdGUsIHJlbmFtZSBvciBkZWxldGUgZmlsZSkgYXJlIHBhcnQgb2YgdGhlIGNoYW5nZSB0aGUgZmFpbHVyZVxyXG4gICAgICogaGFuZGxpbmcgc3RhcnRlZ3kgaXMgYWJvcnQuXHJcbiAgICAgKi9cclxuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVGV4dE9ubHlUcmFuc2FjdGlvbmFsID0gJ3RleHRPbmx5VHJhbnNhY3Rpb25hbCc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjbGllbnQgdHJpZXMgdG8gdW5kbyB0aGUgb3BlcmF0aW9ucyBhbHJlYWR5IGV4ZWN1dGVkLiBCdXQgdGhlcmUgaXMgbm9cclxuICAgICAqIGd1YXJ1bnRlZSB0aGF0IHRoaXMgaXMgc3VjY2VlZGluZy5cclxuICAgICAqL1xyXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5VbmRvID0gJ3VuZG8nO1xyXG59KShGYWlsdXJlSGFuZGxpbmdLaW5kID0gZXhwb3J0cy5GYWlsdXJlSGFuZGxpbmdLaW5kIHx8IChleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSB7fSkpO1xyXG4vKipcclxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcclxuICogZG9jdW1lbnQgY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gKi9cclxudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xyXG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFN5bmNLaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXHJcbiAgICAgKi9cclxuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBhbHdheXMgc2VuZGluZyB0aGUgZnVsbCBjb250ZW50XHJcbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGwgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cclxuICAgICAqIEFmdGVyIHRoYXQgb25seSBpbmNyZW1lbnRhbCB1cGRhdGVzIHRvIHRoZSBkb2N1bWVudCBhcmVcclxuICAgICAqIHNlbmQuXHJcbiAgICAgKi9cclxuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsID0gMjtcclxufSkoVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kIHx8IChleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBpbml0aWFsaXplIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlci5cclxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXHJcbiAqIFRoZSByZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBbSW5pdGlhbGl6ZVBhcmFtc10oI0luaXRpYWxpemVQYXJhbXMpXHJcbiAqIHRoZSByZXNwb25zZSBpZiBvZiB0eXBlIFtJbml0aWFsaXplUmVzdWx0XSgjSW5pdGlhbGl6ZVJlc3VsdCkgb2YgYSBUaGVuYWJsZSB0aGF0XHJcbiAqIHJlc29sdmVzIHRvIHN1Y2guXHJcbiAqL1xyXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoSW5pdGlhbGl6ZVJlcXVlc3QpIHtcclxuICAgIEluaXRpYWxpemVSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnaW5pdGlhbGl6ZScpO1xyXG59KShJbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogS25vd24gZXJyb3IgY29kZXMgZm9yIGFuIGBJbml0aWFsaXplRXJyb3JgO1xyXG4gKi9cclxudmFyIEluaXRpYWxpemVFcnJvcjtcclxuKGZ1bmN0aW9uIChJbml0aWFsaXplRXJyb3IpIHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXHJcbiAgICAgKiBubyB2ZXJzaW9uIGhhbmRzaGFrZSBpbiB2ZXJzaW9uIDMuMHhcclxuICAgICAqL1xyXG4gICAgSW5pdGlhbGl6ZUVycm9yLnVua25vd25Qcm90b2NvbFZlcnNpb24gPSAxO1xyXG59KShJbml0aWFsaXplRXJyb3IgPSBleHBvcnRzLkluaXRpYWxpemVFcnJvciB8fCAoZXhwb3J0cy5Jbml0aWFsaXplRXJyb3IgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGludGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxyXG4gKiBzZXJ2ZXIgYWZ0ZXIgdGhlIGNsaWVudCBpcyBmdWxseSBpbml0aWFsaXplZCBhbmQgdGhlIHNlcnZlclxyXG4gKiBpcyBhbGxvd2VkIHRvIHNlbmQgcmVxdWVzdHMgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQuXHJcbiAqL1xyXG52YXIgSW5pdGlhbGl6ZWROb3RpZmljYXRpb247XHJcbihmdW5jdGlvbiAoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24pIHtcclxuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlKCdpbml0aWFsaXplZCcpO1xyXG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vLy0tLS0gU2h1dGRvd24gTWV0aG9kIC0tLS1cclxuLyoqXHJcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxyXG4gKiBJdCBpcyBzZW50IG9uY2Ugd2hlbiB0aGUgY2xpZW50IGRlY2lkZXMgdG8gc2h1dGRvd24gdGhlXHJcbiAqIHNlcnZlci4gVGhlIG9ubHkgbm90aWZpY2F0aW9uIHRoYXQgaXMgc2VudCBhZnRlciBhIHNodXRkb3duIHJlcXVlc3RcclxuICogaXMgdGhlIGV4aXQgZXZlbnQuXHJcbiAqL1xyXG52YXIgU2h1dGRvd25SZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xyXG4gICAgU2h1dGRvd25SZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZTAoJ3NodXRkb3duJyk7XHJcbn0pKFNodXRkb3duUmVxdWVzdCA9IGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0IHx8IChleHBvcnRzLlNodXRkb3duUmVxdWVzdCA9IHt9KSk7XHJcbi8vLS0tLSBFeGl0IE5vdGlmaWNhdGlvbiAtLS0tXHJcbi8qKlxyXG4gKiBUaGUgZXhpdCBldmVudCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvXHJcbiAqIGFzayB0aGUgc2VydmVyIHRvIGV4aXQgaXRzIHByb2Nlc3MuXHJcbiAqL1xyXG52YXIgRXhpdE5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChFeGl0Tm90aWZpY2F0aW9uKSB7XHJcbiAgICBFeGl0Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCgnZXhpdCcpO1xyXG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vLy0tLS0gQ29uZmlndXJhdGlvbiBub3RpZmljYXRpb24gLS0tLVxyXG4vKipcclxuICogVGhlIGNvbmZpZ3VyYXRpb24gY2hhbmdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyXHJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcclxuICogdGhlIGNoYW5nZWQgY29uZmlndXJhdGlvbiBhcyBkZWZpbmVkIGJ5IHRoZSBsYW5ndWFnZSBjbGllbnQuXHJcbiAqL1xyXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uKSB7XHJcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlKCd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbicpO1xyXG59KShEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSB7fSkpO1xyXG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXHJcbi8qKlxyXG4gKiBUaGUgbWVzc2FnZSB0eXBlXHJcbiAqL1xyXG52YXIgTWVzc2FnZVR5cGU7XHJcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gZXJyb3IgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHdhcm5pbmcgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgTWVzc2FnZVR5cGUuV2FybmluZyA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIE1lc3NhZ2VUeXBlLkluZm8gPSAzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxvZyBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xyXG59KShNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xyXG4gKiB0aGUgY2xpZW50IHRvIGRpc3BsYXkgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UgaW4gdGhlIHVzZXIgaW50ZXJmYWNlLlxyXG4gKi9cclxudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xyXG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XHJcbiAgICBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSgnd2luZG93L3Nob3dNZXNzYWdlJyk7XHJcbn0pKFNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgc2hvdyBtZXNzYWdlIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBzaG93IGEgbWVzc2FnZVxyXG4gKiBhbmQgYSBzZXQgb2Ygb3B0aW9ucyBhY3Rpb25zIHRvIHRoZSB1c2VyLlxyXG4gKi9cclxudmFyIFNob3dNZXNzYWdlUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChTaG93TWVzc2FnZVJlcXVlc3QpIHtcclxuICAgIFNob3dNZXNzYWdlUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3dpbmRvdy9zaG93TWVzc2FnZVJlcXVlc3QnKTtcclxufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBsb2cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBhc2tcclxuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXHJcbiAqL1xyXG52YXIgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XHJcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlKCd3aW5kb3cvbG9nTWVzc2FnZScpO1xyXG59KShMb2dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vLy0tLS0gVGVsZW1ldHJ5IG5vdGlmaWNhdGlvblxyXG4vKipcclxuICogVGhlIHRlbGVtZXRyeSBldmVudCBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBhc2tcclxuICogdGhlIGNsaWVudCB0byBsb2cgdGVsZW1ldHJ5IGRhdGEuXHJcbiAqL1xyXG52YXIgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb247XHJcbihmdW5jdGlvbiAoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24pIHtcclxuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlKCd0ZWxlbWV0cnkvZXZlbnQnKTtcclxufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBkb2N1bWVudCBvcGVuIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIHNpZ25hbFxyXG4gKiBuZXdseSBvcGVuZWQgdGV4dCBkb2N1bWVudHMuIFRoZSBkb2N1bWVudCdzIHRydXRoIGlzIG5vdyBtYW5hZ2VkIGJ5IHRoZSBjbGllbnRcclxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcclxuICogdXJpLiBPcGVuIGluIHRoaXMgc2Vuc2UgbWVhbnMgaXQgaXMgbWFuYWdlZCBieSB0aGUgY2xpZW50LiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5XHJcbiAqIG1lYW4gdGhhdCBpdHMgY29udGVudCBpcyBwcmVzZW50ZWQgaW4gYW4gZWRpdG9yLiBBbiBvcGVuIG5vdGlmaWNhdGlvbiBtdXN0IG5vdFxyXG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cclxuICogVGhpcyBtZWFucyBvcGVuIGFuZCBjbG9zZSBub3RpZmljYXRpb24gbXVzdCBiZSBiYWxhbmNlZCBhbmQgdGhlIG1heCBvcGVuIGNvdW50XHJcbiAqIGlzIG9uZS5cclxuICovXHJcbnZhciBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xyXG4oZnVuY3Rpb24gKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcclxuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3RleHREb2N1bWVudC9kaWRPcGVuJyk7XHJcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgZG9jdW1lbnQgY2hhbmdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIHNpZ25hbFxyXG4gKiBjaGFuZ2VzIHRvIGEgdGV4dCBkb2N1bWVudC5cclxuICovXHJcbnZhciBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XHJcbihmdW5jdGlvbiAoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XHJcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnKTtcclxufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBkb2N1bWVudCBjbG9zZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXHJcbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcclxuICogdGhlIGRvY3VtZW50J3MgdXJpIHBvaW50cyB0byAoZS5nLiBpZiB0aGUgZG9jdW1lbnQncyB1cmkgaXMgYSBmaWxlIHVyaSB0aGVcclxuICogdHJ1dGggbm93IGV4aXN0cyBvbiBkaXNrKS4gQXMgd2l0aCB0aGUgb3BlbiBub3RpZmljYXRpb24gdGhlIGNsb3NlIG5vdGlmaWNhdGlvblxyXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cclxuICogZG9lc24ndCBtZWFuIHRoYXQgdGhlIGRvY3VtZW50IHdhcyBvcGVuIGluIGFuIGVkaXRvciBiZWZvcmUuIEEgY2xvc2VcclxuICogbm90aWZpY2F0aW9uIHJlcXVpcmVzIGEgcHJldmlvdXMgb3BlbiBub3RpZmljYXRpb24gdG8gYmUgc2VudC5cclxuICovXHJcbnZhciBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xyXG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3RleHREb2N1bWVudC9kaWRDbG9zZScpO1xyXG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGRvY3VtZW50IHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxyXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXHJcbiAqL1xyXG52YXIgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XHJcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlKCd0ZXh0RG9jdW1lbnQvZGlkU2F2ZScpO1xyXG59KShEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vKipcclxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXHJcbiAqIHRoZSBkb2N1bWVudCBpcyBhY3R1YWxseSBzYXZlZC5cclxuICovXHJcbnZhciBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xyXG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3RleHREb2N1bWVudC93aWxsU2F2ZScpO1xyXG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vKipcclxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxyXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXHJcbiAqIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdGV4dCBkb2N1bWVudCBiZWZvcmUgaXQgaXMgc2F2ZWQuIFBsZWFzZSBub3RlIHRoYXRcclxuICogY2xpZW50cyBtaWdodCBkcm9wIHJlc3VsdHMgaWYgY29tcHV0aW5nIHRoZSB0ZXh0IGVkaXRzIHRvb2sgdG9vIGxvbmcgb3IgaWYgYVxyXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXHJcbiAqIHJlbGlhYmxlLlxyXG4gKi9cclxudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QpIHtcclxuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC93aWxsU2F2ZVdhaXRVbnRpbCcpO1xyXG59KShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSB7fSkpO1xyXG4vLy0tLS0gRmlsZSBldmVudGluZyAtLS0tXHJcbi8qKlxyXG4gKiBUaGUgd2F0Y2hlZCBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXHJcbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxyXG4gKi9cclxudmFyIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbjtcclxuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcclxuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSgnd29ya3NwYWNlL2RpZENoYW5nZVdhdGNoZWRGaWxlcycpO1xyXG59KShEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxyXG4gKi9cclxudmFyIEZpbGVDaGFuZ2VUeXBlO1xyXG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmaWxlIGdvdCBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBGaWxlQ2hhbmdlVHlwZS5DcmVhdGVkID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIEZpbGVDaGFuZ2VUeXBlLkNoYW5nZWQgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsZSBnb3QgZGVsZXRlZC5cclxuICAgICAqL1xyXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XHJcbn0pKEZpbGVDaGFuZ2VUeXBlID0gZXhwb3J0cy5GaWxlQ2hhbmdlVHlwZSB8fCAoZXhwb3J0cy5GaWxlQ2hhbmdlVHlwZSA9IHt9KSk7XHJcbnZhciBXYXRjaEtpbmQ7XHJcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIEludGVyZXN0ZWQgaW4gY3JlYXRlIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hLaW5kLkNyZWF0ZSA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xyXG4gICAgICovXHJcbiAgICBXYXRjaEtpbmQuQ2hhbmdlID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJlc3RlZCBpbiBkZWxldGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xyXG59KShXYXRjaEtpbmQgPSBleHBvcnRzLldhdGNoS2luZCB8fCAoZXhwb3J0cy5XYXRjaEtpbmQgPSB7fSkpO1xyXG4vLy0tLS0gRGlhZ25vc3RpYyBub3RpZmljYXRpb24gLS0tLVxyXG4vKipcclxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxyXG4gKiByZXN1bHRzIG9mIHZhbGlkYXRpb24gcnVucy5cclxuICovXHJcbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XHJcbihmdW5jdGlvbiAoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uKSB7XHJcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3RleHREb2N1bWVudC9wdWJsaXNoRGlhZ25vc3RpY3MnKTtcclxufSkoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEhvdyBhIGNvbXBsZXRpb24gd2FzIHRyaWdnZXJlZFxyXG4gKi9cclxudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcclxuICAgICAqIGNvbXBsZXRlKSwgbWFudWFsIGludm9jYXRpb24gKGUuZyBDdHJsK1NwYWNlKSBvciB2aWEgQVBJLlxyXG4gICAgICovXHJcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyIHNwZWNpZmllZCBieVxyXG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cclxuICAgICAqL1xyXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wbGV0aW9uIHdhcyByZS10cmlnZ2VyZWQgYXMgY3VycmVudCBjb21wbGV0aW9uIGxpc3QgaXMgaW5jb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XHJcbn0pKENvbXBsZXRpb25UcmlnZ2VyS2luZCA9IGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcclxuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXSgjVGV4dERvY3VtZW50UG9zaXRpb24pIHRoZSByZXNwb25zZVxyXG4gKiBpcyBvZiB0eXBlIFtDb21wbGV0aW9uSXRlbVtdXSgjQ29tcGxldGlvbkl0ZW0pIG9yIFtDb21wbGV0aW9uTGlzdF0oI0NvbXBsZXRpb25MaXN0KVxyXG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICpcclxuICogVGhlIHJlcXVlc3QgY2FuIGRlbGF5IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgW2BkZXRhaWxgXSgjQ29tcGxldGlvbkl0ZW0uZGV0YWlsKVxyXG4gKiBhbmQgW2Bkb2N1bWVudGF0aW9uYF0oI0NvbXBsZXRpb25JdGVtLmRvY3VtZW50YXRpb24pIHByb3BlcnRpZXMgdG8gdGhlIGBjb21wbGV0aW9uSXRlbS9yZXNvbHZlYFxyXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXHJcbiAqIGBmaWx0ZXJUZXh0YCwgYGluc2VydFRleHRgLCBhbmQgYHRleHRFZGl0YCwgbXVzdCBub3QgYmUgY2hhbmdlZCBkdXJpbmcgcmVzb2x2ZS5cclxuICovXHJcbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVxdWVzdCkge1xyXG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvY29tcGxldGlvbicpO1xyXG59KShDb21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogUmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY29tcGxldGlvbiBpdGVtLlRoZSByZXF1ZXN0J3NcclxuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUgW0NvbXBsZXRpb25JdGVtXSgjQ29tcGxldGlvbkl0ZW0pIHRoZSByZXNwb25zZVxyXG4gKiBpcyBvZiB0eXBlIFtDb21wbGV0aW9uSXRlbV0oI0NvbXBsZXRpb25JdGVtKSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0KSB7XHJcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCdjb21wbGV0aW9uSXRlbS9yZXNvbHZlJyk7XHJcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XHJcbi8vLS0tLSBIb3ZlciBTdXBwb3J0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqXHJcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcclxuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXSgjVGV4dERvY3VtZW50UG9zaXRpb24pIHRoZSByZXNwb25zZSBpcyBvZlxyXG4gKiB0eXBlIFtIb3Zlcl0oI0hvdmVyKSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBIb3ZlclJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoSG92ZXJSZXF1ZXN0KSB7XHJcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvaG92ZXInKTtcclxufSkoSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Ib3ZlclJlcXVlc3QgfHwgKGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0ge30pKTtcclxudmFyIFNpZ25hdHVyZUhlbHBSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBSZXF1ZXN0KSB7XHJcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC9zaWduYXR1cmVIZWxwJyk7XHJcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XHJcbi8vLS0tLSBHb3RvIERlZmluaXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIGRlZmluaXRpb24gbG9jYXRpb24gb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0XHJcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvbl1cclxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUgW0RlZmluaXRpb25dKCNEZWZpbml0aW9uKSBvciBhXHJcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBEZWZpbml0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xyXG4gICAgRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbicpO1xyXG59KShEZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGVmaW5pdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxyXG4gKiBieSB0aGUgZ2l2ZW4gdGV4dCBkb2N1bWVudCBwb3NpdGlvbi4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcclxuICogdHlwZSBbUmVmZXJlbmNlUGFyYW1zXSgjUmVmZXJlbmNlUGFyYW1zKSB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxyXG4gKiBbTG9jYXRpb25bXV0oI0xvY2F0aW9uKSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChSZWZlcmVuY2VzUmVxdWVzdCkge1xyXG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvcmVmZXJlbmNlcycpO1xyXG59KShSZWZlcmVuY2VzUmVxdWVzdCA9IGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgfHwgKGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgPSB7fSkpO1xyXG4vLy0tLS0gRG9jdW1lbnQgSGlnaGxpZ2h0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqXHJcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIFtEb2N1bWVudEhpZ2hsaWdodF0oI0RvY3VtZW50SGlnaGxpZ2h0KSBmb3IgYSBnaXZlblxyXG4gKiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvbl1cclxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cclxuICogKCNEb2N1bWVudEhpZ2hsaWdodCkgb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXHJcbiAqL1xyXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCkge1xyXG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgndGV4dERvY3VtZW50L2RvY3VtZW50SGlnaGxpZ2h0Jyk7XHJcbn0pKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IHt9KSk7XHJcbi8vLS0tLSBEb2N1bWVudCBTeW1ib2wgUHJvdmlkZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcclxuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudElkZW50aWZpZXJdKCNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB0aGVcclxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSBbU3ltYm9sSW5mb3JtYXRpb25bXV0oI1N5bWJvbEluZm9ybWF0aW9uKSBvciBhIFRoZW5hYmxlXHJcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cclxuICovXHJcbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XHJcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0KSB7XHJcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRTeW1ib2wnKTtcclxufSkoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0ge30pKTtcclxuLy8tLS0tIFdvcmtzcGFjZSBTeW1ib2wgUHJvdmlkZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBwcm9qZWN0LXdpZGUgc3ltYm9scyBtYXRjaGluZyB0aGUgcXVlcnkgc3RyaW5nIGdpdmVuXHJcbiAqIGJ5IHRoZSBbV29ya3NwYWNlU3ltYm9sUGFyYW1zXSgjV29ya3NwYWNlU3ltYm9sUGFyYW1zKS4gVGhlIHJlc3BvbnNlIGlzXHJcbiAqIG9mIHR5cGUgW1N5bWJvbEluZm9ybWF0aW9uW11dKCNTeW1ib2xJbmZvcm1hdGlvbikgb3IgYSBUaGVuYWJsZSB0aGF0XHJcbiAqIHJlc29sdmVzIHRvIHN1Y2guXHJcbiAqL1xyXG52YXIgV29ya3NwYWNlU3ltYm9sUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XHJcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnd29ya3NwYWNlL3N5bWJvbCcpO1xyXG59KShXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IGFuZCByYW5nZS5cclxuICovXHJcbnZhciBDb2RlQWN0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVxdWVzdCkge1xyXG4gICAgQ29kZUFjdGlvblJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbicpO1xyXG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29kZSBsZW5zIGZvciB0aGUgZ2l2ZW4gdGV4dCBkb2N1bWVudC5cclxuICovXHJcbnZhciBDb2RlTGVuc1JlcXVlc3Q7XHJcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXF1ZXN0KSB7XHJcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvY29kZUxlbnMnKTtcclxufSkoQ29kZUxlbnNSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXF1ZXN0ID0ge30pKTtcclxuLyoqXHJcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIGEgY29tbWFuZCBmb3IgYSBnaXZlbiBjb2RlIGxlbnMuXHJcbiAqL1xyXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0KSB7XHJcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnY29kZUxlbnMvcmVzb2x2ZScpO1xyXG59KShDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxyXG4gKi9cclxudmFyIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3Q7XHJcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xyXG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJyk7XHJcbn0pKERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cclxuICovXHJcbnZhciBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3Q7XHJcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XHJcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJyk7XHJcbn0pKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cclxuICovXHJcbnZhciBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcclxuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZycpO1xyXG59KShEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHJlbmFtZSBhIHN5bWJvbC5cclxuICovXHJcbnZhciBSZW5hbWVSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKFJlbmFtZVJlcXVlc3QpIHtcclxuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvcmVuYW1lJyk7XHJcbn0pKFJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgfHwgKGV4cG9ydHMuUmVuYW1lUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3QgdG8gdGVzdCBhbmQgcGVyZm9ybSB0aGUgc2V0dXAgbmVjZXNzYXJ5IGZvciBhIHJlbmFtZS5cclxuICovXHJcbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChQcmVwYXJlUmVuYW1lUmVxdWVzdCkge1xyXG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvcHJlcGFyZVJlbmFtZScpO1xyXG59KShQcmVwYXJlUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgfHwgKGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSB7fSkpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZG9jdW1lbnQgbGlua3NcclxuICovXHJcbnZhciBEb2N1bWVudExpbmtSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKERvY3VtZW50TGlua1JlcXVlc3QpIHtcclxuICAgIERvY3VtZW50TGlua1JlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd0ZXh0RG9jdW1lbnQvZG9jdW1lbnRMaW5rJyk7XHJcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBkb2N1bWVudCBsaW5rLiBUaGUgcmVxdWVzdCdzXHJcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtEb2N1bWVudExpbmtdKCNEb2N1bWVudExpbmspIHRoZSByZXNwb25zZVxyXG4gKiBpcyBvZiB0eXBlIFtEb2N1bWVudExpbmtdKCNEb2N1bWVudExpbmspIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxyXG4gKi9cclxudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0KSB7XHJcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ2RvY3VtZW50TGluay9yZXNvbHZlJyk7XHJcbn0pKERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3Qgc2VuZCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBleGVjdXRlIGEgY29tbWFuZC4gVGhlIHJlcXVlc3QgbWlnaHQgcmV0dXJuXHJcbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXHJcbiAqL1xyXG52YXIgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xyXG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJyk7XHJcbn0pKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0IHx8IChleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cclxuICovXHJcbnZhciBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0O1xyXG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcclxuICAgIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlKCd3b3Jrc3BhY2UvYXBwbHlFZGl0Jyk7XHJcbn0pKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgfHwgKGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IHt9KSk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * A request to resolve the type definition locations of a symbol at a given text\r\n * document position. The request's parameter is of type [TextDocumentPositioParams]\r\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\r\n * Thenable that resolves to such.\r\n */\r\nvar TypeDefinitionRequest;\r\n(function (TypeDefinitionRequest) {\r\n    TypeDefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/typeDefinition');\r\n})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC50eXBlRGVmaW5pdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC50eXBlRGVmaW5pdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gcmVxdWlyZShcInZzY29kZS1qc29ucnBjXCIpO1xyXG4vKipcclxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHR5cGUgZGVmaW5pdGlvbiBsb2NhdGlvbnMgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0XHJcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvUGFyYW1zXVxyXG4gKiAoI1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKSB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRGVmaW5pdGlvbl0oI0RlZmluaXRpb24pIG9yIGFcclxuICogVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxyXG4gKi9cclxudmFyIFR5cGVEZWZpbml0aW9uUmVxdWVzdDtcclxuKGZ1bmN0aW9uIChUeXBlRGVmaW5pdGlvblJlcXVlc3QpIHtcclxuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUoJ3RleHREb2N1bWVudC90eXBlRGVmaW5pdGlvbicpO1xyXG59KShUeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/main.js\");\r\n/**\r\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\r\n */\r\nvar WorkspaceFoldersRequest;\r\n(function (WorkspaceFoldersRequest) {\r\n    WorkspaceFoldersRequest.type = new vscode_jsonrpc_1.RequestType0('workspace/workspaceFolders');\r\n})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));\r\n/**\r\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\r\n * folder configuration changes.\r\n */\r\nvar DidChangeWorkspaceFoldersNotification;\r\n(function (DidChangeWorkspaceFoldersNotification) {\r\n    DidChangeWorkspaceFoldersNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWorkspaceFolders');\r\n})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9wcm90b2NvbC53b3Jrc3BhY2VGb2xkZXJzLmpzLmpzIiwic291cmNlcyI6WyIuLi8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL3Byb3RvY29sLndvcmtzcGFjZUZvbGRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtanNvbnJwY1wiKTtcclxuLyoqXHJcbiAqIFRoZSBgd29ya3NwYWNlL3dvcmtzcGFjZUZvbGRlcnNgIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gZmV0Y2ggdGhlIG9wZW4gd29ya3NwYWNlIGZvbGRlcnMuXHJcbiAqL1xyXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XHJcbihmdW5jdGlvbiAoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QpIHtcclxuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZTAoJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJyk7XHJcbn0pKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgYHdvcmtzcGFjZS9kaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzYCBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuIHRoZSB3b3Jrc3BhY2VcclxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cclxuICovXHJcbnZhciBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uO1xyXG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcclxuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUoJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzJyk7XHJcbn0pKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IHt9KSk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/utils/is.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/utils/is.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\nfunction typedArray(value, check) {\r\n    return Array.isArray(value) && value.every(check);\r\n}\r\nexports.typedArray = typedArray;\r\nfunction thenable(value) {\r\n    return value && func(value.then);\r\n}\r\nexports.thenable = thenable;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi91dGlscy9pcy5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi91dGlscy9pcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XHJcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbn1cclxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XHJcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XHJcbn1cclxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XHJcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcclxufVxyXG5leHBvcnRzLmVycm9yID0gZXJyb3I7XHJcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZXhwb3J0cy5mdW5jID0gZnVuYztcclxuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XHJcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcclxufVxyXG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XHJcbmZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xyXG59XHJcbmV4cG9ydHMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XHJcbmZ1bmN0aW9uIHRoZW5hYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgZnVuYyh2YWx1ZS50aGVuKTtcclxufVxyXG5leHBvcnRzLnRoZW5hYmxlID0gdGhlbmFibGU7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-protocol/lib/utils/is.js\n");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/*! exports provided: Position, Range, Location, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, Diagnostic, Command, TextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, EOL, TextDocument, TextDocumentSaveReason */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Range\", function() { return Range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Location\", function() { return Location; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorInformation\", function() { return ColorInformation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorPresentation\", function() { return ColorPresentation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FoldingRangeKind\", function() { return FoldingRangeKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FoldingRange\", function() { return FoldingRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiagnosticRelatedInformation\", function() { return DiagnosticRelatedInformation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiagnosticSeverity\", function() { return DiagnosticSeverity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Diagnostic\", function() { return Diagnostic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Command\", function() { return Command; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextEdit\", function() { return TextEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDocumentEdit\", function() { return TextDocumentEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateFile\", function() { return CreateFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenameFile\", function() { return RenameFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeleteFile\", function() { return DeleteFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorkspaceEdit\", function() { return WorkspaceEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorkspaceChange\", function() { return WorkspaceChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDocumentIdentifier\", function() { return TextDocumentIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VersionedTextDocumentIdentifier\", function() { return VersionedTextDocumentIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDocumentItem\", function() { return TextDocumentItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkupKind\", function() { return MarkupKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkupContent\", function() { return MarkupContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompletionItemKind\", function() { return CompletionItemKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InsertTextFormat\", function() { return InsertTextFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompletionItem\", function() { return CompletionItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompletionList\", function() { return CompletionList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkedString\", function() { return MarkedString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Hover\", function() { return Hover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParameterInformation\", function() { return ParameterInformation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignatureInformation\", function() { return SignatureInformation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DocumentHighlightKind\", function() { return DocumentHighlightKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DocumentHighlight\", function() { return DocumentHighlight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolKind\", function() { return SymbolKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SymbolInformation\", function() { return SymbolInformation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DocumentSymbol\", function() { return DocumentSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CodeActionKind\", function() { return CodeActionKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CodeActionContext\", function() { return CodeActionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CodeAction\", function() { return CodeAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CodeLens\", function() { return CodeLens; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormattingOptions\", function() { return FormattingOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DocumentLink\", function() { return DocumentLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOL\", function() { return EOL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDocument\", function() { return TextDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDocumentSaveReason\", function() { return TextDocumentSaveReason; });\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n\r\n/**\r\n * The Position namespace provides helper functions to work with\r\n * [Position](#Position) literals.\r\n */\r\nvar Position;\r\n(function (Position) {\r\n    /**\r\n     * Creates a new Position literal from the given line and character.\r\n     * @param line The position's line.\r\n     * @param character The position's character.\r\n     */\r\n    function create(line, character) {\r\n        return { line: line, character: character };\r\n    }\r\n    Position.create = create;\r\n    /**\r\n     * Checks whether the given liternal conforms to the [Position](#Position) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\r\n    }\r\n    Position.is = is;\r\n})(Position || (Position = {}));\r\n/**\r\n * The Range namespace provides helper functions to work with\r\n * [Range](#Range) literals.\r\n */\r\nvar Range;\r\n(function (Range) {\r\n    function create(one, two, three, four) {\r\n        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\r\n            return { start: Position.create(one, two), end: Position.create(three, four) };\r\n        }\r\n        else if (Position.is(one) && Position.is(two)) {\r\n            return { start: one, end: two };\r\n        }\r\n        else {\r\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\r\n        }\r\n    }\r\n    Range.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n    }\r\n    Range.is = is;\r\n})(Range || (Range = {}));\r\n/**\r\n * The Location namespace provides helper functions to work with\r\n * [Location](#Location) literals.\r\n */\r\nvar Location;\r\n(function (Location) {\r\n    /**\r\n     * Creates a Location literal.\r\n     * @param uri The location's uri.\r\n     * @param range The location's range.\r\n     */\r\n    function create(uri, range) {\r\n        return { uri: uri, range: range };\r\n    }\r\n    Location.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n    }\r\n    Location.is = is;\r\n})(Location || (Location = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [Color](#Color) literals.\r\n */\r\nvar Color;\r\n(function (Color) {\r\n    /**\r\n     * Creates a new Color literal.\r\n     */\r\n    function create(red, green, blue, alpha) {\r\n        return {\r\n            red: red,\r\n            green: green,\r\n            blue: blue,\r\n            alpha: alpha,\r\n        };\r\n    }\r\n    Color.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.red)\r\n            && Is.number(candidate.green)\r\n            && Is.number(candidate.blue)\r\n            && Is.number(candidate.alpha);\r\n    }\r\n    Color.is = is;\r\n})(Color || (Color = {}));\r\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * [ColorInformation](#ColorInformation) literals.\r\n */\r\nvar ColorInformation;\r\n(function (ColorInformation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(range, color) {\r\n        return {\r\n            range: range,\r\n            color: color,\r\n        };\r\n    }\r\n    ColorInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Range.is(candidate.range) && Color.is(candidate.color);\r\n    }\r\n    ColorInformation.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [ColorPresentation](#ColorPresentation) literals.\r\n */\r\nvar ColorPresentation;\r\n(function (ColorPresentation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(label, textEdit, additionalTextEdits) {\r\n        return {\r\n            label: label,\r\n            textEdit: textEdit,\r\n            additionalTextEdits: additionalTextEdits,\r\n        };\r\n    }\r\n    ColorPresentation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate.label)\r\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n    }\r\n    ColorPresentation.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\n/**\r\n * Enum of known range kinds\r\n */\r\nvar FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind[\"Comment\"] = \"comment\";\r\n    /**\r\n     * Folding range for a imports or includes\r\n     */\r\n    FoldingRangeKind[\"Imports\"] = \"imports\";\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind[\"Region\"] = \"region\";\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * [FoldingRange](#FoldingRange) literals.\r\n */\r\nvar FoldingRange;\r\n(function (FoldingRange) {\r\n    /**\r\n     * Creates a new FoldingRange literal.\r\n     */\r\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\r\n        var result = {\r\n            startLine: startLine,\r\n            endLine: endLine\r\n        };\r\n        if (Is.defined(startCharacter)) {\r\n            result.startCharacter = startCharacter;\r\n        }\r\n        if (Is.defined(endCharacter)) {\r\n            result.endCharacter = endCharacter;\r\n        }\r\n        if (Is.defined(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    FoldingRange.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.number(candidate.startLine) && Is.number(candidate.startLine)\r\n            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))\r\n            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))\r\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n    }\r\n    FoldingRange.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\r\n */\r\nvar DiagnosticRelatedInformation;\r\n(function (DiagnosticRelatedInformation) {\r\n    /**\r\n     * Creates a new DiagnosticRelatedInformation literal.\r\n     */\r\n    function create(location, message) {\r\n        return {\r\n            location: location,\r\n            message: message\r\n        };\r\n    }\r\n    DiagnosticRelatedInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n    }\r\n    DiagnosticRelatedInformation.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\n/**\r\n * The diagnostic's severity.\r\n */\r\nvar DiagnosticSeverity;\r\n(function (DiagnosticSeverity) {\r\n    /**\r\n     * Reports an error.\r\n     */\r\n    DiagnosticSeverity.Error = 1;\r\n    /**\r\n     * Reports a warning.\r\n     */\r\n    DiagnosticSeverity.Warning = 2;\r\n    /**\r\n     * Reports an information.\r\n     */\r\n    DiagnosticSeverity.Information = 3;\r\n    /**\r\n     * Reports a hint.\r\n     */\r\n    DiagnosticSeverity.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * [Diagnostic](#Diagnostic) literals.\r\n */\r\nvar Diagnostic;\r\n(function (Diagnostic) {\r\n    /**\r\n     * Creates a new Diagnostic literal.\r\n     */\r\n    function create(range, message, severity, code, source, relatedInformation) {\r\n        var result = { range: range, message: message };\r\n        if (Is.defined(severity)) {\r\n            result.severity = severity;\r\n        }\r\n        if (Is.defined(code)) {\r\n            result.code = code;\r\n        }\r\n        if (Is.defined(source)) {\r\n            result.source = source;\r\n        }\r\n        if (Is.defined(relatedInformation)) {\r\n            result.relatedInformation = relatedInformation;\r\n        }\r\n        return result;\r\n    }\r\n    Diagnostic.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && Range.is(candidate.range)\r\n            && Is.string(candidate.message)\r\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n    }\r\n    Diagnostic.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\n/**\r\n * The Command namespace provides helper functions to work with\r\n * [Command](#Command) literals.\r\n */\r\nvar Command;\r\n(function (Command) {\r\n    /**\r\n     * Creates a new Command literal.\r\n     */\r\n    function create(title, command) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { title: title, command: command };\r\n        if (Is.defined(args) && args.length > 0) {\r\n            result.arguments = args;\r\n        }\r\n        return result;\r\n    }\r\n    Command.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\r\nvar TextEdit;\r\n(function (TextEdit) {\r\n    /**\r\n     * Creates a replace text edit.\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     */\r\n    function replace(range, newText) {\r\n        return { range: range, newText: newText };\r\n    }\r\n    TextEdit.replace = replace;\r\n    /**\r\n     * Creates a insert text edit.\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     */\r\n    function insert(position, newText) {\r\n        return { range: { start: position, end: position }, newText: newText };\r\n    }\r\n    TextEdit.insert = insert;\r\n    /**\r\n     * Creates a delete text edit.\r\n     * @param range The range of text to be deleted.\r\n     */\r\n    function del(range) {\r\n        return { range: range, newText: '' };\r\n    }\r\n    TextEdit.del = del;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && Is.string(candidate.newText)\r\n            && Range.is(candidate.range);\r\n    }\r\n    TextEdit.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\r\nvar TextDocumentEdit;\r\n(function (TextDocumentEdit) {\r\n    /**\r\n     * Creates a new `TextDocumentEdit`\r\n     */\r\n    function create(textDocument, edits) {\r\n        return { textDocument: textDocument, edits: edits };\r\n    }\r\n    TextDocumentEdit.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate)\r\n            && VersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n            && Array.isArray(candidate.edits);\r\n    }\r\n    TextDocumentEdit.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nvar CreateFile;\r\n(function (CreateFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'create',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    CreateFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    CreateFile.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nvar RenameFile;\r\n(function (RenameFile) {\r\n    function create(oldUri, newUri, options) {\r\n        var result = {\r\n            kind: 'rename',\r\n            oldUri: oldUri,\r\n            newUri: newUri\r\n        };\r\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    RenameFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\r\n    }\r\n    RenameFile.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nvar DeleteFile;\r\n(function (DeleteFile) {\r\n    function create(uri, options) {\r\n        var result = {\r\n            kind: 'delete',\r\n            uri: uri\r\n        };\r\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\r\n            result.options = options;\r\n        }\r\n        return result;\r\n    }\r\n    DeleteFile.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&\r\n            (candidate.options === void 0 ||\r\n                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));\r\n    }\r\n    DeleteFile.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nvar WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&\r\n            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\r\n                if (Is.string(change.kind)) {\r\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                }\r\n                else {\r\n                    return TextDocumentEdit.is(change);\r\n                }\r\n            }));\r\n    }\r\n    WorkspaceEdit.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nvar TextEditChangeImpl = /** @class */ (function () {\r\n    function TextEditChangeImpl(edits) {\r\n        this.edits = edits;\r\n    }\r\n    TextEditChangeImpl.prototype.insert = function (position, newText) {\r\n        this.edits.push(TextEdit.insert(position, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.replace = function (range, newText) {\r\n        this.edits.push(TextEdit.replace(range, newText));\r\n    };\r\n    TextEditChangeImpl.prototype.delete = function (range) {\r\n        this.edits.push(TextEdit.del(range));\r\n    };\r\n    TextEditChangeImpl.prototype.add = function (edit) {\r\n        this.edits.push(edit);\r\n    };\r\n    TextEditChangeImpl.prototype.all = function () {\r\n        return this.edits;\r\n    };\r\n    TextEditChangeImpl.prototype.clear = function () {\r\n        this.edits.splice(0, this.edits.length);\r\n    };\r\n    return TextEditChangeImpl;\r\n}());\r\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\r\nvar WorkspaceChange = /** @class */ (function () {\r\n    function WorkspaceChange(workspaceEdit) {\r\n        var _this = this;\r\n        this._textEditChanges = Object.create(null);\r\n        if (workspaceEdit) {\r\n            this._workspaceEdit = workspaceEdit;\r\n            if (workspaceEdit.documentChanges) {\r\n                workspaceEdit.documentChanges.forEach(function (change) {\r\n                    if (TextDocumentEdit.is(change)) {\r\n                        var textEditChange = new TextEditChangeImpl(change.edits);\r\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                    }\r\n                });\r\n            }\r\n            else if (workspaceEdit.changes) {\r\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\r\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                    _this._textEditChanges[key] = textEditChange;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\r\n        /**\r\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\r\n         * use to be returned from a workspace edit operation like rename.\r\n         */\r\n        get: function () {\r\n            return this._workspaceEdit;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\r\n        if (VersionedTextDocumentIdentifier.is(key)) {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    documentChanges: []\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.documentChanges) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var textDocument = key;\r\n            var result = this._textEditChanges[textDocument.uri];\r\n            if (!result) {\r\n                var edits = [];\r\n                var textDocumentEdit = {\r\n                    textDocument: textDocument,\r\n                    edits: edits\r\n                };\r\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[textDocument.uri] = result;\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (!this._workspaceEdit) {\r\n                this._workspaceEdit = {\r\n                    changes: Object.create(null)\r\n                };\r\n            }\r\n            if (!this._workspaceEdit.changes) {\r\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n            }\r\n            var result = this._textEditChanges[key];\r\n            if (!result) {\r\n                var edits = [];\r\n                this._workspaceEdit.changes[key] = edits;\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[key] = result;\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    WorkspaceChange.prototype.createFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\r\n    };\r\n    WorkspaceChange.prototype.deleteFile = function (uri, options) {\r\n        this.checkDocumentChanges();\r\n        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\r\n    };\r\n    WorkspaceChange.prototype.checkDocumentChanges = function () {\r\n        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n    };\r\n    return WorkspaceChange;\r\n}());\r\n\r\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\r\n */\r\nvar TextDocumentIdentifier;\r\n(function (TextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new TextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     */\r\n    function create(uri) {\r\n        return { uri: uri };\r\n    }\r\n    TextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri);\r\n    }\r\n    TextDocumentIdentifier.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\r\n */\r\nvar VersionedTextDocumentIdentifier;\r\n(function (VersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new VersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param uri The document's text.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri: uri, version: version };\r\n    }\r\n    VersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\r\n    }\r\n    VersionedTextDocumentIdentifier.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * [TextDocumentItem](#TextDocumentItem) literals.\r\n */\r\nvar TextDocumentItem;\r\n(function (TextDocumentItem) {\r\n    /**\r\n     * Creates a new TextDocumentItem literal.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language identifier.\r\n     * @param version The document's version number.\r\n     * @param text The document's text.\r\n     */\r\n    function create(uri, languageId, version, text) {\r\n        return { uri: uri, languageId: languageId, version: version, text: text };\r\n    }\r\n    TextDocumentItem.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\r\n    }\r\n    TextDocumentItem.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\r\nvar MarkupKind;\r\n(function (MarkupKind) {\r\n    /**\r\n     * Plain text is supported as a content format\r\n     */\r\n    MarkupKind.PlainText = 'plaintext';\r\n    /**\r\n     * Markdown is supported as a content format\r\n     */\r\n    MarkupKind.Markdown = 'markdown';\r\n})(MarkupKind || (MarkupKind = {}));\r\n(function (MarkupKind) {\r\n    /**\r\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n    }\r\n    MarkupKind.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nvar MarkupContent;\r\n(function (MarkupContent) {\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n    }\r\n    MarkupContent.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\n/**\r\n * The kind of a completion entry.\r\n */\r\nvar CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind.Text = 1;\r\n    CompletionItemKind.Method = 2;\r\n    CompletionItemKind.Function = 3;\r\n    CompletionItemKind.Constructor = 4;\r\n    CompletionItemKind.Field = 5;\r\n    CompletionItemKind.Variable = 6;\r\n    CompletionItemKind.Class = 7;\r\n    CompletionItemKind.Interface = 8;\r\n    CompletionItemKind.Module = 9;\r\n    CompletionItemKind.Property = 10;\r\n    CompletionItemKind.Unit = 11;\r\n    CompletionItemKind.Value = 12;\r\n    CompletionItemKind.Enum = 13;\r\n    CompletionItemKind.Keyword = 14;\r\n    CompletionItemKind.Snippet = 15;\r\n    CompletionItemKind.Color = 16;\r\n    CompletionItemKind.File = 17;\r\n    CompletionItemKind.Reference = 18;\r\n    CompletionItemKind.Folder = 19;\r\n    CompletionItemKind.EnumMember = 20;\r\n    CompletionItemKind.Constant = 21;\r\n    CompletionItemKind.Struct = 22;\r\n    CompletionItemKind.Event = 23;\r\n    CompletionItemKind.Operator = 24;\r\n    CompletionItemKind.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\r\nvar InsertTextFormat;\r\n(function (InsertTextFormat) {\r\n    /**\r\n     * The primary text to be inserted is treated as a plain string.\r\n     */\r\n    InsertTextFormat.PlainText = 1;\r\n    /**\r\n     * The primary text to be inserted is treated as a snippet.\r\n     *\r\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n     * the end of the snippet. Placeholders with equal identifiers are linked,\r\n     * that is typing in one will update others too.\r\n     *\r\n     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\r\n     */\r\n    InsertTextFormat.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\r\nvar CompletionItem;\r\n(function (CompletionItem) {\r\n    /**\r\n     * Create a completion item and seed it with a label.\r\n     * @param label The completion item's label\r\n     */\r\n    function create(label) {\r\n        return { label: label };\r\n    }\r\n    CompletionItem.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\r\nvar CompletionList;\r\n(function (CompletionList) {\r\n    /**\r\n     * Creates a new completion list.\r\n     *\r\n     * @param items The completion items.\r\n     * @param isIncomplete The list is not complete.\r\n     */\r\n    function create(items, isIncomplete) {\r\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n    }\r\n    CompletionList.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nvar MarkedString;\r\n(function (MarkedString) {\r\n    /**\r\n     * Creates a marked string from plain text.\r\n     *\r\n     * @param plainText The plain text.\r\n     */\r\n    function fromPlainText(plainText) {\r\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    }\r\n    MarkedString.fromPlainText = fromPlainText;\r\n    /**\r\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n    }\r\n    MarkedString.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nvar Hover;\r\n(function (Hover) {\r\n    /**\r\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n            MarkedString.is(candidate.contents) ||\r\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\r\n    }\r\n    Hover.is = is;\r\n})(Hover || (Hover = {}));\r\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * [ParameterInformation](#ParameterInformation) literals.\r\n */\r\nvar ParameterInformation;\r\n(function (ParameterInformation) {\r\n    /**\r\n     * Creates a new parameter information literal.\r\n     *\r\n     * @param label A label string.\r\n     * @param documentation A doc string.\r\n     */\r\n    function create(label, documentation) {\r\n        return documentation ? { label: label, documentation: documentation } : { label: label };\r\n    }\r\n    ParameterInformation.create = create;\r\n    ;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * [SignatureInformation](#SignatureInformation) literals.\r\n */\r\nvar SignatureInformation;\r\n(function (SignatureInformation) {\r\n    function create(label, documentation) {\r\n        var parameters = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            parameters[_i - 2] = arguments[_i];\r\n        }\r\n        var result = { label: label };\r\n        if (Is.defined(documentation)) {\r\n            result.documentation = documentation;\r\n        }\r\n        if (Is.defined(parameters)) {\r\n            result.parameters = parameters;\r\n        }\r\n        else {\r\n            result.parameters = [];\r\n        }\r\n        return result;\r\n    }\r\n    SignatureInformation.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nvar DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind.Text = 1;\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind.Read = 2;\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * [DocumentHighlight](#DocumentHighlight) literals.\r\n */\r\nvar DocumentHighlight;\r\n(function (DocumentHighlight) {\r\n    /**\r\n     * Create a DocumentHighlight object.\r\n     * @param range The range the highlight applies to.\r\n     */\r\n    function create(range, kind) {\r\n        var result = { range: range };\r\n        if (Is.number(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentHighlight.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nvar SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind.File = 1;\r\n    SymbolKind.Module = 2;\r\n    SymbolKind.Namespace = 3;\r\n    SymbolKind.Package = 4;\r\n    SymbolKind.Class = 5;\r\n    SymbolKind.Method = 6;\r\n    SymbolKind.Property = 7;\r\n    SymbolKind.Field = 8;\r\n    SymbolKind.Constructor = 9;\r\n    SymbolKind.Enum = 10;\r\n    SymbolKind.Interface = 11;\r\n    SymbolKind.Function = 12;\r\n    SymbolKind.Variable = 13;\r\n    SymbolKind.Constant = 14;\r\n    SymbolKind.String = 15;\r\n    SymbolKind.Number = 16;\r\n    SymbolKind.Boolean = 17;\r\n    SymbolKind.Array = 18;\r\n    SymbolKind.Object = 19;\r\n    SymbolKind.Key = 20;\r\n    SymbolKind.Null = 21;\r\n    SymbolKind.EnumMember = 22;\r\n    SymbolKind.Struct = 23;\r\n    SymbolKind.Event = 24;\r\n    SymbolKind.Operator = 25;\r\n    SymbolKind.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\nvar SymbolInformation;\r\n(function (SymbolInformation) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the location of the symbol.\r\n     * @param uri The resource of the location of symbol, defaults to the current document.\r\n     * @param containerName The name of the symbol containing the symbol.\r\n     */\r\n    function create(name, kind, range, uri, containerName) {\r\n        var result = {\r\n            name: name,\r\n            kind: kind,\r\n            location: { uri: uri, range: range }\r\n        };\r\n        if (containerName) {\r\n            result.containerName = containerName;\r\n        }\r\n        return result;\r\n    }\r\n    SymbolInformation.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\n/**\r\n * Represents programming constructs like variables, classes, interfaces etc.\r\n * that appear in a document. Document symbols can be hierarchical and they\r\n * have two ranges: one that encloses its definition and one that points to\r\n * its most interesting range, e.g. the range of an identifier.\r\n */\r\nvar DocumentSymbol = /** @class */ (function () {\r\n    function DocumentSymbol() {\r\n    }\r\n    return DocumentSymbol;\r\n}());\r\n\r\n(function (DocumentSymbol) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param detail The detail of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the symbol.\r\n     * @param selectionRange The selectionRange of the symbol.\r\n     * @param children Children of the symbol.\r\n     */\r\n    function create(name, detail, kind, range, selectionRange, children) {\r\n        var result = {\r\n            name: name,\r\n            detail: detail,\r\n            kind: kind,\r\n            range: range,\r\n            selectionRange: selectionRange\r\n        };\r\n        if (children !== void 0) {\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentSymbol.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate &&\r\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n            (candidate.detail === void 0 || Is.string(candidate.detail)) &&\r\n            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&\r\n            (candidate.children === void 0 || Array.isArray(candidate.children));\r\n    }\r\n    DocumentSymbol.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\n/**\r\n * A set of predefined code action kinds\r\n */\r\nvar CodeActionKind;\r\n(function (CodeActionKind) {\r\n    /**\r\n     * Base kind for quickfix actions: 'quickfix'\r\n     */\r\n    CodeActionKind.QuickFix = 'quickfix';\r\n    /**\r\n     * Base kind for refactoring actions: 'refactor'\r\n     */\r\n    CodeActionKind.Refactor = 'refactor';\r\n    /**\r\n     * Base kind for refactoring extraction actions: 'refactor.extract'\r\n     *\r\n     * Example extract actions:\r\n     *\r\n     * - Extract method\r\n     * - Extract function\r\n     * - Extract variable\r\n     * - Extract interface from class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorExtract = 'refactor.extract';\r\n    /**\r\n     * Base kind for refactoring inline actions: 'refactor.inline'\r\n     *\r\n     * Example inline actions:\r\n     *\r\n     * - Inline function\r\n     * - Inline variable\r\n     * - Inline constant\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorInline = 'refactor.inline';\r\n    /**\r\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n     *\r\n     * Example rewrite actions:\r\n     *\r\n     * - Convert JavaScript function to class\r\n     * - Add or remove parameter\r\n     * - Encapsulate field\r\n     * - Make method static\r\n     * - Move method to base class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n    /**\r\n     * Base kind for source actions: `source`\r\n     *\r\n     * Source code actions apply to the entire file.\r\n     */\r\n    CodeActionKind.Source = 'source';\r\n    /**\r\n     * Base kind for an organize imports source action: `source.organizeImports`\r\n     */\r\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n})(CodeActionKind || (CodeActionKind = {}));\r\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * [CodeActionContext](#CodeActionContext) literals.\r\n */\r\nvar CodeActionContext;\r\n(function (CodeActionContext) {\r\n    /**\r\n     * Creates a new CodeActionContext literal.\r\n     */\r\n    function create(diagnostics, only) {\r\n        var result = { diagnostics: diagnostics };\r\n        if (only !== void 0 && only !== null) {\r\n            result.only = only;\r\n        }\r\n        return result;\r\n    }\r\n    CodeActionContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\r\n    }\r\n    CodeActionContext.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nvar CodeAction;\r\n(function (CodeAction) {\r\n    function create(title, commandOrEdit, kind) {\r\n        var result = { title: title };\r\n        if (Command.is(commandOrEdit)) {\r\n            result.command = commandOrEdit;\r\n        }\r\n        else {\r\n            result.edit = commandOrEdit;\r\n        }\r\n        if (kind !== void null) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeAction.create = create;\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && Is.string(candidate.title) &&\r\n            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n            (candidate.kind === void 0 || Is.string(candidate.kind)) &&\r\n            (candidate.edit !== void 0 || candidate.command !== void 0) &&\r\n            (candidate.command === void 0 || Command.is(candidate.command)) &&\r\n            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\r\n    }\r\n    CodeAction.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * [CodeLens](#CodeLens) literals.\r\n */\r\nvar CodeLens;\r\n(function (CodeLens) {\r\n    /**\r\n     * Creates a new CodeLens literal.\r\n     */\r\n    function create(range, data) {\r\n        var result = { range: range };\r\n        if (Is.defined(data))\r\n            result.data = data;\r\n        return result;\r\n    }\r\n    CodeLens.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n    }\r\n    CodeLens.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * [FormattingOptions](#FormattingOptions) literals.\r\n */\r\nvar FormattingOptions;\r\n(function (FormattingOptions) {\r\n    /**\r\n     * Creates a new FormattingOptions literal.\r\n     */\r\n    function create(tabSize, insertSpaces) {\r\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\r\n    }\r\n    FormattingOptions.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n    }\r\n    FormattingOptions.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\n/**\r\n * A document link is a range in a text document that links to an internal or external resource, like another\r\n * text document or a web site.\r\n */\r\nvar DocumentLink = /** @class */ (function () {\r\n    function DocumentLink() {\r\n    }\r\n    return DocumentLink;\r\n}());\r\n\r\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * [DocumentLink](#DocumentLink) literals.\r\n */\r\n(function (DocumentLink) {\r\n    /**\r\n     * Creates a new DocumentLink literal.\r\n     */\r\n    function create(range, target, data) {\r\n        return { range: range, target: target, data: data };\r\n    }\r\n    DocumentLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n    }\r\n    DocumentLink.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\nvar EOL = ['\\n', '\\r\\n', '\\r'];\r\nvar TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new ITextDocument literal from the given uri and content.\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\r\n     */\r\n    function is(value) {\r\n        var candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)\r\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n    }\r\n    TextDocument.is = is;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits, function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Ovelapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n    function mergeSort(data, compare) {\r\n        if (data.length <= 1) {\r\n            // sorted\r\n            return data;\r\n        }\r\n        var p = (data.length / 2) | 0;\r\n        var left = data.slice(0, p);\r\n        var right = data.slice(p);\r\n        mergeSort(left, compare);\r\n        mergeSort(right, compare);\r\n        var leftIdx = 0;\r\n        var rightIdx = 0;\r\n        var i = 0;\r\n        while (leftIdx < left.length && rightIdx < right.length) {\r\n            var ret = compare(left[leftIdx], right[rightIdx]);\r\n            if (ret <= 0) {\r\n                // smaller_equal -> take left to preserve order\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            else {\r\n                // greater -> take right\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n        }\r\n        while (leftIdx < left.length) {\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        while (rightIdx < right.length) {\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n        return data;\r\n    }\r\n})(TextDocument || (TextDocument = {}));\r\n/**\r\n * Represents reasons why a text document is saved.\r\n */\r\nvar TextDocumentSaveReason;\r\n(function (TextDocumentSaveReason) {\r\n    /**\r\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\r\n     * or by an API call.\r\n     */\r\n    TextDocumentSaveReason.Manual = 1;\r\n    /**\r\n     * Automatic after a delay.\r\n     */\r\n    TextDocumentSaveReason.AfterDelay = 2;\r\n    /**\r\n     * When the editor lost focus.\r\n     */\r\n    TextDocumentSaveReason.FocusOut = 3;\r\n})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = null;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (event, version) {\r\n        this._content = event.text;\r\n        this._version = version;\r\n        this._lineOffsets = null;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === null) {\r\n            var lineOffsets = [];\r\n            var text = this._content;\r\n            var isLineStart = true;\r\n            for (var i = 0; i < text.length; i++) {\r\n                if (isLineStart) {\r\n                    lineOffsets.push(i);\r\n                    isLineStart = false;\r\n                }\r\n                var ch = text.charAt(i);\r\n                isLineStart = (ch === '\\r' || ch === '\\n');\r\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                    i++;\r\n                }\r\n            }\r\n            if (isLineStart && text.length > 0) {\r\n                lineOffsets.push(text.length);\r\n            }\r\n            this._lineOffsets = lineOffsets;\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return Position.create(0, offset);\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return Position.create(line, offset - lineOffsets[line]);\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FullTextDocument;\r\n}());\r\nvar Is;\r\n(function (Is) {\r\n    var toString = Object.prototype.toString;\r\n    function defined(value) {\r\n        return typeof value !== 'undefined';\r\n    }\r\n    Is.defined = defined;\r\n    function undefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    Is.undefined = undefined;\r\n    function boolean(value) {\r\n        return value === true || value === false;\r\n    }\r\n    Is.boolean = boolean;\r\n    function string(value) {\r\n        return toString.call(value) === '[object String]';\r\n    }\r\n    Is.string = string;\r\n    function number(value) {\r\n        return toString.call(value) === '[object Number]';\r\n    }\r\n    Is.number = number;\r\n    function func(value) {\r\n        return toString.call(value) === '[object Function]';\r\n    }\r\n    Is.func = func;\r\n    function objectLiteral(value) {\r\n        // Strictly speaking class instances pass this check as well. Since the LSP\r\n        // doesn't use classes we ignore this for now. If we do we need to add something\r\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n        return value !== null && typeof value === 'object';\r\n    }\r\n    Is.objectLiteral = objectLiteral;\r\n    function typedArray(value, check) {\r\n        return Array.isArray(value) && value.every(check);\r\n    }\r\n    Is.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbid1c2Ugc3RyaWN0JztcclxuLyoqXHJcbiAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW1Bvc2l0aW9uXSgjUG9zaXRpb24pIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBQb3NpdGlvbjtcclxuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxyXG4gICAgICogQHBhcmFtIGxpbmUgVGhlIHBvc2l0aW9uJ3MgbGluZS5cclxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUobGluZSwgY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY2hhcmFjdGVyOiBjaGFyYWN0ZXIgfTtcclxuICAgIH1cclxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVybmFsIGNvbmZvcm1zIHRvIHRoZSBbUG9zaXRpb25dKCNQb3NpdGlvbikgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlcihjYW5kaWRhdGUubGluZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5jaGFyYWN0ZXIpO1xyXG4gICAgfVxyXG4gICAgUG9zaXRpb24uaXMgPSBpcztcclxufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW1JhbmdlXSgjUmFuZ2UpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBSYW5nZTtcclxuKGZ1bmN0aW9uIChSYW5nZSkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xyXG4gICAgICAgIGlmIChJcy5udW1iZXIob25lKSAmJiBJcy5udW1iZXIodHdvKSAmJiBJcy5udW1iZXIodGhyZWUpICYmIElzLm51bWJlcihmb3VyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzW1wiICsgb25lICsgXCIsIFwiICsgdHdvICsgXCIsIFwiICsgdGhyZWUgKyBcIiwgXCIgKyBmb3VyICsgXCJdXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtSYW5nZV0oI1JhbmdlKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcclxuICAgIH1cclxuICAgIFJhbmdlLmlzID0gaXM7XHJcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgTG9jYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtMb2NhdGlvbl0oI0xvY2F0aW9uKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgTG9jYXRpb247XHJcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uIGxpdGVyYWwuXHJcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cclxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH07XHJcbiAgICB9XHJcbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbTG9jYXRpb25dKCNMb2NhdGlvbikgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xyXG4gICAgfVxyXG4gICAgTG9jYXRpb24uaXMgPSBpcztcclxufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW0NvbG9yXSgjQ29sb3IpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb2xvcjtcclxuKGZ1bmN0aW9uIChDb2xvcikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZDogcmVkLFxyXG4gICAgICAgICAgICBncmVlbjogZ3JlZW4sXHJcbiAgICAgICAgICAgIGJsdWU6IGJsdWUsXHJcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9yXSgjQ29sb3IpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLm51bWJlcihjYW5kaWRhdGUucmVkKVxyXG4gICAgICAgICAgICAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmdyZWVuKVxyXG4gICAgICAgICAgICAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmJsdWUpXHJcbiAgICAgICAgICAgICYmIElzLm51bWJlcihjYW5kaWRhdGUuYWxwaGEpO1xyXG4gICAgfVxyXG4gICAgQ29sb3IuaXMgPSBpcztcclxufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxyXG4gKiBbQ29sb3JJbmZvcm1hdGlvbl0oI0NvbG9ySW5mb3JtYXRpb24pIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb2xvckluZm9ybWF0aW9uO1xyXG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbQ29sb3JJbmZvcm1hdGlvbl0oI0NvbG9ySW5mb3JtYXRpb24pIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcclxuICAgIH1cclxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcclxufSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtDb2xvclByZXNlbnRhdGlvbl0oI0NvbG9yUHJlc2VudGF0aW9uKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgQ29sb3JQcmVzZW50YXRpb247XHJcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgIHRleHRFZGl0OiB0ZXh0RWRpdCxcclxuICAgICAgICAgICAgYWRkaXRpb25hbFRleHRFZGl0czogYWRkaXRpb25hbFRleHRFZGl0cyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgQ29sb3JQcmVzZW50YXRpb24uY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxyXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50ZXh0RWRpdCkgfHwgVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSlcclxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcclxuICAgIH1cclxuICAgIENvbG9yUHJlc2VudGF0aW9uLmlzID0gaXM7XHJcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIG9mIGtub3duIHJhbmdlIGtpbmRzXHJcbiAqL1xyXG5leHBvcnQgdmFyIEZvbGRpbmdSYW5nZUtpbmQ7XHJcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlS2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcclxuICAgICAqL1xyXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIkNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBpbXBvcnRzIG9yIGluY2x1ZGVzXHJcbiAgICAgKi9cclxuICAgIEZvbGRpbmdSYW5nZUtpbmRbXCJJbXBvcnRzXCJdID0gXCJpbXBvcnRzXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcclxuICAgICAqL1xyXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIlJlZ2lvblwiXSA9IFwicmVnaW9uXCI7XHJcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtGb2xkaW5nUmFuZ2VdKCNGb2xkaW5nUmFuZ2UpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBGb2xkaW5nUmFuZ2U7XHJcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9sZGluZ1JhbmdlIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcclxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIEZvbGRpbmdSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRm9sZGluZ1JhbmdlXSgjRm9sZGluZ1JhbmdlKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5udW1iZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5zdGFydExpbmUpXHJcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSB8fCBJcy5udW1iZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcclxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy5udW1iZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXHJcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xyXG4gICAgfVxyXG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XHJcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxyXG4gKiBbRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbl0oI0RpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24pIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xyXG4oZnVuY3Rpb24gKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uXSgjRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKTtcclxuICAgIH1cclxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcclxufSkoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiB8fCAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxyXG4gKi9cclxuZXhwb3J0IHZhciBEaWFnbm9zdGljU2V2ZXJpdHk7XHJcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlcG9ydHMgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxyXG4gICAgICovXHJcbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XHJcbiAgICAvKipcclxuICAgICAqIFJlcG9ydHMgYSBoaW50LlxyXG4gICAgICovXHJcbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XHJcbn0pKERpYWdub3N0aWNTZXZlcml0eSB8fCAoRGlhZ25vc3RpY1NldmVyaXR5ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxyXG4gKiBbRGlhZ25vc3RpY10oI0RpYWdub3N0aWMpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBEaWFnbm9zdGljO1xyXG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc2V2ZXJpdHkpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2RlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQocmVsYXRlZEluZm9ybWF0aW9uKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRGlhZ25vc3RpY10oI0RpYWdub3N0aWMpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKVxyXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXHJcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSlcclxuICAgICAgICAgICAgJiYgKElzLm51bWJlcihjYW5kaWRhdGUuc2V2ZXJpdHkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc2V2ZXJpdHkpKVxyXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZSkpXHJcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnNvdXJjZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zb3VyY2UpKVxyXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24pIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbiwgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcykpO1xyXG4gICAgfVxyXG4gICAgRGlhZ25vc3RpYy5pcyA9IGlzO1xyXG59KShEaWFnbm9zdGljIHx8IChEaWFnbm9zdGljID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBDb21tYW5kIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxyXG4gKiBbQ29tbWFuZF0oI0NvbW1hbmQpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb21tYW5kO1xyXG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb21tYW5kIGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlLCBjb21tYW5kOiBjb21tYW5kIH07XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcmd1bWVudHMgPSBhcmdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbQ29tbWFuZF0oI0NvbW1hbmQpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgQ29tbWFuZC5pcyA9IGlzO1xyXG59KShDb21tYW5kIHx8IChDb21tYW5kID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxyXG4gKiBpbnNlcnQgYW5kIGRlbGV0ZSBlZGl0cyBtb3JlIGVhc2lseS5cclxuICovXHJcbmV4cG9ydCB2YXIgVGV4dEVkaXQ7XHJcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxyXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxyXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiBuZXdUZXh0IH07XHJcbiAgICB9XHJcbiAgICBUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGluc2VydCB0ZXh0IGVkaXQuXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cclxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcclxuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xyXG4gICAgfVxyXG4gICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVsZXRlIHRleHQgZWRpdC5cclxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6ICcnIH07XHJcbiAgICB9XHJcbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXHJcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dClcclxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcclxuICAgIH1cclxuICAgIFRleHRFZGl0LmlzID0gaXM7XHJcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxyXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxyXG4gKi9cclxuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnRFZGl0O1xyXG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGV4dERvY3VtZW50RWRpdGBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcclxuICAgICAgICByZXR1cm4geyB0ZXh0RG9jdW1lbnQ6IHRleHREb2N1bWVudCwgZWRpdHM6IGVkaXRzIH07XHJcbiAgICB9XHJcbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcclxuICAgICAgICAgICAgJiYgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxyXG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5lZGl0cyk7XHJcbiAgICB9XHJcbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XHJcbn0pKFRleHREb2N1bWVudEVkaXQgfHwgKFRleHREb2N1bWVudEVkaXQgPSB7fSkpO1xyXG5leHBvcnQgdmFyIENyZWF0ZUZpbGU7XHJcbihmdW5jdGlvbiAoQ3JlYXRlRmlsZSkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIGtpbmQ6ICdjcmVhdGUnLFxyXG4gICAgICAgICAgICB1cmk6IHVyaVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHZvaWQgMCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB2b2lkIDApKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdm9pZCAwIHx8XHJcbiAgICAgICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB2b2lkIDAgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSk7XHJcbiAgICB9XHJcbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XHJcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFJlbmFtZUZpbGU7XHJcbihmdW5jdGlvbiAoUmVuYW1lRmlsZSkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAga2luZDogJ3JlbmFtZScsXHJcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxyXG4gICAgICAgICAgICBuZXdVcmk6IG5ld1VyaVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHZvaWQgMCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB2b2lkIDApKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIFJlbmFtZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlbmFtZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJlxyXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHZvaWQgMCB8fFxyXG4gICAgICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpO1xyXG4gICAgfVxyXG4gICAgUmVuYW1lRmlsZS5pcyA9IGlzO1xyXG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcclxuZXhwb3J0IHZhciBEZWxldGVGaWxlO1xyXG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcclxuICAgICAgICAgICAgdXJpOiB1cmlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB2b2lkIDAgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdm9pZCAwKSkge1xyXG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBEZWxldGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdkZWxldGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJlxyXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHZvaWQgMCB8fFxyXG4gICAgICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyA9PT0gdm9pZCAwIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMpKSkpO1xyXG4gICAgfVxyXG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xyXG59KShEZWxldGVGaWxlIHx8IChEZWxldGVGaWxlID0ge30pKTtcclxuZXhwb3J0IHZhciBXb3Jrc3BhY2VFZGl0O1xyXG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcclxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB2b2lkIDAgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdm9pZCAwKSAmJlxyXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyA9PT0gdm9pZCAwIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMuZXZlcnkoZnVuY3Rpb24gKGNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBXb3Jrc3BhY2VFZGl0LmlzID0gaXM7XHJcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xyXG52YXIgVGV4dEVkaXRDaGFuZ2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xyXG4gICAgfVxyXG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocG9zaXRpb24sIG5ld1RleHQpIHtcclxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KSk7XHJcbiAgICB9O1xyXG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCBuZXdUZXh0KSB7XHJcbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQpKTtcclxuICAgIH07XHJcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xyXG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChUZXh0RWRpdC5kZWwocmFuZ2UpKTtcclxuICAgIH07XHJcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XHJcbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xyXG4gICAgfTtcclxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRzO1xyXG4gICAgfTtcclxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0cy5zcGxpY2UoMCwgdGhpcy5lZGl0cy5sZW5ndGgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUZXh0RWRpdENoYW5nZUltcGw7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXHJcbiAqL1xyXG52YXIgV29ya3NwYWNlQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XHJcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gdGV4dEVkaXRDaGFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwod29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZSwgXCJlZGl0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIFtXb3Jrc3BhY2VFZGl0XSgjV29ya3NwYWNlRWRpdCkgbGl0ZXJhbFxyXG4gICAgICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZ2V0VGV4dEVkaXRDaGFuZ2UgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dvcmtzcGFjZUVkaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnQgPSBrZXk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnRFZGl0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRzOiBlZGl0c1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl93b3Jrc3BhY2VFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IE9iamVjdC5jcmVhdGUobnVsbClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRG9jdW1lbnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpKTtcclxuICAgIH07XHJcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLnJlbmFtZUZpbGUgPSBmdW5jdGlvbiAob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRG9jdW1lbnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucykpO1xyXG4gICAgfTtcclxuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZGVsZXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRG9jdW1lbnRDaGFuZ2VzKCk7XHJcbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpKTtcclxuICAgIH07XHJcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmNoZWNrRG9jdW1lbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fd29ya3NwYWNlRWRpdCB8fCAhdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdvcmtzcGFjZUNoYW5nZTtcclxufSgpKTtcclxuZXhwb3J0IHsgV29ya3NwYWNlQ2hhbmdlIH07XHJcbi8qKlxyXG4gKiBUaGUgVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW1RleHREb2N1bWVudElkZW50aWZpZXJdKCNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcclxuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxyXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcclxuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSB9O1xyXG4gICAgfVxyXG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbVGV4dERvY3VtZW50SWRlbnRpZmllcl0oI1RleHREb2N1bWVudElkZW50aWZpZXIpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XHJcbiAgICB9XHJcbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XHJcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikgbGl0ZXJhbHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XHJcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cclxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxyXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHZlcnNpb246IHZlcnNpb24gfTtcclxuICAgIH1cclxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJdKCNWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5udW1iZXIoY2FuZGlkYXRlLnZlcnNpb24pKTtcclxuICAgIH1cclxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcclxufSkoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW1RleHREb2N1bWVudEl0ZW1dKCNUZXh0RG9jdW1lbnRJdGVtKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SXRlbTtcclxuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SXRlbSBsaXRlcmFsLlxyXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxyXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcclxuICAgIH1cclxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1RleHREb2N1bWVudEl0ZW1dKCNUZXh0RG9jdW1lbnRJdGVtKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xyXG4gICAgfVxyXG4gICAgVGV4dERvY3VtZW50SXRlbS5pcyA9IGlzO1xyXG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgY29udGVudCB0eXBlIHRoYXQgYSBjbGllbnQgc3VwcG9ydHMgaW4gdmFyaW91c1xyXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cclxuICpcclxuICogUGxlYXNlIG5vdGUgdGhhdCBgTWFya3VwS2luZHNgIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBgJGAuIFRoaXMga2luZHNcclxuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cclxuICovXHJcbmV4cG9ydCB2YXIgTWFya3VwS2luZDtcclxuKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XHJcbiAgICAvKipcclxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcclxuICAgIC8qKlxyXG4gICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XHJcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xyXG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIFtNYXJrdXBLaW5kXSgjTWFya3VwS2luZCkgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xyXG4gICAgfVxyXG4gICAgTWFya3VwS2luZC5pcyA9IGlzO1xyXG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcclxuZXhwb3J0IHZhciBNYXJrdXBDb250ZW50O1xyXG4oZnVuY3Rpb24gKE1hcmt1cENvbnRlbnQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSBbTWFya3VwQ29udGVudF0oI01hcmt1cENvbnRlbnQpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgTWFya3VwQ29udGVudC5pcyA9IGlzO1xyXG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBraW5kIG9mIGEgY29tcGxldGlvbiBlbnRyeS5cclxuICovXHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlRleHQgPSAxO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0cnVjdG9yID0gNDtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzID0gNztcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHkgPSAxMDtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtID0gMTM7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db2xvciA9IDE2O1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5Gb2xkZXIgPSAxOTtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5TdHJ1Y3QgPSAyMjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlciA9IDI1O1xyXG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIHdoZXRoZXIgdGhlIGluc2VydCB0ZXh0IGluIGEgY29tcGxldGlvbiBpdGVtIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhc1xyXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cclxuICovXHJcbmV4cG9ydCB2YXIgSW5zZXJ0VGV4dEZvcm1hdDtcclxuKGZ1bmN0aW9uIChJbnNlcnRUZXh0Rm9ybWF0KSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBzbmlwcGV0LlxyXG4gICAgICpcclxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxyXG4gICAgICogYW5kIGAkezM6Zm9vfWAuIGAkMGAgZGVmaW5lcyB0aGUgZmluYWwgdGFiIHN0b3AsIGl0IGRlZmF1bHRzIHRvXHJcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxyXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXHJcbiAgICAgKlxyXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvdnNjb2RlL2Jsb2IvbWFzdGVyL3NyYy92cy9lZGl0b3IvY29udHJpYi9zbmlwcGV0L2NvbW1vbi9zbmlwcGV0Lm1kXHJcbiAgICAgKi9cclxuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XHJcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXHJcbiAqIGNvbXBsZXRpb24gaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xyXG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBsYWJlbCB9O1xyXG4gICAgfVxyXG4gICAgQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xyXG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIENvbXBsZXRpb25MaXN0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXHJcbiAqIGNvbXBsZXRpb24gbGlzdHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIENvbXBsZXRpb25MaXN0O1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25MaXN0KSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cclxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcclxuICAgIH1cclxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcclxufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcclxuZXhwb3J0IHZhciBNYXJrZWRTdHJpbmc7XHJcbihmdW5jdGlvbiAoTWFya2VkU3RyaW5nKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXJrZWQgc3RyaW5nIGZyb20gcGxhaW4gdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tUGxhaW5UZXh0KHBsYWluVGV4dCkge1xyXG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csIFwiXFxcXCQmXCIpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXHJcbiAgICB9XHJcbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUgW01hcmtlZFN0cmluZ10oI01hcmtlZFN0cmluZykgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgTWFya2VkU3RyaW5nLmlzID0gaXM7XHJcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcclxuZXhwb3J0IHZhciBIb3ZlcjtcclxuKGZ1bmN0aW9uIChIb3Zlcikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIFtIb3Zlcl0oI0hvdmVyKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxyXG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxyXG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB2b2lkIDAgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcclxuICAgIH1cclxuICAgIEhvdmVyLmlzID0gaXM7XHJcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtQYXJhbWV0ZXJJbmZvcm1hdGlvbl0oI1BhcmFtZXRlckluZm9ybWF0aW9uKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XHJcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgQSBsYWJlbCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XHJcbiAgICB9XHJcbiAgICBQYXJhbWV0ZXJJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICA7XHJcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgU2lnbmF0dXJlSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtTaWduYXR1cmVJbmZvcm1hdGlvbl0oI1NpZ25hdHVyZUluZm9ybWF0aW9uKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgU2lnbmF0dXJlSW5mb3JtYXRpb247XHJcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xyXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcGFyYW1ldGVyc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmRvY3VtZW50YXRpb24gPSBkb2N1bWVudGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xyXG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xyXG4vKipcclxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cclxuICovXHJcbmV4cG9ydCB2YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xyXG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cclxuICAgICAqL1xyXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cclxuICAgICAqL1xyXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLldyaXRlID0gMztcclxufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xyXG4vKipcclxuICogRG9jdW1lbnRIaWdobGlnaHQgbmFtZXNwYWNlIHRvIHByb3ZpZGUgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW0RvY3VtZW50SGlnaGxpZ2h0XSgjRG9jdW1lbnRIaWdobGlnaHQpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodDtcclxuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBEb2N1bWVudEhpZ2hsaWdodCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XHJcbiAgICAgICAgaWYgKElzLm51bWJlcihraW5kKSkge1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKERvY3VtZW50SGlnaGxpZ2h0IHx8IChEb2N1bWVudEhpZ2hsaWdodCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHN5bWJvbCBraW5kLlxyXG4gKi9cclxuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xyXG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcclxuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XHJcbiAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XHJcbiAgICBTeW1ib2xLaW5kLk5hbWVzcGFjZSA9IDM7XHJcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xyXG4gICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XHJcbiAgICBTeW1ib2xLaW5kLk1ldGhvZCA9IDY7XHJcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcclxuICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xyXG4gICAgU3ltYm9sS2luZC5Db25zdHJ1Y3RvciA9IDk7XHJcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcclxuICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XHJcbiAgICBTeW1ib2xLaW5kLkZ1bmN0aW9uID0gMTI7XHJcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XHJcbiAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XHJcbiAgICBTeW1ib2xLaW5kLlN0cmluZyA9IDE1O1xyXG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcclxuICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xyXG4gICAgU3ltYm9sS2luZC5BcnJheSA9IDE4O1xyXG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcclxuICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XHJcbiAgICBTeW1ib2xLaW5kLk51bGwgPSAyMTtcclxuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xyXG4gICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcclxuICAgIFN5bWJvbEtpbmQuRXZlbnQgPSAyNDtcclxuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcclxuICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xyXG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcclxuZXhwb3J0IHZhciBTeW1ib2xJbmZvcm1hdGlvbjtcclxuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXHJcbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cclxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wsIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50LlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lck5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBjb250YWluaW5nIHRoZSBzeW1ib2wuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAga2luZDoga2luZCxcclxuICAgICAgICAgICAgbG9jYXRpb246IHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XHJcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHByb2dyYW1taW5nIGNvbnN0cnVjdHMgbGlrZSB2YXJpYWJsZXMsIGNsYXNzZXMsIGludGVyZmFjZXMgZXRjLlxyXG4gKiB0aGF0IGFwcGVhciBpbiBhIGRvY3VtZW50LiBEb2N1bWVudCBzeW1ib2xzIGNhbiBiZSBoaWVyYXJjaGljYWwgYW5kIHRoZXlcclxuICogaGF2ZSB0d28gcmFuZ2VzOiBvbmUgdGhhdCBlbmNsb3NlcyBpdHMgZGVmaW5pdGlvbiBhbmQgb25lIHRoYXQgcG9pbnRzIHRvXHJcbiAqIGl0cyBtb3N0IGludGVyZXN0aW5nIHJhbmdlLCBlLmcuIHRoZSByYW5nZSBvZiBhbiBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIERvY3VtZW50U3ltYm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRTeW1ib2woKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRG9jdW1lbnRTeW1ib2w7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERvY3VtZW50U3ltYm9sIH07XHJcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIGRldGFpbCBUaGUgZGV0YWlsIG9mIHRoZSBzeW1ib2wuXHJcbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblJhbmdlIFRoZSBzZWxlY3Rpb25SYW5nZSBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBkZXRhaWwsIGtpbmQsIHJhbmdlLCBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW4pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcclxuICAgICAgICAgICAga2luZDoga2luZCxcclxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZTogc2VsZWN0aW9uUmFuZ2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0RvY3VtZW50U3ltYm9sXSgjRG9jdW1lbnRTeW1ib2wpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxyXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcclxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB2b2lkIDAgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxyXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHZvaWQgMCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcclxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xyXG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xyXG4vKipcclxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xyXG4gKi9cclxuZXhwb3J0IHZhciBDb2RlQWN0aW9uS2luZDtcclxuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcclxuICAgICAqL1xyXG4gICAgQ29kZUFjdGlvbktpbmQuUXVpY2tGaXggPSAncXVpY2tmaXgnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcclxuICAgICAqL1xyXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGV4dHJhY3Rpb24gYWN0aW9uczogJ3JlZmFjdG9yLmV4dHJhY3QnXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxyXG4gICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXHJcbiAgICAgKiAtIEV4dHJhY3QgdmFyaWFibGVcclxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xyXG4gICAgICogLSAuLi5cclxuICAgICAqL1xyXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGlubGluZSBhY3Rpb25zOiAncmVmYWN0b3IuaW5saW5lJ1xyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cclxuICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXHJcbiAgICAgKiAtIElubGluZSBjb25zdGFudFxyXG4gICAgICogLSAuLi5cclxuICAgICAqL1xyXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUgPSAncmVmYWN0b3IuaW5saW5lJztcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxyXG4gICAgICpcclxuICAgICAqIC0gQ29udmVydCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIGNsYXNzXHJcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXHJcbiAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXHJcbiAgICAgKiAtIE1ha2UgbWV0aG9kIHN0YXRpY1xyXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXHJcbiAgICAgKiAtIC4uLlxyXG4gICAgICovXHJcbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2Uga2luZCBmb3Igc291cmNlIGFjdGlvbnM6IGBzb3VyY2VgXHJcbiAgICAgKlxyXG4gICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGFuIG9yZ2FuaXplIGltcG9ydHMgc291cmNlIGFjdGlvbjogYHNvdXJjZS5vcmdhbml6ZUltcG9ydHNgXHJcbiAgICAgKi9cclxuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcclxufSkoQ29kZUFjdGlvbktpbmQgfHwgKENvZGVBY3Rpb25LaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBDb2RlQWN0aW9uQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW0NvZGVBY3Rpb25Db250ZXh0XSgjQ29kZUFjdGlvbkNvbnRleHQpIGxpdGVyYWxzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb2RlQWN0aW9uQ29udGV4dDtcclxuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7IGRpYWdub3N0aWNzOiBkaWFnbm9zdGljcyB9O1xyXG4gICAgICAgIGlmIChvbmx5ICE9PSB2b2lkIDAgJiYgb25seSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQub25seSA9IG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbQ29kZUFjdGlvbkNvbnRleHRdKCNDb2RlQWN0aW9uQ29udGV4dCkgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSAmJiAoY2FuZGlkYXRlLm9ubHkgPT09IHZvaWQgMCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5vbmx5LCBJcy5zdHJpbmcpKTtcclxuICAgIH1cclxuICAgIENvZGVBY3Rpb25Db250ZXh0LmlzID0gaXM7XHJcbn0pKENvZGVBY3Rpb25Db250ZXh0IHx8IChDb2RlQWN0aW9uQ29udGV4dCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29kZUFjdGlvbjtcclxuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XHJcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmRPckVkaXQsIGtpbmQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUgfTtcclxuICAgICAgICBpZiAoQ29tbWFuZC5pcyhjb21tYW5kT3JFZGl0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGNvbW1hbmRPckVkaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGNvbW1hbmRPckVkaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChraW5kICE9PSB2b2lkIG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHZvaWQgMCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUua2luZCA9PT0gdm9pZCAwIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdm9pZCAwIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB2b2lkIDApICYmXHJcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdm9pZCAwIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxyXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHZvaWQgMCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XHJcbiAgICB9XHJcbiAgICBDb2RlQWN0aW9uLmlzID0gaXM7XHJcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIENvZGVMZW5zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxyXG4gKiBbQ29kZUxlbnNdKCNDb2RlTGVucykgbGl0ZXJhbHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIENvZGVMZW5zO1xyXG4oZnVuY3Rpb24gKENvZGVMZW5zKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUxlbnMgbGl0ZXJhbC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XHJcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpXHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgQ29kZUxlbnMuY3JlYXRlID0gY3JlYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvZGVMZW5zXSgjQ29kZUxlbnMpIGludGVyZmFjZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcclxuICAgIH1cclxuICAgIENvZGVMZW5zLmlzID0gaXM7XHJcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXHJcbiAqIFtGb3JtYXR0aW5nT3B0aW9uc10oI0Zvcm1hdHRpbmdPcHRpb25zKSBsaXRlcmFscy5cclxuICovXHJcbmV4cG9ydCB2YXIgRm9ybWF0dGluZ09wdGlvbnM7XHJcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUodGFiU2l6ZSwgaW5zZXJ0U3BhY2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZTogdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzOiBpbnNlcnRTcGFjZXMgfTtcclxuICAgIH1cclxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtGb3JtYXR0aW5nT3B0aW9uc10oI0Zvcm1hdHRpbmdPcHRpb25zKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xyXG4gICAgfVxyXG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcclxufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcclxuLyoqXHJcbiAqIEEgZG9jdW1lbnQgbGluayBpcyBhIHJhbmdlIGluIGEgdGV4dCBkb2N1bWVudCB0aGF0IGxpbmtzIHRvIGFuIGludGVybmFsIG9yIGV4dGVybmFsIHJlc291cmNlLCBsaWtlIGFub3RoZXJcclxuICogdGV4dCBkb2N1bWVudCBvciBhIHdlYiBzaXRlLlxyXG4gKi9cclxudmFyIERvY3VtZW50TGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvY3VtZW50TGluaygpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBEb2N1bWVudExpbms7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IERvY3VtZW50TGluayB9O1xyXG4vKipcclxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcclxuICogW0RvY3VtZW50TGlua10oI0RvY3VtZW50TGluaykgbGl0ZXJhbHMuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKERvY3VtZW50TGluaykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdGFyZ2V0OiB0YXJnZXQsIGRhdGE6IGRhdGEgfTtcclxuICAgIH1cclxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRG9jdW1lbnRMaW5rXSgjRG9jdW1lbnRMaW5rKSBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XHJcbiAgICB9XHJcbiAgICBEb2N1bWVudExpbmsuaXMgPSBpcztcclxufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xyXG5leHBvcnQgdmFyIEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcclxuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XHJcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cclxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtJVGV4dERvY3VtZW50XSgjSVRleHREb2N1bWVudCkgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmxpbmVDb3VudClcclxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgVGV4dERvY3VtZW50LmlzID0gaXM7XHJcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xyXG4gICAgICAgIHZhciBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cywgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XHJcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gc29ydGVkRWRpdHNbaV07XHJcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0IDw9IGxhc3RNb2RpZmllZE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVsYXBwaW5nIGVkaXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XHJcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHNvcnRlZFxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xyXG4gICAgICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XHJcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xyXG4gICAgICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XHJcbiAgICAgICAgdmFyIGxlZnRJZHggPSAwO1xyXG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcclxuICAgICAgICAgICAgaWYgKHJldCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFRleHREb2N1bWVudFNhdmVSZWFzb247XHJcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW51YWxseSB0cmlnZ2VyZWQsIGUuZy4gYnkgdGhlIHVzZXIgcHJlc3Npbmcgc2F2ZSwgYnkgc3RhcnRpbmcgZGVidWdnaW5nLFxyXG4gICAgICogb3IgYnkgYW4gQVBJIGNhbGwuXHJcbiAgICAgKi9cclxuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uTWFudWFsID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXHJcbiAgICAgKi9cclxuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uQWZ0ZXJEZWxheSA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdGhlIGVkaXRvciBsb3N0IGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcclxufSkoVGV4dERvY3VtZW50U2F2ZVJlYXNvbiB8fCAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XHJcbnZhciBGdWxsVGV4dERvY3VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcclxuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XHJcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cmk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VJZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInZlcnNpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcclxuICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGV2ZW50LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5lT2Zmc2V0cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9jb250ZW50O1xyXG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSAoY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFxuJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQXQoaSArIDEpID09PSAnXFxuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5wdXNoKHRleHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU9mZnNldHM7XHJcbiAgICB9O1xyXG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XHJcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xyXG4gICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChoaWdoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsb3cgaXMgdGhlIGxlYXN0IHggZm9yIHdoaWNoIHRoZSBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcclxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsb3cgLSAxO1xyXG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUobGluZSwgb2Zmc2V0IC0gbGluZU9mZnNldHNbbGluZV0pO1xyXG4gICAgfTtcclxuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xyXG4gICAgICAgIHZhciBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGluZUNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcclxufSgpKTtcclxudmFyIElzO1xyXG4oZnVuY3Rpb24gKElzKSB7XHJcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgfVxyXG4gICAgSXMuZGVmaW5lZCA9IGRlZmluZWQ7XHJcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxuICAgIH1cclxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIGZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgSXMuYm9vbGVhbiA9IGJvb2xlYW47XHJcbiAgICBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xyXG4gICAgfVxyXG4gICAgSXMuc3RyaW5nID0gc3RyaW5nO1xyXG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxuICAgIH1cclxuICAgIElzLm51bWJlciA9IG51bWJlcjtcclxuICAgIGZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcbiAgICB9XHJcbiAgICBJcy5mdW5jID0gZnVuYztcclxuICAgIGZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcclxuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcclxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xyXG4gICAgICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xyXG4gICAgfVxyXG4gICAgSXMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XHJcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShjaGVjayk7XHJcbiAgICB9XHJcbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcclxufSkoSXMgfHwgKElzID0ge30pKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vscode-languageserver-types/lib/esm/main.js\n");

/***/ }),

/***/ "./node_modules/yauzl/index.js":
/*!*************************************!*\
  !*** ./node_modules/yauzl/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar fd_slicer = __webpack_require__(/*! fd-slicer */ \"./node_modules/fd-slicer/index.js\");\nvar crc32 = __webpack_require__(/*! buffer-crc32 */ \"./node_modules/buffer-crc32/index.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Transform = __webpack_require__(/*! stream */ \"stream\").Transform;\nvar PassThrough = __webpack_require__(/*! stream */ \"stream\").PassThrough;\nvar Writable = __webpack_require__(/*! stream */ \"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      }\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)\n                                  : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          }\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self._readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n  this._readEntry();\n};\nZipFile.prototype._readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n\n    self.readEntryCursor += 46;\n\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)\n                                          : buffer.slice(0, entry.fileNameLength);\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);\n      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n      entry.comment = entry.fileComment;\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            }\n            // Version       1 byte      version of this extra field, currently 1\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            }\n            // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            }\n            // UnicodeName   Variable    UTF-8 version of the entry File Name\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      }\n\n      // validate file size\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, options, callback) {\n  var self = this;\n  // parameter validation\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  }\n  // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  }\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      }\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd,\n      });\n      var endpointStream = readStream;\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function(err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function() {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        }\n        // this is part of yauzl's API, so implement this function on the client-visible stream\n        endpointStream.destroy = function() {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\nEntry.prototype.isEncrypted = function() {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\nEntry.prototype.isCompressed = function() {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  }\n  // all good\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, newBuffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000 !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\n// Node 10 deprecated new Buffer().\nvar newBuffer;\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function(len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function(len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWF1emwvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIi4uLy4vbm9kZV9tb2R1bGVzL3lhdXpsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbnZhciB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG52YXIgZmRfc2xpY2VyID0gcmVxdWlyZShcImZkLXNsaWNlclwiKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoXCJidWZmZXItY3JjMzJcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZShcInN0cmVhbVwiKS5QYXNzVGhyb3VnaDtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuV3JpdGFibGU7XG5cbmV4cG9ydHMub3BlbiA9IG9wZW47XG5leHBvcnRzLmZyb21GZCA9IGZyb21GZDtcbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IGZyb21CdWZmZXI7XG5leHBvcnRzLmZyb21SYW5kb21BY2Nlc3NSZWFkZXIgPSBmcm9tUmFuZG9tQWNjZXNzUmVhZGVyO1xuZXhwb3J0cy5kb3NEYXRlVGltZVRvRGF0ZSA9IGRvc0RhdGVUaW1lVG9EYXRlO1xuZXhwb3J0cy52YWxpZGF0ZUZpbGVOYW1lID0gdmFsaWRhdGVGaWxlTmFtZTtcbmV4cG9ydHMuWmlwRmlsZSA9IFppcEZpbGU7XG5leHBvcnRzLkVudHJ5ID0gRW50cnk7XG5leHBvcnRzLlJhbmRvbUFjY2Vzc1JlYWRlciA9IFJhbmRvbUFjY2Vzc1JlYWRlcjtcblxuZnVuY3Rpb24gb3BlbihwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsKSBvcHRpb25zID0ge307XG4gIGlmIChvcHRpb25zLmF1dG9DbG9zZSA9PSBudWxsKSBvcHRpb25zLmF1dG9DbG9zZSA9IHRydWU7XG4gIGlmIChvcHRpb25zLmxhenlFbnRyaWVzID09IG51bGwpIG9wdGlvbnMubGF6eUVudHJpZXMgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PSBudWxsKSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPSB0cnVlO1xuICBpZiAob3B0aW9ucy52YWxpZGF0ZUVudHJ5U2l6ZXMgPT0gbnVsbCkgb3B0aW9ucy52YWxpZGF0ZUVudHJ5U2l6ZXMgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5zdHJpY3RGaWxlTmFtZXMgPT0gbnVsbCkgb3B0aW9ucy5zdHJpY3RGaWxlTmFtZXMgPSBmYWxzZTtcbiAgaWYgKGNhbGxiYWNrID09IG51bGwpIGNhbGxiYWNrID0gZGVmYXVsdENhbGxiYWNrO1xuICBmcy5vcGVuKHBhdGgsIFwiclwiLCBmdW5jdGlvbihlcnIsIGZkKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgZnJvbUZkKGZkLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHppcGZpbGUpIHtcbiAgICAgIGlmIChlcnIpIGZzLmNsb3NlKGZkLCBkZWZhdWx0Q2FsbGJhY2spO1xuICAgICAgY2FsbGJhY2soZXJyLCB6aXBmaWxlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZyb21GZChmZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkgb3B0aW9ucyA9IHt9O1xuICBpZiAob3B0aW9ucy5hdXRvQ2xvc2UgPT0gbnVsbCkgb3B0aW9ucy5hdXRvQ2xvc2UgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMubGF6eUVudHJpZXMgPT0gbnVsbCkgb3B0aW9ucy5sYXp5RW50cmllcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5kZWNvZGVTdHJpbmdzID09IG51bGwpIG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9PSBudWxsKSBvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9PSBudWxsKSBvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9IGZhbHNlO1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgY2FsbGJhY2sgPSBkZWZhdWx0Q2FsbGJhY2s7XG4gIGZzLmZzdGF0KGZkLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgdmFyIHJlYWRlciA9IGZkX3NsaWNlci5jcmVhdGVGcm9tRmQoZmQsIHthdXRvQ2xvc2U6IHRydWV9KTtcbiAgICBmcm9tUmFuZG9tQWNjZXNzUmVhZGVyKHJlYWRlciwgc3RhdHMuc2l6ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIG9wdGlvbnMgPSB7fTtcbiAgb3B0aW9ucy5hdXRvQ2xvc2UgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMubGF6eUVudHJpZXMgPT0gbnVsbCkgb3B0aW9ucy5sYXp5RW50cmllcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5kZWNvZGVTdHJpbmdzID09IG51bGwpIG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9PSBudWxsKSBvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9PSBudWxsKSBvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9IGZhbHNlO1xuICAvLyBsaW1pdCB0aGUgbWF4IGNodW5rIHNpemUuIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGhlam9zaHdvbGZlL3lhdXpsL2lzc3Vlcy84N1xuICB2YXIgcmVhZGVyID0gZmRfc2xpY2VyLmNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCB7bWF4Q2h1bmtTaXplOiAweDEwMDAwfSk7XG4gIGZyb21SYW5kb21BY2Nlc3NSZWFkZXIocmVhZGVyLCBidWZmZXIubGVuZ3RoLCBvcHRpb25zLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZyb21SYW5kb21BY2Nlc3NSZWFkZXIocmVhZGVyLCB0b3RhbFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIG9wdGlvbnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMuYXV0b0Nsb3NlID09IG51bGwpIG9wdGlvbnMuYXV0b0Nsb3NlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMubGF6eUVudHJpZXMgPT0gbnVsbCkgb3B0aW9ucy5sYXp5RW50cmllcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5kZWNvZGVTdHJpbmdzID09IG51bGwpIG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9IHRydWU7XG4gIHZhciBkZWNvZGVTdHJpbmdzID0gISFvcHRpb25zLmRlY29kZVN0cmluZ3M7XG4gIGlmIChvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9PSBudWxsKSBvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcyA9IHRydWU7XG4gIGlmIChvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9PSBudWxsKSBvcHRpb25zLnN0cmljdEZpbGVOYW1lcyA9IGZhbHNlO1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgY2FsbGJhY2sgPSBkZWZhdWx0Q2FsbGJhY2s7XG4gIGlmICh0eXBlb2YgdG90YWxTaXplICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCB0b3RhbFNpemUgcGFyYW1ldGVyIHRvIGJlIGEgbnVtYmVyXCIpO1xuICBpZiAodG90YWxTaXplID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6aXAgZmlsZSB0b28gbGFyZ2UuIG9ubHkgZmlsZSBzaXplcyB1cCB0byAyXjUyIGFyZSBzdXBwb3J0ZWQgZHVlIHRvIEphdmFTY3JpcHQncyBOdW1iZXIgdHlwZSBiZWluZyBhbiBJRUVFIDc1NCBkb3VibGUuXCIpO1xuICB9XG5cbiAgLy8gdGhlIG1hdGNoaW5nIHVucmVmKCkgY2FsbCBpcyBpbiB6aXBmaWxlLmNsb3NlKClcbiAgcmVhZGVyLnJlZigpO1xuXG4gIC8vIGVvY2RyIG1lYW5zIEVuZCBvZiBDZW50cmFsIERpcmVjdG9yeSBSZWNvcmQuXG4gIC8vIHNlYXJjaCBiYWNrd2FyZHMgZm9yIHRoZSBlb2NkciBzaWduYXR1cmUuXG4gIC8vIHRoZSBsYXN0IGZpZWxkIG9mIHRoZSBlb2NkciBpcyBhIHZhcmlhYmxlLWxlbmd0aCBjb21tZW50LlxuICAvLyB0aGUgY29tbWVudCBzaXplIGlzIGVuY29kZWQgaW4gYSAyLWJ5dGUgZmllbGQgaW4gdGhlIGVvY2RyLCB3aGljaCB3ZSBjYW4ndCBmaW5kIHdpdGhvdXQgdHJ1ZGdpbmcgYmFja3dhcmRzIHRocm91Z2ggdGhlIGNvbW1lbnQgdG8gZmluZCBpdC5cbiAgLy8gYXMgYSBjb25zZXF1ZW5jZSBvZiB0aGlzIGRlc2lnbiBkZWNpc2lvbiwgaXQncyBwb3NzaWJsZSB0byBoYXZlIGFtYmlndW91cyB6aXAgZmlsZSBtZXRhZGF0YSBpZiBhIGNvaGVyZW50IGVvY2RyIHdhcyBpbiB0aGUgY29tbWVudC5cbiAgLy8gd2Ugc2VhcmNoIGJhY2t3YXJkcyBmb3IgYSBlb2NkciBzaWduYXR1cmUsIGFuZCBob3BlIHRoYXQgd2hvZXZlciBtYWRlIHRoZSB6aXAgZmlsZSB3YXMgc21hcnQgZW5vdWdoIHRvIGZvcmJpZCB0aGUgZW9jZHIgc2lnbmF0dXJlIGluIHRoZSBjb21tZW50LlxuICB2YXIgZW9jZHJXaXRob3V0Q29tbWVudFNpemUgPSAyMjtcbiAgdmFyIG1heENvbW1lbnRTaXplID0gMHhmZmZmOyAvLyAyLWJ5dGUgc2l6ZVxuICB2YXIgYnVmZmVyU2l6ZSA9IE1hdGgubWluKGVvY2RyV2l0aG91dENvbW1lbnRTaXplICsgbWF4Q29tbWVudFNpemUsIHRvdGFsU2l6ZSk7XG4gIHZhciBidWZmZXIgPSBuZXdCdWZmZXIoYnVmZmVyU2l6ZSk7XG4gIHZhciBidWZmZXJSZWFkU3RhcnQgPSB0b3RhbFNpemUgLSBidWZmZXIubGVuZ3RoO1xuICByZWFkQW5kQXNzZXJ0Tm9Fb2YocmVhZGVyLCBidWZmZXIsIDAsIGJ1ZmZlclNpemUsIGJ1ZmZlclJlYWRTdGFydCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgZm9yICh2YXIgaSA9IGJ1ZmZlclNpemUgLSBlb2NkcldpdGhvdXRDb21tZW50U2l6ZTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChidWZmZXIucmVhZFVJbnQzMkxFKGkpICE9PSAweDA2MDU0YjUwKSBjb250aW51ZTtcbiAgICAgIC8vIGZvdW5kIGVvY2RyXG4gICAgICB2YXIgZW9jZHJCdWZmZXIgPSBidWZmZXIuc2xpY2UoaSk7XG5cbiAgICAgIC8vIDAgLSBFbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgc2lnbmF0dXJlID0gMHgwNjA1NGI1MFxuICAgICAgLy8gNCAtIE51bWJlciBvZiB0aGlzIGRpc2tcbiAgICAgIHZhciBkaXNrTnVtYmVyID0gZW9jZHJCdWZmZXIucmVhZFVJbnQxNkxFKDQpO1xuICAgICAgaWYgKGRpc2tOdW1iZXIgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIm11bHRpLWRpc2sgemlwIGZpbGVzIGFyZSBub3Qgc3VwcG9ydGVkOiBmb3VuZCBkaXNrIG51bWJlcjogXCIgKyBkaXNrTnVtYmVyKSk7XG4gICAgICB9XG4gICAgICAvLyA2IC0gRGlzayB3aGVyZSBjZW50cmFsIGRpcmVjdG9yeSBzdGFydHNcbiAgICAgIC8vIDggLSBOdW1iZXIgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkcyBvbiB0aGlzIGRpc2tcbiAgICAgIC8vIDEwIC0gVG90YWwgbnVtYmVyIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZHNcbiAgICAgIHZhciBlbnRyeUNvdW50ID0gZW9jZHJCdWZmZXIucmVhZFVJbnQxNkxFKDEwKTtcbiAgICAgIC8vIDEyIC0gU2l6ZSBvZiBjZW50cmFsIGRpcmVjdG9yeSAoYnl0ZXMpXG4gICAgICAvLyAxNiAtIE9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSwgcmVsYXRpdmUgdG8gc3RhcnQgb2YgYXJjaGl2ZVxuICAgICAgdmFyIGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQgPSBlb2NkckJ1ZmZlci5yZWFkVUludDMyTEUoMTYpO1xuICAgICAgLy8gMjAgLSBDb21tZW50IGxlbmd0aFxuICAgICAgdmFyIGNvbW1lbnRMZW5ndGggPSBlb2NkckJ1ZmZlci5yZWFkVUludDE2TEUoMjApO1xuICAgICAgdmFyIGV4cGVjdGVkQ29tbWVudExlbmd0aCA9IGVvY2RyQnVmZmVyLmxlbmd0aCAtIGVvY2RyV2l0aG91dENvbW1lbnRTaXplO1xuICAgICAgaWYgKGNvbW1lbnRMZW5ndGggIT09IGV4cGVjdGVkQ29tbWVudExlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiaW52YWxpZCBjb21tZW50IGxlbmd0aC4gZXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWRDb21tZW50TGVuZ3RoICsgXCIuIGZvdW5kOiBcIiArIGNvbW1lbnRMZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIC8vIDIyIC0gQ29tbWVudFxuICAgICAgLy8gdGhlIGVuY29kaW5nIGlzIGFsd2F5cyBjcDQzNy5cbiAgICAgIHZhciBjb21tZW50ID0gZGVjb2RlU3RyaW5ncyA/IGRlY29kZUJ1ZmZlcihlb2NkckJ1ZmZlciwgMjIsIGVvY2RyQnVmZmVyLmxlbmd0aCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlb2NkckJ1ZmZlci5zbGljZSgyMik7XG5cbiAgICAgIGlmICghKGVudHJ5Q291bnQgPT09IDB4ZmZmZiB8fCBjZW50cmFsRGlyZWN0b3J5T2Zmc2V0ID09PSAweGZmZmZmZmZmKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV3IFppcEZpbGUocmVhZGVyLCBjZW50cmFsRGlyZWN0b3J5T2Zmc2V0LCB0b3RhbFNpemUsIGVudHJ5Q291bnQsIGNvbW1lbnQsIG9wdGlvbnMuYXV0b0Nsb3NlLCBvcHRpb25zLmxhenlFbnRyaWVzLCBkZWNvZGVTdHJpbmdzLCBvcHRpb25zLnZhbGlkYXRlRW50cnlTaXplcywgb3B0aW9ucy5zdHJpY3RGaWxlTmFtZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gWklQNjQgZm9ybWF0XG5cbiAgICAgIC8vIFpJUDY0IFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXG4gICAgICB2YXIgemlwNjRFb2NkbEJ1ZmZlciA9IG5ld0J1ZmZlcigyMCk7XG4gICAgICB2YXIgemlwNjRFb2NkbE9mZnNldCA9IGJ1ZmZlclJlYWRTdGFydCArIGkgLSB6aXA2NEVvY2RsQnVmZmVyLmxlbmd0aDtcbiAgICAgIHJlYWRBbmRBc3NlcnROb0VvZihyZWFkZXIsIHppcDY0RW9jZGxCdWZmZXIsIDAsIHppcDY0RW9jZGxCdWZmZXIubGVuZ3RoLCB6aXA2NEVvY2RsT2Zmc2V0LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgLy8gMCAtIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpciBsb2NhdG9yIHNpZ25hdHVyZSA9IDB4MDcwNjRiNTBcbiAgICAgICAgaWYgKHppcDY0RW9jZGxCdWZmZXIucmVhZFVJbnQzMkxFKDApICE9PSAweDA3MDY0YjUwKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImludmFsaWQgemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3Igc2lnbmF0dXJlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA0IC0gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgLy8gOCAtIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFxuICAgICAgICB2YXIgemlwNjRFb2Nkck9mZnNldCA9IHJlYWRVSW50NjRMRSh6aXA2NEVvY2RsQnVmZmVyLCA4KTtcbiAgICAgICAgLy8gMTYgLSB0b3RhbCBudW1iZXIgb2YgZGlza3NcblxuICAgICAgICAvLyBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXG4gICAgICAgIHZhciB6aXA2NEVvY2RyQnVmZmVyID0gbmV3QnVmZmVyKDU2KTtcbiAgICAgICAgcmVhZEFuZEFzc2VydE5vRW9mKHJlYWRlciwgemlwNjRFb2NkckJ1ZmZlciwgMCwgemlwNjRFb2NkckJ1ZmZlci5sZW5ndGgsIHppcDY0RW9jZHJPZmZzZXQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgICAgLy8gMCAtIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmUgICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzICAoMHgwNjA2NGI1MClcbiAgICAgICAgICBpZiAoemlwNjRFb2NkckJ1ZmZlci5yZWFkVUludDMyTEUoMCkgIT09IDB4MDYwNjRiNTApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJpbnZhbGlkIHppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgc2lnbmF0dXJlXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gNCAtIHNpemUgb2YgemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCAgICAgICAgICAgICAgICA4IGJ5dGVzXG4gICAgICAgICAgLy8gMTIgLSB2ZXJzaW9uIG1hZGUgYnkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIGJ5dGVzXG4gICAgICAgICAgLy8gMTQgLSB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIGJ5dGVzXG4gICAgICAgICAgLy8gMTYgLSBudW1iZXIgb2YgdGhpcyBkaXNrICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgICAgLy8gMjAgLSBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICA0IGJ5dGVzXG4gICAgICAgICAgLy8gMjQgLSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrICAgICAgICAgOCBieXRlc1xuICAgICAgICAgIC8vIDMyIC0gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5ICAgICAgICAgICAgOCBieXRlc1xuICAgICAgICAgIGVudHJ5Q291bnQgPSByZWFkVUludDY0TEUoemlwNjRFb2NkckJ1ZmZlciwgMzIpO1xuICAgICAgICAgIC8vIDQwIC0gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOCBieXRlc1xuICAgICAgICAgIC8vIDQ4IC0gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXIgICAgIDggYnl0ZXNcbiAgICAgICAgICBjZW50cmFsRGlyZWN0b3J5T2Zmc2V0ID0gcmVhZFVJbnQ2NExFKHppcDY0RW9jZHJCdWZmZXIsIDQ4KTtcbiAgICAgICAgICAvLyA1NiAtIHppcDY0IGV4dGVuc2libGUgZGF0YSBzZWN0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YXJpYWJsZSBzaXplKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgWmlwRmlsZShyZWFkZXIsIGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQsIHRvdGFsU2l6ZSwgZW50cnlDb3VudCwgY29tbWVudCwgb3B0aW9ucy5hdXRvQ2xvc2UsIG9wdGlvbnMubGF6eUVudHJpZXMsIGRlY29kZVN0cmluZ3MsIG9wdGlvbnMudmFsaWRhdGVFbnRyeVNpemVzLCBvcHRpb25zLnN0cmljdEZpbGVOYW1lcykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkIHNpZ25hdHVyZSBub3QgZm91bmRcIikpO1xuICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhaaXBGaWxlLCBFdmVudEVtaXR0ZXIpO1xuZnVuY3Rpb24gWmlwRmlsZShyZWFkZXIsIGNlbnRyYWxEaXJlY3RvcnlPZmZzZXQsIGZpbGVTaXplLCBlbnRyeUNvdW50LCBjb21tZW50LCBhdXRvQ2xvc2UsIGxhenlFbnRyaWVzLCBkZWNvZGVTdHJpbmdzLCB2YWxpZGF0ZUVudHJ5U2l6ZXMsIHN0cmljdEZpbGVOYW1lcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpO1xuICBzZWxmLnJlYWRlciA9IHJlYWRlcjtcbiAgLy8gZm9yd2FyZCBjbG9zZSBldmVudHNcbiAgc2VsZi5yZWFkZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAvLyBlcnJvciBjbG9zaW5nIHRoZSBmZFxuICAgIGVtaXRFcnJvcihzZWxmLCBlcnIpO1xuICB9KTtcbiAgc2VsZi5yZWFkZXIub25jZShcImNsb3NlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdChcImNsb3NlXCIpO1xuICB9KTtcbiAgc2VsZi5yZWFkRW50cnlDdXJzb3IgPSBjZW50cmFsRGlyZWN0b3J5T2Zmc2V0O1xuICBzZWxmLmZpbGVTaXplID0gZmlsZVNpemU7XG4gIHNlbGYuZW50cnlDb3VudCA9IGVudHJ5Q291bnQ7XG4gIHNlbGYuY29tbWVudCA9IGNvbW1lbnQ7XG4gIHNlbGYuZW50cmllc1JlYWQgPSAwO1xuICBzZWxmLmF1dG9DbG9zZSA9ICEhYXV0b0Nsb3NlO1xuICBzZWxmLmxhenlFbnRyaWVzID0gISFsYXp5RW50cmllcztcbiAgc2VsZi5kZWNvZGVTdHJpbmdzID0gISFkZWNvZGVTdHJpbmdzO1xuICBzZWxmLnZhbGlkYXRlRW50cnlTaXplcyA9ICEhdmFsaWRhdGVFbnRyeVNpemVzO1xuICBzZWxmLnN0cmljdEZpbGVOYW1lcyA9ICEhc3RyaWN0RmlsZU5hbWVzO1xuICBzZWxmLmlzT3BlbiA9IHRydWU7XG4gIHNlbGYuZW1pdHRlZEVycm9yID0gZmFsc2U7XG5cbiAgaWYgKCFzZWxmLmxhenlFbnRyaWVzKSBzZWxmLl9yZWFkRW50cnkoKTtcbn1cblppcEZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc09wZW4pIHJldHVybjtcbiAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgdGhpcy5yZWFkZXIudW5yZWYoKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBlcnIpIHtcbiAgaWYgKHNlbGYuYXV0b0Nsb3NlKSBzZWxmLmNsb3NlKCk7XG4gIGVtaXRFcnJvcihzZWxmLCBlcnIpO1xufVxuZnVuY3Rpb24gZW1pdEVycm9yKHNlbGYsIGVycikge1xuICBpZiAoc2VsZi5lbWl0dGVkRXJyb3IpIHJldHVybjtcbiAgc2VsZi5lbWl0dGVkRXJyb3IgPSB0cnVlO1xuICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xufVxuXG5aaXBGaWxlLnByb3RvdHlwZS5yZWFkRW50cnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmxhenlFbnRyaWVzKSB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkRW50cnkoKSBjYWxsZWQgd2l0aG91dCBsYXp5RW50cmllczp0cnVlXCIpO1xuICB0aGlzLl9yZWFkRW50cnkoKTtcbn07XG5aaXBGaWxlLnByb3RvdHlwZS5fcmVhZEVudHJ5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuZW50cnlDb3VudCA9PT0gc2VsZi5lbnRyaWVzUmVhZCkge1xuICAgIC8vIGRvbmUgd2l0aCBtZXRhZGF0YVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLmF1dG9DbG9zZSkgc2VsZi5jbG9zZSgpO1xuICAgICAgaWYgKHNlbGYuZW1pdHRlZEVycm9yKSByZXR1cm47XG4gICAgICBzZWxmLmVtaXQoXCJlbmRcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzZWxmLmVtaXR0ZWRFcnJvcikgcmV0dXJuO1xuICB2YXIgYnVmZmVyID0gbmV3QnVmZmVyKDQ2KTtcbiAgcmVhZEFuZEFzc2VydE5vRW9mKHNlbGYucmVhZGVyLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHNlbGYucmVhZEVudHJ5Q3Vyc29yLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIGVycik7XG4gICAgaWYgKHNlbGYuZW1pdHRlZEVycm9yKSByZXR1cm47XG4gICAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KCk7XG4gICAgLy8gMCAtIENlbnRyYWwgZGlyZWN0b3J5IGZpbGUgaGVhZGVyIHNpZ25hdHVyZVxuICAgIHZhciBzaWduYXR1cmUgPSBidWZmZXIucmVhZFVJbnQzMkxFKDApO1xuICAgIGlmIChzaWduYXR1cmUgIT09IDB4MDIwMTRiNTApIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiaW52YWxpZCBjZW50cmFsIGRpcmVjdG9yeSBmaWxlIGhlYWRlciBzaWduYXR1cmU6IDB4XCIgKyBzaWduYXR1cmUudG9TdHJpbmcoMTYpKSk7XG4gICAgLy8gNCAtIFZlcnNpb24gbWFkZSBieVxuICAgIGVudHJ5LnZlcnNpb25NYWRlQnkgPSBidWZmZXIucmVhZFVJbnQxNkxFKDQpO1xuICAgIC8vIDYgLSBWZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0IChtaW5pbXVtKVxuICAgIGVudHJ5LnZlcnNpb25OZWVkZWRUb0V4dHJhY3QgPSBidWZmZXIucmVhZFVJbnQxNkxFKDYpO1xuICAgIC8vIDggLSBHZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICBlbnRyeS5nZW5lcmFsUHVycG9zZUJpdEZsYWcgPSBidWZmZXIucmVhZFVJbnQxNkxFKDgpO1xuICAgIC8vIDEwIC0gQ29tcHJlc3Npb24gbWV0aG9kXG4gICAgZW50cnkuY29tcHJlc3Npb25NZXRob2QgPSBidWZmZXIucmVhZFVJbnQxNkxFKDEwKTtcbiAgICAvLyAxMiAtIEZpbGUgbGFzdCBtb2RpZmljYXRpb24gdGltZVxuICAgIGVudHJ5Lmxhc3RNb2RGaWxlVGltZSA9IGJ1ZmZlci5yZWFkVUludDE2TEUoMTIpO1xuICAgIC8vIDE0IC0gRmlsZSBsYXN0IG1vZGlmaWNhdGlvbiBkYXRlXG4gICAgZW50cnkubGFzdE1vZEZpbGVEYXRlID0gYnVmZmVyLnJlYWRVSW50MTZMRSgxNCk7XG4gICAgLy8gMTYgLSBDUkMtMzJcbiAgICBlbnRyeS5jcmMzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMTYpO1xuICAgIC8vIDIwIC0gQ29tcHJlc3NlZCBzaXplXG4gICAgZW50cnkuY29tcHJlc3NlZFNpemUgPSBidWZmZXIucmVhZFVJbnQzMkxFKDIwKTtcbiAgICAvLyAyNCAtIFVuY29tcHJlc3NlZCBzaXplXG4gICAgZW50cnkudW5jb21wcmVzc2VkU2l6ZSA9IGJ1ZmZlci5yZWFkVUludDMyTEUoMjQpO1xuICAgIC8vIDI4IC0gRmlsZSBuYW1lIGxlbmd0aCAobilcbiAgICBlbnRyeS5maWxlTmFtZUxlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2TEUoMjgpO1xuICAgIC8vIDMwIC0gRXh0cmEgZmllbGQgbGVuZ3RoIChtKVxuICAgIGVudHJ5LmV4dHJhRmllbGRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkxFKDMwKTtcbiAgICAvLyAzMiAtIEZpbGUgY29tbWVudCBsZW5ndGggKGspXG4gICAgZW50cnkuZmlsZUNvbW1lbnRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkxFKDMyKTtcbiAgICAvLyAzNCAtIERpc2sgbnVtYmVyIHdoZXJlIGZpbGUgc3RhcnRzXG4gICAgLy8gMzYgLSBJbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICBlbnRyeS5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gYnVmZmVyLnJlYWRVSW50MTZMRSgzNik7XG4gICAgLy8gMzggLSBFeHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICBlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gYnVmZmVyLnJlYWRVSW50MzJMRSgzOCk7XG4gICAgLy8gNDIgLSBSZWxhdGl2ZSBvZmZzZXQgb2YgbG9jYWwgZmlsZSBoZWFkZXJcbiAgICBlbnRyeS5yZWxhdGl2ZU9mZnNldE9mTG9jYWxIZWFkZXIgPSBidWZmZXIucmVhZFVJbnQzMkxFKDQyKTtcblxuICAgIGlmIChlbnRyeS5nZW5lcmFsUHVycG9zZUJpdEZsYWcgJiAweDQwKSByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihcInN0cm9uZyBlbmNyeXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWRcIikpO1xuXG4gICAgc2VsZi5yZWFkRW50cnlDdXJzb3IgKz0gNDY7XG5cbiAgICBidWZmZXIgPSBuZXdCdWZmZXIoZW50cnkuZmlsZU5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIHJlYWRBbmRBc3NlcnROb0VvZihzZWxmLnJlYWRlciwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBzZWxmLnJlYWRFbnRyeUN1cnNvciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIGVycik7XG4gICAgICBpZiAoc2VsZi5lbWl0dGVkRXJyb3IpIHJldHVybjtcbiAgICAgIC8vIDQ2IC0gRmlsZSBuYW1lXG4gICAgICB2YXIgaXNVdGY4ID0gKGVudHJ5LmdlbmVyYWxQdXJwb3NlQml0RmxhZyAmIDB4ODAwKSAhPT0gMDtcbiAgICAgIGVudHJ5LmZpbGVOYW1lID0gc2VsZi5kZWNvZGVTdHJpbmdzID8gZGVjb2RlQnVmZmVyKGJ1ZmZlciwgMCwgZW50cnkuZmlsZU5hbWVMZW5ndGgsIGlzVXRmOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYnVmZmVyLnNsaWNlKDAsIGVudHJ5LmZpbGVOYW1lTGVuZ3RoKTtcblxuICAgICAgLy8gNDYrbiAtIEV4dHJhIGZpZWxkXG4gICAgICB2YXIgZmlsZUNvbW1lbnRTdGFydCA9IGVudHJ5LmZpbGVOYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aDtcbiAgICAgIHZhciBleHRyYUZpZWxkQnVmZmVyID0gYnVmZmVyLnNsaWNlKGVudHJ5LmZpbGVOYW1lTGVuZ3RoLCBmaWxlQ29tbWVudFN0YXJ0KTtcbiAgICAgIGVudHJ5LmV4dHJhRmllbGRzID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGV4dHJhRmllbGRCdWZmZXIubGVuZ3RoIC0gMykge1xuICAgICAgICB2YXIgaGVhZGVySWQgPSBleHRyYUZpZWxkQnVmZmVyLnJlYWRVSW50MTZMRShpICsgMCk7XG4gICAgICAgIHZhciBkYXRhU2l6ZSA9IGV4dHJhRmllbGRCdWZmZXIucmVhZFVJbnQxNkxFKGkgKyAyKTtcbiAgICAgICAgdmFyIGRhdGFTdGFydCA9IGkgKyA0O1xuICAgICAgICB2YXIgZGF0YUVuZCA9IGRhdGFTdGFydCArIGRhdGFTaXplO1xuICAgICAgICBpZiAoZGF0YUVuZCA+IGV4dHJhRmllbGRCdWZmZXIubGVuZ3RoKSByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihcImV4dHJhIGZpZWxkIGxlbmd0aCBleGNlZWRzIGV4dHJhIGZpZWxkIGJ1ZmZlciBzaXplXCIpKTtcbiAgICAgICAgdmFyIGRhdGFCdWZmZXIgPSBuZXdCdWZmZXIoZGF0YVNpemUpO1xuICAgICAgICBleHRyYUZpZWxkQnVmZmVyLmNvcHkoZGF0YUJ1ZmZlciwgMCwgZGF0YVN0YXJ0LCBkYXRhRW5kKTtcbiAgICAgICAgZW50cnkuZXh0cmFGaWVsZHMucHVzaCh7XG4gICAgICAgICAgaWQ6IGhlYWRlcklkLFxuICAgICAgICAgIGRhdGE6IGRhdGFCdWZmZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpID0gZGF0YUVuZDtcbiAgICAgIH1cblxuICAgICAgLy8gNDYrbittIC0gRmlsZSBjb21tZW50XG4gICAgICBlbnRyeS5maWxlQ29tbWVudCA9IHNlbGYuZGVjb2RlU3RyaW5ncyA/IGRlY29kZUJ1ZmZlcihidWZmZXIsIGZpbGVDb21tZW50U3RhcnQsIGZpbGVDb21tZW50U3RhcnQgKyBlbnRyeS5maWxlQ29tbWVudExlbmd0aCwgaXNVdGY4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBidWZmZXIuc2xpY2UoZmlsZUNvbW1lbnRTdGFydCwgZmlsZUNvbW1lbnRTdGFydCArIGVudHJ5LmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICAgIC8vIGNvbXBhdGliaWxpdHkgaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3RoZWpvc2h3b2xmZS95YXV6bC9pc3N1ZXMvNDdcbiAgICAgIGVudHJ5LmNvbW1lbnQgPSBlbnRyeS5maWxlQ29tbWVudDtcblxuICAgICAgc2VsZi5yZWFkRW50cnlDdXJzb3IgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIHNlbGYuZW50cmllc1JlYWQgKz0gMTtcblxuICAgICAgaWYgKGVudHJ5LnVuY29tcHJlc3NlZFNpemUgICAgICAgICAgICA9PT0gMHhmZmZmZmZmZiB8fFxuICAgICAgICAgIGVudHJ5LmNvbXByZXNzZWRTaXplICAgICAgICAgICAgICA9PT0gMHhmZmZmZmZmZiB8fFxuICAgICAgICAgIGVudHJ5LnJlbGF0aXZlT2Zmc2V0T2ZMb2NhbEhlYWRlciA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICAvLyBaSVA2NCBmb3JtYXRcbiAgICAgICAgLy8gZmluZCB0aGUgWmlwNjQgRXh0ZW5kZWQgSW5mb3JtYXRpb24gRXh0cmEgRmllbGRcbiAgICAgICAgdmFyIHppcDY0RWllZkJ1ZmZlciA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnkuZXh0cmFGaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXh0cmFGaWVsZCA9IGVudHJ5LmV4dHJhRmllbGRzW2ldO1xuICAgICAgICAgIGlmIChleHRyYUZpZWxkLmlkID09PSAweDAwMDEpIHtcbiAgICAgICAgICAgIHppcDY0RWllZkJ1ZmZlciA9IGV4dHJhRmllbGQuZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoemlwNjRFaWVmQnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihcImV4cGVjdGVkIHppcDY0IGV4dGVuZGVkIGluZm9ybWF0aW9uIGV4dHJhIGZpZWxkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAvLyAwIC0gT3JpZ2luYWwgU2l6ZSAgICAgICAgICA4IGJ5dGVzXG4gICAgICAgIGlmIChlbnRyeS51bmNvbXByZXNzZWRTaXplID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgaWYgKGluZGV4ICsgOCA+IHppcDY0RWllZkJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiemlwNjQgZXh0ZW5kZWQgaW5mb3JtYXRpb24gZXh0cmEgZmllbGQgZG9lcyBub3QgaW5jbHVkZSB1bmNvbXByZXNzZWQgc2l6ZVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJ5LnVuY29tcHJlc3NlZFNpemUgPSByZWFkVUludDY0TEUoemlwNjRFaWVmQnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyA4IC0gQ29tcHJlc3NlZCBTaXplICAgICAgICA4IGJ5dGVzXG4gICAgICAgIGlmIChlbnRyeS5jb21wcmVzc2VkU2l6ZSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICAgIGlmIChpbmRleCArIDggPiB6aXA2NEVpZWZCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1pdEVycm9yQW5kQXV0b0Nsb3NlKHNlbGYsIG5ldyBFcnJvcihcInppcDY0IGV4dGVuZGVkIGluZm9ybWF0aW9uIGV4dHJhIGZpZWxkIGRvZXMgbm90IGluY2x1ZGUgY29tcHJlc3NlZCBzaXplXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkuY29tcHJlc3NlZFNpemUgPSByZWFkVUludDY0TEUoemlwNjRFaWVmQnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyAxNiAtIFJlbGF0aXZlIEhlYWRlciBPZmZzZXQgOCBieXRlc1xuICAgICAgICBpZiAoZW50cnkucmVsYXRpdmVPZmZzZXRPZkxvY2FsSGVhZGVyID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgaWYgKGluZGV4ICsgOCA+IHppcDY0RWllZkJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0RXJyb3JBbmRBdXRvQ2xvc2Uoc2VsZiwgbmV3IEVycm9yKFwiemlwNjQgZXh0ZW5kZWQgaW5mb3JtYXRpb24gZXh0cmEgZmllbGQgZG9lcyBub3QgaW5jbHVkZSByZWxhdGl2ZSBoZWFkZXIgb2Zmc2V0XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkucmVsYXRpdmVPZmZzZXRPZkxvY2FsSGVhZGVyID0gcmVhZFVJbnQ2NExFKHppcDY0RWllZkJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMjQgLSBEaXNrIFN0YXJ0IE51bWJlciAgICAgIDQgYnl0ZXNcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIEluZm8tWklQIFVuaWNvZGUgUGF0aCBFeHRyYSBGaWVsZCAoMHg3MDc1KVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVqb3Nod29sZmUveWF1emwvaXNzdWVzLzMzXG4gICAgICBpZiAoc2VsZi5kZWNvZGVTdHJpbmdzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnkuZXh0cmFGaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXh0cmFGaWVsZCA9IGVudHJ5LmV4dHJhRmllbGRzW2ldO1xuICAgICAgICAgIGlmIChleHRyYUZpZWxkLmlkID09PSAweDcwNzUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYUZpZWxkLmRhdGEubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgICAvLyB0b28gc2hvcnQgdG8gYmUgbWVhbmluZ2Z1bFxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZlcnNpb24gICAgICAgMSBieXRlICAgICAgdmVyc2lvbiBvZiB0aGlzIGV4dHJhIGZpZWxkLCBjdXJyZW50bHkgMVxuICAgICAgICAgICAgaWYgKGV4dHJhRmllbGQuZGF0YS5yZWFkVUludDgoMCkgIT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gPiBDaGFuZ2VzIG1heSBub3QgYmUgYmFja3dhcmQgY29tcGF0aWJsZSBzbyB0aGlzIGV4dHJhXG4gICAgICAgICAgICAgIC8vID4gZmllbGQgc2hvdWxkIG5vdCBiZSB1c2VkIGlmIHRoZSB2ZXJzaW9uIGlzIG5vdCByZWNvZ25pemVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMiAgICAgNCBieXRlcyAgICAgRmlsZSBOYW1lIEZpZWxkIENSQzMyIENoZWNrc3VtXG4gICAgICAgICAgICB2YXIgb2xkTmFtZUNyYzMyID0gZXh0cmFGaWVsZC5kYXRhLnJlYWRVSW50MzJMRSgxKTtcbiAgICAgICAgICAgIGlmIChjcmMzMi51bnNpZ25lZChidWZmZXIuc2xpY2UoMCwgZW50cnkuZmlsZU5hbWVMZW5ndGgpKSAhPT0gb2xkTmFtZUNyYzMyKSB7XG4gICAgICAgICAgICAgIC8vID4gSWYgdGhlIENSQyBjaGVjayBmYWlscywgdGhpcyBVVEYtOCBQYXRoIEV4dHJhIEZpZWxkIHNob3VsZCBiZVxuICAgICAgICAgICAgICAvLyA+IGlnbm9yZWQgYW5kIHRoZSBGaWxlIE5hbWUgZmllbGQgaW4gdGhlIGhlYWRlciBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lICAgVmFyaWFibGUgICAgVVRGLTggdmVyc2lvbiBvZiB0aGUgZW50cnkgRmlsZSBOYW1lXG4gICAgICAgICAgICBlbnRyeS5maWxlTmFtZSA9IGRlY29kZUJ1ZmZlcihleHRyYUZpZWxkLmRhdGEsIDUsIGV4dHJhRmllbGQuZGF0YS5sZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkYXRlIGZpbGUgc2l6ZVxuICAgICAgaWYgKHNlbGYudmFsaWRhdGVFbnRyeVNpemVzICYmIGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kID09PSAwKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENvbXByZXNzZWRTaXplID0gZW50cnkudW5jb21wcmVzc2VkU2l6ZTtcbiAgICAgICAgaWYgKGVudHJ5LmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAvLyB0cmFkaXRpb25hbCBlbmNyeXB0aW9uIHByZWZpeGVzIHRoZSBmaWxlIGRhdGEgd2l0aCBhIGhlYWRlclxuICAgICAgICAgIGV4cGVjdGVkQ29tcHJlc3NlZFNpemUgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5LmNvbXByZXNzZWRTaXplICE9PSBleHBlY3RlZENvbXByZXNzZWRTaXplKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiY29tcHJlc3NlZC91bmNvbXByZXNzZWQgc2l6ZSBtaXNtYXRjaCBmb3Igc3RvcmVkIGZpbGU6IFwiICsgZW50cnkuY29tcHJlc3NlZFNpemUgKyBcIiAhPSBcIiArIGVudHJ5LnVuY29tcHJlc3NlZFNpemU7XG4gICAgICAgICAgcmV0dXJuIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuZGVjb2RlU3RyaW5ncykge1xuICAgICAgICBpZiAoIXNlbGYuc3RyaWN0RmlsZU5hbWVzKSB7XG4gICAgICAgICAgLy8gYWxsb3cgYmFja3NsYXNoXG4gICAgICAgICAgZW50cnkuZmlsZU5hbWUgPSBlbnRyeS5maWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gdmFsaWRhdGVGaWxlTmFtZShlbnRyeS5maWxlTmFtZSwgc2VsZi52YWxpZGF0ZUZpbGVOYW1lT3B0aW9ucyk7XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UgIT0gbnVsbCkgcmV0dXJuIGVtaXRFcnJvckFuZEF1dG9DbG9zZShzZWxmLCBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoXCJlbnRyeVwiLCBlbnRyeSk7XG5cbiAgICAgIGlmICghc2VsZi5sYXp5RW50cmllcykgc2VsZi5fcmVhZEVudHJ5KCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuWmlwRmlsZS5wcm90b3R5cGUub3BlblJlYWRTdHJlYW0gPSBmdW5jdGlvbihlbnRyeSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBwYXJhbWV0ZXIgdmFsaWRhdGlvblxuICB2YXIgcmVsYXRpdmVTdGFydCA9IDA7XG4gIHZhciByZWxhdGl2ZUVuZCA9IGVudHJ5LmNvbXByZXNzZWRTaXplO1xuICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucyB0aGF0IHRoZSBjYWxsZXIgaGFzIG5vIGV4Y3VzZSB0byBnZXQgd3JvbmdcbiAgICBpZiAob3B0aW9ucy5kZWNyeXB0ICE9IG51bGwpIHtcbiAgICAgIGlmICghZW50cnkuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmRlY3J5cHQgY2FuIG9ubHkgYmUgc3BlY2lmaWVkIGZvciBlbmNyeXB0ZWQgZW50cmllc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRlY3J5cHQgIT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9wdGlvbnMuZGVjcnlwdCB2YWx1ZTogXCIgKyBvcHRpb25zLmRlY3J5cHQpO1xuICAgICAgaWYgKGVudHJ5LmlzQ29tcHJlc3NlZCgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRlY29tcHJlc3MgIT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoXCJlbnRyeSBpcyBlbmNyeXB0ZWQgYW5kIGNvbXByZXNzZWQsIGFuZCBvcHRpb25zLmRlY29tcHJlc3MgIT09IGZhbHNlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZWNvbXByZXNzICE9IG51bGwpIHtcbiAgICAgIGlmICghZW50cnkuaXNDb21wcmVzc2VkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5kZWNvbXByZXNzIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBmb3IgY29tcHJlc3NlZCBlbnRyaWVzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEob3B0aW9ucy5kZWNvbXByZXNzID09PSBmYWxzZSB8fCBvcHRpb25zLmRlY29tcHJlc3MgPT09IHRydWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3B0aW9ucy5kZWNvbXByZXNzIHZhbHVlOiBcIiArIG9wdGlvbnMuZGVjb21wcmVzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YXJ0ICE9IG51bGwgfHwgb3B0aW9ucy5lbmQgIT0gbnVsbCkge1xuICAgICAgaWYgKGVudHJ5LmlzQ29tcHJlc3NlZCgpICYmIG9wdGlvbnMuZGVjb21wcmVzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQvZW5kIHJhbmdlIG5vdCBhbGxvd2VkIGZvciBjb21wcmVzc2VkIGVudHJ5IHdpdGhvdXQgb3B0aW9ucy5kZWNvbXByZXNzID09PSBmYWxzZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS5pc0VuY3J5cHRlZCgpICYmIG9wdGlvbnMuZGVjcnlwdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQvZW5kIHJhbmdlIG5vdCBhbGxvd2VkIGZvciBlbmNyeXB0ZWQgZW50cnkgd2l0aG91dCBvcHRpb25zLmRlY3J5cHQgPT09IGZhbHNlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGFydCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICAgIGlmIChyZWxhdGl2ZVN0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5zdGFydCA8IDBcIik7XG4gICAgICBpZiAocmVsYXRpdmVTdGFydCA+IGVudHJ5LmNvbXByZXNzZWRTaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnN0YXJ0ID4gZW50cnkuY29tcHJlc3NlZFNpemVcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZUVuZCA9IG9wdGlvbnMuZW5kO1xuICAgICAgaWYgKHJlbGF0aXZlRW5kIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5lbmQgPCAwXCIpO1xuICAgICAgaWYgKHJlbGF0aXZlRW5kID4gZW50cnkuY29tcHJlc3NlZFNpemUpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuZW5kID4gZW50cnkuY29tcHJlc3NlZFNpemVcIik7XG4gICAgICBpZiAocmVsYXRpdmVFbmQgPCByZWxhdGl2ZVN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmVuZCA8IG9wdGlvbnMuc3RhcnRcIik7XG4gICAgfVxuICB9XG4gIC8vIGFueSBmdXJ0aGVyIGVycm9ycyBjYW4gZWl0aGVyIGJlIGNhdXNlZCBieSB0aGUgemlwZmlsZSxcbiAgLy8gb3Igd2VyZSBpbnRyb2R1Y2VkIGluIGEgbWlub3IgdmVyc2lvbiBvZiB5YXV6bCxcbiAgLy8gc28gc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY2xpZW50IHJhdGhlciB0aGFuIHRocm93bi5cbiAgaWYgKCFzZWxmLmlzT3BlbikgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImNsb3NlZFwiKSk7XG4gIGlmIChlbnRyeS5pc0VuY3J5cHRlZCgpKSB7XG4gICAgaWYgKG9wdGlvbnMuZGVjcnlwdCAhPT0gZmFsc2UpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJlbnRyeSBpcyBlbmNyeXB0ZWQsIGFuZCBvcHRpb25zLmRlY3J5cHQgIT09IGZhbHNlXCIpKTtcbiAgfVxuICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgbG9zZSB0aGUgZmQgYmVmb3JlIHdlIG9wZW4gdGhlIGFjdHVhbCByZWFkIHN0cmVhbVxuICBzZWxmLnJlYWRlci5yZWYoKTtcbiAgdmFyIGJ1ZmZlciA9IG5ld0J1ZmZlcigzMCk7XG4gIHJlYWRBbmRBc3NlcnROb0VvZihzZWxmLnJlYWRlciwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBlbnRyeS5yZWxhdGl2ZU9mZnNldE9mTG9jYWxIZWFkZXIsIGZ1bmN0aW9uKGVycikge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIC8vIDAgLSBMb2NhbCBmaWxlIGhlYWRlciBzaWduYXR1cmUgPSAweDA0MDM0YjUwXG4gICAgICB2YXIgc2lnbmF0dXJlID0gYnVmZmVyLnJlYWRVSW50MzJMRSgwKTtcbiAgICAgIGlmIChzaWduYXR1cmUgIT09IDB4MDQwMzRiNTApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImludmFsaWQgbG9jYWwgZmlsZSBoZWFkZXIgc2lnbmF0dXJlOiAweFwiICsgc2lnbmF0dXJlLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgfVxuICAgICAgLy8gYWxsIHRoaXMgc2hvdWxkIGJlIHJlZHVuZGFudFxuICAgICAgLy8gNCAtIFZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3QgKG1pbmltdW0pXG4gICAgICAvLyA2IC0gR2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgICAvLyA4IC0gQ29tcHJlc3Npb24gbWV0aG9kXG4gICAgICAvLyAxMCAtIEZpbGUgbGFzdCBtb2RpZmljYXRpb24gdGltZVxuICAgICAgLy8gMTIgLSBGaWxlIGxhc3QgbW9kaWZpY2F0aW9uIGRhdGVcbiAgICAgIC8vIDE0IC0gQ1JDLTMyXG4gICAgICAvLyAxOCAtIENvbXByZXNzZWQgc2l6ZVxuICAgICAgLy8gMjIgLSBVbmNvbXByZXNzZWQgc2l6ZVxuICAgICAgLy8gMjYgLSBGaWxlIG5hbWUgbGVuZ3RoIChuKVxuICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZMRSgyNik7XG4gICAgICAvLyAyOCAtIEV4dHJhIGZpZWxkIGxlbmd0aCAobSlcbiAgICAgIHZhciBleHRyYUZpZWxkTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZMRSgyOCk7XG4gICAgICAvLyAzMCAtIEZpbGUgbmFtZVxuICAgICAgLy8gMzArbiAtIEV4dHJhIGZpZWxkXG4gICAgICB2YXIgbG9jYWxGaWxlSGVhZGVyRW5kID0gZW50cnkucmVsYXRpdmVPZmZzZXRPZkxvY2FsSGVhZGVyICsgYnVmZmVyLmxlbmd0aCArIGZpbGVOYW1lTGVuZ3RoICsgZXh0cmFGaWVsZExlbmd0aDtcbiAgICAgIHZhciBkZWNvbXByZXNzO1xuICAgICAgaWYgKGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kID09PSAwKSB7XG4gICAgICAgIC8vIDAgLSBUaGUgZmlsZSBpcyBzdG9yZWQgKG5vIGNvbXByZXNzaW9uKVxuICAgICAgICBkZWNvbXByZXNzID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmNvbXByZXNzaW9uTWV0aG9kID09PSA4KSB7XG4gICAgICAgIC8vIDggLSBUaGUgZmlsZSBpcyBEZWZsYXRlZFxuICAgICAgICBkZWNvbXByZXNzID0gb3B0aW9ucy5kZWNvbXByZXNzICE9IG51bGwgPyBvcHRpb25zLmRlY29tcHJlc3MgOiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZDogXCIgKyBlbnRyeS5jb21wcmVzc2lvbk1ldGhvZCkpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGVEYXRhU3RhcnQgPSBsb2NhbEZpbGVIZWFkZXJFbmQ7XG4gICAgICB2YXIgZmlsZURhdGFFbmQgPSBmaWxlRGF0YVN0YXJ0ICsgZW50cnkuY29tcHJlc3NlZFNpemU7XG4gICAgICBpZiAoZW50cnkuY29tcHJlc3NlZFNpemUgIT09IDApIHtcbiAgICAgICAgLy8gYm91bmRzIGNoZWNrIG5vdywgYmVjYXVzZSB0aGUgcmVhZCBzdHJlYW1zIHdpbGwgcHJvYmFibHkgbm90IGNvbXBsYWluIGxvdWQgZW5vdWdoLlxuICAgICAgICAvLyBzaW5jZSB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gdW5zaWduZWQgb2Zmc2V0IHBsdXMgYW4gdW5zaWduZWQgc2l6ZSxcbiAgICAgICAgLy8gd2Ugb25seSBoYXZlIDEgdGhpbmcgdG8gY2hlY2sgZm9yLlxuICAgICAgICBpZiAoZmlsZURhdGFFbmQgPiBzZWxmLmZpbGVTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcImZpbGUgZGF0YSBvdmVyZmxvd3MgZmlsZSBib3VuZHM6IFwiICtcbiAgICAgICAgICAgICAgZmlsZURhdGFTdGFydCArIFwiICsgXCIgKyBlbnRyeS5jb21wcmVzc2VkU2l6ZSArIFwiID4gXCIgKyBzZWxmLmZpbGVTaXplKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZWFkU3RyZWFtID0gc2VsZi5yZWFkZXIuY3JlYXRlUmVhZFN0cmVhbSh7XG4gICAgICAgIHN0YXJ0OiBmaWxlRGF0YVN0YXJ0ICsgcmVsYXRpdmVTdGFydCxcbiAgICAgICAgZW5kOiBmaWxlRGF0YVN0YXJ0ICsgcmVsYXRpdmVFbmQsXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRwb2ludFN0cmVhbSA9IHJlYWRTdHJlYW07XG4gICAgICBpZiAoZGVjb21wcmVzcykge1xuICAgICAgICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHZhciBpbmZsYXRlRmlsdGVyID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KCk7XG4gICAgICAgIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAvLyBzZXRJbW1lZGlhdGUgaGVyZSBiZWNhdXNlIGVycm9ycyBjYW4gYmUgZW1pdHRlZCBkdXJpbmcgdGhlIGZpcnN0IGNhbGwgdG8gcGlwZSgpXG4gICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFkZXN0cm95ZWQpIGluZmxhdGVGaWx0ZXIuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWFkU3RyZWFtLnBpcGUoaW5mbGF0ZUZpbHRlcik7XG5cbiAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVFbnRyeVNpemVzKSB7XG4gICAgICAgICAgZW5kcG9pbnRTdHJlYW0gPSBuZXcgQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtKGVudHJ5LnVuY29tcHJlc3NlZFNpemUpO1xuICAgICAgICAgIGluZmxhdGVGaWx0ZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgemxpYiBlcnJvcnMgdG8gdGhlIGNsaWVudC12aXNpYmxlIHN0cmVhbVxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIWRlc3Ryb3llZCkgZW5kcG9pbnRTdHJlYW0uZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmZsYXRlRmlsdGVyLnBpcGUoZW5kcG9pbnRTdHJlYW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZSB6bGliIGZpbHRlciBpcyB0aGUgY2xpZW50LXZpc2libGUgc3RyZWFtXG4gICAgICAgICAgZW5kcG9pbnRTdHJlYW0gPSBpbmZsYXRlRmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgcGFydCBvZiB5YXV6bCdzIEFQSSwgc28gaW1wbGVtZW50IHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsaWVudC12aXNpYmxlIHN0cmVhbVxuICAgICAgICBlbmRwb2ludFN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaW5mbGF0ZUZpbHRlciAhPT0gZW5kcG9pbnRTdHJlYW0pIGluZmxhdGVGaWx0ZXIudW5waXBlKGVuZHBvaW50U3RyZWFtKTtcbiAgICAgICAgICByZWFkU3RyZWFtLnVucGlwZShpbmZsYXRlRmlsdGVyKTtcbiAgICAgICAgICAvLyBUT0RPOiB0aGUgaW5mbGF0ZUZpbHRlciBtYXkgY2F1c2UgYSBtZW1vcnkgbGVhay4gc2VlIElzc3VlICMyNy5cbiAgICAgICAgICByZWFkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGVuZHBvaW50U3RyZWFtKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VsZi5yZWFkZXIudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gRW50cnkoKSB7XG59XG5FbnRyeS5wcm90b3R5cGUuZ2V0TGFzdE1vZERhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRvc0RhdGVUaW1lVG9EYXRlKHRoaXMubGFzdE1vZEZpbGVEYXRlLCB0aGlzLmxhc3RNb2RGaWxlVGltZSk7XG59O1xuRW50cnkucHJvdG90eXBlLmlzRW5jcnlwdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5nZW5lcmFsUHVycG9zZUJpdEZsYWcgJiAweDEpICE9PSAwO1xufTtcbkVudHJ5LnByb3RvdHlwZS5pc0NvbXByZXNzZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPT09IDg7XG59O1xuXG5mdW5jdGlvbiBkb3NEYXRlVGltZVRvRGF0ZShkYXRlLCB0aW1lKSB7XG4gIHZhciBkYXkgPSBkYXRlICYgMHgxZjsgLy8gMS0zMVxuICB2YXIgbW9udGggPSAoZGF0ZSA+PiA1ICYgMHhmKSAtIDE7IC8vIDEtMTIsIDAtMTFcbiAgdmFyIHllYXIgPSAoZGF0ZSA+PiA5ICYgMHg3ZikgKyAxOTgwOyAvLyAwLTEyOCwgMTk4MC0yMTA4XG5cbiAgdmFyIG1pbGxpc2Vjb25kID0gMDtcbiAgdmFyIHNlY29uZCA9ICh0aW1lICYgMHgxZikgKiAyOyAvLyAwLTI5LCAwLTU4IChldmVuIG51bWJlcnMpXG4gIHZhciBtaW51dGUgPSB0aW1lID4+IDUgJiAweDNmOyAvLyAwLTU5XG4gIHZhciBob3VyID0gdGltZSA+PiAxMSAmIDB4MWY7IC8vIDAtMjNcblxuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGaWxlTmFtZShmaWxlTmFtZSkge1xuICBpZiAoZmlsZU5hbWUuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7XG4gICAgcmV0dXJuIFwiaW52YWxpZCBjaGFyYWN0ZXJzIGluIGZpbGVOYW1lOiBcIiArIGZpbGVOYW1lO1xuICB9XG4gIGlmICgvXlthLXpBLVpdOi8udGVzdChmaWxlTmFtZSkgfHwgL15cXC8vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgcmV0dXJuIFwiYWJzb2x1dGUgcGF0aDogXCIgKyBmaWxlTmFtZTtcbiAgfVxuICBpZiAoZmlsZU5hbWUuc3BsaXQoXCIvXCIpLmluZGV4T2YoXCIuLlwiKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkIHJlbGF0aXZlIHBhdGg6IFwiICsgZmlsZU5hbWU7XG4gIH1cbiAgLy8gYWxsIGdvb2RcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRBc3NlcnROb0VvZihyZWFkZXIsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZnMucmVhZCB3aWxsIHRocm93IGFuIG91dC1vZi1ib3VuZHMgZXJyb3IgaWYgeW91IHRyeSB0byByZWFkIDAgYnl0ZXMgZnJvbSBhIDAgYnl0ZSBmaWxlXG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCwgbmV3QnVmZmVyKDApKTsgfSk7XG4gIH1cbiAgcmVhZGVyLnJlYWQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGZ1bmN0aW9uKGVyciwgYnl0ZXNSZWFkKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgaWYgKGJ5dGVzUmVhZCA8IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgRU9GXCIpKTtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtLCBUcmFuc2Zvcm0pO1xuZnVuY3Rpb24gQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtKGJ5dGVDb3VudCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcbiAgdGhpcy5hY3R1YWxCeXRlQ291bnQgPSAwO1xuICB0aGlzLmV4cGVjdGVkQnl0ZUNvdW50ID0gYnl0ZUNvdW50O1xufVxuQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmFjdHVhbEJ5dGVDb3VudCArPSBjaHVuay5sZW5ndGg7XG4gIGlmICh0aGlzLmFjdHVhbEJ5dGVDb3VudCA+IHRoaXMuZXhwZWN0ZWRCeXRlQ291bnQpIHtcbiAgICB2YXIgbXNnID0gXCJ0b28gbWFueSBieXRlcyBpbiB0aGUgc3RyZWFtLiBleHBlY3RlZCBcIiArIHRoaXMuZXhwZWN0ZWRCeXRlQ291bnQgKyBcIi4gZ290IGF0IGxlYXN0IFwiICsgdGhpcy5hY3R1YWxCeXRlQ291bnQ7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtc2cpKTtcbiAgfVxuICBjYihudWxsLCBjaHVuayk7XG59O1xuQXNzZXJ0Qnl0ZUNvdW50U3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy5hY3R1YWxCeXRlQ291bnQgPCB0aGlzLmV4cGVjdGVkQnl0ZUNvdW50KSB7XG4gICAgdmFyIG1zZyA9IFwibm90IGVub3VnaCBieXRlcyBpbiB0aGUgc3RyZWFtLiBleHBlY3RlZCBcIiArIHRoaXMuZXhwZWN0ZWRCeXRlQ291bnQgKyBcIi4gZ290IG9ubHkgXCIgKyB0aGlzLmFjdHVhbEJ5dGVDb3VudDtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKG1zZykpO1xuICB9XG4gIGNiKCk7XG59O1xuXG51dGlsLmluaGVyaXRzKFJhbmRvbUFjY2Vzc1JlYWRlciwgRXZlbnRFbWl0dGVyKTtcbmZ1bmN0aW9uIFJhbmRvbUFjY2Vzc1JlYWRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMucmVmQ291bnQgPSAwO1xufVxuUmFuZG9tQWNjZXNzUmVhZGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWZDb3VudCArPSAxO1xufTtcblJhbmRvbUFjY2Vzc1JlYWRlci5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlZkNvdW50IC09IDE7XG5cbiAgaWYgKHNlbGYucmVmQ291bnQgPiAwKSByZXR1cm47XG4gIGlmIChzZWxmLnJlZkNvdW50IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1bnJlZlwiKTtcblxuICBzZWxmLmNsb3NlKG9uQ2xvc2VEb25lKTtcblxuICBmdW5jdGlvbiBvbkNsb3NlRG9uZShlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICB9XG59O1xuUmFuZG9tQWNjZXNzUmVhZGVyLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQ7XG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgdmFyIGVtcHR5U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZW1wdHlTdHJlYW0uZW5kKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVtcHR5U3RyZWFtO1xuICB9XG4gIHZhciBzdHJlYW0gPSB0aGlzLl9yZWFkU3RyZWFtRm9yUmFuZ2Uoc3RhcnQsIGVuZCk7XG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICB2YXIgcmVmVW5yZWZGaWx0ZXIgPSBuZXcgUmVmVW5yZWZGaWx0ZXIodGhpcyk7XG4gIHN0cmVhbS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZGVzdHJveWVkKSByZWZVbnJlZkZpbHRlci5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlZlVucmVmRmlsdGVyLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBzdHJlYW0udW5waXBlKHJlZlVucmVmRmlsdGVyKTtcbiAgICByZWZVbnJlZkZpbHRlci51bnJlZigpO1xuICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gIH07XG5cbiAgdmFyIGJ5dGVDb3VudGVyID0gbmV3IEFzc2VydEJ5dGVDb3VudFN0cmVhbShlbmQgLSBzdGFydCk7XG4gIHJlZlVucmVmRmlsdGVyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkZXN0cm95ZWQpIGJ5dGVDb3VudGVyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgIH0pO1xuICB9KTtcbiAgYnl0ZUNvdW50ZXIuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgcmVmVW5yZWZGaWx0ZXIudW5waXBlKGJ5dGVDb3VudGVyKTtcbiAgICByZWZVbnJlZkZpbHRlci5kZXN0cm95KCk7XG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbS5waXBlKHJlZlVucmVmRmlsdGVyKS5waXBlKGJ5dGVDb3VudGVyKTtcbn07XG5SYW5kb21BY2Nlc3NSZWFkZXIucHJvdG90eXBlLl9yZWFkU3RyZWFtRm9yUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5SYW5kb21BY2Nlc3NSZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oe3N0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiArIGxlbmd0aH0pO1xuICB2YXIgd3JpdGVTdHJlYW0gPSBuZXcgV3JpdGFibGUoKTtcbiAgdmFyIHdyaXR0ZW4gPSAwO1xuICB3cml0ZVN0cmVhbS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgY2h1bmsuY29weShidWZmZXIsIG9mZnNldCArIHdyaXR0ZW4sIDAsIGNodW5rLmxlbmd0aCk7XG4gICAgd3JpdHRlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgY2IoKTtcbiAgfTtcbiAgd3JpdGVTdHJlYW0ub24oXCJmaW5pc2hcIiwgY2FsbGJhY2spO1xuICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvcik7XG4gIH0pO1xuICByZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xufTtcblJhbmRvbUFjY2Vzc1JlYWRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xufTtcblxudXRpbC5pbmhlcml0cyhSZWZVbnJlZkZpbHRlciwgUGFzc1Rocm91Z2gpO1xuZnVuY3Rpb24gUmVmVW5yZWZGaWx0ZXIoY29udGV4dCkge1xuICBQYXNzVGhyb3VnaC5jYWxsKHRoaXMpO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmNvbnRleHQucmVmKCk7XG4gIHRoaXMudW5yZWZmZWRZZXQgPSBmYWxzZTtcbn1cblJlZlVucmVmRmlsdGVyLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYikge1xuICB0aGlzLnVucmVmKCk7XG4gIGNiKCk7XG59O1xuUmVmVW5yZWZGaWx0ZXIucHJvdG90eXBlLnVucmVmID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKHRoaXMudW5yZWZmZWRZZXQpIHJldHVybjtcbiAgdGhpcy51bnJlZmZlZFlldCA9IHRydWU7XG4gIHRoaXMuY29udGV4dC51bnJlZigpO1xufTtcblxudmFyIGNwNDM3ID0gJ1xcdTAwMDDimLrimLvimaXimabimaPimaDigKLil5jil4vil5nimYLimYDimarimavimLzilrril4TihpXigLzCtsKn4pas4oao4oaR4oaT4oaS4oaQ4oif4oaU4pay4pa8ICFcIiMkJSZcXCcoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX7ijILDh8O8w6nDosOkw6DDpcOnw6rDq8Oow6/DrsOsw4TDhcOJw6bDhsO0w7bDssO7w7nDv8OWw5zCosKjwqXigqfGksOhw63Ds8O6w7HDkcKqwrrCv+KMkMKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqAnO1xuZnVuY3Rpb24gZGVjb2RlQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGVuZCwgaXNVdGY4KSB7XG4gIGlmIChpc1V0ZjgpIHtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBzdGFydCwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IGNwNDM3W2J1ZmZlcltpXV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIC8vIHRoZXJlIGlzIG5vIG5hdGl2ZSBmdW5jdGlvbiBmb3IgdGhpcywgYmVjYXVzZSB3ZSBjYW4ndCBhY3R1YWxseSBzdG9yZSA2NC1iaXQgaW50ZWdlcnMgcHJlY2lzZWx5LlxuICAvLyBhZnRlciA1MyBiaXRzLCBKYXZhU2NyaXB0J3MgTnVtYmVyIHR5cGUgKElFRUUgNzU0IGRvdWJsZSkgY2FuJ3Qgc3RvcmUgaW5kaXZpZHVhbCBpbnRlZ2VycyBhbnltb3JlLlxuICAvLyBidXQgc2luY2UgNTMgYml0cyBpcyBhIHdob2xlIGxvdCBtb3JlIHRoYW4gMzIgYml0cywgd2UgZG8gb3VyIGJlc3QgYW55d2F5LlxuICB2YXIgbG93ZXIzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgdmFyIHVwcGVyMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICAvLyB3ZSBjYW4ndCB1c2UgYml0c2hpZnRpbmcgaGVyZSwgYmVjYXVzZSBKYXZhU2NyaXB0IGJpdHNoaWZ0aW5nIG9ubHkgd29ya3Mgb24gMzItYml0IGludGVnZXJzLlxuICByZXR1cm4gdXBwZXIzMiAqIDB4MTAwMDAwMDAwICsgbG93ZXIzMjtcbiAgLy8gYXMgbG9uZyBhcyB3ZSdyZSBib3VuZHMgY2hlY2tpbmcgdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGFnYWluc3QgdGhlIHRvdGFsIGZpbGUgc2l6ZSxcbiAgLy8gd2UnbGwgY2F0Y2ggYW55IG92ZXJmbG93IGVycm9ycywgYmVjYXVzZSB3ZSBhbHJlYWR5IG1hZGUgc3VyZSB0aGUgdG90YWwgZmlsZSBzaXplIHdhcyB3aXRoaW4gcmVhc29uLlxufVxuXG4vLyBOb2RlIDEwIGRlcHJlY2F0ZWQgbmV3IEJ1ZmZlcigpLlxudmFyIG5ld0J1ZmZlcjtcbmlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgbmV3QnVmZmVyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pO1xuICB9O1xufSBlbHNlIHtcbiAgbmV3QnVmZmVyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIobGVuKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKGVycikge1xuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yauzl/index.js\n");

/***/ }),

/***/ "./node_modules/zone.js/dist/zone-node.js":
/*!************************************************!*\
  !*** ./node_modules/zone.js/dist/zone-node.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n(function (global, factory) {\n     true ? factory() :\n    undefined;\n}(this, (function () { 'use strict';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar Zone$1 = (function (global) {\n    if (global['Zone']) {\n        throw new Error('Zone already loaded.');\n    }\n    var Zone = (function () {\n        function Zone(parent, zoneSpec) {\n            this._properties = null;\n            this._parent = parent;\n            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n            this._properties = zoneSpec && zoneSpec.properties || {};\n            this._zoneDelegate =\n                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n        }\n        Zone.assertZonePatched = function () {\n            if (global.Promise !== ZoneAwarePromise) {\n                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +\n                    'has been overwritten.\\n' +\n                    'Most likely cause is that a Promise polyfill has been loaded ' +\n                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +\n                    'If you must load one, do so before loading zone.js.)');\n            }\n        };\n        Object.defineProperty(Zone, \"current\", {\n            get: function () {\n                return _currentZoneFrame.zone;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone, \"currentTask\", {\n            get: function () {\n                return _currentTask;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone.prototype, \"parent\", {\n            get: function () {\n                return this._parent;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Object.defineProperty(Zone.prototype, \"name\", {\n            get: function () {\n                return this._name;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        \n        Zone.prototype.get = function (key) {\n            var zone = this.getZoneWith(key);\n            if (zone)\n                return zone._properties[key];\n        };\n        Zone.prototype.getZoneWith = function (key) {\n            var current = this;\n            while (current) {\n                if (current._properties.hasOwnProperty(key)) {\n                    return current;\n                }\n                current = current._parent;\n            }\n            return null;\n        };\n        Zone.prototype.fork = function (zoneSpec) {\n            if (!zoneSpec)\n                throw new Error('ZoneSpec required!');\n            return this._zoneDelegate.fork(this, zoneSpec);\n        };\n        Zone.prototype.wrap = function (callback, source) {\n            if (typeof callback !== 'function') {\n                throw new Error('Expecting function got: ' + callback);\n            }\n            var _callback = this._zoneDelegate.intercept(this, callback, source);\n            var zone = this;\n            return function () {\n                return zone.runGuarded(_callback, this, arguments, source);\n            };\n        };\n        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = null; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);\n            try {\n                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n            if (applyThis === void 0) { applyThis = null; }\n            if (applyArgs === void 0) { applyArgs = null; }\n            if (source === void 0) { source = null; }\n            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);\n            try {\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n            }\n        };\n        Zone.prototype.runTask = function (task, applyThis, applyArgs) {\n            task.runCount++;\n            if (task.zone != this)\n                throw new Error('A task can only be run in the zone which created it! (Creation: ' + task.zone.name +\n                    '; Execution: ' + this.name + ')');\n            var previousTask = _currentTask;\n            _currentTask = task;\n            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);\n            try {\n                if (task.type == 'macroTask' && task.data && !task.data.isPeriodic) {\n                    task.cancelFn = null;\n                }\n                try {\n                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                }\n                catch (error) {\n                    if (this._zoneDelegate.handleError(this, error)) {\n                        throw error;\n                    }\n                }\n            }\n            finally {\n                _currentZoneFrame = _currentZoneFrame.parent;\n                _currentTask = previousTask;\n            }\n        };\n        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n            return this._zoneDelegate.scheduleTask(this, new ZoneTask('microTask', this, source, callback, data, customSchedule, null));\n        };\n        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n            return this._zoneDelegate.scheduleTask(this, new ZoneTask('macroTask', this, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n            return this._zoneDelegate.scheduleTask(this, new ZoneTask('eventTask', this, source, callback, data, customSchedule, customCancel));\n        };\n        Zone.prototype.cancelTask = function (task) {\n            var value = this._zoneDelegate.cancelTask(this, task);\n            task.runCount = -1;\n            task.cancelFn = null;\n            return value;\n        };\n        return Zone;\n    }());\n    Zone.__symbol__ = __symbol__;\n    \n    var ZoneDelegate = (function () {\n        function ZoneDelegate(zone, parentDelegate, zoneSpec) {\n            this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 };\n            this.zone = zone;\n            this._parentDelegate = parentDelegate;\n            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\n            this._interceptZS =\n                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n            this._interceptDlgt =\n                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n            this._interceptCurrZone =\n                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\n            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n            this._invokeDlgt =\n                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\n            this._handleErrorZS =\n                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n            this._handleErrorDlgt =\n                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n            this._handleErrorCurrZone =\n                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\n            this._scheduleTaskZS =\n                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n            this._scheduleTaskDlgt =\n                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n            this._scheduleTaskCurrZone =\n                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\n            this._invokeTaskZS =\n                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n            this._invokeTaskDlgt =\n                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n            this._invokeTaskCurrZone =\n                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\n            this._cancelTaskZS =\n                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n            this._cancelTaskDlgt =\n                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n            this._cancelTaskCurrZone =\n                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\n            this._hasTaskZS = zoneSpec && (zoneSpec.onHasTask ? zoneSpec : parentDelegate._hasTaskZS);\n            this._hasTaskDlgt =\n                zoneSpec && (zoneSpec.onHasTask ? parentDelegate : parentDelegate._hasTaskDlgt);\n            this._hasTaskCurrZone = zoneSpec && (zoneSpec.onHasTask ? this.zone : parentDelegate.zone);\n        }\n        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :\n                new Zone(targetZone, zoneSpec);\n        };\n        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n            return this._interceptZS ?\n                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :\n                callback;\n        };\n        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n            return this._invokeZS ?\n                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :\n                callback.apply(applyThis, applyArgs);\n        };\n        ZoneDelegate.prototype.handleError = function (targetZone, error) {\n            return this._handleErrorZS ?\n                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :\n                true;\n        };\n        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n            try {\n                if (this._scheduleTaskZS) {\n                    return this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                }\n                else if (task.scheduleFn) {\n                    task.scheduleFn(task);\n                }\n                else if (task.type == 'microTask') {\n                    scheduleMicroTask(task);\n                }\n                else {\n                    throw new Error('Task is missing scheduleFn.');\n                }\n                return task;\n            }\n            finally {\n                if (targetZone == this.zone) {\n                    this._updateTaskCount(task.type, 1);\n                }\n            }\n        };\n        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n            try {\n                return this._invokeTaskZS ?\n                    this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :\n                    task.callback.apply(applyThis, applyArgs);\n            }\n            finally {\n                if (targetZone == this.zone && (task.type != 'eventTask') &&\n                    !(task.data && task.data.isPeriodic)) {\n                    this._updateTaskCount(task.type, -1);\n                }\n            }\n        };\n        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n            var value;\n            if (this._cancelTaskZS) {\n                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n            }\n            else if (!task.cancelFn) {\n                throw new Error('Task does not support cancellation, or is already canceled.');\n            }\n            else {\n                value = task.cancelFn(task);\n            }\n            if (targetZone == this.zone) {\n                // this should not be in the finally block, because exceptions assume not canceled.\n                this._updateTaskCount(task.type, -1);\n            }\n            return value;\n        };\n        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n            return this._hasTaskZS &&\n                this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n        };\n        ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n            var counts = this._taskCounts;\n            var prev = counts[type];\n            var next = counts[type] = prev + count;\n            if (next < 0) {\n                throw new Error('More tasks executed then were scheduled.');\n            }\n            if (prev == 0 || next == 0) {\n                var isEmpty = {\n                    microTask: counts.microTask > 0,\n                    macroTask: counts.macroTask > 0,\n                    eventTask: counts.eventTask > 0,\n                    change: type\n                };\n                try {\n                    this.hasTask(this.zone, isEmpty);\n                }\n                finally {\n                    if (this._parentDelegate) {\n                        this._parentDelegate._updateTaskCount(type, count);\n                    }\n                }\n            }\n        };\n        return ZoneDelegate;\n    }());\n    var ZoneTask = (function () {\n        function ZoneTask(type, zone, source, callback, options, scheduleFn, cancelFn) {\n            this.runCount = 0;\n            this.type = type;\n            this.zone = zone;\n            this.source = source;\n            this.data = options;\n            this.scheduleFn = scheduleFn;\n            this.cancelFn = cancelFn;\n            this.callback = callback;\n            var self = this;\n            this.invoke = function () {\n                _numberOfNestedTaskFrames++;\n                try {\n                    return zone.runTask(self, this, arguments);\n                }\n                finally {\n                    if (_numberOfNestedTaskFrames == 1) {\n                        drainMicroTaskQueue();\n                    }\n                    _numberOfNestedTaskFrames--;\n                }\n            };\n        }\n        ZoneTask.prototype.toString = function () {\n            if (this.data && typeof this.data.handleId !== 'undefined') {\n                return this.data.handleId;\n            }\n            else {\n                return Object.prototype.toString.call(this);\n            }\n        };\n        // add toJSON method to prevent cyclic error when\n        // call JSON.stringify(zoneTask)\n        ZoneTask.prototype.toJSON = function () {\n            return {\n                type: this.type,\n                source: this.source,\n                data: this.data,\n                zone: this.zone.name,\n                invoke: this.invoke,\n                scheduleFn: this.scheduleFn,\n                cancelFn: this.cancelFn,\n                runCount: this.runCount,\n                callback: this.callback\n            };\n        };\n        return ZoneTask;\n    }());\n    var ZoneFrame = (function () {\n        function ZoneFrame(parent, zone) {\n            this.parent = parent;\n            this.zone = zone;\n        }\n        return ZoneFrame;\n    }());\n    function __symbol__(name) {\n        return '__zone_symbol__' + name;\n    }\n    \n    var symbolSetTimeout = __symbol__('setTimeout');\n    var symbolPromise = __symbol__('Promise');\n    var symbolThen = __symbol__('then');\n    var _currentZoneFrame = new ZoneFrame(null, new Zone(null, null));\n    var _currentTask = null;\n    var _microTaskQueue = [];\n    var _isDrainingMicrotaskQueue = false;\n    var _uncaughtPromiseErrors = [];\n    var _numberOfNestedTaskFrames = 0;\n    function scheduleQueueDrain() {\n        // if we are not running in any task, and there has not been anything scheduled\n        // we must bootstrap the initial task creation by manually scheduling the drain\n        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n            // We are not running in Task, so we need to kickstart the microtask queue.\n            if (global[symbolPromise]) {\n                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);\n            }\n            else {\n                global[symbolSetTimeout](drainMicroTaskQueue, 0);\n            }\n        }\n    }\n    function scheduleMicroTask(task) {\n        scheduleQueueDrain();\n        _microTaskQueue.push(task);\n    }\n    function consoleError(e) {\n        var rejection = e && e.rejection;\n        if (rejection) {\n            console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n        }\n        console.error(e);\n    }\n    function drainMicroTaskQueue() {\n        if (!_isDrainingMicrotaskQueue) {\n            _isDrainingMicrotaskQueue = true;\n            while (_microTaskQueue.length) {\n                var queue = _microTaskQueue;\n                _microTaskQueue = [];\n                for (var i = 0; i < queue.length; i++) {\n                    var task = queue[i];\n                    try {\n                        task.zone.runTask(task, null, null);\n                    }\n                    catch (e) {\n                        consoleError(e);\n                    }\n                }\n            }\n            while (_uncaughtPromiseErrors.length) {\n                var _loop_1 = function () {\n                    var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n                    try {\n                        uncaughtPromiseError.zone.runGuarded(function () {\n                            throw uncaughtPromiseError;\n                        });\n                    }\n                    catch (e) {\n                        consoleError(e);\n                    }\n                };\n                while (_uncaughtPromiseErrors.length) {\n                    _loop_1();\n                }\n            }\n            _isDrainingMicrotaskQueue = false;\n        }\n    }\n    function isThenable(value) {\n        return value && value.then;\n    }\n    function forwardResolution(value) {\n        return value;\n    }\n    function forwardRejection(rejection) {\n        return ZoneAwarePromise.reject(rejection);\n    }\n    var symbolState = __symbol__('state');\n    var symbolValue = __symbol__('value');\n    var source = 'Promise.then';\n    var UNRESOLVED = null;\n    var RESOLVED = true;\n    var REJECTED = false;\n    var REJECTED_NO_CATCH = 0;\n    function makeResolver(promise, state) {\n        return function (v) {\n            resolvePromise(promise, state, v);\n            // Do not return value or you will break the Promise spec.\n        };\n    }\n    function resolvePromise(promise, state, value) {\n        if (promise[symbolState] === UNRESOLVED) {\n            if (value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) &&\n                value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n                clearRejectedNoCatch(value);\n                resolvePromise(promise, value[symbolState], value[symbolValue]);\n            }\n            else if (isThenable(value)) {\n                value.then(makeResolver(promise, state), makeResolver(promise, false));\n            }\n            else {\n                promise[symbolState] = state;\n                var queue = promise[symbolValue];\n                promise[symbolValue] = value;\n                for (var i = 0; i < queue.length;) {\n                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                }\n                if (queue.length == 0 && state == REJECTED) {\n                    promise[symbolState] = REJECTED_NO_CATCH;\n                    try {\n                        throw new Error('Uncaught (in promise): ' + value +\n                            (value && value.stack ? '\\n' + value.stack : ''));\n                    }\n                    catch (e) {\n                        var error_1 = e;\n                        error_1.rejection = value;\n                        error_1.promise = promise;\n                        error_1.zone = Zone.current;\n                        error_1.task = Zone.currentTask;\n                        _uncaughtPromiseErrors.push(error_1);\n                        scheduleQueueDrain();\n                    }\n                }\n            }\n        }\n        // Resolving an already resolved promise is a noop.\n        return promise;\n    }\n    function clearRejectedNoCatch(promise) {\n        if (promise[symbolState] === REJECTED_NO_CATCH) {\n            promise[symbolState] = REJECTED;\n            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                if (promise === _uncaughtPromiseErrors[i].promise) {\n                    _uncaughtPromiseErrors.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n        clearRejectedNoCatch(promise);\n        var delegate = promise[symbolState] ? onFulfilled || forwardResolution : onRejected || forwardRejection;\n        zone.scheduleMicroTask(source, function () {\n            try {\n                resolvePromise(chainPromise, true, zone.run(delegate, null, [promise[symbolValue]]));\n            }\n            catch (error) {\n                resolvePromise(chainPromise, false, error);\n            }\n        });\n    }\n    var ZoneAwarePromise = (function () {\n        function ZoneAwarePromise(executor) {\n            var promise = this;\n            if (!(promise instanceof ZoneAwarePromise)) {\n                throw new Error('Must be an instanceof Promise.');\n            }\n            promise[symbolState] = UNRESOLVED;\n            promise[symbolValue] = []; // queue;\n            try {\n                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n            }\n            catch (e) {\n                resolvePromise(promise, false, e);\n            }\n        }\n        ZoneAwarePromise.toString = function () {\n            return 'function ZoneAwarePromise() { [native code] }';\n        };\n        ZoneAwarePromise.resolve = function (value) {\n            return resolvePromise(new this(null), RESOLVED, value);\n        };\n        ZoneAwarePromise.reject = function (error) {\n            return resolvePromise(new this(null), REJECTED, error);\n        };\n        ZoneAwarePromise.race = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                _a = [res, rej], resolve = _a[0], reject = _a[1];\n                var _a;\n            });\n            function onResolve(value) {\n                promise && (promise =  false || resolve(value));\n            }\n            function onReject(error) {\n                promise && (promise =  false || reject(error));\n            }\n            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                var value = values_1[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then(onResolve, onReject);\n            }\n            return promise;\n        };\n        ZoneAwarePromise.all = function (values) {\n            var resolve;\n            var reject;\n            var promise = new this(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n            var count = 0;\n            var resolvedValues = [];\n            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                var value = values_2[_i];\n                if (!isThenable(value)) {\n                    value = this.resolve(value);\n                }\n                value.then((function (index) { return function (value) {\n                    resolvedValues[index] = value;\n                    count--;\n                    if (!count) {\n                        resolve(resolvedValues);\n                    }\n                }; })(count), reject);\n                count++;\n            }\n            if (!count)\n                resolve(resolvedValues);\n            return promise;\n        };\n        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n            var chainPromise = new this.constructor(null);\n            var zone = Zone.current;\n            if (this[symbolState] == UNRESOLVED) {\n                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n            }\n            else {\n                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n            }\n            return chainPromise;\n        };\n        ZoneAwarePromise.prototype.catch = function (onRejected) {\n            return this.then(null, onRejected);\n        };\n        return ZoneAwarePromise;\n    }());\n    // Protect against aggressive optimizers dropping seemingly unused properties.\n    // E.g. Closure Compiler in advanced mode.\n    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n    ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n    ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n    var NativePromise = global[__symbol__('Promise')] = global['Promise'];\n    global['Promise'] = ZoneAwarePromise;\n    function patchThen(NativePromise) {\n        var NativePromiseProtototype = NativePromise.prototype;\n        var NativePromiseThen = NativePromiseProtototype[__symbol__('then')] =\n            NativePromiseProtototype.then;\n        NativePromiseProtototype.then = function (onResolve, onReject) {\n            var nativePromise = this;\n            return new ZoneAwarePromise(function (resolve, reject) {\n                NativePromiseThen.call(nativePromise, resolve, reject);\n            })\n                .then(onResolve, onReject);\n        };\n    }\n    if (NativePromise) {\n        patchThen(NativePromise);\n        if (typeof global['fetch'] !== 'undefined') {\n            var fetchPromise = void 0;\n            try {\n                // In MS Edge this throws\n                fetchPromise = global['fetch']();\n            }\n            catch (e) {\n                // In Chrome this throws instead.\n                fetchPromise = global['fetch']('about:blank');\n            }\n            // ignore output to prevent error;\n            fetchPromise.then(function () { return null; }, function () { return null; });\n            if (fetchPromise.constructor != NativePromise &&\n                fetchPromise.constructor != ZoneAwarePromise) {\n                patchThen(fetchPromise.constructor);\n            }\n        }\n    }\n    // This is not part of public API, but it is usefull for tests, so we expose it.\n    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    var FrameType;\n    (function (FrameType) {\n        /// Skip this frame when printing out stack\n        FrameType[FrameType[\"blackList\"] = 0] = \"blackList\";\n        /// This frame marks zone transition\n        FrameType[FrameType[\"transition\"] = 1] = \"transition\";\n    })(FrameType || (FrameType = {}));\n    var NativeError = global[__symbol__('Error')] = global.Error;\n    // Store the frames which should be removed from the stack frames\n    var blackListedStackFrames = {};\n    // We must find the frame where Error was created, otherwise we assume we don't understand stack\n    var zoneAwareFrame;\n    global.Error = ZoneAwareError;\n    // How should the stack frames be parsed.\n    var frameParserStrategy = null;\n    var stackRewrite = 'stackRewrite';\n    // fix #595, create property descriptor\n    // for error properties\n    var createProperty = function (props, key) {\n        // if property is already defined, skip it.\n        if (props[key]) {\n            return;\n        }\n        // define a local property\n        // in case error property is not settable\n        var name = __symbol__(key);\n        props[key] = {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                // if local property has no value\n                // use internal error's property value\n                if (!this[name]) {\n                    var error_2 = this[__symbol__('error')];\n                    if (error_2) {\n                        this[name] = error_2[key];\n                    }\n                }\n                return this[name];\n            },\n            set: function (value) {\n                // setter will set value to local property value\n                this[name] = value;\n            }\n        };\n    };\n    // fix #595, create property descriptor\n    // for error method properties\n    var createMethodProperty = function (props, key) {\n        if (props[key]) {\n            return;\n        }\n        props[key] = {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: function () {\n                var error = this[__symbol__('error')];\n                var errorMethod = (error && error[key]) || this[key];\n                if (errorMethod) {\n                    return errorMethod.apply(error, arguments);\n                }\n            }\n        };\n    };\n    var createErrorProperties = function () {\n        var props = Object.create(null);\n        var error = new NativeError();\n        var keys = Object.getOwnPropertyNames(error);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(error, key)) {\n                createProperty(props, key);\n            }\n        }\n        var proto = NativeError.prototype;\n        if (proto) {\n            var pKeys = Object.getOwnPropertyNames(proto);\n            for (var i = 0; i < pKeys.length; i++) {\n                var key = pKeys[i];\n                // skip constructor\n                if (key !== 'constructor' && key !== 'toString' && key !== 'toSource') {\n                    createProperty(props, key);\n                }\n            }\n        }\n        // some other properties are not\n        // in NativeError\n        createProperty(props, 'originalStack');\n        createProperty(props, 'zoneAwareStack');\n        // define toString, toSource as method property\n        createMethodProperty(props, 'toString');\n        createMethodProperty(props, 'toSource');\n        return props;\n    };\n    var errorProperties = createErrorProperties();\n    // for derived Error class which extends ZoneAwareError\n    // we should not override the derived class's property\n    // so we create a new props object only copy the properties\n    // from errorProperties which not exist in derived Error's prototype\n    var getErrorPropertiesForPrototype = function (prototype) {\n        // if the prototype is ZoneAwareError.prototype\n        // we just return the prebuilt errorProperties.\n        if (prototype === ZoneAwareError.prototype) {\n            return errorProperties;\n        }\n        var newProps = Object.create(null);\n        var cKeys = Object.getOwnPropertyNames(errorProperties);\n        var keys = Object.getOwnPropertyNames(prototype);\n        cKeys.forEach(function (cKey) {\n            if (keys.filter(function (key) {\n                return key === cKey;\n            })\n                .length === 0) {\n                newProps[cKey] = errorProperties[cKey];\n            }\n        });\n        return newProps;\n    };\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n    function ZoneAwareError() {\n        // make sure we have a valid this\n        // if this is undefined(call Error without new) or this is global\n        // or this is some other objects, we should force to create a\n        // valid ZoneAwareError by call Object.create()\n        if (!(this instanceof ZoneAwareError)) {\n            return ZoneAwareError.apply(Object.create(ZoneAwareError.prototype), arguments);\n        }\n        // Create an Error.\n        var error = NativeError.apply(this, arguments);\n        this[__symbol__('error')] = error;\n        // Save original stack trace\n        error.originalStack = error.stack;\n        // Process the stack trace and rewrite the frames.\n        if (ZoneAwareError[stackRewrite] && error.originalStack) {\n            var frames_1 = error.originalStack.split('\\n');\n            var zoneFrame = _currentZoneFrame;\n            var i = 0;\n            // Find the first frame\n            while (frames_1[i] !== zoneAwareFrame && i < frames_1.length) {\n                i++;\n            }\n            for (; i < frames_1.length && zoneFrame; i++) {\n                var frame = frames_1[i];\n                if (frame.trim()) {\n                    var frameType = blackListedStackFrames.hasOwnProperty(frame) && blackListedStackFrames[frame];\n                    if (frameType === FrameType.blackList) {\n                        frames_1.splice(i, 1);\n                        i--;\n                    }\n                    else if (frameType === FrameType.transition) {\n                        if (zoneFrame.parent) {\n                            // This is the special frame where zone changed. Print and process it accordingly\n                            frames_1[i] += \" [\" + zoneFrame.parent.zone.name + \" => \" + zoneFrame.zone.name + \"]\";\n                            zoneFrame = zoneFrame.parent;\n                        }\n                        else {\n                            zoneFrame = null;\n                        }\n                    }\n                    else {\n                        frames_1[i] += \" [\" + zoneFrame.zone.name + \"]\";\n                    }\n                }\n            }\n            error.stack = error.zoneAwareStack = frames_1.join('\\n');\n        }\n        // use defineProperties here instead of copy property value\n        // because of issue #595 which will break angular2.\n        Object.defineProperties(this, getErrorPropertiesForPrototype(Object.getPrototypeOf(this)));\n        return this;\n    }\n    // Copy the prototype so that instanceof operator works as expected\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[Zone.__symbol__('blacklistedStackFrames')] = blackListedStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n        // Extend default stack limit as we will be removing few frames.\n        NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n        // make sure that ZoneAwareError has the same property which forwards to NativeError.\n        Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n            get: function () {\n                return NativeError.stackTraceLimit;\n            },\n            set: function (value) {\n                return NativeError.stackTraceLimit = value;\n            }\n        });\n    }\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n        Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n            // add named function here because we need to remove this\n            // stack frame when prepareStackTrace below\n            value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n                NativeError.captureStackTrace(targetObject, constructorOpt);\n            }\n        });\n    }\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n        get: function () {\n            return NativeError.prepareStackTrace;\n        },\n        set: function (value) {\n            if (!value || typeof value !== 'function') {\n                return NativeError.prepareStackTrace = value;\n            }\n            return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n                // remove additional stack information from ZoneAwareError.captureStackTrace\n                if (structuredStackTrace) {\n                    for (var i = 0; i < structuredStackTrace.length; i++) {\n                        var st = structuredStackTrace[i];\n                        // remove the first function which name is zoneCaptureStackTrace\n                        if (st.getFunctionName() === 'zoneCaptureStackTrace') {\n                            structuredStackTrace.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                return value.apply(this, [error, structuredStackTrace]);\n            };\n        }\n    });\n    // Now we need to populet the `blacklistedStackFrames` as well as find the\n    // run/runGuraded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n    var detectZone = Zone.current.fork({\n        name: 'detect',\n        onInvoke: function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            // Here only so that it will show up in the stack frame so that it can be black listed.\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        },\n        onHandleError: function (parentZD, current, target, error) {\n            if (error.originalStack && Error === ZoneAwareError) {\n                var frames_2 = error.originalStack.split(/\\n/);\n                var runFrame = false, runGuardedFrame = false, runTaskFrame = false;\n                while (frames_2.length) {\n                    var frame = frames_2.shift();\n                    // On safari it is possible to have stack frame with no line number.\n                    // This check makes sure that we don't filter frames on name only (must have\n                    // linenumber)\n                    if (/:\\d+:\\d+/.test(frame)) {\n                        // Get rid of the path so that we don't accidintely find function name in path.\n                        // In chrome the seperator is `(` and `@` in FF and safari\n                        // Chrome: at Zone.run (zone.js:100)\n                        // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n                        // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        var fnName = frame.split('(')[0].split('@')[0];\n                        var frameType = FrameType.transition;\n                        if (fnName.indexOf('ZoneAwareError') !== -1) {\n                            zoneAwareFrame = frame;\n                        }\n                        if (fnName.indexOf('runGuarded') !== -1) {\n                            runGuardedFrame = true;\n                        }\n                        else if (fnName.indexOf('runTask') !== -1) {\n                            runTaskFrame = true;\n                        }\n                        else if (fnName.indexOf('run') !== -1) {\n                            runFrame = true;\n                        }\n                        else {\n                            frameType = FrameType.blackList;\n                        }\n                        blackListedStackFrames[frame] = frameType;\n                        // Once we find all of the frames we can stop looking.\n                        if (runFrame && runGuardedFrame && runTaskFrame) {\n                            ZoneAwareError[stackRewrite] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and blacklisted.\n    var detectRunFn = function () {\n        detectZone.run(function () {\n            detectZone.runGuarded(function () {\n                throw new Error('blacklistStackFrames');\n            });\n        });\n    };\n    // Cause the error to extract the stack frames.\n    detectZone.runTask(detectZone.scheduleMacroTask('detect', detectRunFn, null, function () { return null; }, null));\n    return global['Zone'] = Zone;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars}\n */\nvar zoneSymbol = function (n) { return \"__zone_symbol__\" + n; };\nvar _global$1 = typeof window === 'object' && window || typeof self === 'object' && self || global;\nfunction bindArguments(args, source) {\n    for (var i = args.length - 1; i >= 0; i--) {\n        if (typeof args[i] === 'function') {\n            args[i] = Zone.current.wrap(args[i], source + '_' + i);\n        }\n    }\n    return args;\n}\n\n\nvar isNode = (!('nw' in _global$1) && typeof process !== 'undefined' &&\n    {}.toString.call(process) === '[object process]');\n\n\n\n\n\nvar EVENT_TASKS = zoneSymbol('eventTasks');\n// For EventTarget\nvar ADD_EVENT_LISTENER = 'addEventListener';\nvar REMOVE_EVENT_LISTENER = 'removeEventListener';\nfunction findExistingRegisteredTask(target, handler, name, capture, remove) {\n    var eventTasks = target[EVENT_TASKS];\n    if (eventTasks) {\n        for (var i = 0; i < eventTasks.length; i++) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            var listener = data.handler;\n            if ((data.handler === handler || listener.listener === handler) &&\n                data.useCapturing === capture && data.eventName === name) {\n                if (remove) {\n                    eventTasks.splice(i, 1);\n                }\n                return eventTask;\n            }\n        }\n    }\n    return null;\n}\nfunction findAllExistingRegisteredTasks(target, name, capture, remove) {\n    var eventTasks = target[EVENT_TASKS];\n    if (eventTasks) {\n        var result = [];\n        for (var i = eventTasks.length - 1; i >= 0; i--) {\n            var eventTask = eventTasks[i];\n            var data = eventTask.data;\n            if (data.eventName === name && data.useCapturing === capture) {\n                result.push(eventTask);\n                if (remove) {\n                    eventTasks.splice(i, 1);\n                }\n            }\n        }\n        return result;\n    }\n    return null;\n}\nfunction attachRegisteredEvent(target, eventTask, isPrepend) {\n    var eventTasks = target[EVENT_TASKS];\n    if (!eventTasks) {\n        eventTasks = target[EVENT_TASKS] = [];\n    }\n    if (isPrepend) {\n        eventTasks.unshift(eventTask);\n    }\n    else {\n        eventTasks.push(eventTask);\n    }\n}\nvar defaultListenerMetaCreator = function (self, args) {\n    return {\n        useCapturing: args[2],\n        eventName: args[0],\n        handler: args[1],\n        target: self || _global$1,\n        name: args[0],\n        invokeAddFunc: function (addFnSymbol, delegate) {\n            if (delegate && delegate.invoke) {\n                return this.target[addFnSymbol](this.eventName, delegate.invoke, this.useCapturing);\n            }\n            else {\n                return this.target[addFnSymbol](this.eventName, delegate, this.useCapturing);\n            }\n        },\n        invokeRemoveFunc: function (removeFnSymbol, delegate) {\n            if (delegate && delegate.invoke) {\n                return this.target[removeFnSymbol](this.eventName, delegate.invoke, this.useCapturing);\n            }\n            else {\n                return this.target[removeFnSymbol](this.eventName, delegate, this.useCapturing);\n            }\n        }\n    };\n};\nfunction makeZoneAwareAddListener(addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (allowDuplicates === void 0) { allowDuplicates = false; }\n    if (isPrepend === void 0) { isPrepend = false; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var addFnSymbol = zoneSymbol(addFnName);\n    var removeFnSymbol = zoneSymbol(removeFnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    function scheduleEventListener(eventTask) {\n        var meta = eventTask.data;\n        attachRegisteredEvent(meta.target, eventTask, isPrepend);\n        return meta.invokeAddFunc(addFnSymbol, eventTask);\n    }\n    function cancelEventListener(eventTask) {\n        var meta = eventTask.data;\n        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, true);\n        return meta.invokeRemoveFunc(removeFnSymbol, eventTask);\n    }\n    return function zoneAwareAddListener(self, args) {\n        var data = metaCreator(self, args);\n        data.useCapturing = data.useCapturing || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var delegate = null;\n        if (typeof data.handler == 'function') {\n            delegate = data.handler;\n        }\n        else if (data.handler && data.handler.handleEvent) {\n            delegate = function (event) { return data.handler.handleEvent(event); };\n        }\n        var validZoneHandler = false;\n        try {\n            // In cross site contexts (such as WebDriver frameworks like Selenium),\n            // accessing the handler object here will cause an exception to be thrown which\n            // will fail tests prematurely.\n            validZoneHandler = data.handler && data.handler.toString() === '[object FunctionWrapper]';\n        }\n        catch (e) {\n            // Returning nothing here is fine, because objects in a cross-site context are unusable\n            return;\n        }\n        // Ignore special listeners of IE11 & Edge dev tools, see\n        // https://github.com/angular/zone.js/issues/150\n        if (!delegate || validZoneHandler) {\n            return data.invokeAddFunc(addFnSymbol, data.handler);\n        }\n        if (!allowDuplicates) {\n            var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.useCapturing, false);\n            if (eventTask) {\n                // we already registered, so this will have noop.\n                return data.invokeAddFunc(addFnSymbol, eventTask);\n            }\n        }\n        var zone = Zone.current;\n        var source = data.target.constructor['name'] + '.' + addFnName + ':' + data.eventName;\n        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);\n    };\n}\nfunction makeZoneAwareRemoveListener(fnName, useCapturingParam, metaCreator) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }\n    var symbol = zoneSymbol(fnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    return function zoneAwareRemoveListener(self, args) {\n        var data = metaCreator(self, args);\n        data.useCapturing = data.useCapturing || defaultUseCapturing;\n        // - Inside a Web Worker, `this` is undefined, the context is `global`\n        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined\n        // see https://github.com/angular/zone.js/issues/190\n        var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.useCapturing, true);\n        if (eventTask) {\n            eventTask.zone.cancelTask(eventTask);\n        }\n        else {\n            data.invokeRemoveFunc(symbol, data.handler);\n        }\n    };\n}\nfunction makeZoneAwareRemoveAllListeners(fnName, useCapturingParam) {\n    if (useCapturingParam === void 0) { useCapturingParam = true; }\n    var symbol = zoneSymbol(fnName);\n    var defaultUseCapturing = useCapturingParam ? false : undefined;\n    return function zoneAwareRemoveAllListener(self, args) {\n        var target = self || _global$1;\n        if (args.length === 0) {\n            // remove all listeners without eventName\n            target[EVENT_TASKS] = [];\n            // we don't cancel Task either, because call native eventEmitter.removeAllListeners will\n            // will do remove listener(cancelTask) for us\n            target[symbol]();\n            return;\n        }\n        var eventName = args[0];\n        var useCapturing = args[1] || defaultUseCapturing;\n        // call this function just remove the related eventTask from target[EVENT_TASKS]\n        findAllExistingRegisteredTasks(target, eventName, useCapturing, true);\n        // we don't need useCapturing here because useCapturing is just for DOM, and\n        // removeAllListeners should only be called by node eventEmitter\n        // and we don't cancel Task either, because call native eventEmitter.removeAllListeners will\n        // will do remove listener(cancelTask) for us\n        target[symbol](eventName);\n    };\n}\nfunction makeZoneAwareListeners(fnName) {\n    var symbol = zoneSymbol(fnName);\n    return function zoneAwareEventListeners(self, args) {\n        var eventName = args[0];\n        var target = self || _global$1;\n        if (!target[EVENT_TASKS]) {\n            return [];\n        }\n        return target[EVENT_TASKS]\n            .filter(function (task) { return task.data.eventName === eventName; })\n            .map(function (task) { return task.data.handler; });\n    };\n}\nvar zoneAwareAddEventListener = makeZoneAwareAddListener(ADD_EVENT_LISTENER, REMOVE_EVENT_LISTENER);\nvar zoneAwareRemoveEventListener = makeZoneAwareRemoveListener(REMOVE_EVENT_LISTENER);\n\nvar originalInstanceKey = zoneSymbol('originalInstance');\n// wrap some native API on `window`\n\n\nfunction createNamedFn(name, delegate) {\n    try {\n        return (Function('f', \"return function \" + name + \"(){return f(this, arguments)}\"))(delegate);\n    }\n    catch (e) {\n        // if we fail, we must be CSP, just return delegate.\n        return function () {\n            return delegate(this, arguments);\n        };\n    }\n}\nfunction patchMethod(target, name, patchFn) {\n    var proto = target;\n    while (proto && Object.getOwnPropertyNames(proto).indexOf(name) === -1) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    if (!proto && target[name]) {\n        // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n        proto = target;\n    }\n    var delegateName = zoneSymbol(name);\n    var delegate;\n    if (proto && !(delegate = proto[delegateName])) {\n        delegate = proto[delegateName] = proto[name];\n        proto[name] = createNamedFn(name, patchFn(delegate, delegateName, name));\n    }\n    return delegate;\n}\n// TODO: support cancel task later if necessary\nfunction patchMacroTask(obj, funcName, metaCreator) {\n    var setNative = null;\n    function scheduleTask(task) {\n        var data = task.data;\n        data.args[data.callbackIndex] = function () {\n            task.invoke.apply(this, arguments);\n        };\n        setNative.apply(data.target, data.args);\n        return task;\n    }\n    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {\n        var meta = metaCreator(self, args);\n        if (meta.callbackIndex >= 0 && typeof args[meta.callbackIndex] === 'function') {\n            var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);\n            return task;\n        }\n        else {\n            // cause an error by calling it directly.\n            return delegate.apply(self, args);\n        }\n    }; });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar callAndReturnFirstParam = function (fn) {\n    return function (self, args) {\n        fn(self, args);\n        return self;\n    };\n};\n// For EventEmitter\nvar EE_ADD_LISTENER = 'addListener';\nvar EE_PREPEND_LISTENER = 'prependListener';\nvar EE_REMOVE_LISTENER = 'removeListener';\nvar EE_REMOVE_ALL_LISTENER = 'removeAllListeners';\nvar EE_LISTENERS = 'listeners';\nvar EE_ON = 'on';\nvar zoneAwareAddListener$1 = callAndReturnFirstParam(makeZoneAwareAddListener(EE_ADD_LISTENER, EE_REMOVE_LISTENER, false, true, false));\nvar zoneAwarePrependListener = callAndReturnFirstParam(makeZoneAwareAddListener(EE_PREPEND_LISTENER, EE_REMOVE_LISTENER, false, true, true));\nvar zoneAwareRemoveListener$1 = callAndReturnFirstParam(makeZoneAwareRemoveListener(EE_REMOVE_LISTENER, false));\nvar zoneAwareRemoveAllListeners = callAndReturnFirstParam(makeZoneAwareRemoveAllListeners(EE_REMOVE_ALL_LISTENER, false));\nvar zoneAwareListeners = makeZoneAwareListeners(EE_LISTENERS);\nfunction patchEventEmitterMethods(obj) {\n    if (obj && obj.addListener) {\n        patchMethod(obj, EE_ADD_LISTENER, function () { return zoneAwareAddListener$1; });\n        patchMethod(obj, EE_PREPEND_LISTENER, function () { return zoneAwarePrependListener; });\n        patchMethod(obj, EE_REMOVE_LISTENER, function () { return zoneAwareRemoveListener$1; });\n        patchMethod(obj, EE_REMOVE_ALL_LISTENER, function () { return zoneAwareRemoveAllListeners; });\n        patchMethod(obj, EE_LISTENERS, function () { return zoneAwareListeners; });\n        obj[EE_ON] = obj[EE_ADD_LISTENER];\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n// EventEmitter\nvar events;\ntry {\n    events = __webpack_require__(/*! events */ \"events\");\n}\ncatch (err) {\n}\nif (events && events.EventEmitter) {\n    patchEventEmitterMethods(events.EventEmitter.prototype);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar fs;\ntry {\n    fs = __webpack_require__(/*! fs */ \"fs\");\n}\ncatch (err) {\n}\n// watch, watchFile, unwatchFile has been patched\n// because EventEmitter has been patched\nvar TO_PATCH_MACROTASK_METHODS = [\n    'access', 'appendFile', 'chmod', 'chown', 'close', 'exists', 'fchmod',\n    'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod',\n    'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'read',\n    'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rmdir', 'stat',\n    'symlink', 'truncate', 'unlink', 'utimes', 'write', 'writeFile',\n];\nif (fs) {\n    TO_PATCH_MACROTASK_METHODS.filter(function (name) { return !!fs[name] && typeof fs[name] === 'function'; })\n        .forEach(function (name) {\n        patchMacroTask(fs, name, function (self, args) {\n            return {\n                name: 'fs.' + name,\n                args: args,\n                callbackIndex: args.length > 0 ? args.length - 1 : -1,\n                target: self\n            };\n        });\n    });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n    var setNative = null;\n    var clearNative = null;\n    setName += nameSuffix;\n    cancelName += nameSuffix;\n    var tasksByHandleId = {};\n    function scheduleTask(task) {\n        var data = task.data;\n        data.args[0] = function () {\n            task.invoke.apply(this, arguments);\n            delete tasksByHandleId[data.handleId];\n        };\n        data.handleId = setNative.apply(window, data.args);\n        tasksByHandleId[data.handleId] = task;\n        return task;\n    }\n    function clearTask(task) {\n        delete tasksByHandleId[task.data.handleId];\n        return clearNative(task.data.handleId);\n    }\n    setNative =\n        patchMethod(window, setName, function (delegate) { return function (self, args) {\n            if (typeof args[0] === 'function') {\n                var zone = Zone.current;\n                var options = {\n                    handleId: null,\n                    isPeriodic: nameSuffix === 'Interval',\n                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,\n                    args: args\n                };\n                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);\n                if (!task) {\n                    return task;\n                }\n                // Node.js must additionally support the ref and unref functions.\n                var handle = task.data.handleId;\n                if (handle.ref && handle.unref) {\n                    task.ref = handle.ref.bind(handle);\n                    task.unref = handle.unref.bind(handle);\n                }\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(window, args);\n            }\n        }; });\n    clearNative =\n        patchMethod(window, cancelName, function (delegate) { return function (self, args) {\n            var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];\n            if (task && typeof task.type === 'string') {\n                if (task.cancelFn && task.data.isPeriodic || task.runCount === 0) {\n                    // Do not cancel already canceled functions\n                    task.zone.cancelTask(task);\n                }\n            }\n            else {\n                // cause an error by calling it directly.\n                delegate.apply(window, args);\n            }\n        }; });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar set = 'set';\nvar clear = 'clear';\nvar _global = typeof window === 'object' && window || typeof self === 'object' && self || global;\n// Timers\nvar timers = __webpack_require__(/*! timers */ \"timers\");\npatchTimer(timers, set, clear, 'Timeout');\npatchTimer(timers, set, clear, 'Interval');\npatchTimer(timers, set, clear, 'Immediate');\nvar shouldPatchGlobalTimers = global.setTimeout !== timers.setTimeout;\nif (shouldPatchGlobalTimers) {\n    patchTimer(_global, set, clear, 'Timeout');\n    patchTimer(_global, set, clear, 'Interval');\n    patchTimer(_global, set, clear, 'Immediate');\n}\npatchNextTick();\n// Crypto\nvar crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n}\ncatch (err) {\n}\n// TODO(gdi2290): implement a better way to patch these methods\nif (crypto) {\n    var nativeRandomBytes_1 = crypto.randomBytes;\n    crypto.randomBytes = function randomBytesZone(size, callback) {\n        if (!callback) {\n            return nativeRandomBytes_1(size);\n        }\n        else {\n            var zone = Zone.current;\n            var source = crypto.constructor.name + '.randomBytes';\n            return nativeRandomBytes_1(size, zone.wrap(callback, source));\n        }\n    }.bind(crypto);\n    var nativePbkdf2_1 = crypto.pbkdf2;\n    crypto.pbkdf2 = function pbkdf2Zone() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var fn = args[args.length - 1];\n        if (typeof fn === 'function') {\n            var zone = Zone.current;\n            var source = crypto.constructor.name + '.pbkdf2';\n            args[args.length - 1] = zone.wrap(fn, source);\n            return nativePbkdf2_1.apply(void 0, args);\n        }\n        else {\n            return nativePbkdf2_1.apply(void 0, args);\n        }\n    }.bind(crypto);\n}\n// HTTP Client\nvar httpClient;\ntry {\n    httpClient = __webpack_require__(/*! _http_client */ \"_http_client\");\n}\ncatch (err) {\n}\nif (httpClient && httpClient.ClientRequest) {\n    var ClientRequest_1 = httpClient.ClientRequest.bind(httpClient);\n    httpClient.ClientRequest = function (options, callback) {\n        if (!callback) {\n            return new ClientRequest_1(options);\n        }\n        else {\n            var zone = Zone.current;\n            return new ClientRequest_1(options, zone.wrap(callback, 'http.ClientRequest'));\n        }\n    };\n}\nfunction patchNextTick() {\n    var setNative = null;\n    function scheduleTask(task) {\n        var args = task.data;\n        args[0] = function () {\n            task.invoke.apply(this, arguments);\n        };\n        setNative.apply(process, args);\n        return task;\n    }\n    setNative =\n        patchMethod(process, 'nextTick', function (delegate) { return function (self, args) {\n            if (typeof args[0] === 'function') {\n                var zone = Zone.current;\n                var task = zone.scheduleMicroTask('nextTick', args[0], args, scheduleTask);\n                return task;\n            }\n            else {\n                // cause an error by calling it directly.\n                return delegate.apply(process, args);\n            }\n        }; });\n}\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvem9uZS5qcy9kaXN0L3pvbmUtbm9kZS5qcy5qcyIsInNvdXJjZXMiOlsiLi4vLi9ub2RlX21vZHVsZXMvem9uZS5qcy9kaXN0L3pvbmUtbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQGxpY2Vuc2VcbiogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4qXG4qIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4qIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cblxudmFyIFpvbmUkMSA9IChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgaWYgKGdsb2JhbFsnWm9uZSddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWm9uZSBhbHJlYWR5IGxvYWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIFpvbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBab25lKHBhcmVudCwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHpvbmVTcGVjID8gem9uZVNwZWMubmFtZSB8fCAndW5uYW1lZCcgOiAnPHJvb3Q+JztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB6b25lU3BlYyAmJiB6b25lU3BlYy5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5fem9uZURlbGVnYXRlID1cbiAgICAgICAgICAgICAgICBuZXcgWm9uZURlbGVnYXRlKHRoaXMsIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX3pvbmVEZWxlZ2F0ZSwgem9uZVNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIFpvbmUuYXNzZXJ0Wm9uZVBhdGNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLlByb21pc2UgIT09IFpvbmVBd2FyZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmUuanMgaGFzIGRldGVjdGVkIHRoYXQgWm9uZUF3YXJlUHJvbWlzZSBgKHdpbmRvd3xnbG9iYWwpLlByb21pc2VgICcgK1xuICAgICAgICAgICAgICAgICAgICAnaGFzIGJlZW4gb3ZlcndyaXR0ZW4uXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdNb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IGEgUHJvbWlzZSBwb2x5ZmlsbCBoYXMgYmVlbiBsb2FkZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciBab25lLmpzIChQb2x5ZmlsbGluZyBQcm9taXNlIGFwaSBpcyBub3QgbmVjZXNzYXJ5IHdoZW4gem9uZS5qcyBpcyBsb2FkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnSWYgeW91IG11c3QgbG9hZCBvbmUsIGRvIHNvIGJlZm9yZSBsb2FkaW5nIHpvbmUuanMuKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZSwgXCJjdXJyZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycmVudFpvbmVGcmFtZS56b25lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZSwgXCJjdXJyZW50VGFza1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRUYXNrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab25lLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBab25lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMuZ2V0Wm9uZVdpdGgoa2V5KTtcbiAgICAgICAgICAgIGlmICh6b25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB6b25lLl9wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLmdldFpvbmVXaXRoID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5fcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiAoem9uZVNwZWMpIHtcbiAgICAgICAgICAgIGlmICghem9uZVNwZWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lU3BlYyByZXF1aXJlZCEnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuZm9yayh0aGlzLCB6b25lU3BlYyk7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIGZ1bmN0aW9uIGdvdDogJyArIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfY2FsbGJhY2sgPSB0aGlzLl96b25lRGVsZWdhdGUuaW50ZXJjZXB0KHRoaXMsIGNhbGxiYWNrLCBzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gem9uZS5ydW5HdWFyZGVkKF9jYWxsYmFjaywgdGhpcywgYXJndW1lbnRzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoYXBwbHlUaGlzID09PSB2b2lkIDApIHsgYXBwbHlUaGlzID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFwcGx5QXJncyA9PT0gdm9pZCAwKSB7IGFwcGx5QXJncyA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IHZvaWQgMCkgeyBzb3VyY2UgPSBudWxsOyB9XG4gICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IG5ldyBab25lRnJhbWUoX2N1cnJlbnRab25lRnJhbWUsIHRoaXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZURlbGVnYXRlLmludm9rZSh0aGlzLCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IF9jdXJyZW50Wm9uZUZyYW1lLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGFwcGx5VGhpcyA9PT0gdm9pZCAwKSB7IGFwcGx5VGhpcyA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhcHBseUFyZ3MgPT09IHZvaWQgMCkgeyBhcHBseUFyZ3MgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB2b2lkIDApIHsgc291cmNlID0gbnVsbDsgfVxuICAgICAgICAgICAgX2N1cnJlbnRab25lRnJhbWUgPSBuZXcgWm9uZUZyYW1lKF9jdXJyZW50Wm9uZUZyYW1lLCB0aGlzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmVEZWxlZ2F0ZS5pbnZva2UodGhpcywgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvbmVEZWxlZ2F0ZS5oYW5kbGVFcnJvcih0aGlzLCBlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRab25lRnJhbWUgPSBfY3VycmVudFpvbmVGcmFtZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLnJ1blRhc2sgPSBmdW5jdGlvbiAodGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgIHRhc2sucnVuQ291bnQrKztcbiAgICAgICAgICAgIGlmICh0YXNrLnpvbmUgIT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFzayBjYW4gb25seSBiZSBydW4gaW4gdGhlIHpvbmUgd2hpY2ggY3JlYXRlZCBpdCEgKENyZWF0aW9uOiAnICsgdGFzay56b25lLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnOyBFeGVjdXRpb246ICcgKyB0aGlzLm5hbWUgKyAnKScpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzVGFzayA9IF9jdXJyZW50VGFzaztcbiAgICAgICAgICAgIF9jdXJyZW50VGFzayA9IHRhc2s7XG4gICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IG5ldyBab25lRnJhbWUoX2N1cnJlbnRab25lRnJhbWUsIHRoaXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGFzay50eXBlID09ICdtYWNyb1Rhc2snICYmIHRhc2suZGF0YSAmJiAhdGFzay5kYXRhLmlzUGVyaW9kaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5jYW5jZWxGbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuaW52b2tlVGFzayh0aGlzLCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fem9uZURlbGVnYXRlLmhhbmRsZUVycm9yKHRoaXMsIGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IF9jdXJyZW50Wm9uZUZyYW1lLnBhcmVudDtcbiAgICAgICAgICAgICAgICBfY3VycmVudFRhc2sgPSBwcmV2aW91c1Rhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLnNjaGVkdWxlTWljcm9UYXNrID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZURlbGVnYXRlLnNjaGVkdWxlVGFzayh0aGlzLCBuZXcgWm9uZVRhc2soJ21pY3JvVGFzaycsIHRoaXMsIHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBudWxsKSk7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmUucHJvdG90eXBlLnNjaGVkdWxlTWFjcm9UYXNrID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuc2NoZWR1bGVUYXNrKHRoaXMsIG5ldyBab25lVGFzaygnbWFjcm9UYXNrJywgdGhpcywgc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCkpO1xuICAgICAgICB9O1xuICAgICAgICBab25lLnByb3RvdHlwZS5zY2hlZHVsZUV2ZW50VGFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZURlbGVnYXRlLnNjaGVkdWxlVGFzayh0aGlzLCBuZXcgWm9uZVRhc2soJ2V2ZW50VGFzaycsIHRoaXMsIHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZS5wcm90b3R5cGUuY2FuY2VsVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl96b25lRGVsZWdhdGUuY2FuY2VsVGFzayh0aGlzLCB0YXNrKTtcbiAgICAgICAgICAgIHRhc2sucnVuQ291bnQgPSAtMTtcbiAgICAgICAgICAgIHRhc2suY2FuY2VsRm4gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWm9uZTtcbiAgICB9KCkpO1xuICAgIFpvbmUuX19zeW1ib2xfXyA9IF9fc3ltYm9sX187XG4gICAgXG4gICAgdmFyIFpvbmVEZWxlZ2F0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFpvbmVEZWxlZ2F0ZSh6b25lLCBwYXJlbnREZWxlZ2F0ZSwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tDb3VudHMgPSB7IG1pY3JvVGFzazogMCwgbWFjcm9UYXNrOiAwLCBldmVudFRhc2s6IDAgfTtcbiAgICAgICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnREZWxlZ2F0ZSA9IHBhcmVudERlbGVnYXRlO1xuICAgICAgICAgICAgdGhpcy5fZm9ya1pTID0gem9uZVNwZWMgJiYgKHpvbmVTcGVjICYmIHpvbmVTcGVjLm9uRm9yayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2ZvcmtaUyk7XG4gICAgICAgICAgICB0aGlzLl9mb3JrRGxndCA9IHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkZvcmsgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9mb3JrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9mb3JrQ3VyclpvbmUgPSB6b25lU3BlYyAmJiAoem9uZVNwZWMub25Gb3JrID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuem9uZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRaUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5faW50ZXJjZXB0WlMpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0RGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5faW50ZXJjZXB0RGxndCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuem9uZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VaUyA9IHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZSA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2ludm9rZVpTKTtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZURsZ3QgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZSA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX2ludm9rZURsZ3QpO1xuICAgICAgICAgICAgdGhpcy5faW52b2tlQ3VyclpvbmUgPSB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnZva2UgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS56b25lKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yWlMgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5faGFuZGxlRXJyb3JaUyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvckRsZ3QgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5faGFuZGxlRXJyb3JEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuem9uZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRhc2taUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5fc2NoZWR1bGVUYXNrWlMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5fc2NoZWR1bGVUYXNrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRhc2tDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuem9uZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrWlMgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VUYXNrWlMpO1xuICAgICAgICAgICAgdGhpcy5faW52b2tlVGFza0RsZ3QgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VUYXNrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS56b25lKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2taUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2NhbmNlbFRhc2taUyk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUYXNrRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX2NhbmNlbFRhc2tEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2tDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHRoaXMuem9uZSA6IHBhcmVudERlbGVnYXRlLnpvbmUpO1xuICAgICAgICAgICAgdGhpcy5faGFzVGFza1pTID0gem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSGFzVGFzayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2hhc1Rhc2taUyk7XG4gICAgICAgICAgICB0aGlzLl9oYXNUYXNrRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSGFzVGFzayA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX2hhc1Rhc2tEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2tDdXJyWm9uZSA9IHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhc1Rhc2sgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS56b25lKTtcbiAgICAgICAgfVxuICAgICAgICBab25lRGVsZWdhdGUucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiAodGFyZ2V0Wm9uZSwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JrWlMgPyB0aGlzLl9mb3JrWlMub25Gb3JrKHRoaXMuX2ZvcmtEbGd0LCB0aGlzLnpvbmUsIHRhcmdldFpvbmUsIHpvbmVTcGVjKSA6XG4gICAgICAgICAgICAgICAgbmV3IFpvbmUodGFyZ2V0Wm9uZSwgem9uZVNwZWMpO1xuICAgICAgICB9O1xuICAgICAgICBab25lRGVsZWdhdGUucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uICh0YXJnZXRab25lLCBjYWxsYmFjaywgc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJjZXB0WlMgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdFpTLm9uSW50ZXJjZXB0KHRoaXMuX2ludGVyY2VwdERsZ3QsIHRoaXMuX2ludGVyY2VwdEN1cnJab25lLCB0YXJnZXRab25lLCBjYWxsYmFjaywgc291cmNlKSA6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmVEZWxlZ2F0ZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKHRhcmdldFpvbmUsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlWlMgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZVpTLm9uSW52b2tlKHRoaXMuX2ludm9rZURsZ3QsIHRoaXMuX2ludm9rZUN1cnJab25lLCB0YXJnZXRab25lLCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkgOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZURlbGVnYXRlLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uICh0YXJnZXRab25lLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUVycm9yWlMgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yWlMub25IYW5kbGVFcnJvcih0aGlzLl9oYW5kbGVFcnJvckRsZ3QsIHRoaXMuX2hhbmRsZUVycm9yQ3VyclpvbmUsIHRhcmdldFpvbmUsIGVycm9yKSA6XG4gICAgICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZURlbGVnYXRlLnByb3RvdHlwZS5zY2hlZHVsZVRhc2sgPSBmdW5jdGlvbiAodGFyZ2V0Wm9uZSwgdGFzaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2NoZWR1bGVUYXNrWlMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlVGFza1pTLm9uU2NoZWR1bGVUYXNrKHRoaXMuX3NjaGVkdWxlVGFza0RsZ3QsIHRoaXMuX3NjaGVkdWxlVGFza0N1cnJab25lLCB0YXJnZXRab25lLCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFzay5zY2hlZHVsZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suc2NoZWR1bGVGbih0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFzay50eXBlID09ICdtaWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXNrIGlzIG1pc3Npbmcgc2NoZWR1bGVGbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Wm9uZSA9PSB0aGlzLnpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFza0NvdW50KHRhc2sudHlwZSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBab25lRGVsZWdhdGUucHJvdG90eXBlLmludm9rZVRhc2sgPSBmdW5jdGlvbiAodGFyZ2V0Wm9uZSwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZVRhc2taUyA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2taUy5vbkludm9rZVRhc2sodGhpcy5faW52b2tlVGFza0RsZ3QsIHRoaXMuX2ludm9rZVRhc2tDdXJyWm9uZSwgdGFyZ2V0Wm9uZSwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIDpcbiAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseShhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Wm9uZSA9PSB0aGlzLnpvbmUgJiYgKHRhc2sudHlwZSAhPSAnZXZlbnRUYXNrJykgJiZcbiAgICAgICAgICAgICAgICAgICAgISh0YXNrLmRhdGEgJiYgdGFzay5kYXRhLmlzUGVyaW9kaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRhc2tDb3VudCh0YXNrLnR5cGUsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFpvbmVEZWxlZ2F0ZS5wcm90b3R5cGUuY2FuY2VsVGFzayA9IGZ1bmN0aW9uICh0YXJnZXRab25lLCB0YXNrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FuY2VsVGFza1pTKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYW5jZWxUYXNrWlMub25DYW5jZWxUYXNrKHRoaXMuX2NhbmNlbFRhc2tEbGd0LCB0aGlzLl9jYW5jZWxUYXNrQ3VyclpvbmUsIHRhcmdldFpvbmUsIHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRhc2suY2FuY2VsRm4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rhc2sgZG9lcyBub3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24sIG9yIGlzIGFscmVhZHkgY2FuY2VsZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRhc2suY2FuY2VsRm4odGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Wm9uZSA9PSB0aGlzLnpvbmUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBub3QgYmUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGJlY2F1c2UgZXhjZXB0aW9ucyBhc3N1bWUgbm90IGNhbmNlbGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRhc2tDb3VudCh0YXNrLnR5cGUsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZURlbGVnYXRlLnByb3RvdHlwZS5oYXNUYXNrID0gZnVuY3Rpb24gKHRhcmdldFpvbmUsIGlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNUYXNrWlMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUYXNrWlMub25IYXNUYXNrKHRoaXMuX2hhc1Rhc2tEbGd0LCB0aGlzLl9oYXNUYXNrQ3VyclpvbmUsIHRhcmdldFpvbmUsIGlzRW1wdHkpO1xuICAgICAgICB9O1xuICAgICAgICBab25lRGVsZWdhdGUucHJvdG90eXBlLl91cGRhdGVUYXNrQ291bnQgPSBmdW5jdGlvbiAodHlwZSwgY291bnQpIHtcbiAgICAgICAgICAgIHZhciBjb3VudHMgPSB0aGlzLl90YXNrQ291bnRzO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBjb3VudHNbdHlwZV07XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGNvdW50c1t0eXBlXSA9IHByZXYgKyBjb3VudDtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW9yZSB0YXNrcyBleGVjdXRlZCB0aGVuIHdlcmUgc2NoZWR1bGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgPT0gMCB8fCBuZXh0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWljcm9UYXNrOiBjb3VudHMubWljcm9UYXNrID4gMCxcbiAgICAgICAgICAgICAgICAgICAgbWFjcm9UYXNrOiBjb3VudHMubWFjcm9UYXNrID4gMCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXNrOiBjb3VudHMuZXZlbnRUYXNrID4gMCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiB0eXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Rhc2sodGhpcy56b25lLCBpc0VtcHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnREZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50RGVsZWdhdGUuX3VwZGF0ZVRhc2tDb3VudCh0eXBlLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBab25lRGVsZWdhdGU7XG4gICAgfSgpKTtcbiAgICB2YXIgWm9uZVRhc2sgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBab25lVGFzayh0eXBlLCB6b25lLCBzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zLCBzY2hlZHVsZUZuLCBjYW5jZWxGbikge1xuICAgICAgICAgICAgdGhpcy5ydW5Db3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVGbiA9IHNjaGVkdWxlRm47XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEZuID0gY2FuY2VsRm47XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfbnVtYmVyT2ZOZXN0ZWRUYXNrRnJhbWVzKys7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHpvbmUucnVuVGFzayhzZWxmLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhaW5NaWNyb1Rhc2tRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFpvbmVUYXNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdHlwZW9mIHRoaXMuZGF0YS5oYW5kbGVJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhbmRsZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWRkIHRvSlNPTiBtZXRob2QgdG8gcHJldmVudCBjeWNsaWMgZXJyb3Igd2hlblxuICAgICAgICAvLyBjYWxsIEpTT04uc3RyaW5naWZ5KHpvbmVUYXNrKVxuICAgICAgICBab25lVGFzay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgem9uZTogdGhpcy56b25lLm5hbWUsXG4gICAgICAgICAgICAgICAgaW52b2tlOiB0aGlzLmludm9rZSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUZuOiB0aGlzLnNjaGVkdWxlRm4sXG4gICAgICAgICAgICAgICAgY2FuY2VsRm46IHRoaXMuY2FuY2VsRm4sXG4gICAgICAgICAgICAgICAgcnVuQ291bnQ6IHRoaXMucnVuQ291bnQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2FsbGJhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBab25lVGFzaztcbiAgICB9KCkpO1xuICAgIHZhciBab25lRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBab25lRnJhbWUocGFyZW50LCB6b25lKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFpvbmVGcmFtZTtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9fc3ltYm9sX18obmFtZSkge1xuICAgICAgICByZXR1cm4gJ19fem9uZV9zeW1ib2xfXycgKyBuYW1lO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc3ltYm9sU2V0VGltZW91dCA9IF9fc3ltYm9sX18oJ3NldFRpbWVvdXQnKTtcbiAgICB2YXIgc3ltYm9sUHJvbWlzZSA9IF9fc3ltYm9sX18oJ1Byb21pc2UnKTtcbiAgICB2YXIgc3ltYm9sVGhlbiA9IF9fc3ltYm9sX18oJ3RoZW4nKTtcbiAgICB2YXIgX2N1cnJlbnRab25lRnJhbWUgPSBuZXcgWm9uZUZyYW1lKG51bGwsIG5ldyBab25lKG51bGwsIG51bGwpKTtcbiAgICB2YXIgX2N1cnJlbnRUYXNrID0gbnVsbDtcbiAgICB2YXIgX21pY3JvVGFza1F1ZXVlID0gW107XG4gICAgdmFyIF9pc0RyYWluaW5nTWljcm90YXNrUXVldWUgPSBmYWxzZTtcbiAgICB2YXIgX3VuY2F1Z2h0UHJvbWlzZUVycm9ycyA9IFtdO1xuICAgIHZhciBfbnVtYmVyT2ZOZXN0ZWRUYXNrRnJhbWVzID0gMDtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZVF1ZXVlRHJhaW4oKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgcnVubmluZyBpbiBhbnkgdGFzaywgYW5kIHRoZXJlIGhhcyBub3QgYmVlbiBhbnl0aGluZyBzY2hlZHVsZWRcbiAgICAgICAgLy8gd2UgbXVzdCBib290c3RyYXAgdGhlIGluaXRpYWwgdGFzayBjcmVhdGlvbiBieSBtYW51YWxseSBzY2hlZHVsaW5nIHRoZSBkcmFpblxuICAgICAgICBpZiAoX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcyA9PT0gMCAmJiBfbWljcm9UYXNrUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbm90IHJ1bm5pbmcgaW4gVGFzaywgc28gd2UgbmVlZCB0byBraWNrc3RhcnQgdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIGlmIChnbG9iYWxbc3ltYm9sUHJvbWlzZV0pIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxbc3ltYm9sUHJvbWlzZV0ucmVzb2x2ZSgwKVtzeW1ib2xUaGVuXShkcmFpbk1pY3JvVGFza1F1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsb2JhbFtzeW1ib2xTZXRUaW1lb3V0XShkcmFpbk1pY3JvVGFza1F1ZXVlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayh0YXNrKSB7XG4gICAgICAgIHNjaGVkdWxlUXVldWVEcmFpbigpO1xuICAgICAgICBfbWljcm9UYXNrUXVldWUucHVzaCh0YXNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc29sZUVycm9yKGUpIHtcbiAgICAgICAgdmFyIHJlamVjdGlvbiA9IGUgJiYgZS5yZWplY3Rpb247XG4gICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBQcm9taXNlIHJlamVjdGlvbjonLCByZWplY3Rpb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlamVjdGlvbi5tZXNzYWdlIDogcmVqZWN0aW9uLCAnOyBab25lOicsIGUuem9uZS5uYW1lLCAnOyBUYXNrOicsIGUudGFzayAmJiBlLnRhc2suc291cmNlLCAnOyBWYWx1ZTonLCByZWplY3Rpb24sIHJlamVjdGlvbiBpbnN0YW5jZW9mIEVycm9yID8gcmVqZWN0aW9uLnN0YWNrIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmFpbk1pY3JvVGFza1F1ZXVlKCkge1xuICAgICAgICBpZiAoIV9pc0RyYWluaW5nTWljcm90YXNrUXVldWUpIHtcbiAgICAgICAgICAgIF9pc0RyYWluaW5nTWljcm90YXNrUXVldWUgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKF9taWNyb1Rhc2tRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBfbWljcm9UYXNrUXVldWU7XG4gICAgICAgICAgICAgICAgX21pY3JvVGFza1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay56b25lLnJ1blRhc2sodGFzaywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChfdW5jYXVnaHRQcm9taXNlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5jYXVnaHRQcm9taXNlRXJyb3IgPSBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci56b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHVuY2F1Z2h0UHJvbWlzZUVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2hpbGUgKF91bmNhdWdodFByb21pc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfaXNEcmFpbmluZ01pY3JvdGFza1F1ZXVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudGhlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yd2FyZFJlc29sdXRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVqZWN0aW9uKHJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gWm9uZUF3YXJlUHJvbWlzZS5yZWplY3QocmVqZWN0aW9uKTtcbiAgICB9XG4gICAgdmFyIHN5bWJvbFN0YXRlID0gX19zeW1ib2xfXygnc3RhdGUnKTtcbiAgICB2YXIgc3ltYm9sVmFsdWUgPSBfX3N5bWJvbF9fKCd2YWx1ZScpO1xuICAgIHZhciBzb3VyY2UgPSAnUHJvbWlzZS50aGVuJztcbiAgICB2YXIgVU5SRVNPTFZFRCA9IG51bGw7XG4gICAgdmFyIFJFU09MVkVEID0gdHJ1ZTtcbiAgICB2YXIgUkVKRUNURUQgPSBmYWxzZTtcbiAgICB2YXIgUkVKRUNURURfTk9fQ0FUQ0ggPSAwO1xuICAgIGZ1bmN0aW9uIG1ha2VSZXNvbHZlcihwcm9taXNlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHN0YXRlLCB2KTtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXR1cm4gdmFsdWUgb3IgeW91IHdpbGwgYnJlYWsgdGhlIFByb21pc2Ugc3BlYy5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgc3RhdGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlW3N5bWJvbFN0YXRlXSA9PT0gVU5SRVNPTFZFRCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgWm9uZUF3YXJlUHJvbWlzZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2xTdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2xWYWx1ZSkgJiYgdmFsdWVbc3ltYm9sU3RhdGVdICE9PSBVTlJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJSZWplY3RlZE5vQ2F0Y2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHZhbHVlW3N5bWJvbFN0YXRlXSwgdmFsdWVbc3ltYm9sVmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudGhlbihtYWtlUmVzb2x2ZXIocHJvbWlzZSwgc3RhdGUpLCBtYWtlUmVzb2x2ZXIocHJvbWlzZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlID0gcHJvbWlzZVtzeW1ib2xWYWx1ZV07XG4gICAgICAgICAgICAgICAgcHJvbWlzZVtzeW1ib2xWYWx1ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXNvbHZlT3JSZWplY3QocHJvbWlzZSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT0gMCAmJiBzdGF0ZSA9PSBSRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlW3N5bWJvbFN0YXRlXSA9IFJFSkVDVEVEX05PX0NBVENIO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNhdWdodCAoaW4gcHJvbWlzZSk6ICcgKyB2YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlICYmIHZhbHVlLnN0YWNrID8gJ1xcbicgKyB2YWx1ZS5zdGFjayA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcl8xID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEucmVqZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMS56b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMS50YXNrID0gWm9uZS5jdXJyZW50VGFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF91bmNhdWdodFByb21pc2VFcnJvcnMucHVzaChlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUXVldWVEcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmluZyBhbiBhbHJlYWR5IHJlc29sdmVkIHByb21pc2UgaXMgYSBub29wLlxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJSZWplY3RlZE5vQ2F0Y2gocHJvbWlzZSkge1xuICAgICAgICBpZiAocHJvbWlzZVtzeW1ib2xTdGF0ZV0gPT09IFJFSkVDVEVEX05PX0NBVENIKSB7XG4gICAgICAgICAgICBwcm9taXNlW3N5bWJvbFN0YXRlXSA9IFJFSkVDVEVEO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgPT09IF91bmNhdWdodFByb21pc2VFcnJvcnNbaV0ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUmVzb2x2ZU9yUmVqZWN0KHByb21pc2UsIHpvbmUsIGNoYWluUHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgY2xlYXJSZWplY3RlZE5vQ2F0Y2gocHJvbWlzZSk7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHByb21pc2Vbc3ltYm9sU3RhdGVdID8gb25GdWxmaWxsZWQgfHwgZm9yd2FyZFJlc29sdXRpb24gOiBvblJlamVjdGVkIHx8IGZvcndhcmRSZWplY3Rpb247XG4gICAgICAgIHpvbmUuc2NoZWR1bGVNaWNyb1Rhc2soc291cmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNoYWluUHJvbWlzZSwgdHJ1ZSwgem9uZS5ydW4oZGVsZWdhdGUsIG51bGwsIFtwcm9taXNlW3N5bWJvbFZhbHVlXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNoYWluUHJvbWlzZSwgZmFsc2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBab25lQXdhcmVQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWm9uZUF3YXJlUHJvbWlzZShleGVjdXRvcikge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCEocHJvbWlzZSBpbnN0YW5jZW9mIFpvbmVBd2FyZVByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGFuIGluc3RhbmNlb2YgUHJvbWlzZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gVU5SRVNPTFZFRDtcbiAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sVmFsdWVdID0gW107IC8vIHF1ZXVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBleGVjdXRvciAmJiBleGVjdXRvcihtYWtlUmVzb2x2ZXIocHJvbWlzZSwgUkVTT0xWRUQpLCBtYWtlUmVzb2x2ZXIocHJvbWlzZSwgUkVKRUNURUQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgZmFsc2UsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFpvbmVBd2FyZVByb21pc2UudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFpvbmVBd2FyZVByb21pc2UoKSB7IFtuYXRpdmUgY29kZV0gfSc7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmVBd2FyZVByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlKG5ldyB0aGlzKG51bGwpLCBSRVNPTFZFRCwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBab25lQXdhcmVQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlKG5ldyB0aGlzKG51bGwpLCBSRUpFQ1RFRCwgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBab25lQXdhcmVQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgICAgICAgIHZhciByZWplY3Q7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgICAgIF9hID0gW3JlcywgcmVqXSwgcmVzb2x2ZSA9IF9hWzBdLCByZWplY3QgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgJiYgKHByb21pc2UgPSBudWxsIHx8IHJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSAmJiAocHJvbWlzZSA9IG51bGwgfHwgcmVqZWN0KGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlc18xID0gdmFsdWVzOyBfaSA8IHZhbHVlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc18xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICBab25lQXdhcmVQcm9taXNlLmFsbCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHRoaXMoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVzXzIgPSB2YWx1ZXM7IF9pIDwgdmFsdWVzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzXzJbX2ldO1xuICAgICAgICAgICAgICAgIGlmICghaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9OyB9KShjb3VudCksIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY291bnQpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgWm9uZUF3YXJlUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIGNoYWluUHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpc1tzeW1ib2xTdGF0ZV0gPT0gVU5SRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sVmFsdWVdLnB1c2goem9uZSwgY2hhaW5Qcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVJlc29sdmVPclJlamVjdCh0aGlzLCB6b25lLCBjaGFpblByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFpblByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIFpvbmVBd2FyZVByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBab25lQXdhcmVQcm9taXNlO1xuICAgIH0oKSk7XG4gICAgLy8gUHJvdGVjdCBhZ2FpbnN0IGFnZ3Jlc3NpdmUgb3B0aW1pemVycyBkcm9wcGluZyBzZWVtaW5nbHkgdW51c2VkIHByb3BlcnRpZXMuXG4gICAgLy8gRS5nLiBDbG9zdXJlIENvbXBpbGVyIGluIGFkdmFuY2VkIG1vZGUuXG4gICAgWm9uZUF3YXJlUHJvbWlzZVsncmVzb2x2ZSddID0gWm9uZUF3YXJlUHJvbWlzZS5yZXNvbHZlO1xuICAgIFpvbmVBd2FyZVByb21pc2VbJ3JlamVjdCddID0gWm9uZUF3YXJlUHJvbWlzZS5yZWplY3Q7XG4gICAgWm9uZUF3YXJlUHJvbWlzZVsncmFjZSddID0gWm9uZUF3YXJlUHJvbWlzZS5yYWNlO1xuICAgIFpvbmVBd2FyZVByb21pc2VbJ2FsbCddID0gWm9uZUF3YXJlUHJvbWlzZS5hbGw7XG4gICAgdmFyIE5hdGl2ZVByb21pc2UgPSBnbG9iYWxbX19zeW1ib2xfXygnUHJvbWlzZScpXSA9IGdsb2JhbFsnUHJvbWlzZSddO1xuICAgIGdsb2JhbFsnUHJvbWlzZSddID0gWm9uZUF3YXJlUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBwYXRjaFRoZW4oTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICB2YXIgTmF0aXZlUHJvbWlzZVByb3RvdG90eXBlID0gTmF0aXZlUHJvbWlzZS5wcm90b3R5cGU7XG4gICAgICAgIHZhciBOYXRpdmVQcm9taXNlVGhlbiA9IE5hdGl2ZVByb21pc2VQcm90b3RvdHlwZVtfX3N5bWJvbF9fKCd0aGVuJyldID1cbiAgICAgICAgICAgIE5hdGl2ZVByb21pc2VQcm90b3RvdHlwZS50aGVuO1xuICAgICAgICBOYXRpdmVQcm9taXNlUHJvdG90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlUHJvbWlzZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvbmVBd2FyZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIE5hdGl2ZVByb21pc2VUaGVuLmNhbGwobmF0aXZlUHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgIHBhdGNoVGhlbihOYXRpdmVQcm9taXNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxbJ2ZldGNoJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgZmV0Y2hQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJbiBNUyBFZGdlIHRoaXMgdGhyb3dzXG4gICAgICAgICAgICAgICAgZmV0Y2hQcm9taXNlID0gZ2xvYmFsWydmZXRjaCddKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEluIENocm9tZSB0aGlzIHRocm93cyBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGZldGNoUHJvbWlzZSA9IGdsb2JhbFsnZmV0Y2gnXSgnYWJvdXQ6YmxhbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlnbm9yZSBvdXRwdXQgdG8gcHJldmVudCBlcnJvcjtcbiAgICAgICAgICAgIGZldGNoUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICAgICAgaWYgKGZldGNoUHJvbWlzZS5jb25zdHJ1Y3RvciAhPSBOYXRpdmVQcm9taXNlICYmXG4gICAgICAgICAgICAgICAgZmV0Y2hQcm9taXNlLmNvbnN0cnVjdG9yICE9IFpvbmVBd2FyZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFRoZW4oZmV0Y2hQcm9taXNlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHB1YmxpYyBBUEksIGJ1dCBpdCBpcyB1c2VmdWxsIGZvciB0ZXN0cywgc28gd2UgZXhwb3NlIGl0LlxuICAgIFByb21pc2VbWm9uZS5fX3N5bWJvbF9fKCd1bmNhdWdodFByb21pc2VFcnJvcnMnKV0gPSBfdW5jYXVnaHRQcm9taXNlRXJyb3JzO1xuICAgIC8qXG4gICAgICogVGhpcyBjb2RlIHBhdGNoZXMgRXJyb3Igc28gdGhhdDpcbiAgICAgKiAgIC0gSXQgaWdub3JlcyB1bi1uZWVkZWQgc3RhY2sgZnJhbWVzLlxuICAgICAqICAgLSBJdCBTaG93cyB0aGUgYXNzb2NpYXRlZCBab25lIGZvciByZWFjaCBmcmFtZS5cbiAgICAgKi9cbiAgICB2YXIgRnJhbWVUeXBlO1xuICAgIChmdW5jdGlvbiAoRnJhbWVUeXBlKSB7XG4gICAgICAgIC8vLyBTa2lwIHRoaXMgZnJhbWUgd2hlbiBwcmludGluZyBvdXQgc3RhY2tcbiAgICAgICAgRnJhbWVUeXBlW0ZyYW1lVHlwZVtcImJsYWNrTGlzdFwiXSA9IDBdID0gXCJibGFja0xpc3RcIjtcbiAgICAgICAgLy8vIFRoaXMgZnJhbWUgbWFya3Mgem9uZSB0cmFuc2l0aW9uXG4gICAgICAgIEZyYW1lVHlwZVtGcmFtZVR5cGVbXCJ0cmFuc2l0aW9uXCJdID0gMV0gPSBcInRyYW5zaXRpb25cIjtcbiAgICB9KShGcmFtZVR5cGUgfHwgKEZyYW1lVHlwZSA9IHt9KSk7XG4gICAgdmFyIE5hdGl2ZUVycm9yID0gZ2xvYmFsW19fc3ltYm9sX18oJ0Vycm9yJyldID0gZ2xvYmFsLkVycm9yO1xuICAgIC8vIFN0b3JlIHRoZSBmcmFtZXMgd2hpY2ggc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3RhY2sgZnJhbWVzXG4gICAgdmFyIGJsYWNrTGlzdGVkU3RhY2tGcmFtZXMgPSB7fTtcbiAgICAvLyBXZSBtdXN0IGZpbmQgdGhlIGZyYW1lIHdoZXJlIEVycm9yIHdhcyBjcmVhdGVkLCBvdGhlcndpc2Ugd2UgYXNzdW1lIHdlIGRvbid0IHVuZGVyc3RhbmQgc3RhY2tcbiAgICB2YXIgem9uZUF3YXJlRnJhbWU7XG4gICAgZ2xvYmFsLkVycm9yID0gWm9uZUF3YXJlRXJyb3I7XG4gICAgLy8gSG93IHNob3VsZCB0aGUgc3RhY2sgZnJhbWVzIGJlIHBhcnNlZC5cbiAgICB2YXIgZnJhbWVQYXJzZXJTdHJhdGVneSA9IG51bGw7XG4gICAgdmFyIHN0YWNrUmV3cml0ZSA9ICdzdGFja1Jld3JpdGUnO1xuICAgIC8vIGZpeCAjNTk1LCBjcmVhdGUgcHJvcGVydHkgZGVzY3JpcHRvclxuICAgIC8vIGZvciBlcnJvciBwcm9wZXJ0aWVzXG4gICAgdmFyIGNyZWF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BzLCBrZXkpIHtcbiAgICAgICAgLy8gaWYgcHJvcGVydHkgaXMgYWxyZWFkeSBkZWZpbmVkLCBza2lwIGl0LlxuICAgICAgICBpZiAocHJvcHNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSBhIGxvY2FsIHByb3BlcnR5XG4gICAgICAgIC8vIGluIGNhc2UgZXJyb3IgcHJvcGVydHkgaXMgbm90IHNldHRhYmxlXG4gICAgICAgIHZhciBuYW1lID0gX19zeW1ib2xfXyhrZXkpO1xuICAgICAgICBwcm9wc1trZXldID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGxvY2FsIHByb3BlcnR5IGhhcyBubyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHVzZSBpbnRlcm5hbCBlcnJvcidzIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcl8yID0gdGhpc1tfX3N5bWJvbF9fKCdlcnJvcicpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBlcnJvcl8yW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0ZXIgd2lsbCBzZXQgdmFsdWUgdG8gbG9jYWwgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBmaXggIzU5NSwgY3JlYXRlIHByb3BlcnR5IGRlc2NyaXB0b3JcbiAgICAvLyBmb3IgZXJyb3IgbWV0aG9kIHByb3BlcnRpZXNcbiAgICB2YXIgY3JlYXRlTWV0aG9kUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcHMsIGtleSkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXNbX19zeW1ib2xfXygnZXJyb3InKV07XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWV0aG9kID0gKGVycm9yICYmIGVycm9yW2tleV0pIHx8IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yTWV0aG9kLmFwcGx5KGVycm9yLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVFcnJvclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBOYXRpdmVFcnJvcigpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnJvciwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVByb3BlcnR5KHByb3BzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm90byA9IE5hdGl2ZUVycm9yLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgICAgICB2YXIgcEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHBLZXlzW2ldO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIGtleSAhPT0gJ3RvU3RyaW5nJyAmJiBrZXkgIT09ICd0b1NvdXJjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUHJvcGVydHkocHJvcHMsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNvbWUgb3RoZXIgcHJvcGVydGllcyBhcmUgbm90XG4gICAgICAgIC8vIGluIE5hdGl2ZUVycm9yXG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHByb3BzLCAnb3JpZ2luYWxTdGFjaycpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShwcm9wcywgJ3pvbmVBd2FyZVN0YWNrJyk7XG4gICAgICAgIC8vIGRlZmluZSB0b1N0cmluZywgdG9Tb3VyY2UgYXMgbWV0aG9kIHByb3BlcnR5XG4gICAgICAgIGNyZWF0ZU1ldGhvZFByb3BlcnR5KHByb3BzLCAndG9TdHJpbmcnKTtcbiAgICAgICAgY3JlYXRlTWV0aG9kUHJvcGVydHkocHJvcHMsICd0b1NvdXJjZScpO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JQcm9wZXJ0aWVzID0gY3JlYXRlRXJyb3JQcm9wZXJ0aWVzKCk7XG4gICAgLy8gZm9yIGRlcml2ZWQgRXJyb3IgY2xhc3Mgd2hpY2ggZXh0ZW5kcyBab25lQXdhcmVFcnJvclxuICAgIC8vIHdlIHNob3VsZCBub3Qgb3ZlcnJpZGUgdGhlIGRlcml2ZWQgY2xhc3MncyBwcm9wZXJ0eVxuICAgIC8vIHNvIHdlIGNyZWF0ZSBhIG5ldyBwcm9wcyBvYmplY3Qgb25seSBjb3B5IHRoZSBwcm9wZXJ0aWVzXG4gICAgLy8gZnJvbSBlcnJvclByb3BlcnRpZXMgd2hpY2ggbm90IGV4aXN0IGluIGRlcml2ZWQgRXJyb3IncyBwcm90b3R5cGVcbiAgICB2YXIgZ2V0RXJyb3JQcm9wZXJ0aWVzRm9yUHJvdG90eXBlID0gZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgICAgICAvLyBpZiB0aGUgcHJvdG90eXBlIGlzIFpvbmVBd2FyZUVycm9yLnByb3RvdHlwZVxuICAgICAgICAvLyB3ZSBqdXN0IHJldHVybiB0aGUgcHJlYnVpbHQgZXJyb3JQcm9wZXJ0aWVzLlxuICAgICAgICBpZiAocHJvdG90eXBlID09PSBab25lQXdhcmVFcnJvci5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIGNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyb3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xuICAgICAgICBjS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChjS2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IGNLZXk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tjS2V5XSA9IGVycm9yUHJvcGVydGllc1tjS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgWm9uZUF3YXJlRXJyb3Igd2hpY2ggcHJvY2Vzc2VzIHRoZSBzdGFjayBmcmFtZSBhbmQgY2xlYW5zIHVwIGV4dHJhIGZyYW1lcyBhcyB3ZWxsIGFzXG4gICAgICogYWRkcyB6b25lIGluZm9ybWF0aW9uIHRvIGl0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpvbmVBd2FyZUVycm9yKCkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIHRoaXNcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB1bmRlZmluZWQoY2FsbCBFcnJvciB3aXRob3V0IG5ldykgb3IgdGhpcyBpcyBnbG9iYWxcbiAgICAgICAgLy8gb3IgdGhpcyBpcyBzb21lIG90aGVyIG9iamVjdHMsIHdlIHNob3VsZCBmb3JjZSB0byBjcmVhdGUgYVxuICAgICAgICAvLyB2YWxpZCBab25lQXdhcmVFcnJvciBieSBjYWxsIE9iamVjdC5jcmVhdGUoKVxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgWm9uZUF3YXJlRXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gWm9uZUF3YXJlRXJyb3IuYXBwbHkoT2JqZWN0LmNyZWF0ZShab25lQXdhcmVFcnJvci5wcm90b3R5cGUpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhbiBFcnJvci5cbiAgICAgICAgdmFyIGVycm9yID0gTmF0aXZlRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpc1tfX3N5bWJvbF9fKCdlcnJvcicpXSA9IGVycm9yO1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIHN0YWNrIHRyYWNlXG4gICAgICAgIGVycm9yLm9yaWdpbmFsU3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgc3RhY2sgdHJhY2UgYW5kIHJld3JpdGUgdGhlIGZyYW1lcy5cbiAgICAgICAgaWYgKFpvbmVBd2FyZUVycm9yW3N0YWNrUmV3cml0ZV0gJiYgZXJyb3Iub3JpZ2luYWxTdGFjaykge1xuICAgICAgICAgICAgdmFyIGZyYW1lc18xID0gZXJyb3Iub3JpZ2luYWxTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgem9uZUZyYW1lID0gX2N1cnJlbnRab25lRnJhbWU7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBmcmFtZVxuICAgICAgICAgICAgd2hpbGUgKGZyYW1lc18xW2ldICE9PSB6b25lQXdhcmVGcmFtZSAmJiBpIDwgZnJhbWVzXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGkgPCBmcmFtZXNfMS5sZW5ndGggJiYgem9uZUZyYW1lOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNfMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVR5cGUgPSBibGFja0xpc3RlZFN0YWNrRnJhbWVzLmhhc093blByb3BlcnR5KGZyYW1lKSAmJiBibGFja0xpc3RlZFN0YWNrRnJhbWVzW2ZyYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lVHlwZSA9PT0gRnJhbWVUeXBlLmJsYWNrTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzXzEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyYW1lVHlwZSA9PT0gRnJhbWVUeXBlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6b25lRnJhbWUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3BlY2lhbCBmcmFtZSB3aGVyZSB6b25lIGNoYW5nZWQuIFByaW50IGFuZCBwcm9jZXNzIGl0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzXzFbaV0gKz0gXCIgW1wiICsgem9uZUZyYW1lLnBhcmVudC56b25lLm5hbWUgKyBcIiA9PiBcIiArIHpvbmVGcmFtZS56b25lLm5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b25lRnJhbWUgPSB6b25lRnJhbWUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9uZUZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lc18xW2ldICs9IFwiIFtcIiArIHpvbmVGcmFtZS56b25lLm5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuem9uZUF3YXJlU3RhY2sgPSBmcmFtZXNfMS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGluc3RlYWQgb2YgY29weSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAvLyBiZWNhdXNlIG9mIGlzc3VlICM1OTUgd2hpY2ggd2lsbCBicmVhayBhbmd1bGFyMi5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgZ2V0RXJyb3JQcm9wZXJ0aWVzRm9yUHJvdG90eXBlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQ29weSB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaW5zdGFuY2VvZiBvcGVyYXRvciB3b3JrcyBhcyBleHBlY3RlZFxuICAgIFpvbmVBd2FyZUVycm9yLnByb3RvdHlwZSA9IE5hdGl2ZUVycm9yLnByb3RvdHlwZTtcbiAgICBab25lQXdhcmVFcnJvcltab25lLl9fc3ltYm9sX18oJ2JsYWNrbGlzdGVkU3RhY2tGcmFtZXMnKV0gPSBibGFja0xpc3RlZFN0YWNrRnJhbWVzO1xuICAgIFpvbmVBd2FyZUVycm9yW3N0YWNrUmV3cml0ZV0gPSBmYWxzZTtcbiAgICBpZiAoTmF0aXZlRXJyb3IuaGFzT3duUHJvcGVydHkoJ3N0YWNrVHJhY2VMaW1pdCcpKSB7XG4gICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0YWNrIGxpbWl0IGFzIHdlIHdpbGwgYmUgcmVtb3ZpbmcgZmV3IGZyYW1lcy5cbiAgICAgICAgTmF0aXZlRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gTWF0aC5tYXgoTmF0aXZlRXJyb3Iuc3RhY2tUcmFjZUxpbWl0LCAxNSk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IFpvbmVBd2FyZUVycm9yIGhhcyB0aGUgc2FtZSBwcm9wZXJ0eSB3aGljaCBmb3J3YXJkcyB0byBOYXRpdmVFcnJvci5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFpvbmVBd2FyZUVycm9yLCAnc3RhY2tUcmFjZUxpbWl0Jywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZUVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVFcnJvci5zdGFja1RyYWNlTGltaXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChOYXRpdmVFcnJvci5oYXNPd25Qcm9wZXJ0eSgnY2FwdHVyZVN0YWNrVHJhY2UnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZUF3YXJlRXJyb3IsICdjYXB0dXJlU3RhY2tUcmFjZScsIHtcbiAgICAgICAgICAgIC8vIGFkZCBuYW1lZCBmdW5jdGlvbiBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byByZW1vdmUgdGhpc1xuICAgICAgICAgICAgLy8gc3RhY2sgZnJhbWUgd2hlbiBwcmVwYXJlU3RhY2tUcmFjZSBiZWxvd1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHpvbmVDYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXRPYmplY3QsIGNvbnN0cnVjdG9yT3B0KSB7XG4gICAgICAgICAgICAgICAgTmF0aXZlRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0T2JqZWN0LCBjb25zdHJ1Y3Rvck9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWm9uZUF3YXJlRXJyb3IsICdwcmVwYXJlU3RhY2tUcmFjZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTmF0aXZlRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZUVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKGVycm9yLCBzdHJ1Y3R1cmVkU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhZGRpdGlvbmFsIHN0YWNrIGluZm9ybWF0aW9uIGZyb20gWm9uZUF3YXJlRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VcbiAgICAgICAgICAgICAgICBpZiAoc3RydWN0dXJlZFN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3R1cmVkU3RhY2tUcmFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ID0gc3RydWN0dXJlZFN0YWNrVHJhY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZpcnN0IGZ1bmN0aW9uIHdoaWNoIG5hbWUgaXMgem9uZUNhcHR1cmVTdGFja1RyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QuZ2V0RnVuY3Rpb25OYW1lKCkgPT09ICd6b25lQ2FwdHVyZVN0YWNrVHJhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0dXJlZFN0YWNrVHJhY2Uuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzLCBbZXJyb3IsIHN0cnVjdHVyZWRTdGFja1RyYWNlXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gTm93IHdlIG5lZWQgdG8gcG9wdWxldCB0aGUgYGJsYWNrbGlzdGVkU3RhY2tGcmFtZXNgIGFzIHdlbGwgYXMgZmluZCB0aGVcbiAgICAvLyBydW4vcnVuR3VyYWRlZC9ydW5UYXNrIGZyYW1lcy4gVGhpcyBpcyBkb25lIGJ5IGNyZWF0aW5nIGEgZGV0ZWN0IHpvbmUgYW5kIHRoZW4gdGhyZWFkaW5nXG4gICAgLy8gdGhlIGV4ZWN1dGlvbiB0aHJvdWdoIGFsbCBvZiB0aGUgYWJvdmUgbWV0aG9kcyBzbyB0aGF0IHdlIGNhbiBsb29rIGF0IHRoZSBzdGFjayB0cmFjZSBhbmRcbiAgICAvLyBmaW5kIHRoZSBmcmFtZXMgb2YgaW50ZXJlc3QuXG4gICAgdmFyIGRldGVjdFpvbmUgPSBab25lLmN1cnJlbnQuZm9yayh7XG4gICAgICAgIG5hbWU6ICdkZXRlY3QnLFxuICAgICAgICBvbkludm9rZTogZnVuY3Rpb24gKHBhcmVudFpvbmVEZWxlZ2F0ZSwgY3VycmVudFpvbmUsIHRhcmdldFpvbmUsIGRlbGVnYXRlLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICAvLyBIZXJlIG9ubHkgc28gdGhhdCBpdCB3aWxsIHNob3cgdXAgaW4gdGhlIHN0YWNrIGZyYW1lIHNvIHRoYXQgaXQgY2FuIGJlIGJsYWNrIGxpc3RlZC5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRab25lRGVsZWdhdGUuaW52b2tlKHRhcmdldFpvbmUsIGRlbGVnYXRlLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25IYW5kbGVFcnJvcjogZnVuY3Rpb24gKHBhcmVudFpELCBjdXJyZW50LCB0YXJnZXQsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3Iub3JpZ2luYWxTdGFjayAmJiBFcnJvciA9PT0gWm9uZUF3YXJlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzIgPSBlcnJvci5vcmlnaW5hbFN0YWNrLnNwbGl0KC9cXG4vKTtcbiAgICAgICAgICAgICAgICB2YXIgcnVuRnJhbWUgPSBmYWxzZSwgcnVuR3VhcmRlZEZyYW1lID0gZmFsc2UsIHJ1blRhc2tGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmcmFtZXNfMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZnJhbWVzXzIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gc2FmYXJpIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgc3RhY2sgZnJhbWUgd2l0aCBubyBsaW5lIG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBtYWtlcyBzdXJlIHRoYXQgd2UgZG9uJ3QgZmlsdGVyIGZyYW1lcyBvbiBuYW1lIG9ubHkgKG11c3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBsaW5lbnVtYmVyKVxuICAgICAgICAgICAgICAgICAgICBpZiAoLzpcXGQrOlxcZCsvLnRlc3QoZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcmlkIG9mIHRoZSBwYXRoIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRpbnRlbHkgZmluZCBmdW5jdGlvbiBuYW1lIGluIHBhdGguXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjaHJvbWUgdGhlIHNlcGVyYXRvciBpcyBgKGAgYW5kIGBAYCBpbiBGRiBhbmQgc2FmYXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWU6IGF0IFpvbmUucnVuICh6b25lLmpzOjEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZTogYXQgWm9uZS5ydW4gKGh0dHA6Ly9sb2NhbGhvc3Q6OTg3Ni9iYXNlL2J1aWxkL2xpYi96b25lLmpzOjEwMDoyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVGb3g6IFpvbmUucHJvdG90eXBlLnJ1bkBodHRwOi8vbG9jYWxob3N0Ojk4NzYvYmFzZS9idWlsZC9saWIvem9uZS5qczoxMDE6MjRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaTogcnVuQGh0dHA6Ly9sb2NhbGhvc3Q6OTg3Ni9iYXNlL2J1aWxkL2xpYi96b25lLmpzOjEwMToyNFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuTmFtZSA9IGZyYW1lLnNwbGl0KCcoJylbMF0uc3BsaXQoJ0AnKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVR5cGUgPSBGcmFtZVR5cGUudHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbk5hbWUuaW5kZXhPZignWm9uZUF3YXJlRXJyb3InKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b25lQXdhcmVGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuTmFtZS5pbmRleE9mKCdydW5HdWFyZGVkJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuR3VhcmRlZEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZuTmFtZS5pbmRleE9mKCdydW5UYXNrJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuVGFza0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZuTmFtZS5pbmRleE9mKCdydW4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5GcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVR5cGUgPSBGcmFtZVR5cGUuYmxhY2tMaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxhY2tMaXN0ZWRTdGFja0ZyYW1lc1tmcmFtZV0gPSBmcmFtZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGZpbmQgYWxsIG9mIHRoZSBmcmFtZXMgd2UgY2FuIHN0b3AgbG9va2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5GcmFtZSAmJiBydW5HdWFyZGVkRnJhbWUgJiYgcnVuVGFza0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWm9uZUF3YXJlRXJyb3Jbc3RhY2tSZXdyaXRlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBjYXJlZnVsbHkgY29uc3RydWN0b3IgYSBzdGFjayBmcmFtZSB3aGljaCBjb250YWlucyBhbGwgb2YgdGhlIGZyYW1lcyBvZiBpbnRlcmVzdCB3aGljaFxuICAgIC8vIG5lZWQgdG8gYmUgZGV0ZWN0ZWQgYW5kIGJsYWNrbGlzdGVkLlxuICAgIHZhciBkZXRlY3RSdW5GbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGV0ZWN0Wm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGV0ZWN0Wm9uZS5ydW5HdWFyZGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JsYWNrbGlzdFN0YWNrRnJhbWVzJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBDYXVzZSB0aGUgZXJyb3IgdG8gZXh0cmFjdCB0aGUgc3RhY2sgZnJhbWVzLlxuICAgIGRldGVjdFpvbmUucnVuVGFzayhkZXRlY3Rab25lLnNjaGVkdWxlTWFjcm9UYXNrKCdkZXRlY3QnLCBkZXRlY3RSdW5GbiwgbnVsbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgbnVsbCkpO1xuICAgIHJldHVybiBnbG9iYWxbJ1pvbmUnXSA9IFpvbmU7XG59KSh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cgfHwgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYgfHwgZ2xvYmFsKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBTdXBwcmVzcyBjbG9zdXJlIGNvbXBpbGVyIGVycm9ycyBhYm91dCB1bmtub3duICdab25lJyB2YXJpYWJsZVxuICogQGZpbGVvdmVydmlld1xuICogQHN1cHByZXNzIHt1bmRlZmluZWRWYXJzfVxuICovXG52YXIgem9uZVN5bWJvbCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIl9fem9uZV9zeW1ib2xfX1wiICsgbjsgfTtcbnZhciBfZ2xvYmFsJDEgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cgfHwgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYgfHwgZ2xvYmFsO1xuZnVuY3Rpb24gYmluZEFyZ3VtZW50cyhhcmdzLCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBab25lLmN1cnJlbnQud3JhcChhcmdzW2ldLCBzb3VyY2UgKyAnXycgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn1cblxuXG52YXIgaXNOb2RlID0gKCEoJ253JyBpbiBfZ2xvYmFsJDEpICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XG5cblxuXG5cblxudmFyIEVWRU5UX1RBU0tTID0gem9uZVN5bWJvbCgnZXZlbnRUYXNrcycpO1xuLy8gRm9yIEV2ZW50VGFyZ2V0XG52YXIgQUREX0VWRU5UX0xJU1RFTkVSID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xudmFyIFJFTU9WRV9FVkVOVF9MSVNURU5FUiA9ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbmZ1bmN0aW9uIGZpbmRFeGlzdGluZ1JlZ2lzdGVyZWRUYXNrKHRhcmdldCwgaGFuZGxlciwgbmFtZSwgY2FwdHVyZSwgcmVtb3ZlKSB7XG4gICAgdmFyIGV2ZW50VGFza3MgPSB0YXJnZXRbRVZFTlRfVEFTS1NdO1xuICAgIGlmIChldmVudFRhc2tzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV2ZW50VGFzayA9IGV2ZW50VGFza3NbaV07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50VGFzay5kYXRhO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZGF0YS5oYW5kbGVyO1xuICAgICAgICAgICAgaWYgKChkYXRhLmhhbmRsZXIgPT09IGhhbmRsZXIgfHwgbGlzdGVuZXIubGlzdGVuZXIgPT09IGhhbmRsZXIpICYmXG4gICAgICAgICAgICAgICAgZGF0YS51c2VDYXB0dXJpbmcgPT09IGNhcHR1cmUgJiYgZGF0YS5ldmVudE5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRUYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEFsbEV4aXN0aW5nUmVnaXN0ZXJlZFRhc2tzKHRhcmdldCwgbmFtZSwgY2FwdHVyZSwgcmVtb3ZlKSB7XG4gICAgdmFyIGV2ZW50VGFza3MgPSB0YXJnZXRbRVZFTlRfVEFTS1NdO1xuICAgIGlmIChldmVudFRhc2tzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGV2ZW50VGFza3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBldmVudFRhc2sgPSBldmVudFRhc2tzW2ldO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudFRhc2suZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmV2ZW50TmFtZSA9PT0gbmFtZSAmJiBkYXRhLnVzZUNhcHR1cmluZyA9PT0gY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV2ZW50VGFzayk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhc2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdHRhY2hSZWdpc3RlcmVkRXZlbnQodGFyZ2V0LCBldmVudFRhc2ssIGlzUHJlcGVuZCkge1xuICAgIHZhciBldmVudFRhc2tzID0gdGFyZ2V0W0VWRU5UX1RBU0tTXTtcbiAgICBpZiAoIWV2ZW50VGFza3MpIHtcbiAgICAgICAgZXZlbnRUYXNrcyA9IHRhcmdldFtFVkVOVF9UQVNLU10gPSBbXTtcbiAgICB9XG4gICAgaWYgKGlzUHJlcGVuZCkge1xuICAgICAgICBldmVudFRhc2tzLnVuc2hpZnQoZXZlbnRUYXNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50VGFza3MucHVzaChldmVudFRhc2spO1xuICAgIH1cbn1cbnZhciBkZWZhdWx0TGlzdGVuZXJNZXRhQ3JlYXRvciA9IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2FwdHVyaW5nOiBhcmdzWzJdLFxuICAgICAgICBldmVudE5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIGhhbmRsZXI6IGFyZ3NbMV0sXG4gICAgICAgIHRhcmdldDogc2VsZiB8fCBfZ2xvYmFsJDEsXG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIGludm9rZUFkZEZ1bmM6IGZ1bmN0aW9uIChhZGRGblN5bWJvbCwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5pbnZva2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRbYWRkRm5TeW1ib2xdKHRoaXMuZXZlbnROYW1lLCBkZWxlZ2F0ZS5pbnZva2UsIHRoaXMudXNlQ2FwdHVyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFthZGRGblN5bWJvbF0odGhpcy5ldmVudE5hbWUsIGRlbGVnYXRlLCB0aGlzLnVzZUNhcHR1cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludm9rZVJlbW92ZUZ1bmM6IGZ1bmN0aW9uIChyZW1vdmVGblN5bWJvbCwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5pbnZva2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRbcmVtb3ZlRm5TeW1ib2xdKHRoaXMuZXZlbnROYW1lLCBkZWxlZ2F0ZS5pbnZva2UsIHRoaXMudXNlQ2FwdHVyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFtyZW1vdmVGblN5bWJvbF0odGhpcy5ldmVudE5hbWUsIGRlbGVnYXRlLCB0aGlzLnVzZUNhcHR1cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uIG1ha2Vab25lQXdhcmVBZGRMaXN0ZW5lcihhZGRGbk5hbWUsIHJlbW92ZUZuTmFtZSwgdXNlQ2FwdHVyaW5nUGFyYW0sIGFsbG93RHVwbGljYXRlcywgaXNQcmVwZW5kLCBtZXRhQ3JlYXRvcikge1xuICAgIGlmICh1c2VDYXB0dXJpbmdQYXJhbSA9PT0gdm9pZCAwKSB7IHVzZUNhcHR1cmluZ1BhcmFtID0gdHJ1ZTsgfVxuICAgIGlmIChhbGxvd0R1cGxpY2F0ZXMgPT09IHZvaWQgMCkgeyBhbGxvd0R1cGxpY2F0ZXMgPSBmYWxzZTsgfVxuICAgIGlmIChpc1ByZXBlbmQgPT09IHZvaWQgMCkgeyBpc1ByZXBlbmQgPSBmYWxzZTsgfVxuICAgIGlmIChtZXRhQ3JlYXRvciA9PT0gdm9pZCAwKSB7IG1ldGFDcmVhdG9yID0gZGVmYXVsdExpc3RlbmVyTWV0YUNyZWF0b3I7IH1cbiAgICB2YXIgYWRkRm5TeW1ib2wgPSB6b25lU3ltYm9sKGFkZEZuTmFtZSk7XG4gICAgdmFyIHJlbW92ZUZuU3ltYm9sID0gem9uZVN5bWJvbChyZW1vdmVGbk5hbWUpO1xuICAgIHZhciBkZWZhdWx0VXNlQ2FwdHVyaW5nID0gdXNlQ2FwdHVyaW5nUGFyYW0gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZUV2ZW50TGlzdGVuZXIoZXZlbnRUYXNrKSB7XG4gICAgICAgIHZhciBtZXRhID0gZXZlbnRUYXNrLmRhdGE7XG4gICAgICAgIGF0dGFjaFJlZ2lzdGVyZWRFdmVudChtZXRhLnRhcmdldCwgZXZlbnRUYXNrLCBpc1ByZXBlbmQpO1xuICAgICAgICByZXR1cm4gbWV0YS5pbnZva2VBZGRGdW5jKGFkZEZuU3ltYm9sLCBldmVudFRhc2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxFdmVudExpc3RlbmVyKGV2ZW50VGFzaykge1xuICAgICAgICB2YXIgbWV0YSA9IGV2ZW50VGFzay5kYXRhO1xuICAgICAgICBmaW5kRXhpc3RpbmdSZWdpc3RlcmVkVGFzayhtZXRhLnRhcmdldCwgZXZlbnRUYXNrLmludm9rZSwgbWV0YS5ldmVudE5hbWUsIG1ldGEudXNlQ2FwdHVyaW5nLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG1ldGEuaW52b2tlUmVtb3ZlRnVuYyhyZW1vdmVGblN5bWJvbCwgZXZlbnRUYXNrKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHpvbmVBd2FyZUFkZExpc3RlbmVyKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtZXRhQ3JlYXRvcihzZWxmLCBhcmdzKTtcbiAgICAgICAgZGF0YS51c2VDYXB0dXJpbmcgPSBkYXRhLnVzZUNhcHR1cmluZyB8fCBkZWZhdWx0VXNlQ2FwdHVyaW5nO1xuICAgICAgICAvLyAtIEluc2lkZSBhIFdlYiBXb3JrZXIsIGB0aGlzYCBpcyB1bmRlZmluZWQsIHRoZSBjb250ZXh0IGlzIGBnbG9iYWxgXG4gICAgICAgIC8vIC0gV2hlbiBgYWRkRXZlbnRMaXN0ZW5lcmAgaXMgY2FsbGVkIG9uIHRoZSBnbG9iYWwgY29udGV4dCBpbiBzdHJpY3QgbW9kZSwgYHRoaXNgIGlzIHVuZGVmaW5lZFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvem9uZS5qcy9pc3N1ZXMvMTkwXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5oYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gZGF0YS5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEuaGFuZGxlciAmJiBkYXRhLmhhbmRsZXIuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBkYXRhLmhhbmRsZXIuaGFuZGxlRXZlbnQoZXZlbnQpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZFpvbmVIYW5kbGVyID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJbiBjcm9zcyBzaXRlIGNvbnRleHRzIChzdWNoIGFzIFdlYkRyaXZlciBmcmFtZXdvcmtzIGxpa2UgU2VsZW5pdW0pLFxuICAgICAgICAgICAgLy8gYWNjZXNzaW5nIHRoZSBoYW5kbGVyIG9iamVjdCBoZXJlIHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGljaFxuICAgICAgICAgICAgLy8gd2lsbCBmYWlsIHRlc3RzIHByZW1hdHVyZWx5LlxuICAgICAgICAgICAgdmFsaWRab25lSGFuZGxlciA9IGRhdGEuaGFuZGxlciAmJiBkYXRhLmhhbmRsZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25XcmFwcGVyXSc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFJldHVybmluZyBub3RoaW5nIGhlcmUgaXMgZmluZSwgYmVjYXVzZSBvYmplY3RzIGluIGEgY3Jvc3Mtc2l0ZSBjb250ZXh0IGFyZSB1bnVzYWJsZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBzcGVjaWFsIGxpc3RlbmVycyBvZiBJRTExICYgRWRnZSBkZXYgdG9vbHMsIHNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci96b25lLmpzL2lzc3Vlcy8xNTBcbiAgICAgICAgaWYgKCFkZWxlZ2F0ZSB8fCB2YWxpZFpvbmVIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pbnZva2VBZGRGdW5jKGFkZEZuU3ltYm9sLCBkYXRhLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXNrID0gZmluZEV4aXN0aW5nUmVnaXN0ZXJlZFRhc2soZGF0YS50YXJnZXQsIGRhdGEuaGFuZGxlciwgZGF0YS5ldmVudE5hbWUsIGRhdGEudXNlQ2FwdHVyaW5nLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoZXZlbnRUYXNrKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSByZWdpc3RlcmVkLCBzbyB0aGlzIHdpbGwgaGF2ZSBub29wLlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmludm9rZUFkZEZ1bmMoYWRkRm5TeW1ib2wsIGV2ZW50VGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzb3VyY2UgPSBkYXRhLnRhcmdldC5jb25zdHJ1Y3RvclsnbmFtZSddICsgJy4nICsgYWRkRm5OYW1lICsgJzonICsgZGF0YS5ldmVudE5hbWU7XG4gICAgICAgIHpvbmUuc2NoZWR1bGVFdmVudFRhc2soc291cmNlLCBkZWxlZ2F0ZSwgZGF0YSwgc2NoZWR1bGVFdmVudExpc3RlbmVyLCBjYW5jZWxFdmVudExpc3RlbmVyKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZVpvbmVBd2FyZVJlbW92ZUxpc3RlbmVyKGZuTmFtZSwgdXNlQ2FwdHVyaW5nUGFyYW0sIG1ldGFDcmVhdG9yKSB7XG4gICAgaWYgKHVzZUNhcHR1cmluZ1BhcmFtID09PSB2b2lkIDApIHsgdXNlQ2FwdHVyaW5nUGFyYW0gPSB0cnVlOyB9XG4gICAgaWYgKG1ldGFDcmVhdG9yID09PSB2b2lkIDApIHsgbWV0YUNyZWF0b3IgPSBkZWZhdWx0TGlzdGVuZXJNZXRhQ3JlYXRvcjsgfVxuICAgIHZhciBzeW1ib2wgPSB6b25lU3ltYm9sKGZuTmFtZSk7XG4gICAgdmFyIGRlZmF1bHRVc2VDYXB0dXJpbmcgPSB1c2VDYXB0dXJpbmdQYXJhbSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmdW5jdGlvbiB6b25lQXdhcmVSZW1vdmVMaXN0ZW5lcihzZWxmLCBhcmdzKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWV0YUNyZWF0b3Ioc2VsZiwgYXJncyk7XG4gICAgICAgIGRhdGEudXNlQ2FwdHVyaW5nID0gZGF0YS51c2VDYXB0dXJpbmcgfHwgZGVmYXVsdFVzZUNhcHR1cmluZztcbiAgICAgICAgLy8gLSBJbnNpZGUgYSBXZWIgV29ya2VyLCBgdGhpc2AgaXMgdW5kZWZpbmVkLCB0aGUgY29udGV4dCBpcyBgZ2xvYmFsYFxuICAgICAgICAvLyAtIFdoZW4gYGFkZEV2ZW50TGlzdGVuZXJgIGlzIGNhbGxlZCBvbiB0aGUgZ2xvYmFsIGNvbnRleHQgaW4gc3RyaWN0IG1vZGUsIGB0aGlzYCBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzE5MFxuICAgICAgICB2YXIgZXZlbnRUYXNrID0gZmluZEV4aXN0aW5nUmVnaXN0ZXJlZFRhc2soZGF0YS50YXJnZXQsIGRhdGEuaGFuZGxlciwgZGF0YS5ldmVudE5hbWUsIGRhdGEudXNlQ2FwdHVyaW5nLCB0cnVlKTtcbiAgICAgICAgaWYgKGV2ZW50VGFzaykge1xuICAgICAgICAgICAgZXZlbnRUYXNrLnpvbmUuY2FuY2VsVGFzayhldmVudFRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5pbnZva2VSZW1vdmVGdW5jKHN5bWJvbCwgZGF0YS5oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlWm9uZUF3YXJlUmVtb3ZlQWxsTGlzdGVuZXJzKGZuTmFtZSwgdXNlQ2FwdHVyaW5nUGFyYW0pIHtcbiAgICBpZiAodXNlQ2FwdHVyaW5nUGFyYW0gPT09IHZvaWQgMCkgeyB1c2VDYXB0dXJpbmdQYXJhbSA9IHRydWU7IH1cbiAgICB2YXIgc3ltYm9sID0gem9uZVN5bWJvbChmbk5hbWUpO1xuICAgIHZhciBkZWZhdWx0VXNlQ2FwdHVyaW5nID0gdXNlQ2FwdHVyaW5nUGFyYW0gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gem9uZUF3YXJlUmVtb3ZlQWxsTGlzdGVuZXIoc2VsZiwgYXJncykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc2VsZiB8fCBfZ2xvYmFsJDE7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgd2l0aG91dCBldmVudE5hbWVcbiAgICAgICAgICAgIHRhcmdldFtFVkVOVF9UQVNLU10gPSBbXTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhbmNlbCBUYXNrIGVpdGhlciwgYmVjYXVzZSBjYWxsIG5hdGl2ZSBldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzIHdpbGxcbiAgICAgICAgICAgIC8vIHdpbGwgZG8gcmVtb3ZlIGxpc3RlbmVyKGNhbmNlbFRhc2spIGZvciB1c1xuICAgICAgICAgICAgdGFyZ2V0W3N5bWJvbF0oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnROYW1lID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHVzZUNhcHR1cmluZyA9IGFyZ3NbMV0gfHwgZGVmYXVsdFVzZUNhcHR1cmluZztcbiAgICAgICAgLy8gY2FsbCB0aGlzIGZ1bmN0aW9uIGp1c3QgcmVtb3ZlIHRoZSByZWxhdGVkIGV2ZW50VGFzayBmcm9tIHRhcmdldFtFVkVOVF9UQVNLU11cbiAgICAgICAgZmluZEFsbEV4aXN0aW5nUmVnaXN0ZXJlZFRhc2tzKHRhcmdldCwgZXZlbnROYW1lLCB1c2VDYXB0dXJpbmcsIHRydWUpO1xuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHVzZUNhcHR1cmluZyBoZXJlIGJlY2F1c2UgdXNlQ2FwdHVyaW5nIGlzIGp1c3QgZm9yIERPTSwgYW5kXG4gICAgICAgIC8vIHJlbW92ZUFsbExpc3RlbmVycyBzaG91bGQgb25seSBiZSBjYWxsZWQgYnkgbm9kZSBldmVudEVtaXR0ZXJcbiAgICAgICAgLy8gYW5kIHdlIGRvbid0IGNhbmNlbCBUYXNrIGVpdGhlciwgYmVjYXVzZSBjYWxsIG5hdGl2ZSBldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzIHdpbGxcbiAgICAgICAgLy8gd2lsbCBkbyByZW1vdmUgbGlzdGVuZXIoY2FuY2VsVGFzaykgZm9yIHVzXG4gICAgICAgIHRhcmdldFtzeW1ib2xdKGV2ZW50TmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2Vab25lQXdhcmVMaXN0ZW5lcnMoZm5OYW1lKSB7XG4gICAgdmFyIHN5bWJvbCA9IHpvbmVTeW1ib2woZm5OYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gem9uZUF3YXJlRXZlbnRMaXN0ZW5lcnMoc2VsZiwgYXJncykge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHNlbGYgfHwgX2dsb2JhbCQxO1xuICAgICAgICBpZiAoIXRhcmdldFtFVkVOVF9UQVNLU10pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0W0VWRU5UX1RBU0tTXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodGFzaykgeyByZXR1cm4gdGFzay5kYXRhLmV2ZW50TmFtZSA9PT0gZXZlbnROYW1lOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodGFzaykgeyByZXR1cm4gdGFzay5kYXRhLmhhbmRsZXI7IH0pO1xuICAgIH07XG59XG52YXIgem9uZUF3YXJlQWRkRXZlbnRMaXN0ZW5lciA9IG1ha2Vab25lQXdhcmVBZGRMaXN0ZW5lcihBRERfRVZFTlRfTElTVEVORVIsIFJFTU9WRV9FVkVOVF9MSVNURU5FUik7XG52YXIgem9uZUF3YXJlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IG1ha2Vab25lQXdhcmVSZW1vdmVMaXN0ZW5lcihSRU1PVkVfRVZFTlRfTElTVEVORVIpO1xuXG52YXIgb3JpZ2luYWxJbnN0YW5jZUtleSA9IHpvbmVTeW1ib2woJ29yaWdpbmFsSW5zdGFuY2UnKTtcbi8vIHdyYXAgc29tZSBuYXRpdmUgQVBJIG9uIGB3aW5kb3dgXG5cblxuZnVuY3Rpb24gY3JlYXRlTmFtZWRGbihuYW1lLCBkZWxlZ2F0ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoRnVuY3Rpb24oJ2YnLCBcInJldHVybiBmdW5jdGlvbiBcIiArIG5hbWUgKyBcIigpe3JldHVybiBmKHRoaXMsIGFyZ3VtZW50cyl9XCIpKShkZWxlZ2F0ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHdlIGZhaWwsIHdlIG11c3QgYmUgQ1NQLCBqdXN0IHJldHVybiBkZWxlZ2F0ZS5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTWV0aG9kKHRhcmdldCwgbmFtZSwgcGF0Y2hGbikge1xuICAgIHZhciBwcm90byA9IHRhcmdldDtcbiAgICB3aGlsZSAocHJvdG8gJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgaWYgKCFwcm90byAmJiB0YXJnZXRbbmFtZV0pIHtcbiAgICAgICAgLy8gc29tZWhvdyB3ZSBkaWQgbm90IGZpbmQgaXQsIGJ1dCB3ZSBjYW4gc2VlIGl0LiBUaGlzIGhhcHBlbnMgb24gSUUgZm9yIFdpbmRvdyBwcm9wZXJ0aWVzLlxuICAgICAgICBwcm90byA9IHRhcmdldDtcbiAgICB9XG4gICAgdmFyIGRlbGVnYXRlTmFtZSA9IHpvbmVTeW1ib2wobmFtZSk7XG4gICAgdmFyIGRlbGVnYXRlO1xuICAgIGlmIChwcm90byAmJiAhKGRlbGVnYXRlID0gcHJvdG9bZGVsZWdhdGVOYW1lXSkpIHtcbiAgICAgICAgZGVsZWdhdGUgPSBwcm90b1tkZWxlZ2F0ZU5hbWVdID0gcHJvdG9bbmFtZV07XG4gICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTmFtZWRGbihuYW1lLCBwYXRjaEZuKGRlbGVnYXRlLCBkZWxlZ2F0ZU5hbWUsIG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGVnYXRlO1xufVxuLy8gVE9ETzogc3VwcG9ydCBjYW5jZWwgdGFzayBsYXRlciBpZiBuZWNlc3NhcnlcbmZ1bmN0aW9uIHBhdGNoTWFjcm9UYXNrKG9iaiwgZnVuY05hbWUsIG1ldGFDcmVhdG9yKSB7XG4gICAgdmFyIHNldE5hdGl2ZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVUYXNrKHRhc2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0YXNrLmRhdGE7XG4gICAgICAgIGRhdGEuYXJnc1tkYXRhLmNhbGxiYWNrSW5kZXhdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFzay5pbnZva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0TmF0aXZlLmFwcGx5KGRhdGEudGFyZ2V0LCBkYXRhLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgc2V0TmF0aXZlID0gcGF0Y2hNZXRob2Qob2JqLCBmdW5jTmFtZSwgZnVuY3Rpb24gKGRlbGVnYXRlKSB7IHJldHVybiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICB2YXIgbWV0YSA9IG1ldGFDcmVhdG9yKHNlbGYsIGFyZ3MpO1xuICAgICAgICBpZiAobWV0YS5jYWxsYmFja0luZGV4ID49IDAgJiYgdHlwZW9mIGFyZ3NbbWV0YS5jYWxsYmFja0luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2sobWV0YS5uYW1lLCBhcmdzW21ldGEuY2FsbGJhY2tJbmRleF0sIG1ldGEsIHNjaGVkdWxlVGFzaywgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIGJ5IGNhbGxpbmcgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9OyB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIGNhbGxBbmRSZXR1cm5GaXJzdFBhcmFtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgIGZuKHNlbGYsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xufTtcbi8vIEZvciBFdmVudEVtaXR0ZXJcbnZhciBFRV9BRERfTElTVEVORVIgPSAnYWRkTGlzdGVuZXInO1xudmFyIEVFX1BSRVBFTkRfTElTVEVORVIgPSAncHJlcGVuZExpc3RlbmVyJztcbnZhciBFRV9SRU1PVkVfTElTVEVORVIgPSAncmVtb3ZlTGlzdGVuZXInO1xudmFyIEVFX1JFTU9WRV9BTExfTElTVEVORVIgPSAncmVtb3ZlQWxsTGlzdGVuZXJzJztcbnZhciBFRV9MSVNURU5FUlMgPSAnbGlzdGVuZXJzJztcbnZhciBFRV9PTiA9ICdvbic7XG52YXIgem9uZUF3YXJlQWRkTGlzdGVuZXIkMSA9IGNhbGxBbmRSZXR1cm5GaXJzdFBhcmFtKG1ha2Vab25lQXdhcmVBZGRMaXN0ZW5lcihFRV9BRERfTElTVEVORVIsIEVFX1JFTU9WRV9MSVNURU5FUiwgZmFsc2UsIHRydWUsIGZhbHNlKSk7XG52YXIgem9uZUF3YXJlUHJlcGVuZExpc3RlbmVyID0gY2FsbEFuZFJldHVybkZpcnN0UGFyYW0obWFrZVpvbmVBd2FyZUFkZExpc3RlbmVyKEVFX1BSRVBFTkRfTElTVEVORVIsIEVFX1JFTU9WRV9MSVNURU5FUiwgZmFsc2UsIHRydWUsIHRydWUpKTtcbnZhciB6b25lQXdhcmVSZW1vdmVMaXN0ZW5lciQxID0gY2FsbEFuZFJldHVybkZpcnN0UGFyYW0obWFrZVpvbmVBd2FyZVJlbW92ZUxpc3RlbmVyKEVFX1JFTU9WRV9MSVNURU5FUiwgZmFsc2UpKTtcbnZhciB6b25lQXdhcmVSZW1vdmVBbGxMaXN0ZW5lcnMgPSBjYWxsQW5kUmV0dXJuRmlyc3RQYXJhbShtYWtlWm9uZUF3YXJlUmVtb3ZlQWxsTGlzdGVuZXJzKEVFX1JFTU9WRV9BTExfTElTVEVORVIsIGZhbHNlKSk7XG52YXIgem9uZUF3YXJlTGlzdGVuZXJzID0gbWFrZVpvbmVBd2FyZUxpc3RlbmVycyhFRV9MSVNURU5FUlMpO1xuZnVuY3Rpb24gcGF0Y2hFdmVudEVtaXR0ZXJNZXRob2RzKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLmFkZExpc3RlbmVyKSB7XG4gICAgICAgIHBhdGNoTWV0aG9kKG9iaiwgRUVfQUREX0xJU1RFTkVSLCBmdW5jdGlvbiAoKSB7IHJldHVybiB6b25lQXdhcmVBZGRMaXN0ZW5lciQxOyB9KTtcbiAgICAgICAgcGF0Y2hNZXRob2Qob2JqLCBFRV9QUkVQRU5EX0xJU1RFTkVSLCBmdW5jdGlvbiAoKSB7IHJldHVybiB6b25lQXdhcmVQcmVwZW5kTGlzdGVuZXI7IH0pO1xuICAgICAgICBwYXRjaE1ldGhvZChvYmosIEVFX1JFTU9WRV9MSVNURU5FUiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gem9uZUF3YXJlUmVtb3ZlTGlzdGVuZXIkMTsgfSk7XG4gICAgICAgIHBhdGNoTWV0aG9kKG9iaiwgRUVfUkVNT1ZFX0FMTF9MSVNURU5FUiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gem9uZUF3YXJlUmVtb3ZlQWxsTGlzdGVuZXJzOyB9KTtcbiAgICAgICAgcGF0Y2hNZXRob2Qob2JqLCBFRV9MSVNURU5FUlMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHpvbmVBd2FyZUxpc3RlbmVyczsgfSk7XG4gICAgICAgIG9ialtFRV9PTl0gPSBvYmpbRUVfQUREX0xJU1RFTkVSXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8gRXZlbnRFbWl0dGVyXG52YXIgZXZlbnRzO1xudHJ5IHtcbiAgICBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbn1cbmNhdGNoIChlcnIpIHtcbn1cbmlmIChldmVudHMgJiYgZXZlbnRzLkV2ZW50RW1pdHRlcikge1xuICAgIHBhdGNoRXZlbnRFbWl0dGVyTWV0aG9kcyhldmVudHMuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBmcztcbnRyeSB7XG4gICAgZnMgPSByZXF1aXJlKCdmcycpO1xufVxuY2F0Y2ggKGVycikge1xufVxuLy8gd2F0Y2gsIHdhdGNoRmlsZSwgdW53YXRjaEZpbGUgaGFzIGJlZW4gcGF0Y2hlZFxuLy8gYmVjYXVzZSBFdmVudEVtaXR0ZXIgaGFzIGJlZW4gcGF0Y2hlZFxudmFyIFRPX1BBVENIX01BQ1JPVEFTS19NRVRIT0RTID0gW1xuICAgICdhY2Nlc3MnLCAnYXBwZW5kRmlsZScsICdjaG1vZCcsICdjaG93bicsICdjbG9zZScsICdleGlzdHMnLCAnZmNobW9kJyxcbiAgICAnZmNob3duJywgJ2ZkYXRhc3luYycsICdmc3RhdCcsICdmc3luYycsICdmdHJ1bmNhdGUnLCAnZnV0aW1lcycsICdsY2htb2QnLFxuICAgICdsY2hvd24nLCAnbGluaycsICdsc3RhdCcsICdta2RpcicsICdta2R0ZW1wJywgJ29wZW4nLCAncmVhZCcsXG4gICAgJ3JlYWRkaXInLCAncmVhZEZpbGUnLCAncmVhZGxpbmsnLCAncmVhbHBhdGgnLCAncmVuYW1lJywgJ3JtZGlyJywgJ3N0YXQnLFxuICAgICdzeW1saW5rJywgJ3RydW5jYXRlJywgJ3VubGluaycsICd1dGltZXMnLCAnd3JpdGUnLCAnd3JpdGVGaWxlJyxcbl07XG5pZiAoZnMpIHtcbiAgICBUT19QQVRDSF9NQUNST1RBU0tfTUVUSE9EUy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICEhZnNbbmFtZV0gJiYgdHlwZW9mIGZzW25hbWVdID09PSAnZnVuY3Rpb24nOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBwYXRjaE1hY3JvVGFzayhmcywgbmFtZSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ZzLicgKyBuYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbmRleDogYXJncy5sZW5ndGggPiAwID8gYXJncy5sZW5ndGggLSAxIDogLTEsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBzZWxmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcGF0Y2hUaW1lcih3aW5kb3csIHNldE5hbWUsIGNhbmNlbE5hbWUsIG5hbWVTdWZmaXgpIHtcbiAgICB2YXIgc2V0TmF0aXZlID0gbnVsbDtcbiAgICB2YXIgY2xlYXJOYXRpdmUgPSBudWxsO1xuICAgIHNldE5hbWUgKz0gbmFtZVN1ZmZpeDtcbiAgICBjYW5jZWxOYW1lICs9IG5hbWVTdWZmaXg7XG4gICAgdmFyIHRhc2tzQnlIYW5kbGVJZCA9IHt9O1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayh0YXNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGFzay5kYXRhO1xuICAgICAgICBkYXRhLmFyZ3NbMF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXNrLmludm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVJZFtkYXRhLmhhbmRsZUlkXTtcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5oYW5kbGVJZCA9IHNldE5hdGl2ZS5hcHBseSh3aW5kb3csIGRhdGEuYXJncyk7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVJZFtkYXRhLmhhbmRsZUlkXSA9IHRhc2s7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhclRhc2sodGFzaykge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZUlkW3Rhc2suZGF0YS5oYW5kbGVJZF07XG4gICAgICAgIHJldHVybiBjbGVhck5hdGl2ZSh0YXNrLmRhdGEuaGFuZGxlSWQpO1xuICAgIH1cbiAgICBzZXROYXRpdmUgPVxuICAgICAgICBwYXRjaE1ldGhvZCh3aW5kb3csIHNldE5hbWUsIGZ1bmN0aW9uIChkZWxlZ2F0ZSkgeyByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciB6b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaXNQZXJpb2RpYzogbmFtZVN1ZmZpeCA9PT0gJ0ludGVydmFsJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IChuYW1lU3VmZml4ID09PSAnVGltZW91dCcgfHwgbmFtZVN1ZmZpeCA9PT0gJ0ludGVydmFsJykgPyBhcmdzWzFdIHx8IDAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHpvbmUuc2NoZWR1bGVNYWNyb1Rhc2soc2V0TmFtZSwgYXJnc1swXSwgb3B0aW9ucywgc2NoZWR1bGVUYXNrLCBjbGVhclRhc2spO1xuICAgICAgICAgICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyBtdXN0IGFkZGl0aW9uYWxseSBzdXBwb3J0IHRoZSByZWYgYW5kIHVucmVmIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gdGFzay5kYXRhLmhhbmRsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUucmVmICYmIGhhbmRsZS51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnJlZiA9IGhhbmRsZS5yZWYuYmluZChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnVucmVmID0gaGFuZGxlLnVucmVmLmJpbmQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciBieSBjYWxsaW5nIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh3aW5kb3csIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyB9KTtcbiAgICBjbGVhck5hdGl2ZSA9XG4gICAgICAgIHBhdGNoTWV0aG9kKHdpbmRvdywgY2FuY2VsTmFtZSwgZnVuY3Rpb24gKGRlbGVnYXRlKSB7IHJldHVybiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgPyB0YXNrc0J5SGFuZGxlSWRbYXJnc1swXV0gOiBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKHRhc2sgJiYgdHlwZW9mIHRhc2sudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFzay5jYW5jZWxGbiAmJiB0YXNrLmRhdGEuaXNQZXJpb2RpYyB8fCB0YXNrLnJ1bkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBjYW5jZWwgYWxyZWFkeSBjYW5jZWxlZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdGFzay56b25lLmNhbmNlbFRhc2sodGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2F1c2UgYW4gZXJyb3IgYnkgY2FsbGluZyBpdCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5hcHBseSh3aW5kb3csIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIHNldCA9ICdzZXQnO1xudmFyIGNsZWFyID0gJ2NsZWFyJztcbnZhciBfZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93IHx8IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmIHx8IGdsb2JhbDtcbi8vIFRpbWVyc1xudmFyIHRpbWVycyA9IHJlcXVpcmUoJ3RpbWVycycpO1xucGF0Y2hUaW1lcih0aW1lcnMsIHNldCwgY2xlYXIsICdUaW1lb3V0Jyk7XG5wYXRjaFRpbWVyKHRpbWVycywgc2V0LCBjbGVhciwgJ0ludGVydmFsJyk7XG5wYXRjaFRpbWVyKHRpbWVycywgc2V0LCBjbGVhciwgJ0ltbWVkaWF0ZScpO1xudmFyIHNob3VsZFBhdGNoR2xvYmFsVGltZXJzID0gZ2xvYmFsLnNldFRpbWVvdXQgIT09IHRpbWVycy5zZXRUaW1lb3V0O1xuaWYgKHNob3VsZFBhdGNoR2xvYmFsVGltZXJzKSB7XG4gICAgcGF0Y2hUaW1lcihfZ2xvYmFsLCBzZXQsIGNsZWFyLCAnVGltZW91dCcpO1xuICAgIHBhdGNoVGltZXIoX2dsb2JhbCwgc2V0LCBjbGVhciwgJ0ludGVydmFsJyk7XG4gICAgcGF0Y2hUaW1lcihfZ2xvYmFsLCBzZXQsIGNsZWFyLCAnSW1tZWRpYXRlJyk7XG59XG5wYXRjaE5leHRUaWNrKCk7XG4vLyBDcnlwdG9cbnZhciBjcnlwdG87XG50cnkge1xuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xufVxuY2F0Y2ggKGVycikge1xufVxuLy8gVE9ETyhnZGkyMjkwKTogaW1wbGVtZW50IGEgYmV0dGVyIHdheSB0byBwYXRjaCB0aGVzZSBtZXRob2RzXG5pZiAoY3J5cHRvKSB7XG4gICAgdmFyIG5hdGl2ZVJhbmRvbUJ5dGVzXzEgPSBjcnlwdG8ucmFuZG9tQnl0ZXM7XG4gICAgY3J5cHRvLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24gcmFuZG9tQnl0ZXNab25lKHNpemUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSYW5kb21CeXRlc18xKHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gY3J5cHRvLmNvbnN0cnVjdG9yLm5hbWUgKyAnLnJhbmRvbUJ5dGVzJztcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSYW5kb21CeXRlc18xKHNpemUsIHpvbmUud3JhcChjYWxsYmFjaywgc291cmNlKSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQoY3J5cHRvKTtcbiAgICB2YXIgbmF0aXZlUGJrZGYyXzEgPSBjcnlwdG8ucGJrZGYyO1xuICAgIGNyeXB0by5wYmtkZjIgPSBmdW5jdGlvbiBwYmtkZjJab25lKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gY3J5cHRvLmNvbnN0cnVjdG9yLm5hbWUgKyAnLnBia2RmMic7XG4gICAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSB6b25lLndyYXAoZm4sIHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUGJrZGYyXzEuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVQYmtkZjJfMS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKGNyeXB0byk7XG59XG4vLyBIVFRQIENsaWVudFxudmFyIGh0dHBDbGllbnQ7XG50cnkge1xuICAgIGh0dHBDbGllbnQgPSByZXF1aXJlKCdfaHR0cF9jbGllbnQnKTtcbn1cbmNhdGNoIChlcnIpIHtcbn1cbmlmIChodHRwQ2xpZW50ICYmIGh0dHBDbGllbnQuQ2xpZW50UmVxdWVzdCkge1xuICAgIHZhciBDbGllbnRSZXF1ZXN0XzEgPSBodHRwQ2xpZW50LkNsaWVudFJlcXVlc3QuYmluZChodHRwQ2xpZW50KTtcbiAgICBodHRwQ2xpZW50LkNsaWVudFJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRSZXF1ZXN0XzEob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgem9uZSA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2xpZW50UmVxdWVzdF8xKG9wdGlvbnMsIHpvbmUud3JhcChjYWxsYmFjaywgJ2h0dHAuQ2xpZW50UmVxdWVzdCcpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRjaE5leHRUaWNrKCkge1xuICAgIHZhciBzZXROYXRpdmUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayh0YXNrKSB7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5kYXRhO1xuICAgICAgICBhcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFzay5pbnZva2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0TmF0aXZlLmFwcGx5KHByb2Nlc3MsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgc2V0TmF0aXZlID1cbiAgICAgICAgcGF0Y2hNZXRob2QocHJvY2VzcywgJ25leHRUaWNrJywgZnVuY3Rpb24gKGRlbGVnYXRlKSB7IHJldHVybiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB6b25lLnNjaGVkdWxlTWljcm9UYXNrKCduZXh0VGljaycsIGFyZ3NbMF0sIGFyZ3MsIHNjaGVkdWxlVGFzayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciBieSBjYWxsaW5nIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseShwcm9jZXNzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTsgfSk7XG59XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zone.js/dist/zone-node.js\n");

/***/ }),

/***/ "./src/Debugger/attachQuickPick.ts":
/*!*****************************************!*\
  !*** ./src/Debugger/attachQuickPick.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass RefreshButton {\r\n    get iconPath() {\r\n        const refreshImagePathDark = util.getExtensionFilePath(\"assets/Refresh_inverse.svg\");\r\n        const refreshImagePathLight = util.getExtensionFilePath(\"assets/Refresh.svg\");\r\n        return {\r\n            dark: vscode.Uri.file(refreshImagePathDark),\r\n            light: vscode.Uri.file(refreshImagePathLight)\r\n        };\r\n    }\r\n    get tooltip() {\r\n        return \"Refresh process list\";\r\n    }\r\n}\r\nfunction showQuickPick(getAttachItems) {\r\n    return getAttachItems().then(processEntries => {\r\n        return new Promise((resolve, reject) => {\r\n            let quickPick = vscode.window.createQuickPick();\r\n            quickPick.title = \"Attach to process\";\r\n            quickPick.canSelectMany = false;\r\n            quickPick.matchOnDescription = true;\r\n            quickPick.matchOnDetail = true;\r\n            quickPick.placeholder = \"Select the process to attach to\";\r\n            quickPick.items = processEntries;\r\n            quickPick.buttons = [new RefreshButton()];\r\n            let disposables = [];\r\n            quickPick.onDidTriggerButton(button => {\r\n                getAttachItems().then(processEntries => quickPick.items = processEntries);\r\n            }, undefined, disposables);\r\n            quickPick.onDidAccept(() => {\r\n                if (quickPick.selectedItems.length !== 1) {\r\n                    reject(new Error(\"Process not selected\"));\r\n                }\r\n                let selectedId = quickPick.selectedItems[0].id;\r\n                disposables.forEach(item => item.dispose());\r\n                quickPick.dispose();\r\n                resolve(selectedId);\r\n            }, undefined, disposables);\r\n            quickPick.onDidHide(() => {\r\n                disposables.forEach(item => item.dispose());\r\n                quickPick.dispose();\r\n                reject(new Error(\"Process not selected.\"));\r\n            }, undefined, disposables);\r\n            quickPick.show();\r\n        });\r\n    });\r\n}\r\nexports.showQuickPick = showQuickPick;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvYXR0YWNoUXVpY2tQaWNrLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9EZWJ1Z2dlci9hdHRhY2hRdWlja1BpY2sudHMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY2xhc3MgUmVmcmVzaEJ1dHRvbiB7XHJcbiAgICBnZXQgaWNvblBhdGgoKSB7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaEltYWdlUGF0aERhcmsgPSB1dGlsLmdldEV4dGVuc2lvbkZpbGVQYXRoKFwiYXNzZXRzL1JlZnJlc2hfaW52ZXJzZS5zdmdcIik7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaEltYWdlUGF0aExpZ2h0ID0gdXRpbC5nZXRFeHRlbnNpb25GaWxlUGF0aChcImFzc2V0cy9SZWZyZXNoLnN2Z1wiKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXJrOiB2c2NvZGUuVXJpLmZpbGUocmVmcmVzaEltYWdlUGF0aERhcmspLFxyXG4gICAgICAgICAgICBsaWdodDogdnNjb2RlLlVyaS5maWxlKHJlZnJlc2hJbWFnZVBhdGhMaWdodClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IHRvb2x0aXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiUmVmcmVzaCBwcm9jZXNzIGxpc3RcIjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzaG93UXVpY2tQaWNrKGdldEF0dGFjaEl0ZW1zKSB7XHJcbiAgICByZXR1cm4gZ2V0QXR0YWNoSXRlbXMoKS50aGVuKHByb2Nlc3NFbnRyaWVzID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcXVpY2tQaWNrID0gdnNjb2RlLndpbmRvdy5jcmVhdGVRdWlja1BpY2soKTtcclxuICAgICAgICAgICAgcXVpY2tQaWNrLnRpdGxlID0gXCJBdHRhY2ggdG8gcHJvY2Vzc1wiO1xyXG4gICAgICAgICAgICBxdWlja1BpY2suY2FuU2VsZWN0TWFueSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBxdWlja1BpY2subWF0Y2hPbkRlc2NyaXB0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgcXVpY2tQaWNrLm1hdGNoT25EZXRhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICBxdWlja1BpY2sucGxhY2Vob2xkZXIgPSBcIlNlbGVjdCB0aGUgcHJvY2VzcyB0byBhdHRhY2ggdG9cIjtcclxuICAgICAgICAgICAgcXVpY2tQaWNrLml0ZW1zID0gcHJvY2Vzc0VudHJpZXM7XHJcbiAgICAgICAgICAgIHF1aWNrUGljay5idXR0b25zID0gW25ldyBSZWZyZXNoQnV0dG9uKCldO1xyXG4gICAgICAgICAgICBsZXQgZGlzcG9zYWJsZXMgPSBbXTtcclxuICAgICAgICAgICAgcXVpY2tQaWNrLm9uRGlkVHJpZ2dlckJ1dHRvbihidXR0b24gPT4ge1xyXG4gICAgICAgICAgICAgICAgZ2V0QXR0YWNoSXRlbXMoKS50aGVuKHByb2Nlc3NFbnRyaWVzID0+IHF1aWNrUGljay5pdGVtcyA9IHByb2Nlc3NFbnRyaWVzKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBkaXNwb3NhYmxlcyk7XHJcbiAgICAgICAgICAgIHF1aWNrUGljay5vbkRpZEFjY2VwdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVpY2tQaWNrLnNlbGVjdGVkSXRlbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlByb2Nlc3Mgbm90IHNlbGVjdGVkXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZElkID0gcXVpY2tQaWNrLnNlbGVjdGVkSXRlbXNbMF0uaWQ7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5kaXNwb3NlKCkpO1xyXG4gICAgICAgICAgICAgICAgcXVpY2tQaWNrLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZWN0ZWRJZCk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgICAgICBxdWlja1BpY2sub25EaWRIaWRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLmZvckVhY2goaXRlbSA9PiBpdGVtLmRpc3Bvc2UoKSk7XHJcbiAgICAgICAgICAgICAgICBxdWlja1BpY2suZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlByb2Nlc3Mgbm90IHNlbGVjdGVkLlwiKSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgICAgICBxdWlja1BpY2suc2hvdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5zaG93UXVpY2tQaWNrID0gc2hvd1F1aWNrUGljaztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Debugger/attachQuickPick.ts\n");

/***/ }),

/***/ "./src/Debugger/attachToProcess.ts":
/*!*****************************************!*\
  !*** ./src/Debugger/attachToProcess.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_1 = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst nativeAttach_1 = __webpack_require__(/*! ./nativeAttach */ \"./src/Debugger/nativeAttach.ts\");\r\nconst attachQuickPick_1 = __webpack_require__(/*! ./attachQuickPick */ \"./src/Debugger/attachQuickPick.ts\");\r\nconst debugUtils = __webpack_require__(/*! ./utils */ \"./src/Debugger/utils.ts\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass AttachPicker {\r\n    constructor(attachItemsProvider) {\r\n        this.attachItemsProvider = attachItemsProvider;\r\n    }\r\n    ShowAttachEntries() {\r\n        return util.isExtensionReady().then(ready => {\r\n            if (!ready) {\r\n                util.displayExtensionNotReadyPrompt();\r\n            }\r\n            else {\r\n                return attachQuickPick_1.showQuickPick(() => this.attachItemsProvider.getAttachItems());\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.AttachPicker = AttachPicker;\r\nclass RemoteAttachPicker {\r\n    constructor() {\r\n        this._channel = null;\r\n        this._channel = vscode.window.createOutputChannel('remote-attach');\r\n    }\r\n    ShowAttachEntries(config) {\r\n        return util.isExtensionReady().then(ready => {\r\n            if (!ready) {\r\n                util.displayExtensionNotReadyPrompt();\r\n            }\r\n            else {\r\n                this._channel.clear();\r\n                let pipeTransport = config ? config.pipeTransport : null;\r\n                if (pipeTransport === null) {\r\n                    return Promise.reject(new Error(\"Chosen debug configuration does not contain pipeTransport\"));\r\n                }\r\n                let pipeProgram = null;\r\n                if (os.platform() === 'win32' &&\r\n                    pipeTransport.pipeProgram &&\r\n                    !fs.existsSync(pipeTransport.pipeProgram)) {\r\n                    const pipeProgramStr = pipeTransport.pipeProgram.toLowerCase().trim();\r\n                    const expectedArch = debugUtils.ArchType[process.arch];\r\n                    if (!fs.existsSync(config.pipeTransport.pipeProgram)) {\r\n                        pipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(pipeProgramStr, expectedArch);\r\n                    }\r\n                    if (!pipeProgram && config.pipeTransport.pipeCwd) {\r\n                        const pipeCwdStr = config.pipeTransport.pipeCwd.toLowerCase().trim();\r\n                        const newPipeProgramStr = path.join(pipeCwdStr, pipeProgramStr);\r\n                        if (!fs.existsSync(newPipeProgramStr)) {\r\n                            pipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(newPipeProgramStr, expectedArch);\r\n                        }\r\n                    }\r\n                }\r\n                if (!pipeProgram) {\r\n                    pipeProgram = pipeTransport.pipeProgram;\r\n                }\r\n                let pipeArgs = pipeTransport.pipeArgs;\r\n                let argList = RemoteAttachPicker.createArgumentList(pipeArgs);\r\n                let pipeCmd = `\"${pipeProgram}\" ${argList}`;\r\n                return this.getRemoteOSAndProcesses(pipeCmd)\r\n                    .then(processes => {\r\n                    let attachPickOptions = {\r\n                        matchOnDetail: true,\r\n                        matchOnDescription: true,\r\n                        placeHolder: \"Select the process to attach to\"\r\n                    };\r\n                    return vscode.window.showQuickPick(processes, attachPickOptions)\r\n                        .then(item => {\r\n                        return item ? item.id : Promise.reject(new Error(\"Process not selected.\"));\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    }\r\n    getRemoteOSAndProcesses(pipeCmd) {\r\n        const command = `sh -c \"uname && if [ $(uname) = \\\\\\\"Linux\\\\\\\" ] ; then ${nativeAttach_1.PsProcessParser.psLinuxCommand} ; elif [ $(uname) = \\\\\\\"Darwin\\\\\\\" ] ; ` +\r\n            `then ${nativeAttach_1.PsProcessParser.psDarwinCommand}; fi\"`;\r\n        return common_1.execChildProcess(`${pipeCmd} '${command}'`, null, this._channel).then(output => {\r\n            let lines = output.split(/\\r?\\n/);\r\n            if (lines.length === 0) {\r\n                return Promise.reject(new Error(\"Pipe transport failed to get OS and processes.\"));\r\n            }\r\n            else {\r\n                let remoteOS = lines[0].replace(/[\\r\\n]+/g, '');\r\n                if (remoteOS !== \"Linux\" && remoteOS !== \"Darwin\") {\r\n                    return Promise.reject(new Error(`Operating system \"${remoteOS}\" not supported.`));\r\n                }\r\n                if (lines.length === 1) {\r\n                    return Promise.reject(new Error(\"Transport attach could not obtain processes list.\"));\r\n                }\r\n                else {\r\n                    let processes = lines.slice(1);\r\n                    return nativeAttach_1.PsProcessParser.ParseProcessFromPsArray(processes)\r\n                        .sort((a, b) => {\r\n                        if (a.name === undefined) {\r\n                            if (b.name === undefined) {\r\n                                return 0;\r\n                            }\r\n                            return 1;\r\n                        }\r\n                        if (b.name === undefined) {\r\n                            return -1;\r\n                        }\r\n                        let aLower = a.name.toLowerCase();\r\n                        let bLower = b.name.toLowerCase();\r\n                        if (aLower === bLower) {\r\n                            return 0;\r\n                        }\r\n                        return aLower < bLower ? -1 : 1;\r\n                    })\r\n                        .map(p => p.toAttachItem());\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static createArgumentList(args) {\r\n        let argsString = \"\";\r\n        for (let arg of args) {\r\n            if (argsString) {\r\n                argsString += \" \";\r\n            }\r\n            argsString += `\"${arg}\"`;\r\n        }\r\n        return argsString;\r\n    }\r\n}\r\nexports.RemoteAttachPicker = RemoteAttachPicker;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvYXR0YWNoVG9Qcm9jZXNzLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9EZWJ1Z2dlci9hdHRhY2hUb1Byb2Nlc3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IG5hdGl2ZUF0dGFjaF8xID0gcmVxdWlyZShcIi4vbmF0aXZlQXR0YWNoXCIpO1xyXG5jb25zdCBhdHRhY2hRdWlja1BpY2tfMSA9IHJlcXVpcmUoXCIuL2F0dGFjaFF1aWNrUGlja1wiKTtcclxuY29uc3QgZGVidWdVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNsYXNzIEF0dGFjaFBpY2tlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdHRhY2hJdGVtc1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hdHRhY2hJdGVtc1Byb3ZpZGVyID0gYXR0YWNoSXRlbXNQcm92aWRlcjtcclxuICAgIH1cclxuICAgIFNob3dBdHRhY2hFbnRyaWVzKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsLmlzRXh0ZW5zaW9uUmVhZHkoKS50aGVuKHJlYWR5ID0+IHtcclxuICAgICAgICAgICAgaWYgKCFyZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgdXRpbC5kaXNwbGF5RXh0ZW5zaW9uTm90UmVhZHlQcm9tcHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2hRdWlja1BpY2tfMS5zaG93UXVpY2tQaWNrKCgpID0+IHRoaXMuYXR0YWNoSXRlbXNQcm92aWRlci5nZXRBdHRhY2hJdGVtcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQXR0YWNoUGlja2VyID0gQXR0YWNoUGlja2VyO1xyXG5jbGFzcyBSZW1vdGVBdHRhY2hQaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IHZzY29kZS53aW5kb3cuY3JlYXRlT3V0cHV0Q2hhbm5lbCgncmVtb3RlLWF0dGFjaCcpO1xyXG4gICAgfVxyXG4gICAgU2hvd0F0dGFjaEVudHJpZXMoY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuaXNFeHRlbnNpb25SZWFkeSgpLnRoZW4ocmVhZHkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsLmRpc3BsYXlFeHRlbnNpb25Ob3RSZWFkeVByb21wdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbm5lbC5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBpcGVUcmFuc3BvcnQgPSBjb25maWcgPyBjb25maWcucGlwZVRyYW5zcG9ydCA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAocGlwZVRyYW5zcG9ydCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDaG9zZW4gZGVidWcgY29uZmlndXJhdGlvbiBkb2VzIG5vdCBjb250YWluIHBpcGVUcmFuc3BvcnRcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHBpcGVQcm9ncmFtID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGlwZVRyYW5zcG9ydC5waXBlUHJvZ3JhbSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFmcy5leGlzdHNTeW5jKHBpcGVUcmFuc3BvcnQucGlwZVByb2dyYW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGlwZVByb2dyYW1TdHIgPSBwaXBlVHJhbnNwb3J0LnBpcGVQcm9ncmFtLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQXJjaCA9IGRlYnVnVXRpbHMuQXJjaFR5cGVbcHJvY2Vzcy5hcmNoXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoY29uZmlnLnBpcGVUcmFuc3BvcnQucGlwZVByb2dyYW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpcGVQcm9ncmFtID0gZGVidWdVdGlscy5BcmNoaXRlY3R1cmVSZXBsYWNlci5jaGVja0FuZFJlcGxhY2VXU0xQaXBlUHJvZ3JhbShwaXBlUHJvZ3JhbVN0ciwgZXhwZWN0ZWRBcmNoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwaXBlUHJvZ3JhbSAmJiBjb25maWcucGlwZVRyYW5zcG9ydC5waXBlQ3dkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpcGVDd2RTdHIgPSBjb25maWcucGlwZVRyYW5zcG9ydC5waXBlQ3dkLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQaXBlUHJvZ3JhbVN0ciA9IHBhdGguam9pbihwaXBlQ3dkU3RyLCBwaXBlUHJvZ3JhbVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhuZXdQaXBlUHJvZ3JhbVN0cikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpcGVQcm9ncmFtID0gZGVidWdVdGlscy5BcmNoaXRlY3R1cmVSZXBsYWNlci5jaGVja0FuZFJlcGxhY2VXU0xQaXBlUHJvZ3JhbShuZXdQaXBlUHJvZ3JhbVN0ciwgZXhwZWN0ZWRBcmNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcGlwZVByb2dyYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwaXBlUHJvZ3JhbSA9IHBpcGVUcmFuc3BvcnQucGlwZVByb2dyYW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcGlwZUFyZ3MgPSBwaXBlVHJhbnNwb3J0LnBpcGVBcmdzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFyZ0xpc3QgPSBSZW1vdGVBdHRhY2hQaWNrZXIuY3JlYXRlQXJndW1lbnRMaXN0KHBpcGVBcmdzKTtcclxuICAgICAgICAgICAgICAgIGxldCBwaXBlQ21kID0gYFwiJHtwaXBlUHJvZ3JhbX1cIiAke2FyZ0xpc3R9YDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbW90ZU9TQW5kUHJvY2Vzc2VzKHBpcGVDbWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocHJvY2Vzc2VzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0YWNoUGlja09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoT25EZXRhaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoT25EZXNjcmlwdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXI6IFwiU2VsZWN0IHRoZSBwcm9jZXNzIHRvIGF0dGFjaCB0b1wiXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnNjb2RlLndpbmRvdy5zaG93UXVpY2tQaWNrKHByb2Nlc3NlcywgYXR0YWNoUGlja09wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaWQgOiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJQcm9jZXNzIG5vdCBzZWxlY3RlZC5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFJlbW90ZU9TQW5kUHJvY2Vzc2VzKHBpcGVDbWQpIHtcclxuICAgICAgICBjb25zdCBjb21tYW5kID0gYHNoIC1jIFwidW5hbWUgJiYgaWYgWyAkKHVuYW1lKSA9IFxcXFxcXFwiTGludXhcXFxcXFxcIiBdIDsgdGhlbiAke25hdGl2ZUF0dGFjaF8xLlBzUHJvY2Vzc1BhcnNlci5wc0xpbnV4Q29tbWFuZH0gOyBlbGlmIFsgJCh1bmFtZSkgPSBcXFxcXFxcIkRhcndpblxcXFxcXFwiIF0gOyBgICtcclxuICAgICAgICAgICAgYHRoZW4gJHtuYXRpdmVBdHRhY2hfMS5Qc1Byb2Nlc3NQYXJzZXIucHNEYXJ3aW5Db21tYW5kfTsgZmlcImA7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4ZWNDaGlsZFByb2Nlc3MoYCR7cGlwZUNtZH0gJyR7Y29tbWFuZH0nYCwgbnVsbCwgdGhpcy5fY2hhbm5lbCkudGhlbihvdXRwdXQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGluZXMgPSBvdXRwdXQuc3BsaXQoL1xccj9cXG4vKTtcclxuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlBpcGUgdHJhbnNwb3J0IGZhaWxlZCB0byBnZXQgT1MgYW5kIHByb2Nlc3Nlcy5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbW90ZU9TID0gbGluZXNbMF0ucmVwbGFjZSgvW1xcclxcbl0rL2csICcnKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVPUyAhPT0gXCJMaW51eFwiICYmIHJlbW90ZU9TICE9PSBcIkRhcndpblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgT3BlcmF0aW5nIHN5c3RlbSBcIiR7cmVtb3RlT1N9XCIgbm90IHN1cHBvcnRlZC5gKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlRyYW5zcG9ydCBhdHRhY2ggY291bGQgbm90IG9idGFpbiBwcm9jZXNzZXMgbGlzdC5cIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2Nlc3NlcyA9IGxpbmVzLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVBdHRhY2hfMS5Qc1Byb2Nlc3NQYXJzZXIuUGFyc2VQcm9jZXNzRnJvbVBzQXJyYXkocHJvY2Vzc2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5uYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIubmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFMb3dlciA9IGEubmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYkxvd2VyID0gYi5uYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhTG93ZXIgPT09IGJMb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFMb3dlciA8IGJMb3dlciA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHAgPT4gcC50b0F0dGFjaEl0ZW0oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVBcmd1bWVudExpc3QoYXJncykge1xyXG4gICAgICAgIGxldCBhcmdzU3RyaW5nID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBhcmcgb2YgYXJncykge1xyXG4gICAgICAgICAgICBpZiAoYXJnc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1N0cmluZyArPSBcIiBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmdzU3RyaW5nICs9IGBcIiR7YXJnfVwiYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyZ3NTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZW1vdGVBdHRhY2hQaWNrZXIgPSBSZW1vdGVBdHRhY2hQaWNrZXI7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Debugger/attachToProcess.ts\n");

/***/ }),

/***/ "./src/Debugger/configurationProvider.ts":
/*!***********************************************!*\
  !*** ./src/Debugger/configurationProvider.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst debugUtils = __webpack_require__(/*! ./utils */ \"./src/Debugger/utils.ts\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst extension_1 = __webpack_require__(/*! ../LanguageServer/extension */ \"./src/LanguageServer/extension.ts\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst Telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nconst extension_2 = __webpack_require__(/*! ./extension */ \"./src/Debugger/extension.ts\");\r\nconst configurations_1 = __webpack_require__(/*! ./configurations */ \"./src/Debugger/configurations.ts\");\r\nconst jsonc_parser_1 = __webpack_require__(/*! jsonc-parser */ \"./node_modules/jsonc-parser/lib/esm/main.js\");\r\nconst platform_1 = __webpack_require__(/*! ../platform */ \"./src/platform.ts\");\r\nfunction isDebugLaunchStr(str) {\r\n    return str === \"(gdb) Launch\" || str === \"(lldb) Launch\" || str === \"(Windows) Launch\";\r\n}\r\nclass QuickPickConfigurationProvider {\r\n    constructor(provider) {\r\n        this.underlyingProvider = provider;\r\n    }\r\n    provideDebugConfigurations(folder, token) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const configs = yield this.underlyingProvider.provideDebugConfigurations(folder, token);\r\n            const defaultConfig = configs.find(config => { return isDebugLaunchStr(config.name); });\r\n            console.assert(defaultConfig);\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor || !util.fileIsCOrCppSource(editor.document.fileName) || configs.length <= 1) {\r\n                return [defaultConfig];\r\n            }\r\n            const items = configs.map(config => {\r\n                let menuItem = { label: config.name, configuration: config };\r\n                if (isDebugLaunchStr(menuItem.label)) {\r\n                    menuItem.label = \"Default Configuration\";\r\n                }\r\n                return menuItem;\r\n            });\r\n            const selection = yield vscode.window.showQuickPick(items, { placeHolder: \"Select a configuration\" });\r\n            if (!selection) {\r\n                throw new Error();\r\n            }\r\n            if (selection.label.startsWith(\"cl.exe\")) {\r\n                if (!process.env.DevEnvDir || process.env.DevEnvDir.length === 0) {\r\n                    vscode.window.showErrorMessage('cl.exe build and debug is only usable when VS Code is run from the Developer Command Prompt for VS.');\r\n                    throw new Error();\r\n                }\r\n            }\r\n            if (selection.label.indexOf(extension_2.buildAndDebugActiveFileStr()) !== -1 && selection.configuration.preLaunchTask) {\r\n                try {\r\n                    yield util.ensureBuildTaskExists(selection.configuration.preLaunchTask);\r\n                    yield vscode.debug.startDebugging(folder, selection.configuration);\r\n                    Telemetry.logDebuggerEvent(\"buildAndDebug\", { \"success\": \"true\" });\r\n                }\r\n                catch (e) {\r\n                    Telemetry.logDebuggerEvent(\"buildAndDebug\", { \"success\": \"false\" });\r\n                }\r\n            }\r\n            return [selection.configuration];\r\n        });\r\n    }\r\n    resolveDebugConfiguration(folder, config, token) {\r\n        return this.underlyingProvider.resolveDebugConfiguration(folder, config, token);\r\n    }\r\n}\r\nexports.QuickPickConfigurationProvider = QuickPickConfigurationProvider;\r\nclass CppConfigurationProvider {\r\n    constructor(provider, type) {\r\n        this.provider = provider;\r\n        this.type = type;\r\n    }\r\n    provideDebugConfigurations(folder, token) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let buildTasks = yield extension_1.getBuildTasks();\r\n            if (buildTasks.length === 0) {\r\n                return Promise.resolve(this.provider.getInitialConfigurations(this.type));\r\n            }\r\n            const defaultConfig = this.provider.getInitialConfigurations(this.type).find(config => {\r\n                return isDebugLaunchStr(config.name);\r\n            });\r\n            console.assert(defaultConfig, \"Could not find default debug configuration.\");\r\n            const platformInfo = yield platform_1.PlatformInformation.GetPlatformInformation();\r\n            const platform = platformInfo.platform;\r\n            buildTasks = buildTasks.filter((task) => {\r\n                if (defaultConfig.name === \"(Windows) Launch\") {\r\n                    if (task.name.startsWith(\"cl.exe\")) {\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (!task.name.startsWith(\"cl.exe\")) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n            let configs = yield Promise.all(buildTasks.map((task) => __awaiter(this, void 0, void 0, function* () {\r\n                const definition = task.definition;\r\n                const compilerName = path.basename(definition.compilerPath);\r\n                let newConfig = Object.assign({}, defaultConfig);\r\n                newConfig.name = compilerName + extension_2.buildAndDebugActiveFileStr();\r\n                newConfig.preLaunchTask = task.name;\r\n                newConfig.externalConsole = false;\r\n                const exeName = path.join(\"${fileDirname}\", \"${fileBasenameNoExtension}\");\r\n                newConfig.program = platform === \"win32\" ? exeName + \".exe\" : exeName;\r\n                return new Promise(resolve => {\r\n                    if (platform === \"darwin\") {\r\n                        return resolve(newConfig);\r\n                    }\r\n                    else {\r\n                        let debuggerName;\r\n                        if (compilerName.startsWith(\"clang\")) {\r\n                            newConfig.MIMode = \"lldb\";\r\n                            const suffixIndex = compilerName.indexOf(\"-\");\r\n                            const suffix = suffixIndex === -1 ? \"\" : compilerName.substr(suffixIndex);\r\n                            debuggerName = \"lldb-mi\" + suffix;\r\n                        }\r\n                        else if (compilerName === \"cl.exe\") {\r\n                            newConfig.miDebuggerPath = undefined;\r\n                            newConfig.type = \"cppvsdbg\";\r\n                            return resolve(newConfig);\r\n                        }\r\n                        else {\r\n                            debuggerName = \"gdb\";\r\n                        }\r\n                        if (platform === \"win32\") {\r\n                            debuggerName += \".exe\";\r\n                        }\r\n                        const compilerDirname = path.dirname(definition.compilerPath);\r\n                        const debuggerPath = path.join(compilerDirname, debuggerName);\r\n                        fs.stat(debuggerPath, (err, stats) => {\r\n                            if (!err && stats && stats.isFile) {\r\n                                newConfig.miDebuggerPath = debuggerPath;\r\n                            }\r\n                            else {\r\n                                newConfig.miDebuggerPath = path.join(\"/usr\", \"bin\", debuggerName);\r\n                            }\r\n                            return resolve(newConfig);\r\n                        });\r\n                    }\r\n                });\r\n            })));\r\n            configs.push(defaultConfig);\r\n            return configs;\r\n        });\r\n    }\r\n    resolveDebugConfiguration(folder, config, token) {\r\n        if (config) {\r\n            if (config.type === 'cppvsdbg' && os.platform() !== 'win32') {\r\n                vscode.window.showErrorMessage(\"Debugger of type: 'cppvsdbg' is only available on Windows. Use type: 'cppdbg' on the current OS platform.\");\r\n                return undefined;\r\n            }\r\n            if (os.platform() === 'win32' &&\r\n                config.pipeTransport &&\r\n                config.pipeTransport.pipeProgram) {\r\n                let replacedPipeProgram = null;\r\n                const pipeProgramStr = config.pipeTransport.pipeProgram.toLowerCase().trim();\r\n                replacedPipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(pipeProgramStr, debugUtils.ArchType.ia32);\r\n                if (!replacedPipeProgram && !path.isAbsolute(pipeProgramStr) && config.pipeTransport.pipeCwd) {\r\n                    const pipeCwdStr = config.pipeTransport.pipeCwd.toLowerCase().trim();\r\n                    const newPipeProgramStr = path.join(pipeCwdStr, pipeProgramStr);\r\n                    replacedPipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(newPipeProgramStr, debugUtils.ArchType.ia32);\r\n                }\r\n                if (replacedPipeProgram) {\r\n                    config.pipeTransport.pipeProgram = replacedPipeProgram;\r\n                }\r\n            }\r\n        }\r\n        return config && config.type ? config : null;\r\n    }\r\n}\r\nclass CppVsDbgConfigurationProvider extends CppConfigurationProvider {\r\n    constructor(provider) {\r\n        super(provider, configurations_1.DebuggerType.cppvsdbg);\r\n    }\r\n}\r\nexports.CppVsDbgConfigurationProvider = CppVsDbgConfigurationProvider;\r\nclass CppDbgConfigurationProvider extends CppConfigurationProvider {\r\n    constructor(provider) {\r\n        super(provider, configurations_1.DebuggerType.cppdbg);\r\n    }\r\n}\r\nexports.CppDbgConfigurationProvider = CppDbgConfigurationProvider;\r\nclass ConfigurationAssetProviderFactory {\r\n    static getConfigurationProvider() {\r\n        switch (os.platform()) {\r\n            case 'win32':\r\n                return new WindowsConfigurationProvider();\r\n            case 'darwin':\r\n                return new OSXConfigurationProvider();\r\n            case 'linux':\r\n                return new LinuxConfigurationProvider();\r\n            default:\r\n                throw new Error(\"Unexpected OS type\");\r\n        }\r\n    }\r\n}\r\nexports.ConfigurationAssetProviderFactory = ConfigurationAssetProviderFactory;\r\nclass DefaultConfigurationProvider {\r\n    getInitialConfigurations(debuggerType) {\r\n        let configurationSnippet = [];\r\n        this.configurations.forEach(configuration => {\r\n            configurationSnippet.push(configuration.GetLaunchConfiguration());\r\n        });\r\n        let initialConfigurations = configurationSnippet.filter(snippet => snippet.debuggerType === debuggerType && snippet.isInitialConfiguration)\r\n            .map(snippet => JSON.parse(snippet.bodyText));\r\n        return initialConfigurations;\r\n    }\r\n    getConfigurationSnippets() {\r\n        let completionItems = [];\r\n        this.configurations.forEach(configuration => {\r\n            completionItems.push(convertConfigurationSnippetToCompetionItem(configuration.GetLaunchConfiguration()));\r\n            completionItems.push(convertConfigurationSnippetToCompetionItem(configuration.GetAttachConfiguration()));\r\n        });\r\n        return completionItems;\r\n    }\r\n}\r\nclass WindowsConfigurationProvider extends DefaultConfigurationProvider {\r\n    constructor() {\r\n        super();\r\n        this.executable = \"a.exe\";\r\n        this.pipeProgram = \"<full path to pipe program such as plink.exe>\";\r\n        this.MIMode = 'gdb';\r\n        this.setupCommandsBlock = `\"setupCommands\": [\r\n    {\r\n        \"description\": \"Enable pretty-printing for gdb\",\r\n        \"text\": \"-enable-pretty-printing\",\r\n        \"ignoreFailures\": true\r\n    }\r\n]`;\r\n        this.configurations = [\r\n            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),\r\n            new configurations_1.PipeTransportConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),\r\n            new configurations_1.WindowsConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),\r\n            new configurations_1.WSLConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),\r\n        ];\r\n    }\r\n}\r\nclass OSXConfigurationProvider extends DefaultConfigurationProvider {\r\n    constructor() {\r\n        super();\r\n        this.MIMode = 'lldb';\r\n        this.executable = \"a.out\";\r\n        this.pipeProgram = \"/usr/bin/ssh\";\r\n        this.configurations = [\r\n            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram),\r\n        ];\r\n    }\r\n}\r\nclass LinuxConfigurationProvider extends DefaultConfigurationProvider {\r\n    constructor() {\r\n        super();\r\n        this.MIMode = 'gdb';\r\n        this.setupCommandsBlock = `\"setupCommands\": [\r\n    {\r\n        \"description\": \"Enable pretty-printing for gdb\",\r\n        \"text\": \"-enable-pretty-printing\",\r\n        \"ignoreFailures\": true\r\n    }\r\n]`;\r\n        this.executable = \"a.out\";\r\n        this.pipeProgram = \"/usr/bin/ssh\";\r\n        this.configurations = [\r\n            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),\r\n            new configurations_1.PipeTransportConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock)\r\n        ];\r\n    }\r\n}\r\nfunction convertConfigurationSnippetToCompetionItem(snippet) {\r\n    let item = new vscode.CompletionItem(snippet.label, vscode.CompletionItemKind.Snippet);\r\n    item.insertText = snippet.bodyText;\r\n    return item;\r\n}\r\nclass ConfigurationSnippetProvider {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        this.snippets = this.provider.getConfigurationSnippets();\r\n    }\r\n    resolveCompletionItem(item, token) {\r\n        return Promise.resolve(item);\r\n    }\r\n    provideCompletionItems(document, position, token, context) {\r\n        let items = this.snippets;\r\n        const launch = jsonc_parser_1.parse(document.getText());\r\n        if (launch.configurations.length !== 0) {\r\n            items = [];\r\n            this.snippets.forEach((item) => items.push(Object.assign({}, item)));\r\n            items.map((item) => {\r\n                item.insertText = item.insertText + ',';\r\n            });\r\n        }\r\n        return Promise.resolve(new vscode.CompletionList(items, true));\r\n    }\r\n}\r\nexports.ConfigurationSnippetProvider = ConfigurationSnippetProvider;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvY29uZmlndXJhdGlvblByb3ZpZGVyLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9EZWJ1Z2dlci9jb25maWd1cmF0aW9uUHJvdmlkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBkZWJ1Z1V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IGV4dGVuc2lvbl8xID0gcmVxdWlyZShcIi4uL0xhbmd1YWdlU2VydmVyL2V4dGVuc2lvblwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCBUZWxlbWV0cnkgPSByZXF1aXJlKFwiLi4vdGVsZW1ldHJ5XCIpO1xyXG5jb25zdCBleHRlbnNpb25fMiA9IHJlcXVpcmUoXCIuL2V4dGVuc2lvblwiKTtcclxuY29uc3QgY29uZmlndXJhdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb25zXCIpO1xyXG5jb25zdCBqc29uY19wYXJzZXJfMSA9IHJlcXVpcmUoXCJqc29uYy1wYXJzZXJcIik7XHJcbmNvbnN0IHBsYXRmb3JtXzEgPSByZXF1aXJlKFwiLi4vcGxhdGZvcm1cIik7XHJcbmZ1bmN0aW9uIGlzRGVidWdMYXVuY2hTdHIoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyID09PSBcIihnZGIpIExhdW5jaFwiIHx8IHN0ciA9PT0gXCIobGxkYikgTGF1bmNoXCIgfHwgc3RyID09PSBcIihXaW5kb3dzKSBMYXVuY2hcIjtcclxufVxyXG5jbGFzcyBRdWlja1BpY2tDb25maWd1cmF0aW9uUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLnVuZGVybHlpbmdQcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgcHJvdmlkZURlYnVnQ29uZmlndXJhdGlvbnMoZm9sZGVyLCB0b2tlbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3MgPSB5aWVsZCB0aGlzLnVuZGVybHlpbmdQcm92aWRlci5wcm92aWRlRGVidWdDb25maWd1cmF0aW9ucyhmb2xkZXIsIHRva2VuKTtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IGNvbmZpZ3MuZmluZChjb25maWcgPT4geyByZXR1cm4gaXNEZWJ1Z0xhdW5jaFN0cihjb25maWcubmFtZSk7IH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChkZWZhdWx0Q29uZmlnKTtcclxuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yO1xyXG4gICAgICAgICAgICBpZiAoIWVkaXRvciB8fCAhdXRpbC5maWxlSXNDT3JDcHBTb3VyY2UoZWRpdG9yLmRvY3VtZW50LmZpbGVOYW1lKSB8fCBjb25maWdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2RlZmF1bHRDb25maWddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gY29uZmlncy5tYXAoY29uZmlnID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBtZW51SXRlbSA9IHsgbGFiZWw6IGNvbmZpZy5uYW1lLCBjb25maWd1cmF0aW9uOiBjb25maWcgfTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlYnVnTGF1bmNoU3RyKG1lbnVJdGVtLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtLmxhYmVsID0gXCJEZWZhdWx0IENvbmZpZ3VyYXRpb25cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtZW51SXRlbTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHlpZWxkIHZzY29kZS53aW5kb3cuc2hvd1F1aWNrUGljayhpdGVtcywgeyBwbGFjZUhvbGRlcjogXCJTZWxlY3QgYSBjb25maWd1cmF0aW9uXCIgfSk7XHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxhYmVsLnN0YXJ0c1dpdGgoXCJjbC5leGVcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzcy5lbnYuRGV2RW52RGlyIHx8IHByb2Nlc3MuZW52LkRldkVudkRpci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UoJ2NsLmV4ZSBidWlsZCBhbmQgZGVidWcgaXMgb25seSB1c2FibGUgd2hlbiBWUyBDb2RlIGlzIHJ1biBmcm9tIHRoZSBEZXZlbG9wZXIgQ29tbWFuZCBQcm9tcHQgZm9yIFZTLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGFiZWwuaW5kZXhPZihleHRlbnNpb25fMi5idWlsZEFuZERlYnVnQWN0aXZlRmlsZVN0cigpKSAhPT0gLTEgJiYgc2VsZWN0aW9uLmNvbmZpZ3VyYXRpb24ucHJlTGF1bmNoVGFzaykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB1dGlsLmVuc3VyZUJ1aWxkVGFza0V4aXN0cyhzZWxlY3Rpb24uY29uZmlndXJhdGlvbi5wcmVMYXVuY2hUYXNrKTtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB2c2NvZGUuZGVidWcuc3RhcnREZWJ1Z2dpbmcoZm9sZGVyLCBzZWxlY3Rpb24uY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJidWlsZEFuZERlYnVnXCIsIHsgXCJzdWNjZXNzXCI6IFwidHJ1ZVwiIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBUZWxlbWV0cnkubG9nRGVidWdnZXJFdmVudChcImJ1aWxkQW5kRGVidWdcIiwgeyBcInN1Y2Nlc3NcIjogXCJmYWxzZVwiIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbc2VsZWN0aW9uLmNvbmZpZ3VyYXRpb25dO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZURlYnVnQ29uZmlndXJhdGlvbihmb2xkZXIsIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nUHJvdmlkZXIucmVzb2x2ZURlYnVnQ29uZmlndXJhdGlvbihmb2xkZXIsIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVpY2tQaWNrQ29uZmlndXJhdGlvblByb3ZpZGVyID0gUXVpY2tQaWNrQ29uZmlndXJhdGlvblByb3ZpZGVyO1xyXG5jbGFzcyBDcHBDb25maWd1cmF0aW9uUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHR5cGUpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIH1cclxuICAgIHByb3ZpZGVEZWJ1Z0NvbmZpZ3VyYXRpb25zKGZvbGRlciwgdG9rZW4pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgYnVpbGRUYXNrcyA9IHlpZWxkIGV4dGVuc2lvbl8xLmdldEJ1aWxkVGFza3MoKTtcclxuICAgICAgICAgICAgaWYgKGJ1aWxkVGFza3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucHJvdmlkZXIuZ2V0SW5pdGlhbENvbmZpZ3VyYXRpb25zKHRoaXMudHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB0aGlzLnByb3ZpZGVyLmdldEluaXRpYWxDb25maWd1cmF0aW9ucyh0aGlzLnR5cGUpLmZpbmQoY29uZmlnID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0RlYnVnTGF1bmNoU3RyKGNvbmZpZy5uYW1lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGRlZmF1bHRDb25maWcsIFwiQ291bGQgbm90IGZpbmQgZGVmYXVsdCBkZWJ1ZyBjb25maWd1cmF0aW9uLlwiKTtcclxuICAgICAgICAgICAgY29uc3QgcGxhdGZvcm1JbmZvID0geWllbGQgcGxhdGZvcm1fMS5QbGF0Zm9ybUluZm9ybWF0aW9uLkdldFBsYXRmb3JtSW5mb3JtYXRpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBwbGF0Zm9ybUluZm8ucGxhdGZvcm07XHJcbiAgICAgICAgICAgIGJ1aWxkVGFza3MgPSBidWlsZFRhc2tzLmZpbHRlcigodGFzaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDb25maWcubmFtZSA9PT0gXCIoV2luZG93cykgTGF1bmNoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5uYW1lLnN0YXJ0c1dpdGgoXCJjbC5leGVcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXNrLm5hbWUuc3RhcnRzV2l0aChcImNsLmV4ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlncyA9IHlpZWxkIFByb21pc2UuYWxsKGJ1aWxkVGFza3MubWFwKCh0YXNrKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGFzay5kZWZpbml0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGlsZXJOYW1lID0gcGF0aC5iYXNlbmFtZShkZWZpbml0aW9uLmNvbXBpbGVyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICBuZXdDb25maWcubmFtZSA9IGNvbXBpbGVyTmFtZSArIGV4dGVuc2lvbl8yLmJ1aWxkQW5kRGVidWdBY3RpdmVGaWxlU3RyKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdDb25maWcucHJlTGF1bmNoVGFzayA9IHRhc2submFtZTtcclxuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5leHRlcm5hbENvbnNvbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZU5hbWUgPSBwYXRoLmpvaW4oXCIke2ZpbGVEaXJuYW1lfVwiLCBcIiR7ZmlsZUJhc2VuYW1lTm9FeHRlbnNpb259XCIpO1xyXG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLnByb2dyYW0gPSBwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiID8gZXhlTmFtZSArIFwiLmV4ZVwiIDogZXhlTmFtZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobmV3Q29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWJ1Z2dlck5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21waWxlck5hbWUuc3RhcnRzV2l0aChcImNsYW5nXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuTUlNb2RlID0gXCJsbGRiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXhJbmRleCA9IGNvbXBpbGVyTmFtZS5pbmRleE9mKFwiLVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHN1ZmZpeEluZGV4ID09PSAtMSA/IFwiXCIgOiBjb21waWxlck5hbWUuc3Vic3RyKHN1ZmZpeEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyTmFtZSA9IFwibGxkYi1taVwiICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyTmFtZSA9PT0gXCJjbC5leGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLm1pRGVidWdnZXJQYXRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLnR5cGUgPSBcImNwcHZzZGJnXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShuZXdDb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJOYW1lID0gXCJnZGJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJOYW1lICs9IFwiLmV4ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyRGlybmFtZSA9IHBhdGguZGlybmFtZShkZWZpbml0aW9uLmNvbXBpbGVyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnZ2VyUGF0aCA9IHBhdGguam9pbihjb21waWxlckRpcm5hbWUsIGRlYnVnZ2VyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLnN0YXQoZGVidWdnZXJQYXRoLCAoZXJyLCBzdGF0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgc3RhdHMgJiYgc3RhdHMuaXNGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLm1pRGVidWdnZXJQYXRoID0gZGVidWdnZXJQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLm1pRGVidWdnZXJQYXRoID0gcGF0aC5qb2luKFwiL3VzclwiLCBcImJpblwiLCBkZWJ1Z2dlck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobmV3Q29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgIGNvbmZpZ3MucHVzaChkZWZhdWx0Q29uZmlnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlRGVidWdDb25maWd1cmF0aW9uKGZvbGRlciwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy50eXBlID09PSAnY3BwdnNkYmcnICYmIG9zLnBsYXRmb3JtKCkgIT09ICd3aW4zMicpIHtcclxuICAgICAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZShcIkRlYnVnZ2VyIG9mIHR5cGU6ICdjcHB2c2RiZycgaXMgb25seSBhdmFpbGFibGUgb24gV2luZG93cy4gVXNlIHR5cGU6ICdjcHBkYmcnIG9uIHRoZSBjdXJyZW50IE9TIHBsYXRmb3JtLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicgJiZcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5waXBlVHJhbnNwb3J0ICYmXHJcbiAgICAgICAgICAgICAgICBjb25maWcucGlwZVRyYW5zcG9ydC5waXBlUHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VkUGlwZVByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGlwZVByb2dyYW1TdHIgPSBjb25maWcucGlwZVRyYW5zcG9ydC5waXBlUHJvZ3JhbS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VkUGlwZVByb2dyYW0gPSBkZWJ1Z1V0aWxzLkFyY2hpdGVjdHVyZVJlcGxhY2VyLmNoZWNrQW5kUmVwbGFjZVdTTFBpcGVQcm9ncmFtKHBpcGVQcm9ncmFtU3RyLCBkZWJ1Z1V0aWxzLkFyY2hUeXBlLmlhMzIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlZFBpcGVQcm9ncmFtICYmICFwYXRoLmlzQWJzb2x1dGUocGlwZVByb2dyYW1TdHIpICYmIGNvbmZpZy5waXBlVHJhbnNwb3J0LnBpcGVDd2QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXBlQ3dkU3RyID0gY29uZmlnLnBpcGVUcmFuc3BvcnQucGlwZUN3ZC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQaXBlUHJvZ3JhbVN0ciA9IHBhdGguam9pbihwaXBlQ3dkU3RyLCBwaXBlUHJvZ3JhbVN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWRQaXBlUHJvZ3JhbSA9IGRlYnVnVXRpbHMuQXJjaGl0ZWN0dXJlUmVwbGFjZXIuY2hlY2tBbmRSZXBsYWNlV1NMUGlwZVByb2dyYW0obmV3UGlwZVByb2dyYW1TdHIsIGRlYnVnVXRpbHMuQXJjaFR5cGUuaWEzMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZWRQaXBlUHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5waXBlVHJhbnNwb3J0LnBpcGVQcm9ncmFtID0gcmVwbGFjZWRQaXBlUHJvZ3JhbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29uZmlnICYmIGNvbmZpZy50eXBlID8gY29uZmlnIDogbnVsbDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDcHBWc0RiZ0NvbmZpZ3VyYXRpb25Qcm92aWRlciBleHRlbmRzIENwcENvbmZpZ3VyYXRpb25Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKHByb3ZpZGVyLCBjb25maWd1cmF0aW9uc18xLkRlYnVnZ2VyVHlwZS5jcHB2c2RiZyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DcHBWc0RiZ0NvbmZpZ3VyYXRpb25Qcm92aWRlciA9IENwcFZzRGJnQ29uZmlndXJhdGlvblByb3ZpZGVyO1xyXG5jbGFzcyBDcHBEYmdDb25maWd1cmF0aW9uUHJvdmlkZXIgZXh0ZW5kcyBDcHBDb25maWd1cmF0aW9uUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihwcm92aWRlciwgY29uZmlndXJhdGlvbnNfMS5EZWJ1Z2dlclR5cGUuY3BwZGJnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNwcERiZ0NvbmZpZ3VyYXRpb25Qcm92aWRlciA9IENwcERiZ0NvbmZpZ3VyYXRpb25Qcm92aWRlcjtcclxuY2xhc3MgQ29uZmlndXJhdGlvbkFzc2V0UHJvdmlkZXJGYWN0b3J5IHtcclxuICAgIHN0YXRpYyBnZXRDb25maWd1cmF0aW9uUHJvdmlkZXIoKSB7XHJcbiAgICAgICAgc3dpdGNoIChvcy5wbGF0Zm9ybSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3dpbjMyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93c0NvbmZpZ3VyYXRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjYXNlICdkYXJ3aW4nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPU1hDb25maWd1cmF0aW9uUHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY2FzZSAnbGludXgnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW51eENvbmZpZ3VyYXRpb25Qcm92aWRlcigpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBPUyB0eXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbmZpZ3VyYXRpb25Bc3NldFByb3ZpZGVyRmFjdG9yeSA9IENvbmZpZ3VyYXRpb25Bc3NldFByb3ZpZGVyRmFjdG9yeTtcclxuY2xhc3MgRGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlciB7XHJcbiAgICBnZXRJbml0aWFsQ29uZmlndXJhdGlvbnMoZGVidWdnZXJUeXBlKSB7XHJcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb25TbmlwcGV0ID0gW107XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucy5mb3JFYWNoKGNvbmZpZ3VyYXRpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uU25pcHBldC5wdXNoKGNvbmZpZ3VyYXRpb24uR2V0TGF1bmNoQ29uZmlndXJhdGlvbigpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaW5pdGlhbENvbmZpZ3VyYXRpb25zID0gY29uZmlndXJhdGlvblNuaXBwZXQuZmlsdGVyKHNuaXBwZXQgPT4gc25pcHBldC5kZWJ1Z2dlclR5cGUgPT09IGRlYnVnZ2VyVHlwZSAmJiBzbmlwcGV0LmlzSW5pdGlhbENvbmZpZ3VyYXRpb24pXHJcbiAgICAgICAgICAgIC5tYXAoc25pcHBldCA9PiBKU09OLnBhcnNlKHNuaXBwZXQuYm9keVRleHQpKTtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbENvbmZpZ3VyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29uZmlndXJhdGlvblNuaXBwZXRzKCkge1xyXG4gICAgICAgIGxldCBjb21wbGV0aW9uSXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zLmZvckVhY2goY29uZmlndXJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRpb25JdGVtcy5wdXNoKGNvbnZlcnRDb25maWd1cmF0aW9uU25pcHBldFRvQ29tcGV0aW9uSXRlbShjb25maWd1cmF0aW9uLkdldExhdW5jaENvbmZpZ3VyYXRpb24oKSkpO1xyXG4gICAgICAgICAgICBjb21wbGV0aW9uSXRlbXMucHVzaChjb252ZXJ0Q29uZmlndXJhdGlvblNuaXBwZXRUb0NvbXBldGlvbkl0ZW0oY29uZmlndXJhdGlvbi5HZXRBdHRhY2hDb25maWd1cmF0aW9uKCkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGlvbkl0ZW1zO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFdpbmRvd3NDb25maWd1cmF0aW9uUHJvdmlkZXIgZXh0ZW5kcyBEZWZhdWx0Q29uZmlndXJhdGlvblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5leGVjdXRhYmxlID0gXCJhLmV4ZVwiO1xyXG4gICAgICAgIHRoaXMucGlwZVByb2dyYW0gPSBcIjxmdWxsIHBhdGggdG8gcGlwZSBwcm9ncmFtIHN1Y2ggYXMgcGxpbmsuZXhlPlwiO1xyXG4gICAgICAgIHRoaXMuTUlNb2RlID0gJ2dkYic7XHJcbiAgICAgICAgdGhpcy5zZXR1cENvbW1hbmRzQmxvY2sgPSBgXCJzZXR1cENvbW1hbmRzXCI6IFtcclxuICAgIHtcclxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRW5hYmxlIHByZXR0eS1wcmludGluZyBmb3IgZ2RiXCIsXHJcbiAgICAgICAgXCJ0ZXh0XCI6IFwiLWVuYWJsZS1wcmV0dHktcHJpbnRpbmdcIixcclxuICAgICAgICBcImlnbm9yZUZhaWx1cmVzXCI6IHRydWVcclxuICAgIH1cclxuXWA7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IFtcclxuICAgICAgICAgICAgbmV3IGNvbmZpZ3VyYXRpb25zXzEuTUlDb25maWd1cmF0aW9ucyh0aGlzLk1JTW9kZSwgdGhpcy5leGVjdXRhYmxlLCB0aGlzLnBpcGVQcm9ncmFtLCB0aGlzLnNldHVwQ29tbWFuZHNCbG9jayksXHJcbiAgICAgICAgICAgIG5ldyBjb25maWd1cmF0aW9uc18xLlBpcGVUcmFuc3BvcnRDb25maWd1cmF0aW9ucyh0aGlzLk1JTW9kZSwgdGhpcy5leGVjdXRhYmxlLCB0aGlzLnBpcGVQcm9ncmFtLCB0aGlzLnNldHVwQ29tbWFuZHNCbG9jayksXHJcbiAgICAgICAgICAgIG5ldyBjb25maWd1cmF0aW9uc18xLldpbmRvd3NDb25maWd1cmF0aW9ucyh0aGlzLk1JTW9kZSwgdGhpcy5leGVjdXRhYmxlLCB0aGlzLnBpcGVQcm9ncmFtLCB0aGlzLnNldHVwQ29tbWFuZHNCbG9jayksXHJcbiAgICAgICAgICAgIG5ldyBjb25maWd1cmF0aW9uc18xLldTTENvbmZpZ3VyYXRpb25zKHRoaXMuTUlNb2RlLCB0aGlzLmV4ZWN1dGFibGUsIHRoaXMucGlwZVByb2dyYW0sIHRoaXMuc2V0dXBDb21tYW5kc0Jsb2NrKSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE9TWENvbmZpZ3VyYXRpb25Qcm92aWRlciBleHRlbmRzIERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLk1JTW9kZSA9ICdsbGRiJztcclxuICAgICAgICB0aGlzLmV4ZWN1dGFibGUgPSBcImEub3V0XCI7XHJcbiAgICAgICAgdGhpcy5waXBlUHJvZ3JhbSA9IFwiL3Vzci9iaW4vc3NoXCI7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IFtcclxuICAgICAgICAgICAgbmV3IGNvbmZpZ3VyYXRpb25zXzEuTUlDb25maWd1cmF0aW9ucyh0aGlzLk1JTW9kZSwgdGhpcy5leGVjdXRhYmxlLCB0aGlzLnBpcGVQcm9ncmFtKSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIExpbnV4Q29uZmlndXJhdGlvblByb3ZpZGVyIGV4dGVuZHMgRGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuTUlNb2RlID0gJ2dkYic7XHJcbiAgICAgICAgdGhpcy5zZXR1cENvbW1hbmRzQmxvY2sgPSBgXCJzZXR1cENvbW1hbmRzXCI6IFtcclxuICAgIHtcclxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRW5hYmxlIHByZXR0eS1wcmludGluZyBmb3IgZ2RiXCIsXHJcbiAgICAgICAgXCJ0ZXh0XCI6IFwiLWVuYWJsZS1wcmV0dHktcHJpbnRpbmdcIixcclxuICAgICAgICBcImlnbm9yZUZhaWx1cmVzXCI6IHRydWVcclxuICAgIH1cclxuXWA7XHJcbiAgICAgICAgdGhpcy5leGVjdXRhYmxlID0gXCJhLm91dFwiO1xyXG4gICAgICAgIHRoaXMucGlwZVByb2dyYW0gPSBcIi91c3IvYmluL3NzaFwiO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBjb25maWd1cmF0aW9uc18xLk1JQ29uZmlndXJhdGlvbnModGhpcy5NSU1vZGUsIHRoaXMuZXhlY3V0YWJsZSwgdGhpcy5waXBlUHJvZ3JhbSwgdGhpcy5zZXR1cENvbW1hbmRzQmxvY2spLFxyXG4gICAgICAgICAgICBuZXcgY29uZmlndXJhdGlvbnNfMS5QaXBlVHJhbnNwb3J0Q29uZmlndXJhdGlvbnModGhpcy5NSU1vZGUsIHRoaXMuZXhlY3V0YWJsZSwgdGhpcy5waXBlUHJvZ3JhbSwgdGhpcy5zZXR1cENvbW1hbmRzQmxvY2spXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0Q29uZmlndXJhdGlvblNuaXBwZXRUb0NvbXBldGlvbkl0ZW0oc25pcHBldCkge1xyXG4gICAgbGV0IGl0ZW0gPSBuZXcgdnNjb2RlLkNvbXBsZXRpb25JdGVtKHNuaXBwZXQubGFiZWwsIHZzY29kZS5Db21wbGV0aW9uSXRlbUtpbmQuU25pcHBldCk7XHJcbiAgICBpdGVtLmluc2VydFRleHQgPSBzbmlwcGV0LmJvZHlUZXh0O1xyXG4gICAgcmV0dXJuIGl0ZW07XHJcbn1cclxuY2xhc3MgQ29uZmlndXJhdGlvblNuaXBwZXRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLnNuaXBwZXRzID0gdGhpcy5wcm92aWRlci5nZXRDb25maWd1cmF0aW9uU25pcHBldHMoKTtcclxuICAgIH1cclxuICAgIHJlc29sdmVDb21wbGV0aW9uSXRlbShpdGVtLCB0b2tlbikge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaXRlbSk7XHJcbiAgICB9XHJcbiAgICBwcm92aWRlQ29tcGxldGlvbkl0ZW1zKGRvY3VtZW50LCBwb3NpdGlvbiwgdG9rZW4sIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLnNuaXBwZXRzO1xyXG4gICAgICAgIGNvbnN0IGxhdW5jaCA9IGpzb25jX3BhcnNlcl8xLnBhcnNlKGRvY3VtZW50LmdldFRleHQoKSk7XHJcbiAgICAgICAgaWYgKGxhdW5jaC5jb25maWd1cmF0aW9ucy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zbmlwcGV0cy5mb3JFYWNoKChpdGVtKSA9PiBpdGVtcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKSk7XHJcbiAgICAgICAgICAgIGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5pbnNlcnRUZXh0ID0gaXRlbS5pbnNlcnRUZXh0ICsgJywnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgdnNjb2RlLkNvbXBsZXRpb25MaXN0KGl0ZW1zLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db25maWd1cmF0aW9uU25pcHBldFByb3ZpZGVyID0gQ29uZmlndXJhdGlvblNuaXBwZXRQcm92aWRlcjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Debugger/configurationProvider.ts\n");

/***/ }),

/***/ "./src/Debugger/configurations.ts":
/*!****************************************!*\
  !*** ./src/Debugger/configurations.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nvar DebuggerType;\r\n(function (DebuggerType) {\r\n    DebuggerType[DebuggerType[\"cppvsdbg\"] = 0] = \"cppvsdbg\";\r\n    DebuggerType[DebuggerType[\"cppdbg\"] = 1] = \"cppdbg\";\r\n})(DebuggerType = exports.DebuggerType || (exports.DebuggerType = {}));\r\nfunction indentJsonString(json, numTabs = 1) {\r\n    return json.split('\\n').map(line => '\\t'.repeat(numTabs) + line).join('\\n').trim();\r\n}\r\nexports.indentJsonString = indentJsonString;\r\nfunction formatString(format, args) {\r\n    for (let arg in args) {\r\n        format = format.replace(\"{\" + arg + \"}\", args[arg]);\r\n    }\r\n    return format;\r\n}\r\nfunction createLaunchString(name, type, executable) {\r\n    return `\"name\": \"${name}\",\r\n\"type\": \"${type}\",\r\n\"request\": \"launch\",\r\n\"program\": \"${\"enter program name, for example \" + \"$\\{workspaceFolder\\}\" + \"/\" + executable}\",\r\n\"args\": [],\r\n\"stopAtEntry\": false,\r\n\"cwd\": \"$\\{workspaceFolder\\}\",\r\n\"environment\": [],\r\n\"externalConsole\": true\r\n`;\r\n}\r\nfunction createAttachString(name, type, executable) {\r\n    return formatString(`\r\n\"name\": \"${name}\",\r\n\"type\": \"${type}\",\r\n\"request\": \"attach\",{0}\r\n\"processId\": \"$\\{command:pickProcess\\}\"\r\n`, [type === \"cppdbg\" ? `${os.EOL}\"program\": \"${\"enter program name, for example $\\{workspaceFolder\\}/\" + executable}\",` : \"\"]);\r\n}\r\nfunction createRemoteAttachString(name, type, executable) {\r\n    return `\r\n\"name\": \"${name}\",\r\n\"type\": \"${type}\",\r\n\"request\": \"attach\",\r\n\"program\": \"${\"enter program name, for example $\\{workspaceFolder\\}/\" + executable}\",\r\n\"processId\": \"$\\{command:pickRemoteProcess\\}\"\r\n`;\r\n}\r\nfunction createPipeTransportString(pipeProgram, debuggerProgram, pipeArgs = []) {\r\n    return `\r\n\"pipeTransport\": {\r\n\\t\"debuggerPath\": \"/usr/bin/${debuggerProgram}\",\r\n\\t\"pipeProgram\": \"${pipeProgram}\",\r\n\\t\"pipeArgs\": ${JSON.stringify(pipeArgs)},\r\n\\t\"pipeCwd\": \"\"\r\n}`;\r\n}\r\nclass Configuration {\r\n    constructor(MIMode, executable, pipeProgram, additionalProperties = \"\") {\r\n        this.snippetPrefix = \"C/C++: \";\r\n        this.miDebugger = \"cppdbg\";\r\n        this.windowsDebugger = \"cppvsdbg\";\r\n        this.MIMode = MIMode;\r\n        this.executable = executable;\r\n        this.pipeProgram = pipeProgram;\r\n        this.additionalProperties = additionalProperties;\r\n    }\r\n}\r\nclass MIConfigurations extends Configuration {\r\n    GetLaunchConfiguration() {\r\n        let name = `(${this.MIMode}) Launch`;\r\n        let body = formatString(`{\r\n\\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},\r\n\\t\"MIMode\": \"${this.MIMode}\"{0}{1}\r\n}`, [this.miDebugger === \"cppdbg\" && os.platform() === \"win32\" ? `,${os.EOL}\\t\"miDebuggerPath\": \"/path/to/gdb\"` : \"\",\r\n            this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Launch with ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"isInitialConfiguration\": true,\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n    GetAttachConfiguration() {\r\n        let name = `(${this.MIMode}) Attach`;\r\n        let body = formatString(`{ \r\n\\t${indentJsonString(createAttachString(name, this.miDebugger, this.executable))},\r\n\\t\"MIMode\": \"${this.MIMode}\"{0}{1}\r\n}`, [this.miDebugger === \"cppdbg\" && os.platform() === \"win32\" ? `,${os.EOL}\\t\"miDebuggerPath\": \"/path/to/gdb\"` : \"\",\r\n            this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Attach with ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n}\r\nexports.MIConfigurations = MIConfigurations;\r\nclass PipeTransportConfigurations extends Configuration {\r\n    GetLaunchConfiguration() {\r\n        let name = `(${this.MIMode}) Pipe Launch`;\r\n        let body = formatString(`\r\n{\r\n\\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},\r\n\\t${indentJsonString(createPipeTransportString(this.pipeProgram, this.MIMode))},\r\n\\t\"MIMode\": \"${this.MIMode}\"{0}\r\n}`, [this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Pipe Launch with ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n    GetAttachConfiguration() {\r\n        let name = `(${this.MIMode}) Pipe Attach`;\r\n        let body = formatString(`\r\n{\r\n\\t${indentJsonString(createRemoteAttachString(name, this.miDebugger, this.executable))},\r\n\\t${indentJsonString(createPipeTransportString(this.pipeProgram, this.MIMode))},\r\n\\t\"MIMode\": \"${this.MIMode}\"{0}\r\n}`, [this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Pipe Attach with ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n}\r\nexports.PipeTransportConfigurations = PipeTransportConfigurations;\r\nclass WindowsConfigurations extends Configuration {\r\n    GetLaunchConfiguration() {\r\n        let name = \"(Windows) Launch\";\r\n        let body = `\r\n{\r\n\\t${indentJsonString(createLaunchString(name, this.windowsDebugger, this.executable))}\r\n}`;\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": \"Launch with the Visual Studio C/C++ debugger.\",\r\n            \"bodyText\": body.trim(),\r\n            \"isInitialConfiguration\": true,\r\n            \"debuggerType\": DebuggerType.cppvsdbg\r\n        };\r\n    }\r\n    GetAttachConfiguration() {\r\n        let name = \"(Windows) Attach\";\r\n        let body = `\r\n{\r\n\\t${indentJsonString(createAttachString(name, this.windowsDebugger, this.executable))}\r\n}`;\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": \"Attach to a process with the Visual Studio C/C++ debugger.\",\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppvsdbg\r\n        };\r\n    }\r\n}\r\nexports.WindowsConfigurations = WindowsConfigurations;\r\nclass WSLConfigurations extends Configuration {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.bashPipeProgram = process.arch === 'ia32' ? \"${env:windir}\\\\\\\\sysnative\\\\\\\\bash.exe\" : \"${env:windir}\\\\\\\\system32\\\\\\\\bash.exe\";\r\n    }\r\n    GetLaunchConfiguration() {\r\n        let name = `(${this.MIMode}) Bash on Windows Launch`;\r\n        let body = formatString(`\r\n{\r\n\\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},\r\n\\t${indentJsonString(createPipeTransportString(this.bashPipeProgram, this.MIMode, [\"-c\"]))}{0}\r\n}`, [this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Launch in Bash on Windows using ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n    GetAttachConfiguration() {\r\n        let name = `(${this.MIMode}) Bash on Windows Attach`;\r\n        let body = formatString(`\r\n{\r\n\\t${indentJsonString(createRemoteAttachString(name, this.miDebugger, this.executable))},\r\n\\t${indentJsonString(createPipeTransportString(this.bashPipeProgram, this.MIMode, [\"-c\"]))}{0}\r\n}`, [this.additionalProperties ? `,${os.EOL}\\t${indentJsonString(this.additionalProperties)}` : \"\"]);\r\n        return {\r\n            \"label\": this.snippetPrefix + name,\r\n            \"description\": `Attach to a remote process running in Bash on Windows using ${this.MIMode}.`,\r\n            \"bodyText\": body.trim(),\r\n            \"debuggerType\": DebuggerType.cppdbg\r\n        };\r\n    }\r\n}\r\nexports.WSLConfigurations = WSLConfigurations;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvY29uZmlndXJhdGlvbnMudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0RlYnVnZ2VyL2NvbmZpZ3VyYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbnZhciBEZWJ1Z2dlclR5cGU7XHJcbihmdW5jdGlvbiAoRGVidWdnZXJUeXBlKSB7XHJcbiAgICBEZWJ1Z2dlclR5cGVbRGVidWdnZXJUeXBlW1wiY3BwdnNkYmdcIl0gPSAwXSA9IFwiY3BwdnNkYmdcIjtcclxuICAgIERlYnVnZ2VyVHlwZVtEZWJ1Z2dlclR5cGVbXCJjcHBkYmdcIl0gPSAxXSA9IFwiY3BwZGJnXCI7XHJcbn0pKERlYnVnZ2VyVHlwZSA9IGV4cG9ydHMuRGVidWdnZXJUeXBlIHx8IChleHBvcnRzLkRlYnVnZ2VyVHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIGluZGVudEpzb25TdHJpbmcoanNvbiwgbnVtVGFicyA9IDEpIHtcclxuICAgIHJldHVybiBqc29uLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiAnXFx0Jy5yZXBlYXQobnVtVGFicykgKyBsaW5lKS5qb2luKCdcXG4nKS50cmltKCk7XHJcbn1cclxuZXhwb3J0cy5pbmRlbnRKc29uU3RyaW5nID0gaW5kZW50SnNvblN0cmluZztcclxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGZvcm1hdCwgYXJncykge1xyXG4gICAgZm9yIChsZXQgYXJnIGluIGFyZ3MpIHtcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShcIntcIiArIGFyZyArIFwifVwiLCBhcmdzW2FyZ10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMYXVuY2hTdHJpbmcobmFtZSwgdHlwZSwgZXhlY3V0YWJsZSkge1xyXG4gICAgcmV0dXJuIGBcIm5hbWVcIjogXCIke25hbWV9XCIsXHJcblwidHlwZVwiOiBcIiR7dHlwZX1cIixcclxuXCJyZXF1ZXN0XCI6IFwibGF1bmNoXCIsXHJcblwicHJvZ3JhbVwiOiBcIiR7XCJlbnRlciBwcm9ncmFtIG5hbWUsIGZvciBleGFtcGxlIFwiICsgXCIkXFx7d29ya3NwYWNlRm9sZGVyXFx9XCIgKyBcIi9cIiArIGV4ZWN1dGFibGV9XCIsXHJcblwiYXJnc1wiOiBbXSxcclxuXCJzdG9wQXRFbnRyeVwiOiBmYWxzZSxcclxuXCJjd2RcIjogXCIkXFx7d29ya3NwYWNlRm9sZGVyXFx9XCIsXHJcblwiZW52aXJvbm1lbnRcIjogW10sXHJcblwiZXh0ZXJuYWxDb25zb2xlXCI6IHRydWVcclxuYDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hTdHJpbmcobmFtZSwgdHlwZSwgZXhlY3V0YWJsZSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdFN0cmluZyhgXHJcblwibmFtZVwiOiBcIiR7bmFtZX1cIixcclxuXCJ0eXBlXCI6IFwiJHt0eXBlfVwiLFxyXG5cInJlcXVlc3RcIjogXCJhdHRhY2hcIix7MH1cclxuXCJwcm9jZXNzSWRcIjogXCIkXFx7Y29tbWFuZDpwaWNrUHJvY2Vzc1xcfVwiXHJcbmAsIFt0eXBlID09PSBcImNwcGRiZ1wiID8gYCR7b3MuRU9MfVwicHJvZ3JhbVwiOiBcIiR7XCJlbnRlciBwcm9ncmFtIG5hbWUsIGZvciBleGFtcGxlICRcXHt3b3Jrc3BhY2VGb2xkZXJcXH0vXCIgKyBleGVjdXRhYmxlfVwiLGAgOiBcIlwiXSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlQXR0YWNoU3RyaW5nKG5hbWUsIHR5cGUsIGV4ZWN1dGFibGUpIHtcclxuICAgIHJldHVybiBgXHJcblwibmFtZVwiOiBcIiR7bmFtZX1cIixcclxuXCJ0eXBlXCI6IFwiJHt0eXBlfVwiLFxyXG5cInJlcXVlc3RcIjogXCJhdHRhY2hcIixcclxuXCJwcm9ncmFtXCI6IFwiJHtcImVudGVyIHByb2dyYW0gbmFtZSwgZm9yIGV4YW1wbGUgJFxce3dvcmtzcGFjZUZvbGRlclxcfS9cIiArIGV4ZWN1dGFibGV9XCIsXHJcblwicHJvY2Vzc0lkXCI6IFwiJFxce2NvbW1hbmQ6cGlja1JlbW90ZVByb2Nlc3NcXH1cIlxyXG5gO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBpcGVUcmFuc3BvcnRTdHJpbmcocGlwZVByb2dyYW0sIGRlYnVnZ2VyUHJvZ3JhbSwgcGlwZUFyZ3MgPSBbXSkge1xyXG4gICAgcmV0dXJuIGBcclxuXCJwaXBlVHJhbnNwb3J0XCI6IHtcclxuXFx0XCJkZWJ1Z2dlclBhdGhcIjogXCIvdXNyL2Jpbi8ke2RlYnVnZ2VyUHJvZ3JhbX1cIixcclxuXFx0XCJwaXBlUHJvZ3JhbVwiOiBcIiR7cGlwZVByb2dyYW19XCIsXHJcblxcdFwicGlwZUFyZ3NcIjogJHtKU09OLnN0cmluZ2lmeShwaXBlQXJncyl9LFxyXG5cXHRcInBpcGVDd2RcIjogXCJcIlxyXG59YDtcclxufVxyXG5jbGFzcyBDb25maWd1cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKE1JTW9kZSwgZXhlY3V0YWJsZSwgcGlwZVByb2dyYW0sIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gXCJcIikge1xyXG4gICAgICAgIHRoaXMuc25pcHBldFByZWZpeCA9IFwiQy9DKys6IFwiO1xyXG4gICAgICAgIHRoaXMubWlEZWJ1Z2dlciA9IFwiY3BwZGJnXCI7XHJcbiAgICAgICAgdGhpcy53aW5kb3dzRGVidWdnZXIgPSBcImNwcHZzZGJnXCI7XHJcbiAgICAgICAgdGhpcy5NSU1vZGUgPSBNSU1vZGU7XHJcbiAgICAgICAgdGhpcy5leGVjdXRhYmxlID0gZXhlY3V0YWJsZTtcclxuICAgICAgICB0aGlzLnBpcGVQcm9ncmFtID0gcGlwZVByb2dyYW07XHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE1JQ29uZmlndXJhdGlvbnMgZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcclxuICAgIEdldExhdW5jaENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSBgKCR7dGhpcy5NSU1vZGV9KSBMYXVuY2hgO1xyXG4gICAgICAgIGxldCBib2R5ID0gZm9ybWF0U3RyaW5nKGB7XHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVMYXVuY2hTdHJpbmcobmFtZSwgdGhpcy5taURlYnVnZ2VyLCB0aGlzLmV4ZWN1dGFibGUpKX0sXHJcblxcdFwiTUlNb2RlXCI6IFwiJHt0aGlzLk1JTW9kZX1cInswfXsxfVxyXG59YCwgW3RoaXMubWlEZWJ1Z2dlciA9PT0gXCJjcHBkYmdcIiAmJiBvcy5wbGF0Zm9ybSgpID09PSBcIndpbjMyXCIgPyBgLCR7b3MuRU9MfVxcdFwibWlEZWJ1Z2dlclBhdGhcIjogXCIvcGF0aC90by9nZGJcImAgOiBcIlwiLFxyXG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gYCwke29zLkVPTH1cXHQke2luZGVudEpzb25TdHJpbmcodGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyl9YCA6IFwiXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImxhYmVsXCI6IHRoaXMuc25pcHBldFByZWZpeCArIG5hbWUsXHJcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogYExhdW5jaCB3aXRoICR7dGhpcy5NSU1vZGV9LmAsXHJcbiAgICAgICAgICAgIFwiYm9keVRleHRcIjogYm9keS50cmltKCksXHJcbiAgICAgICAgICAgIFwiaXNJbml0aWFsQ29uZmlndXJhdGlvblwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImRlYnVnZ2VyVHlwZVwiOiBEZWJ1Z2dlclR5cGUuY3BwZGJnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEdldEF0dGFjaENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSBgKCR7dGhpcy5NSU1vZGV9KSBBdHRhY2hgO1xyXG4gICAgICAgIGxldCBib2R5ID0gZm9ybWF0U3RyaW5nKGB7IFxyXG5cXHQke2luZGVudEpzb25TdHJpbmcoY3JlYXRlQXR0YWNoU3RyaW5nKG5hbWUsIHRoaXMubWlEZWJ1Z2dlciwgdGhpcy5leGVjdXRhYmxlKSl9LFxyXG5cXHRcIk1JTW9kZVwiOiBcIiR7dGhpcy5NSU1vZGV9XCJ7MH17MX1cclxufWAsIFt0aGlzLm1pRGVidWdnZXIgPT09IFwiY3BwZGJnXCIgJiYgb3MucGxhdGZvcm0oKSA9PT0gXCJ3aW4zMlwiID8gYCwke29zLkVPTH1cXHRcIm1pRGVidWdnZXJQYXRoXCI6IFwiL3BhdGgvdG8vZ2RiXCJgIDogXCJcIixcclxuICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyA/IGAsJHtvcy5FT0x9XFx0JHtpbmRlbnRKc29uU3RyaW5nKHRoaXMuYWRkaXRpb25hbFByb3BlcnRpZXMpfWAgOiBcIlwiXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJsYWJlbFwiOiB0aGlzLnNuaXBwZXRQcmVmaXggKyBuYW1lLFxyXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IGBBdHRhY2ggd2l0aCAke3RoaXMuTUlNb2RlfS5gLFxyXG4gICAgICAgICAgICBcImJvZHlUZXh0XCI6IGJvZHkudHJpbSgpLFxyXG4gICAgICAgICAgICBcImRlYnVnZ2VyVHlwZVwiOiBEZWJ1Z2dlclR5cGUuY3BwZGJnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1JQ29uZmlndXJhdGlvbnMgPSBNSUNvbmZpZ3VyYXRpb25zO1xyXG5jbGFzcyBQaXBlVHJhbnNwb3J0Q29uZmlndXJhdGlvbnMgZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcclxuICAgIEdldExhdW5jaENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSBgKCR7dGhpcy5NSU1vZGV9KSBQaXBlIExhdW5jaGA7XHJcbiAgICAgICAgbGV0IGJvZHkgPSBmb3JtYXRTdHJpbmcoYFxyXG57XHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVMYXVuY2hTdHJpbmcobmFtZSwgdGhpcy5taURlYnVnZ2VyLCB0aGlzLmV4ZWN1dGFibGUpKX0sXHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVQaXBlVHJhbnNwb3J0U3RyaW5nKHRoaXMucGlwZVByb2dyYW0sIHRoaXMuTUlNb2RlKSl9LFxyXG5cXHRcIk1JTW9kZVwiOiBcIiR7dGhpcy5NSU1vZGV9XCJ7MH1cclxufWAsIFt0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gYCwke29zLkVPTH1cXHQke2luZGVudEpzb25TdHJpbmcodGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyl9YCA6IFwiXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImxhYmVsXCI6IHRoaXMuc25pcHBldFByZWZpeCArIG5hbWUsXHJcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogYFBpcGUgTGF1bmNoIHdpdGggJHt0aGlzLk1JTW9kZX0uYCxcclxuICAgICAgICAgICAgXCJib2R5VGV4dFwiOiBib2R5LnRyaW0oKSxcclxuICAgICAgICAgICAgXCJkZWJ1Z2dlclR5cGVcIjogRGVidWdnZXJUeXBlLmNwcGRiZ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBHZXRBdHRhY2hDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIGxldCBuYW1lID0gYCgke3RoaXMuTUlNb2RlfSkgUGlwZSBBdHRhY2hgO1xyXG4gICAgICAgIGxldCBib2R5ID0gZm9ybWF0U3RyaW5nKGBcclxue1xyXG5cXHQke2luZGVudEpzb25TdHJpbmcoY3JlYXRlUmVtb3RlQXR0YWNoU3RyaW5nKG5hbWUsIHRoaXMubWlEZWJ1Z2dlciwgdGhpcy5leGVjdXRhYmxlKSl9LFxyXG5cXHQke2luZGVudEpzb25TdHJpbmcoY3JlYXRlUGlwZVRyYW5zcG9ydFN0cmluZyh0aGlzLnBpcGVQcm9ncmFtLCB0aGlzLk1JTW9kZSkpfSxcclxuXFx0XCJNSU1vZGVcIjogXCIke3RoaXMuTUlNb2RlfVwiezB9XHJcbn1gLCBbdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyA/IGAsJHtvcy5FT0x9XFx0JHtpbmRlbnRKc29uU3RyaW5nKHRoaXMuYWRkaXRpb25hbFByb3BlcnRpZXMpfWAgOiBcIlwiXSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJsYWJlbFwiOiB0aGlzLnNuaXBwZXRQcmVmaXggKyBuYW1lLFxyXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IGBQaXBlIEF0dGFjaCB3aXRoICR7dGhpcy5NSU1vZGV9LmAsXHJcbiAgICAgICAgICAgIFwiYm9keVRleHRcIjogYm9keS50cmltKCksXHJcbiAgICAgICAgICAgIFwiZGVidWdnZXJUeXBlXCI6IERlYnVnZ2VyVHlwZS5jcHBkYmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGlwZVRyYW5zcG9ydENvbmZpZ3VyYXRpb25zID0gUGlwZVRyYW5zcG9ydENvbmZpZ3VyYXRpb25zO1xyXG5jbGFzcyBXaW5kb3dzQ29uZmlndXJhdGlvbnMgZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcclxuICAgIEdldExhdW5jaENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSBcIihXaW5kb3dzKSBMYXVuY2hcIjtcclxuICAgICAgICBsZXQgYm9keSA9IGBcclxue1xyXG5cXHQke2luZGVudEpzb25TdHJpbmcoY3JlYXRlTGF1bmNoU3RyaW5nKG5hbWUsIHRoaXMud2luZG93c0RlYnVnZ2VyLCB0aGlzLmV4ZWN1dGFibGUpKX1cclxufWA7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJsYWJlbFwiOiB0aGlzLnNuaXBwZXRQcmVmaXggKyBuYW1lLFxyXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGF1bmNoIHdpdGggdGhlIFZpc3VhbCBTdHVkaW8gQy9DKysgZGVidWdnZXIuXCIsXHJcbiAgICAgICAgICAgIFwiYm9keVRleHRcIjogYm9keS50cmltKCksXHJcbiAgICAgICAgICAgIFwiaXNJbml0aWFsQ29uZmlndXJhdGlvblwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImRlYnVnZ2VyVHlwZVwiOiBEZWJ1Z2dlclR5cGUuY3BwdnNkYmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgR2V0QXR0YWNoQ29uZmlndXJhdGlvbigpIHtcclxuICAgICAgICBsZXQgbmFtZSA9IFwiKFdpbmRvd3MpIEF0dGFjaFwiO1xyXG4gICAgICAgIGxldCBib2R5ID0gYFxyXG57XHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVBdHRhY2hTdHJpbmcobmFtZSwgdGhpcy53aW5kb3dzRGVidWdnZXIsIHRoaXMuZXhlY3V0YWJsZSkpfVxyXG59YDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImxhYmVsXCI6IHRoaXMuc25pcHBldFByZWZpeCArIG5hbWUsXHJcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBdHRhY2ggdG8gYSBwcm9jZXNzIHdpdGggdGhlIFZpc3VhbCBTdHVkaW8gQy9DKysgZGVidWdnZXIuXCIsXHJcbiAgICAgICAgICAgIFwiYm9keVRleHRcIjogYm9keS50cmltKCksXHJcbiAgICAgICAgICAgIFwiZGVidWdnZXJUeXBlXCI6IERlYnVnZ2VyVHlwZS5jcHB2c2RiZ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5XaW5kb3dzQ29uZmlndXJhdGlvbnMgPSBXaW5kb3dzQ29uZmlndXJhdGlvbnM7XHJcbmNsYXNzIFdTTENvbmZpZ3VyYXRpb25zIGV4dGVuZHMgQ29uZmlndXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuYmFzaFBpcGVQcm9ncmFtID0gcHJvY2Vzcy5hcmNoID09PSAnaWEzMicgPyBcIiR7ZW52OndpbmRpcn1cXFxcXFxcXHN5c25hdGl2ZVxcXFxcXFxcYmFzaC5leGVcIiA6IFwiJHtlbnY6d2luZGlyfVxcXFxcXFxcc3lzdGVtMzJcXFxcXFxcXGJhc2guZXhlXCI7XHJcbiAgICB9XHJcbiAgICBHZXRMYXVuY2hDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIGxldCBuYW1lID0gYCgke3RoaXMuTUlNb2RlfSkgQmFzaCBvbiBXaW5kb3dzIExhdW5jaGA7XHJcbiAgICAgICAgbGV0IGJvZHkgPSBmb3JtYXRTdHJpbmcoYFxyXG57XHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVMYXVuY2hTdHJpbmcobmFtZSwgdGhpcy5taURlYnVnZ2VyLCB0aGlzLmV4ZWN1dGFibGUpKX0sXHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVQaXBlVHJhbnNwb3J0U3RyaW5nKHRoaXMuYmFzaFBpcGVQcm9ncmFtLCB0aGlzLk1JTW9kZSwgW1wiLWNcIl0pKX17MH1cclxufWAsIFt0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gYCwke29zLkVPTH1cXHQke2luZGVudEpzb25TdHJpbmcodGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyl9YCA6IFwiXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImxhYmVsXCI6IHRoaXMuc25pcHBldFByZWZpeCArIG5hbWUsXHJcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogYExhdW5jaCBpbiBCYXNoIG9uIFdpbmRvd3MgdXNpbmcgJHt0aGlzLk1JTW9kZX0uYCxcclxuICAgICAgICAgICAgXCJib2R5VGV4dFwiOiBib2R5LnRyaW0oKSxcclxuICAgICAgICAgICAgXCJkZWJ1Z2dlclR5cGVcIjogRGVidWdnZXJUeXBlLmNwcGRiZ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBHZXRBdHRhY2hDb25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIGxldCBuYW1lID0gYCgke3RoaXMuTUlNb2RlfSkgQmFzaCBvbiBXaW5kb3dzIEF0dGFjaGA7XHJcbiAgICAgICAgbGV0IGJvZHkgPSBmb3JtYXRTdHJpbmcoYFxyXG57XHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVSZW1vdGVBdHRhY2hTdHJpbmcobmFtZSwgdGhpcy5taURlYnVnZ2VyLCB0aGlzLmV4ZWN1dGFibGUpKX0sXHJcblxcdCR7aW5kZW50SnNvblN0cmluZyhjcmVhdGVQaXBlVHJhbnNwb3J0U3RyaW5nKHRoaXMuYmFzaFBpcGVQcm9ncmFtLCB0aGlzLk1JTW9kZSwgW1wiLWNcIl0pKX17MH1cclxufWAsIFt0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gYCwke29zLkVPTH1cXHQke2luZGVudEpzb25TdHJpbmcodGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyl9YCA6IFwiXCJdKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcImxhYmVsXCI6IHRoaXMuc25pcHBldFByZWZpeCArIG5hbWUsXHJcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogYEF0dGFjaCB0byBhIHJlbW90ZSBwcm9jZXNzIHJ1bm5pbmcgaW4gQmFzaCBvbiBXaW5kb3dzIHVzaW5nICR7dGhpcy5NSU1vZGV9LmAsXHJcbiAgICAgICAgICAgIFwiYm9keVRleHRcIjogYm9keS50cmltKCksXHJcbiAgICAgICAgICAgIFwiZGVidWdnZXJUeXBlXCI6IERlYnVnZ2VyVHlwZS5jcHBkYmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuV1NMQ29uZmlndXJhdGlvbnMgPSBXU0xDb25maWd1cmF0aW9ucztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Debugger/configurations.ts\n");

/***/ }),

/***/ "./src/Debugger/debugAdapterDescriptorFactory.ts":
/*!*******************************************************!*\
  !*** ./src/Debugger/debugAdapterDescriptorFactory.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nclass AbstractDebugAdapterDescriptorFactory {\r\n    constructor(context) {\r\n        this.context = context;\r\n    }\r\n}\r\nclass CppdbgDebugAdapterDescriptorFactory extends AbstractDebugAdapterDescriptorFactory {\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    createDebugAdapterDescriptor(session, executable) {\r\n        return util.isExtensionReady().then(ready => {\r\n            if (ready) {\r\n                let command = path.join(this.context.extensionPath, './debugAdapters/OpenDebugAD7');\r\n                if (os.platform() === 'win32') {\r\n                    command = path.join(this.context.extensionPath, \"./debugAdapters/bin/OpenDebugAD7.exe\");\r\n                }\r\n                return new vscode.DebugAdapterExecutable(command, []);\r\n            }\r\n            else {\r\n                throw new Error(util.extensionNotReadyString);\r\n            }\r\n        });\r\n    }\r\n}\r\nCppdbgDebugAdapterDescriptorFactory.DEBUG_TYPE = \"cppdbg\";\r\nexports.CppdbgDebugAdapterDescriptorFactory = CppdbgDebugAdapterDescriptorFactory;\r\nclass CppvsdbgDebugAdapterDescriptorFactory extends AbstractDebugAdapterDescriptorFactory {\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    createDebugAdapterDescriptor(session, executable) {\r\n        if (os.platform() !== 'win32') {\r\n            vscode.window.showErrorMessage(\"Debugger type 'cppvsdbg' is not avaliable for non-Windows machines.\");\r\n            return null;\r\n        }\r\n        else {\r\n            return util.isExtensionReady().then(ready => {\r\n                if (ready) {\r\n                    return new vscode.DebugAdapterExecutable(path.join(this.context.extensionPath, './debugAdapters/vsdbg/bin/vsdbg.exe'), ['--interpreter=vscode']);\r\n                }\r\n                else {\r\n                    throw new Error(util.extensionNotReadyString);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nCppvsdbgDebugAdapterDescriptorFactory.DEBUG_TYPE = \"cppvsdbg\";\r\nexports.CppvsdbgDebugAdapterDescriptorFactory = CppvsdbgDebugAdapterDescriptorFactory;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvZGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnkudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0RlYnVnZ2VyL2RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNsYXNzIEFic3RyYWN0RGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3Rvcnkge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ3BwZGJnRGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnkgZXh0ZW5kcyBBYnN0cmFjdERlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZURlYnVnQWRhcHRlckRlc2NyaXB0b3Ioc2Vzc2lvbiwgZXhlY3V0YWJsZSkge1xyXG4gICAgICAgIHJldHVybiB1dGlsLmlzRXh0ZW5zaW9uUmVhZHkoKS50aGVuKHJlYWR5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IHBhdGguam9pbih0aGlzLmNvbnRleHQuZXh0ZW5zaW9uUGF0aCwgJy4vZGVidWdBZGFwdGVycy9PcGVuRGVidWdBRDcnKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHBhdGguam9pbih0aGlzLmNvbnRleHQuZXh0ZW5zaW9uUGF0aCwgXCIuL2RlYnVnQWRhcHRlcnMvYmluL09wZW5EZWJ1Z0FENy5leGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZzY29kZS5EZWJ1Z0FkYXB0ZXJFeGVjdXRhYmxlKGNvbW1hbmQsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmV4dGVuc2lvbk5vdFJlYWR5U3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbkNwcGRiZ0RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5LkRFQlVHX1RZUEUgPSBcImNwcGRiZ1wiO1xyXG5leHBvcnRzLkNwcGRiZ0RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5ID0gQ3BwZGJnRGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3Rvcnk7XHJcbmNsYXNzIENwcHZzZGJnRGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnkgZXh0ZW5kcyBBYnN0cmFjdERlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZURlYnVnQWRhcHRlckRlc2NyaXB0b3Ioc2Vzc2lvbiwgZXhlY3V0YWJsZSkge1xyXG4gICAgICAgIGlmIChvcy5wbGF0Zm9ybSgpICE9PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZShcIkRlYnVnZ2VyIHR5cGUgJ2NwcHZzZGJnJyBpcyBub3QgYXZhbGlhYmxlIGZvciBub24tV2luZG93cyBtYWNoaW5lcy5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNFeHRlbnNpb25SZWFkeSgpLnRoZW4ocmVhZHkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2c2NvZGUuRGVidWdBZGFwdGVyRXhlY3V0YWJsZShwYXRoLmpvaW4odGhpcy5jb250ZXh0LmV4dGVuc2lvblBhdGgsICcuL2RlYnVnQWRhcHRlcnMvdnNkYmcvYmluL3ZzZGJnLmV4ZScpLCBbJy0taW50ZXJwcmV0ZXI9dnNjb2RlJ10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZXh0ZW5zaW9uTm90UmVhZHlTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQ3BwdnNkYmdEZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeS5ERUJVR19UWVBFID0gXCJjcHB2c2RiZ1wiO1xyXG5leHBvcnRzLkNwcHZzZGJnRGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnkgPSBDcHB2c2RiZ0RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Debugger/debugAdapterDescriptorFactory.ts\n");

/***/ }),

/***/ "./src/Debugger/extension.ts":
/*!***********************************!*\
  !*** ./src/Debugger/extension.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst attachToProcess_1 = __webpack_require__(/*! ./attachToProcess */ \"./src/Debugger/attachToProcess.ts\");\r\nconst nativeAttach_1 = __webpack_require__(/*! ./nativeAttach */ \"./src/Debugger/nativeAttach.ts\");\r\nconst configurationProvider_1 = __webpack_require__(/*! ./configurationProvider */ \"./src/Debugger/configurationProvider.ts\");\r\nconst debugAdapterDescriptorFactory_1 = __webpack_require__(/*! ./debugAdapterDescriptorFactory */ \"./src/Debugger/debugAdapterDescriptorFactory.ts\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst Telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nlet disposables = [];\r\nfunction buildAndDebugActiveFileStr() {\r\n    return \" build and debug active file\";\r\n}\r\nexports.buildAndDebugActiveFileStr = buildAndDebugActiveFileStr;\r\nfunction initialize(context) {\r\n    let attachItemsProvider = nativeAttach_1.NativeAttachItemsProviderFactory.Get();\r\n    let attacher = new attachToProcess_1.AttachPicker(attachItemsProvider);\r\n    disposables.push(vscode.commands.registerCommand('extension.pickNativeProcess', () => attacher.ShowAttachEntries()));\r\n    let remoteAttacher = new attachToProcess_1.RemoteAttachPicker();\r\n    disposables.push(vscode.commands.registerCommand('extension.pickRemoteNativeProcess', (any) => remoteAttacher.ShowAttachEntries(any)));\r\n    let configurationProvider = configurationProvider_1.ConfigurationAssetProviderFactory.getConfigurationProvider();\r\n    let vsdbgProvider = null;\r\n    if (os.platform() === 'win32') {\r\n        vsdbgProvider = new configurationProvider_1.CppVsDbgConfigurationProvider(configurationProvider);\r\n        disposables.push(vscode.debug.registerDebugConfigurationProvider('cppvsdbg', new configurationProvider_1.QuickPickConfigurationProvider(vsdbgProvider)));\r\n    }\r\n    const provider = new configurationProvider_1.CppDbgConfigurationProvider(configurationProvider);\r\n    disposables.push(vscode.debug.registerDebugConfigurationProvider('cppdbg', new configurationProvider_1.QuickPickConfigurationProvider(provider)));\r\n    disposables.push(vscode.commands.registerTextEditorCommand(\"C_Cpp.BuildAndDebugActiveFile\", (textEditor, edit, ...args) => __awaiter(this, void 0, void 0, function* () {\r\n        const folder = vscode.workspace.getWorkspaceFolder(textEditor.document.uri);\r\n        if (!folder) {\r\n            vscode.window.showErrorMessage('This command is not yet available for single-file mode.');\r\n            return Promise.resolve();\r\n        }\r\n        if (!util.fileIsCOrCppSource(textEditor.document.uri.fsPath)) {\r\n            vscode.window.showErrorMessage('Cannot build and debug because the active file is not a C or C++ source file.');\r\n            return Promise.resolve();\r\n        }\r\n        let configs = (yield provider.provideDebugConfigurations(folder)).filter(config => {\r\n            return config.name.indexOf(buildAndDebugActiveFileStr()) !== -1;\r\n        });\r\n        if (vsdbgProvider) {\r\n            let vsdbgConfigs = (yield vsdbgProvider.provideDebugConfigurations(folder)).filter(config => {\r\n                return config.name.indexOf(buildAndDebugActiveFileStr()) !== -1;\r\n            });\r\n            if (vsdbgConfigs) {\r\n                configs.push(...vsdbgConfigs);\r\n            }\r\n        }\r\n        const items = configs.map(config => {\r\n            return { label: config.name, configuration: config };\r\n        });\r\n        vscode.window.showQuickPick(items, { placeHolder: (items.length === 0 ? \"No compiler found\" : \"Select a compiler\") }).then((selection) => __awaiter(this, void 0, void 0, function* () {\r\n            if (!selection) {\r\n                return;\r\n            }\r\n            if (selection.label.startsWith(\"cl.exe\")) {\r\n                if (!process.env.DevEnvDir || process.env.DevEnvDir.length === 0) {\r\n                    vscode.window.showErrorMessage('cl.exe build and debug is only usable when VS Code is run from the Developer Command Prompt for VS.');\r\n                    return;\r\n                }\r\n            }\r\n            if (selection.configuration.preLaunchTask) {\r\n                if (folder) {\r\n                    try {\r\n                        yield util.ensureBuildTaskExists(selection.configuration.preLaunchTask);\r\n                        Telemetry.logDebuggerEvent(\"buildAndDebug\", { \"success\": \"false\" });\r\n                    }\r\n                    catch (e) {\r\n                        return Promise.resolve();\r\n                    }\r\n                }\r\n                else {\r\n                    return Promise.resolve();\r\n                }\r\n            }\r\n            try {\r\n                yield vscode.debug.startDebugging(folder, selection.configuration.name);\r\n                Telemetry.logDebuggerEvent(\"buildAndDebug\", { \"success\": \"true\" });\r\n            }\r\n            catch (e) {\r\n                try {\r\n                    vscode.debug.startDebugging(folder, selection.configuration);\r\n                }\r\n                catch (e) {\r\n                    Telemetry.logDebuggerEvent(\"buildAndDebug\", { \"success\": \"false\" });\r\n                }\r\n            }\r\n        }));\r\n    })));\r\n    configurationProvider.getConfigurationSnippets();\r\n    const launchJsonDocumentSelector = [{\r\n            scheme: 'file',\r\n            language: 'jsonc',\r\n            pattern: '**/launch.json'\r\n        }];\r\n    disposables.push(vscode.languages.registerCompletionItemProvider(launchJsonDocumentSelector, new configurationProvider_1.ConfigurationSnippetProvider(configurationProvider)));\r\n    disposables.push(vscode.debug.registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory_1.CppvsdbgDebugAdapterDescriptorFactory.DEBUG_TYPE, new debugAdapterDescriptorFactory_1.CppvsdbgDebugAdapterDescriptorFactory(context)));\r\n    disposables.push(vscode.debug.registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory_1.CppdbgDebugAdapterDescriptorFactory.DEBUG_TYPE, new debugAdapterDescriptorFactory_1.CppdbgDebugAdapterDescriptorFactory(context)));\r\n    vscode.Disposable.from(...disposables);\r\n}\r\nexports.initialize = initialize;\r\nfunction dispose() {\r\n    disposables.forEach(d => d.dispose());\r\n}\r\nexports.dispose = dispose;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvZXh0ZW5zaW9uLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9EZWJ1Z2dlci9leHRlbnNpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxuY29uc3QgYXR0YWNoVG9Qcm9jZXNzXzEgPSByZXF1aXJlKFwiLi9hdHRhY2hUb1Byb2Nlc3NcIik7XHJcbmNvbnN0IG5hdGl2ZUF0dGFjaF8xID0gcmVxdWlyZShcIi4vbmF0aXZlQXR0YWNoXCIpO1xyXG5jb25zdCBjb25maWd1cmF0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb25Qcm92aWRlclwiKTtcclxuY29uc3QgZGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5XCIpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcclxuY29uc3QgVGVsZW1ldHJ5ID0gcmVxdWlyZShcIi4uL3RlbGVtZXRyeVwiKTtcclxubGV0IGRpc3Bvc2FibGVzID0gW107XHJcbmZ1bmN0aW9uIGJ1aWxkQW5kRGVidWdBY3RpdmVGaWxlU3RyKCkge1xyXG4gICAgcmV0dXJuIFwiIGJ1aWxkIGFuZCBkZWJ1ZyBhY3RpdmUgZmlsZVwiO1xyXG59XHJcbmV4cG9ydHMuYnVpbGRBbmREZWJ1Z0FjdGl2ZUZpbGVTdHIgPSBidWlsZEFuZERlYnVnQWN0aXZlRmlsZVN0cjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZShjb250ZXh0KSB7XHJcbiAgICBsZXQgYXR0YWNoSXRlbXNQcm92aWRlciA9IG5hdGl2ZUF0dGFjaF8xLk5hdGl2ZUF0dGFjaEl0ZW1zUHJvdmlkZXJGYWN0b3J5LkdldCgpO1xyXG4gICAgbGV0IGF0dGFjaGVyID0gbmV3IGF0dGFjaFRvUHJvY2Vzc18xLkF0dGFjaFBpY2tlcihhdHRhY2hJdGVtc1Byb3ZpZGVyKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnZXh0ZW5zaW9uLnBpY2tOYXRpdmVQcm9jZXNzJywgKCkgPT4gYXR0YWNoZXIuU2hvd0F0dGFjaEVudHJpZXMoKSkpO1xyXG4gICAgbGV0IHJlbW90ZUF0dGFjaGVyID0gbmV3IGF0dGFjaFRvUHJvY2Vzc18xLlJlbW90ZUF0dGFjaFBpY2tlcigpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdleHRlbnNpb24ucGlja1JlbW90ZU5hdGl2ZVByb2Nlc3MnLCAoYW55KSA9PiByZW1vdGVBdHRhY2hlci5TaG93QXR0YWNoRW50cmllcyhhbnkpKSk7XHJcbiAgICBsZXQgY29uZmlndXJhdGlvblByb3ZpZGVyID0gY29uZmlndXJhdGlvblByb3ZpZGVyXzEuQ29uZmlndXJhdGlvbkFzc2V0UHJvdmlkZXJGYWN0b3J5LmdldENvbmZpZ3VyYXRpb25Qcm92aWRlcigpO1xyXG4gICAgbGV0IHZzZGJnUHJvdmlkZXIgPSBudWxsO1xyXG4gICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcclxuICAgICAgICB2c2RiZ1Byb3ZpZGVyID0gbmV3IGNvbmZpZ3VyYXRpb25Qcm92aWRlcl8xLkNwcFZzRGJnQ29uZmlndXJhdGlvblByb3ZpZGVyKGNvbmZpZ3VyYXRpb25Qcm92aWRlcik7XHJcbiAgICAgICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuZGVidWcucmVnaXN0ZXJEZWJ1Z0NvbmZpZ3VyYXRpb25Qcm92aWRlcignY3BwdnNkYmcnLCBuZXcgY29uZmlndXJhdGlvblByb3ZpZGVyXzEuUXVpY2tQaWNrQ29uZmlndXJhdGlvblByb3ZpZGVyKHZzZGJnUHJvdmlkZXIpKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBjb25maWd1cmF0aW9uUHJvdmlkZXJfMS5DcHBEYmdDb25maWd1cmF0aW9uUHJvdmlkZXIoY29uZmlndXJhdGlvblByb3ZpZGVyKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmRlYnVnLnJlZ2lzdGVyRGVidWdDb25maWd1cmF0aW9uUHJvdmlkZXIoJ2NwcGRiZycsIG5ldyBjb25maWd1cmF0aW9uUHJvdmlkZXJfMS5RdWlja1BpY2tDb25maWd1cmF0aW9uUHJvdmlkZXIocHJvdmlkZXIpKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlclRleHRFZGl0b3JDb21tYW5kKFwiQ19DcHAuQnVpbGRBbmREZWJ1Z0FjdGl2ZUZpbGVcIiwgKHRleHRFZGl0b3IsIGVkaXQsIC4uLmFyZ3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBmb2xkZXIgPSB2c2NvZGUud29ya3NwYWNlLmdldFdvcmtzcGFjZUZvbGRlcih0ZXh0RWRpdG9yLmRvY3VtZW50LnVyaSk7XHJcbiAgICAgICAgaWYgKCFmb2xkZXIpIHtcclxuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93RXJyb3JNZXNzYWdlKCdUaGlzIGNvbW1hbmQgaXMgbm90IHlldCBhdmFpbGFibGUgZm9yIHNpbmdsZS1maWxlIG1vZGUuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGlsLmZpbGVJc0NPckNwcFNvdXJjZSh0ZXh0RWRpdG9yLmRvY3VtZW50LnVyaS5mc1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZSgnQ2Fubm90IGJ1aWxkIGFuZCBkZWJ1ZyBiZWNhdXNlIHRoZSBhY3RpdmUgZmlsZSBpcyBub3QgYSBDIG9yIEMrKyBzb3VyY2UgZmlsZS4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29uZmlncyA9ICh5aWVsZCBwcm92aWRlci5wcm92aWRlRGVidWdDb25maWd1cmF0aW9ucyhmb2xkZXIpKS5maWx0ZXIoY29uZmlnID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5uYW1lLmluZGV4T2YoYnVpbGRBbmREZWJ1Z0FjdGl2ZUZpbGVTdHIoKSkgIT09IC0xO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh2c2RiZ1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIGxldCB2c2RiZ0NvbmZpZ3MgPSAoeWllbGQgdnNkYmdQcm92aWRlci5wcm92aWRlRGVidWdDb25maWd1cmF0aW9ucyhmb2xkZXIpKS5maWx0ZXIoY29uZmlnID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcubmFtZS5pbmRleE9mKGJ1aWxkQW5kRGVidWdBY3RpdmVGaWxlU3RyKCkpICE9PSAtMTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh2c2RiZ0NvbmZpZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3MucHVzaCguLi52c2RiZ0NvbmZpZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gY29uZmlncy5tYXAoY29uZmlnID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGNvbmZpZy5uYW1lLCBjb25maWd1cmF0aW9uOiBjb25maWcgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2c2NvZGUud2luZG93LnNob3dRdWlja1BpY2soaXRlbXMsIHsgcGxhY2VIb2xkZXI6IChpdGVtcy5sZW5ndGggPT09IDAgPyBcIk5vIGNvbXBpbGVyIGZvdW5kXCIgOiBcIlNlbGVjdCBhIGNvbXBpbGVyXCIpIH0pLnRoZW4oKHNlbGVjdGlvbikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGFiZWwuc3RhcnRzV2l0aChcImNsLmV4ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5EZXZFbnZEaXIgfHwgcHJvY2Vzcy5lbnYuRGV2RW52RGlyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZSgnY2wuZXhlIGJ1aWxkIGFuZCBkZWJ1ZyBpcyBvbmx5IHVzYWJsZSB3aGVuIFZTIENvZGUgaXMgcnVuIGZyb20gdGhlIERldmVsb3BlciBDb21tYW5kIFByb21wdCBmb3IgVlMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uY29uZmlndXJhdGlvbi5wcmVMYXVuY2hUYXNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdXRpbC5lbnN1cmVCdWlsZFRhc2tFeGlzdHMoc2VsZWN0aW9uLmNvbmZpZ3VyYXRpb24ucHJlTGF1bmNoVGFzayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlbGVtZXRyeS5sb2dEZWJ1Z2dlckV2ZW50KFwiYnVpbGRBbmREZWJ1Z1wiLCB7IFwic3VjY2Vzc1wiOiBcImZhbHNlXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHZzY29kZS5kZWJ1Zy5zdGFydERlYnVnZ2luZyhmb2xkZXIsIHNlbGVjdGlvbi5jb25maWd1cmF0aW9uLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJidWlsZEFuZERlYnVnXCIsIHsgXCJzdWNjZXNzXCI6IFwidHJ1ZVwiIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZzY29kZS5kZWJ1Zy5zdGFydERlYnVnZ2luZyhmb2xkZXIsIHNlbGVjdGlvbi5jb25maWd1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJidWlsZEFuZERlYnVnXCIsIHsgXCJzdWNjZXNzXCI6IFwiZmFsc2VcIiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgIH0pKSk7XHJcbiAgICBjb25maWd1cmF0aW9uUHJvdmlkZXIuZ2V0Q29uZmlndXJhdGlvblNuaXBwZXRzKCk7XHJcbiAgICBjb25zdCBsYXVuY2hKc29uRG9jdW1lbnRTZWxlY3RvciA9IFt7XHJcbiAgICAgICAgICAgIHNjaGVtZTogJ2ZpbGUnLFxyXG4gICAgICAgICAgICBsYW5ndWFnZTogJ2pzb25jJyxcclxuICAgICAgICAgICAgcGF0dGVybjogJyoqL2xhdW5jaC5qc29uJ1xyXG4gICAgICAgIH1dO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUubGFuZ3VhZ2VzLnJlZ2lzdGVyQ29tcGxldGlvbkl0ZW1Qcm92aWRlcihsYXVuY2hKc29uRG9jdW1lbnRTZWxlY3RvciwgbmV3IGNvbmZpZ3VyYXRpb25Qcm92aWRlcl8xLkNvbmZpZ3VyYXRpb25TbmlwcGV0UHJvdmlkZXIoY29uZmlndXJhdGlvblByb3ZpZGVyKSkpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuZGVidWcucmVnaXN0ZXJEZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeShkZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeV8xLkNwcHZzZGJnRGVidWdBZGFwdGVyRGVzY3JpcHRvckZhY3RvcnkuREVCVUdfVFlQRSwgbmV3IGRlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5XzEuQ3BwdnNkYmdEZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeShjb250ZXh0KSkpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuZGVidWcucmVnaXN0ZXJEZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeShkZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeV8xLkNwcGRiZ0RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5LkRFQlVHX1RZUEUsIG5ldyBkZWJ1Z0FkYXB0ZXJEZXNjcmlwdG9yRmFjdG9yeV8xLkNwcGRiZ0RlYnVnQWRhcHRlckRlc2NyaXB0b3JGYWN0b3J5KGNvbnRleHQpKSk7XHJcbiAgICB2c2NvZGUuRGlzcG9zYWJsZS5mcm9tKC4uLmRpc3Bvc2FibGVzKTtcclxufVxyXG5leHBvcnRzLmluaXRpYWxpemUgPSBpbml0aWFsaXplO1xyXG5mdW5jdGlvbiBkaXNwb3NlKCkge1xyXG4gICAgZGlzcG9zYWJsZXMuZm9yRWFjaChkID0+IGQuZGlzcG9zZSgpKTtcclxufVxyXG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Debugger/extension.ts\n");

/***/ }),

/***/ "./src/Debugger/nativeAttach.ts":
/*!**************************************!*\
  !*** ./src/Debugger/nativeAttach.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst child_process = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nclass Process {\r\n    constructor(name, pid, commandLine) {\r\n        this.name = name;\r\n        this.pid = pid;\r\n        this.commandLine = commandLine;\r\n    }\r\n    toAttachItem() {\r\n        return {\r\n            label: this.name,\r\n            description: this.pid,\r\n            detail: this.commandLine,\r\n            id: this.pid\r\n        };\r\n    }\r\n}\r\nclass NativeAttachItemsProviderFactory {\r\n    static Get() {\r\n        if (os.platform() === 'win32') {\r\n            return new WmicAttachItemsProvider();\r\n        }\r\n        else {\r\n            return new PsAttachItemsProvider();\r\n        }\r\n    }\r\n}\r\nexports.NativeAttachItemsProviderFactory = NativeAttachItemsProviderFactory;\r\nclass NativeAttachItemsProvider {\r\n    getAttachItems() {\r\n        return this.getInternalProcessEntries().then(processEntries => {\r\n            processEntries.sort((a, b) => {\r\n                if (a.name === undefined) {\r\n                    if (b.name === undefined) {\r\n                        return 0;\r\n                    }\r\n                    return 1;\r\n                }\r\n                if (b.name === undefined) {\r\n                    return -1;\r\n                }\r\n                let aLower = a.name.toLowerCase();\r\n                let bLower = b.name.toLowerCase();\r\n                if (aLower === bLower) {\r\n                    return 0;\r\n                }\r\n                return aLower < bLower ? -1 : 1;\r\n            });\r\n            let attachItems = processEntries.map(p => p.toAttachItem());\r\n            return attachItems;\r\n        });\r\n    }\r\n}\r\nclass PsAttachItemsProvider extends NativeAttachItemsProvider {\r\n    getInternalProcessEntries() {\r\n        let processCmd = '';\r\n        switch (os.platform()) {\r\n            case 'darwin':\r\n                processCmd = PsProcessParser.psDarwinCommand;\r\n                break;\r\n            case 'linux':\r\n                processCmd = PsProcessParser.psLinuxCommand;\r\n                break;\r\n            default:\r\n                return Promise.reject(new Error(`Operating system \"${os.platform()}\" not support.`));\r\n        }\r\n        return execChildProcess(processCmd, null).then(processes => {\r\n            return PsProcessParser.ParseProcessFromPs(processes);\r\n        });\r\n    }\r\n}\r\nexports.PsAttachItemsProvider = PsAttachItemsProvider;\r\nclass PsProcessParser {\r\n    static get secondColumnCharacters() { return 50; }\r\n    static get commColumnTitle() { return Array(PsProcessParser.secondColumnCharacters).join(\"a\"); }\r\n    static get psLinuxCommand() { return `ps axww -o pid=,comm=${PsProcessParser.commColumnTitle},args=`; }\r\n    static get psDarwinCommand() { return `ps axww -o pid=,comm=${PsProcessParser.commColumnTitle},args= -c`; }\r\n    static ParseProcessFromPs(processes) {\r\n        let lines = processes.split(os.EOL);\r\n        return PsProcessParser.ParseProcessFromPsArray(lines);\r\n    }\r\n    static ParseProcessFromPsArray(processArray) {\r\n        let processEntries = [];\r\n        for (let i = 1; i < processArray.length; i++) {\r\n            let line = processArray[i];\r\n            if (!line) {\r\n                continue;\r\n            }\r\n            let processEntry = PsProcessParser.parseLineFromPs(line);\r\n            processEntries.push(processEntry);\r\n        }\r\n        return processEntries;\r\n    }\r\n    static parseLineFromPs(line) {\r\n        const psEntry = new RegExp(`^\\\\s*([0-9]+)\\\\s+(.{${PsProcessParser.secondColumnCharacters - 1}})\\\\s+(.*)$`);\r\n        const matches = psEntry.exec(line);\r\n        if (matches && matches.length === 4) {\r\n            const pid = matches[1].trim();\r\n            const executable = matches[2].trim();\r\n            const cmdline = matches[3].trim();\r\n            return new Process(executable, pid, cmdline);\r\n        }\r\n    }\r\n}\r\nexports.PsProcessParser = PsProcessParser;\r\nfunction execChildProcess(process, workingDirectory) {\r\n    return new Promise((resolve, reject) => {\r\n        child_process.exec(process, { cwd: workingDirectory, maxBuffer: 500 * 1024 }, (error, stdout, stderr) => {\r\n            if (error) {\r\n                reject(error);\r\n                return;\r\n            }\r\n            if (stderr && stderr.length > 0) {\r\n                reject(new Error(stderr));\r\n                return;\r\n            }\r\n            resolve(stdout);\r\n        });\r\n    });\r\n}\r\nclass WmicAttachItemsProvider extends NativeAttachItemsProvider {\r\n    getInternalProcessEntries() {\r\n        const wmicCommand = 'wmic process get Name,ProcessId,CommandLine /FORMAT:list';\r\n        return execChildProcess(wmicCommand, null).then(processes => {\r\n            return WmicProcessParser.ParseProcessFromWmic(processes);\r\n        });\r\n    }\r\n}\r\nexports.WmicAttachItemsProvider = WmicAttachItemsProvider;\r\nclass WmicProcessParser {\r\n    static get wmicNameTitle() { return 'Name'; }\r\n    static get wmicCommandLineTitle() { return 'CommandLine'; }\r\n    static get wmicPidTitle() { return 'ProcessId'; }\r\n    static ParseProcessFromWmic(processes) {\r\n        let lines = processes.split(os.EOL);\r\n        let currentProcess = new Process(null, null, null);\r\n        let processEntries = [];\r\n        for (let i = 0; i < lines.length; i++) {\r\n            let line = lines[i];\r\n            if (!line) {\r\n                continue;\r\n            }\r\n            WmicProcessParser.parseLineFromWmic(line, currentProcess);\r\n            if (line.lastIndexOf(WmicProcessParser.wmicPidTitle, 0) === 0) {\r\n                processEntries.push(currentProcess);\r\n                currentProcess = new Process(null, null, null);\r\n            }\r\n        }\r\n        return processEntries;\r\n    }\r\n    static parseLineFromWmic(line, process) {\r\n        let splitter = line.indexOf('=');\r\n        if (splitter >= 0) {\r\n            let key = line.slice(0, line.indexOf('=')).trim();\r\n            let value = line.slice(line.indexOf('=') + 1).trim();\r\n            if (key === WmicProcessParser.wmicNameTitle) {\r\n                process.name = value;\r\n            }\r\n            else if (key === WmicProcessParser.wmicPidTitle) {\r\n                process.pid = value;\r\n            }\r\n            else if (key === WmicProcessParser.wmicCommandLineTitle) {\r\n                const extendedLengthPath = '\\\\??\\\\';\r\n                if (value.lastIndexOf(extendedLengthPath, 0) === 0) {\r\n                    value = value.slice(extendedLengthPath.length);\r\n                }\r\n                process.commandLine = value;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.WmicProcessParser = WmicProcessParser;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvbmF0aXZlQXR0YWNoLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9EZWJ1Z2dlci9uYXRpdmVBdHRhY2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jbGFzcyBQcm9jZXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBpZCwgY29tbWFuZExpbmUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucGlkID0gcGlkO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZExpbmUgPSBjb21tYW5kTGluZTtcclxuICAgIH1cclxuICAgIHRvQXR0YWNoSXRlbSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5waWQsXHJcbiAgICAgICAgICAgIGRldGFpbDogdGhpcy5jb21tYW5kTGluZSxcclxuICAgICAgICAgICAgaWQ6IHRoaXMucGlkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBOYXRpdmVBdHRhY2hJdGVtc1Byb3ZpZGVyRmFjdG9yeSB7XHJcbiAgICBzdGF0aWMgR2V0KCkge1xyXG4gICAgICAgIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV21pY0F0dGFjaEl0ZW1zUHJvdmlkZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHNBdHRhY2hJdGVtc1Byb3ZpZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTmF0aXZlQXR0YWNoSXRlbXNQcm92aWRlckZhY3RvcnkgPSBOYXRpdmVBdHRhY2hJdGVtc1Byb3ZpZGVyRmFjdG9yeTtcclxuY2xhc3MgTmF0aXZlQXR0YWNoSXRlbXNQcm92aWRlciB7XHJcbiAgICBnZXRBdHRhY2hJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcm5hbFByb2Nlc3NFbnRyaWVzKCkudGhlbihwcm9jZXNzRW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbnRyaWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5uYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYUxvd2VyID0gYS5uYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYkxvd2VyID0gYi5uYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYUxvd2VyID09PSBiTG93ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhTG93ZXIgPCBiTG93ZXIgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgYXR0YWNoSXRlbXMgPSBwcm9jZXNzRW50cmllcy5tYXAocCA9PiBwLnRvQXR0YWNoSXRlbSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaEl0ZW1zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBzQXR0YWNoSXRlbXNQcm92aWRlciBleHRlbmRzIE5hdGl2ZUF0dGFjaEl0ZW1zUHJvdmlkZXIge1xyXG4gICAgZ2V0SW50ZXJuYWxQcm9jZXNzRW50cmllcygpIHtcclxuICAgICAgICBsZXQgcHJvY2Vzc0NtZCA9ICcnO1xyXG4gICAgICAgIHN3aXRjaCAob3MucGxhdGZvcm0oKSkge1xyXG4gICAgICAgICAgICBjYXNlICdkYXJ3aW4nOlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NtZCA9IFBzUHJvY2Vzc1BhcnNlci5wc0RhcndpbkNvbW1hbmQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGludXgnOlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NtZCA9IFBzUHJvY2Vzc1BhcnNlci5wc0xpbnV4Q29tbWFuZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgT3BlcmF0aW5nIHN5c3RlbSBcIiR7b3MucGxhdGZvcm0oKX1cIiBub3Qgc3VwcG9ydC5gKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleGVjQ2hpbGRQcm9jZXNzKHByb2Nlc3NDbWQsIG51bGwpLnRoZW4ocHJvY2Vzc2VzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFBzUHJvY2Vzc1BhcnNlci5QYXJzZVByb2Nlc3NGcm9tUHMocHJvY2Vzc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBzQXR0YWNoSXRlbXNQcm92aWRlciA9IFBzQXR0YWNoSXRlbXNQcm92aWRlcjtcclxuY2xhc3MgUHNQcm9jZXNzUGFyc2VyIHtcclxuICAgIHN0YXRpYyBnZXQgc2Vjb25kQ29sdW1uQ2hhcmFjdGVycygpIHsgcmV0dXJuIDUwOyB9XHJcbiAgICBzdGF0aWMgZ2V0IGNvbW1Db2x1bW5UaXRsZSgpIHsgcmV0dXJuIEFycmF5KFBzUHJvY2Vzc1BhcnNlci5zZWNvbmRDb2x1bW5DaGFyYWN0ZXJzKS5qb2luKFwiYVwiKTsgfVxyXG4gICAgc3RhdGljIGdldCBwc0xpbnV4Q29tbWFuZCgpIHsgcmV0dXJuIGBwcyBheHd3IC1vIHBpZD0sY29tbT0ke1BzUHJvY2Vzc1BhcnNlci5jb21tQ29sdW1uVGl0bGV9LGFyZ3M9YDsgfVxyXG4gICAgc3RhdGljIGdldCBwc0RhcndpbkNvbW1hbmQoKSB7IHJldHVybiBgcHMgYXh3dyAtbyBwaWQ9LGNvbW09JHtQc1Byb2Nlc3NQYXJzZXIuY29tbUNvbHVtblRpdGxlfSxhcmdzPSAtY2A7IH1cclxuICAgIHN0YXRpYyBQYXJzZVByb2Nlc3NGcm9tUHMocHJvY2Vzc2VzKSB7XHJcbiAgICAgICAgbGV0IGxpbmVzID0gcHJvY2Vzc2VzLnNwbGl0KG9zLkVPTCk7XHJcbiAgICAgICAgcmV0dXJuIFBzUHJvY2Vzc1BhcnNlci5QYXJzZVByb2Nlc3NGcm9tUHNBcnJheShsaW5lcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgUGFyc2VQcm9jZXNzRnJvbVBzQXJyYXkocHJvY2Vzc0FycmF5KSB7XHJcbiAgICAgICAgbGV0IHByb2Nlc3NFbnRyaWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9jZXNzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGxpbmUgPSBwcm9jZXNzQXJyYXlbaV07XHJcbiAgICAgICAgICAgIGlmICghbGluZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHByb2Nlc3NFbnRyeSA9IFBzUHJvY2Vzc1BhcnNlci5wYXJzZUxpbmVGcm9tUHMobGluZSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbnRyaWVzLnB1c2gocHJvY2Vzc0VudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NFbnRyaWVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHBhcnNlTGluZUZyb21QcyhsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcHNFbnRyeSA9IG5ldyBSZWdFeHAoYF5cXFxccyooWzAtOV0rKVxcXFxzKygueyR7UHNQcm9jZXNzUGFyc2VyLnNlY29uZENvbHVtbkNoYXJhY3RlcnMgLSAxfX0pXFxcXHMrKC4qKSRgKTtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gcHNFbnRyeS5leGVjKGxpbmUpO1xyXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpZCA9IG1hdGNoZXNbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICBjb25zdCBleGVjdXRhYmxlID0gbWF0Y2hlc1syXS50cmltKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZGxpbmUgPSBtYXRjaGVzWzNdLnRyaW0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzKGV4ZWN1dGFibGUsIHBpZCwgY21kbGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHNQcm9jZXNzUGFyc2VyID0gUHNQcm9jZXNzUGFyc2VyO1xyXG5mdW5jdGlvbiBleGVjQ2hpbGRQcm9jZXNzKHByb2Nlc3MsIHdvcmtpbmdEaXJlY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY2hpbGRfcHJvY2Vzcy5leGVjKHByb2Nlc3MsIHsgY3dkOiB3b3JraW5nRGlyZWN0b3J5LCBtYXhCdWZmZXI6IDUwMCAqIDEwMjQgfSwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0ZGVyciAmJiBzdGRlcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihzdGRlcnIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKHN0ZG91dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5jbGFzcyBXbWljQXR0YWNoSXRlbXNQcm92aWRlciBleHRlbmRzIE5hdGl2ZUF0dGFjaEl0ZW1zUHJvdmlkZXIge1xyXG4gICAgZ2V0SW50ZXJuYWxQcm9jZXNzRW50cmllcygpIHtcclxuICAgICAgICBjb25zdCB3bWljQ29tbWFuZCA9ICd3bWljIHByb2Nlc3MgZ2V0IE5hbWUsUHJvY2Vzc0lkLENvbW1hbmRMaW5lIC9GT1JNQVQ6bGlzdCc7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWNDaGlsZFByb2Nlc3Mod21pY0NvbW1hbmQsIG51bGwpLnRoZW4ocHJvY2Vzc2VzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFdtaWNQcm9jZXNzUGFyc2VyLlBhcnNlUHJvY2Vzc0Zyb21XbWljKHByb2Nlc3Nlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5XbWljQXR0YWNoSXRlbXNQcm92aWRlciA9IFdtaWNBdHRhY2hJdGVtc1Byb3ZpZGVyO1xyXG5jbGFzcyBXbWljUHJvY2Vzc1BhcnNlciB7XHJcbiAgICBzdGF0aWMgZ2V0IHdtaWNOYW1lVGl0bGUoKSB7IHJldHVybiAnTmFtZSc7IH1cclxuICAgIHN0YXRpYyBnZXQgd21pY0NvbW1hbmRMaW5lVGl0bGUoKSB7IHJldHVybiAnQ29tbWFuZExpbmUnOyB9XHJcbiAgICBzdGF0aWMgZ2V0IHdtaWNQaWRUaXRsZSgpIHsgcmV0dXJuICdQcm9jZXNzSWQnOyB9XHJcbiAgICBzdGF0aWMgUGFyc2VQcm9jZXNzRnJvbVdtaWMocHJvY2Vzc2VzKSB7XHJcbiAgICAgICAgbGV0IGxpbmVzID0gcHJvY2Vzc2VzLnNwbGl0KG9zLkVPTCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9jZXNzID0gbmV3IFByb2Nlc3MobnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgbGV0IHByb2Nlc3NFbnRyaWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFdtaWNQcm9jZXNzUGFyc2VyLnBhcnNlTGluZUZyb21XbWljKGxpbmUsIGN1cnJlbnRQcm9jZXNzKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUubGFzdEluZGV4T2YoV21pY1Byb2Nlc3NQYXJzZXIud21pY1BpZFRpdGxlLCAwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0VudHJpZXMucHVzaChjdXJyZW50UHJvY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2VzcyA9IG5ldyBQcm9jZXNzKG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9jZXNzRW50cmllcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBwYXJzZUxpbmVGcm9tV21pYyhsaW5lLCBwcm9jZXNzKSB7XHJcbiAgICAgICAgbGV0IHNwbGl0dGVyID0gbGluZS5pbmRleE9mKCc9Jyk7XHJcbiAgICAgICAgaWYgKHNwbGl0dGVyID49IDApIHtcclxuICAgICAgICAgICAgbGV0IGtleSA9IGxpbmUuc2xpY2UoMCwgbGluZS5pbmRleE9mKCc9JykpLnRyaW0oKTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gbGluZS5zbGljZShsaW5lLmluZGV4T2YoJz0nKSArIDEpLnRyaW0oKTtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gV21pY1Byb2Nlc3NQYXJzZXIud21pY05hbWVUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBXbWljUHJvY2Vzc1BhcnNlci53bWljUGlkVGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MucGlkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBXbWljUHJvY2Vzc1BhcnNlci53bWljQ29tbWFuZExpbmVUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRMZW5ndGhQYXRoID0gJ1xcXFw/P1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKGV4dGVuZGVkTGVuZ3RoUGF0aCwgMCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKGV4dGVuZGVkTGVuZ3RoUGF0aC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5jb21tYW5kTGluZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuV21pY1Byb2Nlc3NQYXJzZXIgPSBXbWljUHJvY2Vzc1BhcnNlcjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Debugger/nativeAttach.ts\n");

/***/ }),

/***/ "./src/Debugger/utils.ts":
/*!*******************************!*\
  !*** ./src/Debugger/utils.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ArchType;\r\n(function (ArchType) {\r\n    ArchType[ArchType[\"ia32\"] = 0] = \"ia32\";\r\n    ArchType[ArchType[\"x64\"] = 1] = \"x64\";\r\n})(ArchType = exports.ArchType || (exports.ArchType = {}));\r\nclass ArchitectureReplacer {\r\n    static checkAndReplaceWSLPipeProgram(pipeProgramStr, expectedArch) {\r\n        let replacedPipeProgram = null;\r\n        const winDir = process.env.WINDIR ? process.env.WINDIR.toLowerCase() : null;\r\n        const winDirAltDirSep = process.env.WINDIR ? process.env.WINDIR.replace('\\\\', '/').toLowerCase() : null;\r\n        const winDirEnv = \"${env:windir}\";\r\n        if (winDir && winDirAltDirSep && (pipeProgramStr.indexOf(winDir) === 0 || pipeProgramStr.indexOf(winDirAltDirSep) === 0 || pipeProgramStr.indexOf(winDirEnv) === 0)) {\r\n            if (expectedArch === ArchType.x64) {\r\n                const pathSep = ArchitectureReplacer.checkForFolderInPath(pipeProgramStr, \"sysnative\");\r\n                if (pathSep) {\r\n                    replacedPipeProgram = pipeProgramStr.replace(`${pathSep}sysnative${pathSep}`, `${pathSep}system32${pathSep}`);\r\n                }\r\n            }\r\n            else if (expectedArch === ArchType.ia32) {\r\n                const pathSep = ArchitectureReplacer.checkForFolderInPath(pipeProgramStr, \"system32\");\r\n                if (pathSep) {\r\n                    replacedPipeProgram = pipeProgramStr.replace(`${pathSep}system32${pathSep}`, `${pathSep}sysnative${pathSep}`);\r\n                }\r\n            }\r\n        }\r\n        return replacedPipeProgram;\r\n    }\r\n    static checkForFolderInPath(path, folder) {\r\n        if (path.indexOf(`/${folder}/`) >= 0) {\r\n            return '/';\r\n        }\r\n        else if (path.indexOf(`\\\\${folder}\\\\`) >= 0) {\r\n            return '\\\\';\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\nexports.ArchitectureReplacer = ArchitectureReplacer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRGVidWdnZXIvdXRpbHMudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0RlYnVnZ2VyL3V0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFyY2hUeXBlO1xyXG4oZnVuY3Rpb24gKEFyY2hUeXBlKSB7XHJcbiAgICBBcmNoVHlwZVtBcmNoVHlwZVtcImlhMzJcIl0gPSAwXSA9IFwiaWEzMlwiO1xyXG4gICAgQXJjaFR5cGVbQXJjaFR5cGVbXCJ4NjRcIl0gPSAxXSA9IFwieDY0XCI7XHJcbn0pKEFyY2hUeXBlID0gZXhwb3J0cy5BcmNoVHlwZSB8fCAoZXhwb3J0cy5BcmNoVHlwZSA9IHt9KSk7XHJcbmNsYXNzIEFyY2hpdGVjdHVyZVJlcGxhY2VyIHtcclxuICAgIHN0YXRpYyBjaGVja0FuZFJlcGxhY2VXU0xQaXBlUHJvZ3JhbShwaXBlUHJvZ3JhbVN0ciwgZXhwZWN0ZWRBcmNoKSB7XHJcbiAgICAgICAgbGV0IHJlcGxhY2VkUGlwZVByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHdpbkRpciA9IHByb2Nlc3MuZW52LldJTkRJUiA/IHByb2Nlc3MuZW52LldJTkRJUi50b0xvd2VyQ2FzZSgpIDogbnVsbDtcclxuICAgICAgICBjb25zdCB3aW5EaXJBbHREaXJTZXAgPSBwcm9jZXNzLmVudi5XSU5ESVIgPyBwcm9jZXNzLmVudi5XSU5ESVIucmVwbGFjZSgnXFxcXCcsICcvJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcbiAgICAgICAgY29uc3Qgd2luRGlyRW52ID0gXCIke2Vudjp3aW5kaXJ9XCI7XHJcbiAgICAgICAgaWYgKHdpbkRpciAmJiB3aW5EaXJBbHREaXJTZXAgJiYgKHBpcGVQcm9ncmFtU3RyLmluZGV4T2Yod2luRGlyKSA9PT0gMCB8fCBwaXBlUHJvZ3JhbVN0ci5pbmRleE9mKHdpbkRpckFsdERpclNlcCkgPT09IDAgfHwgcGlwZVByb2dyYW1TdHIuaW5kZXhPZih3aW5EaXJFbnYpID09PSAwKSkge1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRBcmNoID09PSBBcmNoVHlwZS54NjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhTZXAgPSBBcmNoaXRlY3R1cmVSZXBsYWNlci5jaGVja0ZvckZvbGRlckluUGF0aChwaXBlUHJvZ3JhbVN0ciwgXCJzeXNuYXRpdmVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aFNlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkUGlwZVByb2dyYW0gPSBwaXBlUHJvZ3JhbVN0ci5yZXBsYWNlKGAke3BhdGhTZXB9c3lzbmF0aXZlJHtwYXRoU2VwfWAsIGAke3BhdGhTZXB9c3lzdGVtMzIke3BhdGhTZXB9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRBcmNoID09PSBBcmNoVHlwZS5pYTMyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoU2VwID0gQXJjaGl0ZWN0dXJlUmVwbGFjZXIuY2hlY2tGb3JGb2xkZXJJblBhdGgocGlwZVByb2dyYW1TdHIsIFwic3lzdGVtMzJcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aFNlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VkUGlwZVByb2dyYW0gPSBwaXBlUHJvZ3JhbVN0ci5yZXBsYWNlKGAke3BhdGhTZXB9c3lzdGVtMzIke3BhdGhTZXB9YCwgYCR7cGF0aFNlcH1zeXNuYXRpdmUke3BhdGhTZXB9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VkUGlwZVByb2dyYW07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tGb3JGb2xkZXJJblBhdGgocGF0aCwgZm9sZGVyKSB7XHJcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihgLyR7Zm9sZGVyfS9gKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGguaW5kZXhPZihgXFxcXCR7Zm9sZGVyfVxcXFxgKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQXJjaGl0ZWN0dXJlUmVwbGFjZXIgPSBBcmNoaXRlY3R1cmVSZXBsYWNlcjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Debugger/utils.ts\n");

/***/ }),

/***/ "./src/LanguageServer/client.ts":
/*!**************************************!*\
  !*** ./src/LanguageServer/client.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst vscode_languageclient_1 = __webpack_require__(/*! vscode-languageclient */ \"./node_modules/vscode-languageclient/lib/main.js\");\r\nconst vscode_cpptools_1 = __webpack_require__(/*! vscode-cpptools */ \"./node_modules/vscode-cpptools/out/api.js\");\r\nconst testApi_1 = __webpack_require__(/*! vscode-cpptools/out/testApi */ \"./node_modules/vscode-cpptools/out/testApi.js\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst configs = __webpack_require__(/*! ./configurations */ \"./src/LanguageServer/configurations.ts\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/LanguageServer/settings.ts\");\r\nconst telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nconst persistentState_1 = __webpack_require__(/*! ./persistentState */ \"./src/LanguageServer/persistentState.ts\");\r\nconst ui_1 = __webpack_require__(/*! ./ui */ \"./src/LanguageServer/ui.ts\");\r\nconst protocolFilter_1 = __webpack_require__(/*! ./protocolFilter */ \"./src/LanguageServer/protocolFilter.ts\");\r\nconst dataBinding_1 = __webpack_require__(/*! ./dataBinding */ \"./src/LanguageServer/dataBinding.ts\");\r\nconst minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\");\r\nconst logger = __webpack_require__(/*! ../logger */ \"./src/logger.ts\");\r\nconst extension_1 = __webpack_require__(/*! ./extension */ \"./src/LanguageServer/extension.ts\");\r\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst settingsTracker_1 = __webpack_require__(/*! ./settingsTracker */ \"./src/LanguageServer/settingsTracker.ts\");\r\nconst testHook_1 = __webpack_require__(/*! ../testHook */ \"./src/testHook.ts\");\r\nconst customProviders_1 = __webpack_require__(/*! ../LanguageServer/customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nconst abTesting_1 = __webpack_require__(/*! ../abTesting */ \"./src/abTesting.ts\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nlet ui;\r\nconst configProviderTimeout = 2000;\r\nconst NavigationListRequest = new vscode_languageclient_1.RequestType('cpptools/requestNavigationList');\r\nconst GoToDeclarationRequest = new vscode_languageclient_1.RequestType('cpptools/goToDeclaration');\r\nconst QueryCompilerDefaultsRequest = new vscode_languageclient_1.RequestType('cpptools/queryCompilerDefaults');\r\nconst SwitchHeaderSourceRequest = new vscode_languageclient_1.RequestType('cpptools/didSwitchHeaderSource');\r\nconst DidOpenNotification = new vscode_languageclient_1.NotificationType('textDocument/didOpen');\r\nconst FileCreatedNotification = new vscode_languageclient_1.NotificationType('cpptools/fileCreated');\r\nconst FileDeletedNotification = new vscode_languageclient_1.NotificationType('cpptools/fileDeleted');\r\nconst ResetDatabaseNotification = new vscode_languageclient_1.NotificationType('cpptools/resetDatabase');\r\nconst PauseParsingNotification = new vscode_languageclient_1.NotificationType('cpptools/pauseParsing');\r\nconst ResumeParsingNotification = new vscode_languageclient_1.NotificationType('cpptools/resumeParsing');\r\nconst ActiveDocumentChangeNotification = new vscode_languageclient_1.NotificationType('cpptools/activeDocumentChange');\r\nconst TextEditorSelectionChangeNotification = new vscode_languageclient_1.NotificationType('cpptools/textEditorSelectionChange');\r\nconst ChangeFolderSettingsNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeFolderSettings');\r\nconst ChangeCompileCommandsNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCompileCommands');\r\nconst ChangeSelectedSettingNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeSelectedSetting');\r\nconst IntervalTimerNotification = new vscode_languageclient_1.NotificationType('cpptools/onIntervalTimer');\r\nconst CustomConfigurationNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCustomConfiguration');\r\nconst CustomBrowseConfigurationNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCustomBrowseConfiguration');\r\nconst ClearCustomConfigurationsNotification = new vscode_languageclient_1.NotificationType('cpptools/clearCustomConfigurations');\r\nconst ReloadWindowNotification = new vscode_languageclient_1.NotificationType('cpptools/reloadWindow');\r\nconst LogTelemetryNotification = new vscode_languageclient_1.NotificationType('cpptools/logTelemetry');\r\nconst ReportNavigationNotification = new vscode_languageclient_1.NotificationType('cpptools/reportNavigation');\r\nconst ReportTagParseStatusNotification = new vscode_languageclient_1.NotificationType('cpptools/reportTagParseStatus');\r\nconst ReportStatusNotification = new vscode_languageclient_1.NotificationType('cpptools/reportStatus');\r\nconst DebugProtocolNotification = new vscode_languageclient_1.NotificationType('cpptools/debugProtocol');\r\nconst DebugLogNotification = new vscode_languageclient_1.NotificationType('cpptools/debugLog');\r\nconst InactiveRegionNotification = new vscode_languageclient_1.NotificationType('cpptools/inactiveRegions');\r\nconst CompileCommandsPathsNotification = new vscode_languageclient_1.NotificationType('cpptools/compileCommandsPaths');\r\nconst UpdateClangFormatPathNotification = new vscode_languageclient_1.NotificationType('cpptools/updateClangFormatPath');\r\nclass BlockingTask {\r\n    constructor(task, dependency) {\r\n        this.done = false;\r\n        this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                let result = yield task();\r\n                resolve(result);\r\n                this.done = true;\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n                this.done = true;\r\n            }\r\n        }));\r\n        this.dependency = dependency;\r\n    }\r\n    get Done() {\r\n        return this.done && (!this.dependency || this.dependency.Done);\r\n    }\r\n    then(onSucceeded, onRejected) {\r\n        return this.promise.then(onSucceeded, onRejected);\r\n    }\r\n}\r\nlet failureMessageShown = false;\r\nfunction createClient(allClients, workspaceFolder) {\r\n    return new DefaultClient(allClients, workspaceFolder);\r\n}\r\nexports.createClient = createClient;\r\nfunction createNullClient() {\r\n    return new NullClient();\r\n}\r\nexports.createNullClient = createNullClient;\r\nclass DefaultClient {\r\n    constructor(allClients, workspaceFolder) {\r\n        this.disposables = [];\r\n        this.trackedDocuments = new Set();\r\n        this.crashTimes = [];\r\n        this.isSupported = true;\r\n        this.inactiveRegionsDecorations = new Map();\r\n        this.model = {\r\n            isTagParsing: new dataBinding_1.DataBinding(false),\r\n            isUpdatingIntelliSense: new dataBinding_1.DataBinding(false),\r\n            navigationLocation: new dataBinding_1.DataBinding(\"\"),\r\n            tagParserStatus: new dataBinding_1.DataBinding(\"\"),\r\n            activeConfigName: new dataBinding_1.DataBinding(\"\")\r\n        };\r\n        try {\r\n            console.log('create LanguageClient');\r\n            let languageClient = this.createLanguageClient(allClients, workspaceFolder);\r\n            languageClient.registerProposedFeatures();\r\n            languageClient.start();\r\n            util.setProgress(util.getProgressExecutableStarted());\r\n            this.rootFolder = workspaceFolder;\r\n            ui = ui_1.getUI();\r\n            ui.bind(this);\r\n            this.queueBlockingTask(() => languageClient.onReady().then(() => {\r\n                console.log('client ready');\r\n                this.configuration = new configs.CppProperties(this.RootUri);\r\n                this.configuration.ConfigurationsChanged((e) => this.onConfigurationsChanged(e));\r\n                this.configuration.SelectionChanged((e) => this.onSelectedConfigurationChanged(e));\r\n                this.configuration.CompileCommandsChanged((e) => this.onCompileCommandsChanged(e));\r\n                this.disposables.push(this.configuration);\r\n                languageClient.sendRequest(QueryCompilerDefaultsRequest, {}).then((compilerDefaults) => {\r\n                    this.configuration.CompilerDefaults = compilerDefaults;\r\n                    console.log('compiler defaults received');\r\n                    extension_1.registerCommands();\r\n                });\r\n                this.languageClient = languageClient;\r\n                this.settingsTracker = settingsTracker_1.getTracker(this.RootUri);\r\n                telemetry.logLanguageServerEvent(\"NonDefaultInitialCppSettings\", this.settingsTracker.getUserModifiedSettings());\r\n                failureMessageShown = false;\r\n                this.registerNotifications();\r\n                this.registerFileWatcher();\r\n                console.log('registered stuff');\r\n            }, (err) => {\r\n                this.isSupported = false;\r\n                if (!failureMessageShown) {\r\n                    failureMessageShown = true;\r\n                    vscode.window.showErrorMessage(\"Unable to start the C/C++ language server. IntelliSense features will be disabled. Error: \" + String(err));\r\n                }\r\n            }));\r\n        }\r\n        catch (err) {\r\n            this.isSupported = false;\r\n            if (!failureMessageShown) {\r\n                failureMessageShown = true;\r\n                let additionalInfo;\r\n                if (err.code === \"EPERM\") {\r\n                    additionalInfo = `EPERM: Check permissions for '${getLanguageServerFileName()}'`;\r\n                }\r\n                else {\r\n                    additionalInfo = String(err);\r\n                }\r\n                vscode.window.showErrorMessage(\"Unable to start the C/C++ language server. IntelliSense features will be disabled. Error: \" + additionalInfo);\r\n            }\r\n        }\r\n    }\r\n    get TagParsingChanged() { return this.model.isTagParsing.ValueChanged; }\r\n    get IntelliSenseParsingChanged() { return this.model.isUpdatingIntelliSense.ValueChanged; }\r\n    get NavigationLocationChanged() { return this.model.navigationLocation.ValueChanged; }\r\n    get TagParserStatusChanged() { return this.model.tagParserStatus.ValueChanged; }\r\n    get ActiveConfigChanged() { return this.model.activeConfigName.ValueChanged; }\r\n    get RootPath() {\r\n        return (this.rootFolder) ? this.rootFolder.uri.fsPath : \"\";\r\n    }\r\n    get RootUri() {\r\n        return (this.rootFolder) ? this.rootFolder.uri : null;\r\n    }\r\n    get Name() {\r\n        return this.getName(this.rootFolder);\r\n    }\r\n    get TrackedDocuments() {\r\n        return this.trackedDocuments;\r\n    }\r\n    get AdditionalEnvironment() {\r\n        return { workspaceFolderBasename: this.Name };\r\n    }\r\n    getName(workspaceFolder) {\r\n        return workspaceFolder ? workspaceFolder.name : \"untitled\";\r\n    }\r\n    createLanguageClient(allClients, workspaceFolder) {\r\n        let serverModule = getLanguageServerFileName();\r\n        let exeExists = fs.existsSync(serverModule);\r\n        if (!exeExists) {\r\n            throw String('Missing binary at ' + serverModule);\r\n        }\r\n        let serverName = this.getName(workspaceFolder);\r\n        let serverOptions = {\r\n            run: { command: serverModule },\r\n            debug: { command: serverModule, args: [serverName] }\r\n        };\r\n        let settings = new settings_1.CppSettings(workspaceFolder ? workspaceFolder.uri : null);\r\n        let other = new settings_1.OtherSettings(workspaceFolder ? workspaceFolder.uri : null);\r\n        let storagePath = util.extensionContext.storagePath;\r\n        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) {\r\n            storagePath = path.join(storagePath, serverName);\r\n        }\r\n        let abTestSettings = abTesting_1.getABTestSettings();\r\n        let intelliSenseCacheDisabled = false;\r\n        if (os.platform() === \"darwin\") {\r\n            const releaseParts = os.release().split(\".\");\r\n            if (releaseParts.length >= 1) {\r\n                intelliSenseCacheDisabled = parseInt(releaseParts[0]) < 17;\r\n            }\r\n        }\r\n        let clientOptions = {\r\n            documentSelector: [\r\n                { scheme: 'file', language: 'cpp' },\r\n                { scheme: 'file', language: 'c' }\r\n            ],\r\n            synchronize: {\r\n                configurationSection: ['C_Cpp', 'files', 'search']\r\n            },\r\n            workspaceFolder: workspaceFolder,\r\n            initializationOptions: {\r\n                clang_format_path: util.resolveVariables(settings.clangFormatPath, this.AdditionalEnvironment),\r\n                clang_format_style: settings.clangFormatStyle,\r\n                clang_format_fallbackStyle: settings.clangFormatFallbackStyle,\r\n                clang_format_sortIncludes: settings.clangFormatSortIncludes,\r\n                formatting: settings.formatting,\r\n                extension_path: util.extensionContext.extensionPath,\r\n                exclude_files: other.filesExclude,\r\n                exclude_search: other.searchExclude,\r\n                storage_path: storagePath,\r\n                tab_size: other.editorTabSize,\r\n                intelliSenseEngine: settings.intelliSenseEngine,\r\n                intelliSenseEngineFallback: settings.intelliSenseEngineFallback,\r\n                intelliSenseCacheDisabled: intelliSenseCacheDisabled,\r\n                intelliSenseCachePath: settings.intelliSenseCachePath,\r\n                intelliSenseCacheSize: settings.intelliSenseCacheSize,\r\n                autocomplete: settings.autoComplete,\r\n                errorSquiggles: settings.errorSquiggles,\r\n                dimInactiveRegions: settings.dimInactiveRegions,\r\n                suggestSnippets: settings.suggestSnippets,\r\n                loggingLevel: settings.loggingLevel,\r\n                workspaceParsingPriority: settings.workspaceParsingPriority,\r\n                workspaceSymbols: settings.workspaceSymbols,\r\n                exclusionPolicy: settings.exclusionPolicy,\r\n                preferredPathSeparator: settings.preferredPathSeparator,\r\n                default: {\r\n                    systemIncludePath: settings.defaultSystemIncludePath\r\n                },\r\n                vcpkg_root: util.getVcpkgRoot(),\r\n                gotoDefIntelliSense: abTestSettings.UseGoToDefIntelliSense\r\n            },\r\n            middleware: protocolFilter_1.createProtocolFilter(this, allClients),\r\n            errorHandler: {\r\n                error: () => vscode_languageclient_1.ErrorAction.Continue,\r\n                closed: () => {\r\n                    this.crashTimes.push(Date.now());\r\n                    if (this.crashTimes.length < 5) {\r\n                        let newClient = allClients.replace(this, true);\r\n                        newClient.crashTimes = this.crashTimes;\r\n                    }\r\n                    else {\r\n                        let elapsed = this.crashTimes[this.crashTimes.length - 1] - this.crashTimes[0];\r\n                        if (elapsed <= 3 * 60 * 1000) {\r\n                            if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) {\r\n                                vscode.window.showErrorMessage(`The language server for '${serverName}' crashed 5 times in the last 3 minutes. It will not be restarted.`);\r\n                            }\r\n                            else {\r\n                                vscode.window.showErrorMessage(`The language server crashed 5 times in the last 3 minutes. It will not be restarted.`);\r\n                            }\r\n                            allClients.replace(this, false);\r\n                        }\r\n                        else {\r\n                            this.crashTimes.shift();\r\n                            let newClient = allClients.replace(this, true);\r\n                            newClient.crashTimes = this.crashTimes;\r\n                        }\r\n                    }\r\n                    return vscode_languageclient_1.CloseAction.DoNotRestart;\r\n                }\r\n            }\r\n        };\r\n        return new vscode_languageclient_1.LanguageClient(`cpptools: ${serverName}`, serverOptions, clientOptions);\r\n    }\r\n    onDidChangeSettings() {\r\n        let changedSettings = this.settingsTracker.getChangedSettings();\r\n        if (Object.keys(changedSettings).length > 0) {\r\n            if (changedSettings[\"commentContinuationPatterns\"]) {\r\n                extension_1.updateLanguageConfigurations();\r\n            }\r\n            if (changedSettings[\"clang_format_path\"]) {\r\n                let settings = new settings_1.CppSettings(this.RootUri);\r\n                this.languageClient.sendNotification(UpdateClangFormatPathNotification, util.resolveVariables(settings.clangFormatPath, this.AdditionalEnvironment));\r\n            }\r\n            this.configuration.onDidChangeSettings();\r\n            telemetry.logLanguageServerEvent(\"CppSettingsChange\", changedSettings, null);\r\n        }\r\n        return changedSettings;\r\n    }\r\n    onDidChangeVisibleTextEditors(editors) {\r\n        let settings = new settings_1.CppSettings(this.RootUri);\r\n        if (settings.dimInactiveRegions) {\r\n            for (let e of editors) {\r\n                let valuePair = this.inactiveRegionsDecorations.get(e.document.uri.toString());\r\n                if (valuePair) {\r\n                    e.setDecorations(valuePair.decoration, valuePair.ranges);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    onRegisterCustomConfigurationProvider(provider) {\r\n        let onRegistered = () => {\r\n            if (provider.version >= vscode_cpptools_1.Version.v2) {\r\n                this.pauseParsing();\r\n            }\r\n        };\r\n        return this.notifyWhenReady(() => {\r\n            if (!this.RootPath) {\r\n                return;\r\n            }\r\n            let selectedProvider = this.configuration.CurrentConfigurationProvider;\r\n            if (!selectedProvider) {\r\n                let ask = new persistentState_1.PersistentFolderState(\"Client.registerProvider\", true, this.RootPath);\r\n                if (ask.Value) {\r\n                    ui.showConfigureCustomProviderMessage(() => {\r\n                        let folderStr = (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) ? \"the '\" + this.Name + \"'\" : \"this\";\r\n                        const message = `${provider.name} would like to configure IntelliSense for ${folderStr} folder.`;\r\n                        const allow = \"Allow\";\r\n                        const dontAllow = \"Don't Allow\";\r\n                        const askLater = \"Ask Me Later\";\r\n                        return vscode.window.showInformationMessage(message, allow, dontAllow, askLater).then(result => {\r\n                            switch (result) {\r\n                                case allow: {\r\n                                    this.configuration.updateCustomConfigurationProvider(provider.extensionId).then(() => {\r\n                                        onRegistered();\r\n                                        telemetry.logLanguageServerEvent(\"customConfigurationProvider\", { \"providerId\": provider.extensionId });\r\n                                    });\r\n                                    ask.Value = false;\r\n                                    return true;\r\n                                }\r\n                                case dontAllow: {\r\n                                    ask.Value = false;\r\n                                    break;\r\n                                }\r\n                                default: {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }, () => ask.Value = false);\r\n                }\r\n            }\r\n            else if (selectedProvider === provider.extensionId) {\r\n                onRegistered();\r\n                telemetry.logLanguageServerEvent(\"customConfigurationProvider\", { \"providerId\": provider.extensionId });\r\n            }\r\n            else if (selectedProvider === provider.name) {\r\n                onRegistered();\r\n                this.configuration.updateCustomConfigurationProvider(provider.extensionId);\r\n            }\r\n        });\r\n    }\r\n    updateCustomConfigurations(requestingProvider) {\r\n        return this.notifyWhenReady(() => {\r\n            if (!this.configurationProvider) {\r\n                return;\r\n            }\r\n            let currentProvider = customProviders_1.getCustomConfigProviders().get(this.configurationProvider);\r\n            if (!currentProvider || (requestingProvider && requestingProvider.extensionId !== currentProvider.extensionId) || this.trackedDocuments.size === 0) {\r\n                return;\r\n            }\r\n            let tokenSource = new vscode_1.CancellationTokenSource();\r\n            let documentUris = [];\r\n            this.trackedDocuments.forEach(document => documentUris.push(document.uri));\r\n            let task = () => {\r\n                return currentProvider.provideConfigurations(documentUris, tokenSource.token);\r\n            };\r\n            this.queueTaskWithTimeout(task, configProviderTimeout, tokenSource).then(configs => this.sendCustomConfigurations(configs), () => { });\r\n        });\r\n    }\r\n    updateCustomBrowseConfiguration(requestingProvider) {\r\n        return this.notifyWhenReady(() => {\r\n            if (!this.configurationProvider) {\r\n                return;\r\n            }\r\n            console.log(\"updateCustomBrowseConfiguration\");\r\n            let currentProvider = customProviders_1.getCustomConfigProviders().get(this.configurationProvider);\r\n            if (!currentProvider || (requestingProvider && requestingProvider.extensionId !== currentProvider.extensionId)) {\r\n                return;\r\n            }\r\n            let tokenSource = new vscode_1.CancellationTokenSource();\r\n            let task = () => __awaiter(this, void 0, void 0, function* () {\r\n                if (yield currentProvider.canProvideBrowseConfiguration(tokenSource.token)) {\r\n                    return currentProvider.provideBrowseConfiguration(tokenSource.token);\r\n                }\r\n                if (currentProvider.version >= vscode_cpptools_1.Version.v2) {\r\n                    console.warn(\"failed to provide browse configuration\");\r\n                }\r\n                return Promise.reject(\"\");\r\n            });\r\n            this.queueTaskWithTimeout(task, configProviderTimeout, tokenSource).then((config) => __awaiter(this, void 0, void 0, function* () {\r\n                yield this.sendCustomBrowseConfiguration(config);\r\n                this.resumeParsing();\r\n            }), () => { });\r\n        });\r\n    }\r\n    provideCustomConfiguration(document) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let tokenSource = new vscode_1.CancellationTokenSource();\r\n            let providers = customProviders_1.getCustomConfigProviders();\r\n            if (providers.size === 0) {\r\n                return Promise.resolve();\r\n            }\r\n            console.log(\"provideCustomConfiguration\");\r\n            let providerId = yield this.getCustomConfigurationProviderId();\r\n            if (!providerId) {\r\n                return Promise.resolve();\r\n            }\r\n            let providerName = providerId;\r\n            let configName = yield this.getCurrentConfigName();\r\n            const notReadyMessage = `${providerName} is not ready`;\r\n            let provideConfigurationAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    let provider = providers.get(providerId);\r\n                    if (provider) {\r\n                        if (!provider.isReady) {\r\n                            return Promise.reject(notReadyMessage);\r\n                        }\r\n                        providerName = provider.name;\r\n                        if (yield provider.canProvideConfiguration(document.uri, tokenSource.token)) {\r\n                            return provider.provideConfigurations([document.uri], tokenSource.token);\r\n                        }\r\n                    }\r\n                }\r\n                catch (err) {\r\n                }\r\n                console.warn(\"failed to provide configuration\");\r\n                return Promise.reject(\"\");\r\n            });\r\n            return this.queueTaskWithTimeout(provideConfigurationAsync, configProviderTimeout, tokenSource).then((configs) => {\r\n                if (configs && configs.length > 0) {\r\n                    this.sendCustomConfigurations(configs, true);\r\n                }\r\n            }, (err) => {\r\n                if (err === notReadyMessage) {\r\n                    return;\r\n                }\r\n                let settings = new settings_1.CppSettings(this.RootUri);\r\n                if (settings.configurationWarnings === \"Enabled\" && !this.isExternalHeader(document) && !vscode.debug.activeDebugSession) {\r\n                    const dismiss = \"Dismiss\";\r\n                    const disable = \"Disable Warnings\";\r\n                    let message = `'${providerName}' is unable to provide IntelliSense configuration information for '${document.uri.fsPath}'. ` +\r\n                        `Settings from the '${configName}' configuration will be used instead.`;\r\n                    if (err) {\r\n                        message += ` (${err})`;\r\n                    }\r\n                    vscode.window.showInformationMessage(message, dismiss, disable).then(response => {\r\n                        switch (response) {\r\n                            case disable: {\r\n                                settings.toggleSetting(\"configurationWarnings\", \"Enabled\", \"Disabled\");\r\n                                break;\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    isExternalHeader(document) {\r\n        return util.isHeader(document) && !document.uri.toString().startsWith(this.RootUri.toString());\r\n    }\r\n    getCustomConfigurationProviderId() {\r\n        return this.queueTask(() => Promise.resolve(this.configuration.CurrentConfigurationProvider));\r\n    }\r\n    getCurrentConfigName() {\r\n        return this.queueTask(() => Promise.resolve(this.configuration.CurrentConfiguration.name));\r\n    }\r\n    getCompilerPath() {\r\n        return this.queueTask(() => Promise.resolve(this.configuration.CompilerPath));\r\n    }\r\n    getKnownCompilers() {\r\n        return this.queueTask(() => Promise.resolve(this.configuration.KnownCompiler));\r\n    }\r\n    takeOwnership(document) {\r\n        let params = {\r\n            textDocument: {\r\n                uri: document.uri.toString(),\r\n                languageId: document.languageId,\r\n                version: document.version,\r\n                text: document.getText()\r\n            }\r\n        };\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(DidOpenNotification, params));\r\n        this.trackedDocuments.add(document);\r\n    }\r\n    queueTask(task) {\r\n        if (this.isSupported) {\r\n            let nextTask = () => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    return yield task();\r\n                }\r\n                catch (err) {\r\n                    console.error(err);\r\n                    throw err;\r\n                }\r\n            });\r\n            if (this.pendingTask && !this.pendingTask.Done) {\r\n                return this.pendingTask.then(nextTask, nextTask);\r\n            }\r\n            else {\r\n                this.pendingTask = undefined;\r\n                return nextTask();\r\n            }\r\n        }\r\n        else {\r\n            return Promise.reject(\"Unsupported client\");\r\n        }\r\n    }\r\n    queueBlockingTask(task) {\r\n        if (this.isSupported) {\r\n            this.pendingTask = new BlockingTask(task, this.pendingTask);\r\n        }\r\n        else {\r\n            return Promise.reject(\"Unsupported client\");\r\n        }\r\n    }\r\n    queueTaskWithTimeout(task, ms, cancelToken) {\r\n        let timer;\r\n        let timeout = () => new Promise((resolve, reject) => {\r\n            timer = setTimeout(() => {\r\n                clearTimeout(timer);\r\n                if (cancelToken) {\r\n                    cancelToken.cancel();\r\n                }\r\n                reject(\"Timed out in \" + ms + \"ms.\");\r\n            }, ms);\r\n        });\r\n        return this.queueTask(() => {\r\n            return Promise.race([task(), timeout()]).then((result) => {\r\n                clearTimeout(timer);\r\n                return result;\r\n            }, (error) => {\r\n                clearTimeout(timer);\r\n                throw error;\r\n            });\r\n        });\r\n    }\r\n    requestWhenReady(request) {\r\n        return this.queueTask(request);\r\n    }\r\n    notifyWhenReady(notify, blockingTask) {\r\n        let task = () => new Promise(resolve => {\r\n            notify();\r\n            resolve();\r\n        });\r\n        if (blockingTask) {\r\n            return this.queueBlockingTask(task);\r\n        }\r\n        else {\r\n            return this.queueTask(task);\r\n        }\r\n    }\r\n    registerNotifications() {\r\n        console.assert(this.languageClient !== undefined, \"This method must not be called until this.languageClient is set in \\\"onReady\\\"\");\r\n        this.languageClient.onNotification(ReloadWindowNotification, () => util.promptForReloadWindowDueToSettingsChange());\r\n        this.languageClient.onNotification(LogTelemetryNotification, (e) => this.logTelemetry(e));\r\n        this.languageClient.onNotification(ReportNavigationNotification, (e) => this.navigate(e));\r\n        this.languageClient.onNotification(ReportStatusNotification, (e) => this.updateStatus(e));\r\n        this.languageClient.onNotification(ReportTagParseStatusNotification, (e) => this.updateTagParseStatus(e));\r\n        this.languageClient.onNotification(InactiveRegionNotification, (e) => this.updateInactiveRegions(e));\r\n        this.languageClient.onNotification(CompileCommandsPathsNotification, (e) => this.promptCompileCommands(e));\r\n        this.setupOutputHandlers();\r\n    }\r\n    registerFileWatcher() {\r\n        console.assert(this.languageClient !== undefined, \"This method must not be called until this.languageClient is set in \\\"onReady\\\"\");\r\n        if (this.rootFolder) {\r\n            this.rootPathFileWatcher = vscode.workspace.createFileSystemWatcher(\"**/*\", false, true, false);\r\n            this.rootPathFileWatcher.onDidCreate((uri) => {\r\n                this.languageClient.sendNotification(FileCreatedNotification, { uri: uri.toString() });\r\n            });\r\n            this.rootPathFileWatcher.onDidDelete((uri) => {\r\n                this.languageClient.sendNotification(FileDeletedNotification, { uri: uri.toString() });\r\n            });\r\n            this.disposables.push(this.rootPathFileWatcher);\r\n        }\r\n        else {\r\n            this.rootPathFileWatcher = undefined;\r\n        }\r\n    }\r\n    setupOutputHandlers() {\r\n        console.assert(this.languageClient !== undefined, \"This method must not be called until this.languageClient is set in \\\"onReady\\\"\");\r\n        this.languageClient.onNotification(DebugProtocolNotification, (output) => {\r\n            if (!this.debugChannel) {\r\n                this.debugChannel = vscode.window.createOutputChannel(`C/C++ Debug Protocol: ${this.Name}`);\r\n                this.disposables.push(this.debugChannel);\r\n            }\r\n            this.debugChannel.appendLine(\"\");\r\n            this.debugChannel.appendLine(\"************************************************************************************************************************\");\r\n            this.debugChannel.append(`${output}`);\r\n        });\r\n        this.languageClient.onNotification(DebugLogNotification, (output) => {\r\n            if (!this.outputChannel) {\r\n                if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) {\r\n                    this.outputChannel = vscode.window.createOutputChannel(`C/C++: ${this.Name}`);\r\n                }\r\n                else {\r\n                    this.outputChannel = logger.getOutputChannel();\r\n                }\r\n                this.disposables.push(this.outputChannel);\r\n            }\r\n            this.outputChannel.appendLine(`${output}`);\r\n        });\r\n    }\r\n    logTelemetry(notificationBody) {\r\n        telemetry.logLanguageServerEvent(notificationBody.event, notificationBody.properties, notificationBody.metrics);\r\n    }\r\n    navigate(payload) {\r\n        let cppSettings = new settings_1.CppSettings(this.RootUri);\r\n        if (cppSettings.autoAddFileAssociations && payload.navigation.startsWith(\"<def\")) {\r\n            this.addFileAssociations(payload.navigation.substr(4));\r\n            return;\r\n        }\r\n        let currentNavigation = payload.navigation;\r\n        let maxLength = cppSettings.navigationLength;\r\n        if (currentNavigation.length > maxLength) {\r\n            currentNavigation = currentNavigation.substring(0, maxLength - 3).concat(\"...\");\r\n        }\r\n        this.model.navigationLocation.Value = currentNavigation;\r\n    }\r\n    addFileAssociations(fileAssociations) {\r\n        let settings = new settings_1.OtherSettings(this.RootUri);\r\n        let assocs = settings.filesAssociations;\r\n        let is_c = fileAssociations.startsWith(\"c\");\r\n        fileAssociations = fileAssociations.substr(is_c ? 3 : 2);\r\n        let filesAndPaths = fileAssociations.split(\";\");\r\n        let foundNewAssociation = false;\r\n        for (let i = 0; i < filesAndPaths.length - 1; ++i) {\r\n            let fileAndPath = filesAndPaths[i].split(\"@\");\r\n            let file = fileAndPath[0];\r\n            let filePath = fileAndPath[1];\r\n            if ((file in assocs) || ((\"**/\" + file) in assocs)) {\r\n                continue;\r\n            }\r\n            let j = file.lastIndexOf('.');\r\n            if (j !== -1) {\r\n                let ext = file.substr(j);\r\n                if (((\"*\" + ext) in assocs) || ((\"**/*\" + ext) in assocs)) {\r\n                    continue;\r\n                }\r\n            }\r\n            let foundGlobMatch = false;\r\n            for (let assoc in assocs) {\r\n                if (minimatch(filePath, assoc)) {\r\n                    foundGlobMatch = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundGlobMatch) {\r\n                continue;\r\n            }\r\n            assocs[file] = is_c ? \"c\" : \"cpp\";\r\n            foundNewAssociation = true;\r\n        }\r\n        if (foundNewAssociation) {\r\n            settings.filesAssociations = assocs;\r\n        }\r\n    }\r\n    updateStatus(notificationBody) {\r\n        let message = notificationBody.status;\r\n        util.setProgress(util.getProgressExecutableSuccess());\r\n        let testHook = testHook_1.getTestHook();\r\n        if (message.endsWith(\"Indexing...\")) {\r\n            this.model.isTagParsing.Value = true;\r\n            testHook.updateStatus(testApi_1.Status.TagParsingBegun);\r\n        }\r\n        else if (message.endsWith(\"Updating IntelliSense...\")) {\r\n            this.model.isUpdatingIntelliSense.Value = true;\r\n            testHook.updateStatus(testApi_1.Status.IntelliSenseCompiling);\r\n        }\r\n        else if (message.endsWith(\"IntelliSense Ready\")) {\r\n            this.model.isUpdatingIntelliSense.Value = false;\r\n            testHook.updateStatus(testApi_1.Status.IntelliSenseReady);\r\n        }\r\n        else if (message.endsWith(\"Ready\")) {\r\n            this.model.isTagParsing.Value = false;\r\n            testHook.updateStatus(testApi_1.Status.TagParsingDone);\r\n            util.setProgress(util.getProgressParseRootSuccess());\r\n        }\r\n        else if (message.endsWith(\"No Squiggles\")) {\r\n            util.setIntelliSenseProgress(util.getProgressIntelliSenseNoSquiggles());\r\n        }\r\n        else if (message.endsWith(\"IntelliSense Fallback\")) {\r\n            let showIntelliSenseFallbackMessage = new persistentState_1.PersistentState(\"CPP.showIntelliSenseFallbackMessage\", true);\r\n            if (showIntelliSenseFallbackMessage.Value) {\r\n                ui.showConfigureIncludePathMessage(() => {\r\n                    let learnMorePanel = \"Configuration Help\";\r\n                    let dontShowAgain = \"Don't Show Again\";\r\n                    let fallbackMsg = this.configuration.VcpkgInstalled ?\r\n                        \"Update your IntelliSense settings or use Vcpkg to install libraries to help find missing headers.\" :\r\n                        \"Configure your IntelliSense settings to help find missing headers.\";\r\n                    return vscode.window.showInformationMessage(fallbackMsg, learnMorePanel, dontShowAgain).then((value) => {\r\n                        switch (value) {\r\n                            case learnMorePanel:\r\n                                let uri = vscode.Uri.parse(`https://go.microsoft.com/fwlink/?linkid=864631`);\r\n                                vscode.commands.executeCommand('vscode.open', uri);\r\n                                vscode.commands.getCommands(true).then((commands) => {\r\n                                    if (commands.indexOf(\"workbench.action.problems.focus\") >= 0) {\r\n                                        vscode.commands.executeCommand(\"workbench.action.problems.focus\");\r\n                                    }\r\n                                });\r\n                                this.handleConfigurationEditCommand();\r\n                                break;\r\n                            case dontShowAgain:\r\n                                showIntelliSenseFallbackMessage.Value = false;\r\n                                break;\r\n                        }\r\n                        return true;\r\n                    });\r\n                }, () => showIntelliSenseFallbackMessage.Value = false);\r\n            }\r\n        }\r\n    }\r\n    updateTagParseStatus(notificationBody) {\r\n        this.model.tagParserStatus.Value = notificationBody.status;\r\n    }\r\n    updateInactiveRegions(params) {\r\n        let settings = new settings_1.CppSettings(this.RootUri);\r\n        let decoration = vscode.window.createTextEditorDecorationType({\r\n            opacity: settings.inactiveRegionOpacity.toString(),\r\n            backgroundColor: settings.inactiveRegionBackgroundColor,\r\n            color: settings.inactiveRegionForegroundColor,\r\n            rangeBehavior: vscode.DecorationRangeBehavior.ClosedOpen\r\n        });\r\n        let ranges = [];\r\n        params.regions.forEach(element => {\r\n            let newRange = new vscode.Range(element.startLine, 0, element.endLine, 0);\r\n            ranges.push(newRange);\r\n        });\r\n        let valuePair = this.inactiveRegionsDecorations.get(params.uri);\r\n        if (valuePair) {\r\n            valuePair.decoration.dispose();\r\n            valuePair.decoration = decoration;\r\n            valuePair.ranges = ranges;\r\n        }\r\n        else {\r\n            let toInsert = {\r\n                decoration: decoration,\r\n                ranges: ranges\r\n            };\r\n            this.inactiveRegionsDecorations.set(params.uri, toInsert);\r\n        }\r\n        if (settings.dimInactiveRegions) {\r\n            let editors = vscode.window.visibleTextEditors.filter(e => e.document.uri.toString() === params.uri);\r\n            for (let e of editors) {\r\n                e.setDecorations(decoration, ranges);\r\n            }\r\n        }\r\n    }\r\n    promptCompileCommands(params) {\r\n        if (this.configuration.CurrentConfiguration.compileCommands !== undefined) {\r\n            return;\r\n        }\r\n        let ask = new persistentState_1.PersistentState(\"CPP.showCompileCommandsSelection\", true);\r\n        if (!ask.Value) {\r\n            return;\r\n        }\r\n        let compileCommandStr = params.paths.length > 1 ? \"a compile_commands.json file\" : params.paths[0];\r\n        let folderStr = (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) ? \"the '\" + this.Name + \"'\" : \"this\";\r\n        const message = `Would you like to use ${compileCommandStr} to auto-configure IntelliSense for ${folderStr} folder?`;\r\n        ui.showConfigureCompileCommandsMessage(() => {\r\n            const yes = \"Yes\";\r\n            const no = \"No\";\r\n            const askLater = \"Ask Me Later\";\r\n            return vscode.window.showInformationMessage(message, yes, no, askLater).then((value) => __awaiter(this, void 0, void 0, function* () {\r\n                switch (value) {\r\n                    case yes:\r\n                        if (params.paths.length > 1) {\r\n                            let index = yield ui.showCompileCommands(params.paths);\r\n                            if (index < 0) {\r\n                                return false;\r\n                            }\r\n                            this.configuration.setCompileCommands(params.paths[index]);\r\n                        }\r\n                        else {\r\n                            this.configuration.setCompileCommands(params.paths[0]);\r\n                        }\r\n                        return true;\r\n                    case askLater:\r\n                        break;\r\n                    case no:\r\n                        ask.Value = false;\r\n                        break;\r\n                }\r\n                return false;\r\n            }));\r\n        }, () => ask.Value = false);\r\n    }\r\n    requestGoToDeclaration() {\r\n        return this.requestWhenReady(() => this.languageClient.sendRequest(GoToDeclarationRequest, null));\r\n    }\r\n    requestSwitchHeaderSource(rootPath, fileName) {\r\n        let params = {\r\n            rootPath: rootPath,\r\n            switchHeaderSourceFileName: fileName\r\n        };\r\n        return this.requestWhenReady(() => this.languageClient.sendRequest(SwitchHeaderSourceRequest, params));\r\n    }\r\n    requestNavigationList(document) {\r\n        return this.requestWhenReady(() => {\r\n            return this.languageClient.sendRequest(NavigationListRequest, this.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document));\r\n        });\r\n    }\r\n    activeDocumentChanged(document) {\r\n        this.notifyWhenReady(() => {\r\n            this.languageClient.sendNotification(ActiveDocumentChangeNotification, this.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document));\r\n        });\r\n    }\r\n    activate() {\r\n        for (let key in this.model) {\r\n            if (this.model.hasOwnProperty(key)) {\r\n                this.model[key].activate();\r\n            }\r\n        }\r\n        this.resumeParsing();\r\n    }\r\n    selectionChanged(selection) {\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(TextEditorSelectionChangeNotification, selection));\r\n    }\r\n    resetDatabase() {\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(ResetDatabaseNotification));\r\n    }\r\n    deactivate() {\r\n        for (let key in this.model) {\r\n            if (this.model.hasOwnProperty(key)) {\r\n                this.model[key].deactivate();\r\n            }\r\n        }\r\n        this.pauseParsing();\r\n    }\r\n    pauseParsing() {\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(PauseParsingNotification));\r\n    }\r\n    resumeParsing() {\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(ResumeParsingNotification));\r\n    }\r\n    onConfigurationsChanged(configurations) {\r\n        let params = {\r\n            configurations: configurations,\r\n            currentConfiguration: this.configuration.CurrentConfigurationIndex\r\n        };\r\n        this.notifyWhenReady(() => {\r\n            this.languageClient.sendNotification(ChangeFolderSettingsNotification, params);\r\n            this.model.activeConfigName.Value = configurations[params.currentConfiguration].name;\r\n        }).then(() => {\r\n            let newProvider = this.configuration.CurrentConfigurationProvider;\r\n            if (this.configurationProvider !== newProvider) {\r\n                this.configurationProvider = newProvider;\r\n                this.updateCustomConfigurations();\r\n                this.updateCustomBrowseConfiguration();\r\n            }\r\n        });\r\n    }\r\n    onSelectedConfigurationChanged(index) {\r\n        let params = {\r\n            currentConfiguration: index\r\n        };\r\n        this.notifyWhenReady(() => {\r\n            this.languageClient.sendNotification(ChangeSelectedSettingNotification, params);\r\n            this.model.activeConfigName.Value = this.configuration.ConfigurationNames[index];\r\n        });\r\n    }\r\n    onCompileCommandsChanged(path) {\r\n        let params = {\r\n            uri: path\r\n        };\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(ChangeCompileCommandsNotification, params));\r\n    }\r\n    isSourceFileConfigurationItem(input) {\r\n        return (input && (util.isString(input.uri) || util.isUri(input.uri)) &&\r\n            input.configuration && util.isArrayOfString(input.configuration.includePath) && util.isArrayOfString(input.configuration.defines) &&\r\n            util.isString(input.configuration.intelliSenseMode) && util.isString(input.configuration.standard) && util.isOptionalString(input.configuration.compilerPath) &&\r\n            util.isOptionalArrayOfString(input.configuration.forcedInclude));\r\n    }\r\n    sendCustomConfigurations(configs, blockingTask) {\r\n        if (!configs || !(configs instanceof Array)) {\r\n            console.warn(\"discarding invalid SourceFileConfigurationItems[]: \" + configs);\r\n            return;\r\n        }\r\n        let settings = new settings_1.CppSettings(this.RootUri);\r\n        let out = logger.getOutputChannelLogger();\r\n        if (settings.loggingLevel === \"Debug\") {\r\n            out.appendLine(\"Custom configurations received:\");\r\n        }\r\n        let sanitized = [];\r\n        configs.forEach(item => {\r\n            if (this.isSourceFileConfigurationItem(item)) {\r\n                sanitized.push({\r\n                    uri: item.uri.toString(),\r\n                    configuration: item.configuration\r\n                });\r\n                if (settings.loggingLevel === \"Debug\") {\r\n                    out.appendLine(`  uri: ${item.uri.toString()}`);\r\n                    out.appendLine(`  config: ${JSON.stringify(item.configuration, null, 2)}`);\r\n                }\r\n                if (item.configuration.includePath.some(path => path.endsWith('**'))) {\r\n                    console.warn(\"custom include paths should not use recursive includes ('**')\");\r\n                }\r\n            }\r\n            else {\r\n                console.warn(\"discarding invalid SourceFileConfigurationItem: \" + item);\r\n            }\r\n        });\r\n        if (sanitized.length === 0) {\r\n            return;\r\n        }\r\n        let params = {\r\n            configurationItems: sanitized\r\n        };\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(CustomConfigurationNotification, params), blockingTask);\r\n    }\r\n    sendCustomBrowseConfiguration(config) {\r\n        if (!config || config instanceof Array) {\r\n            console.warn(\"discarding invalid WorkspaceBrowseConfiguration: \" + config);\r\n            return Promise.resolve();\r\n        }\r\n        let sanitized = config;\r\n        if (!util.isArrayOfString(sanitized.browsePath) || !util.isOptionalString(sanitized.compilerPath) ||\r\n            !util.isOptionalString(sanitized.standard) || !util.isOptionalString(sanitized.windowsSdkVersion)) {\r\n            console.warn(\"discarding invalid WorkspaceBrowseConfiguration: \" + config);\r\n            return Promise.resolve();\r\n        }\r\n        let settings = new settings_1.CppSettings(this.RootUri);\r\n        let out = logger.getOutputChannelLogger();\r\n        if (settings.loggingLevel === \"Debug\") {\r\n            out.appendLine(`Custom browse configuration received: ${JSON.stringify(sanitized, null, 2)}`);\r\n        }\r\n        let params = {\r\n            browseConfiguration: sanitized\r\n        };\r\n        return this.notifyWhenReady(() => this.languageClient.sendNotification(CustomBrowseConfigurationNotification, params));\r\n    }\r\n    clearCustomConfigurations() {\r\n        this.notifyWhenReady(() => this.languageClient.sendNotification(ClearCustomConfigurationsNotification));\r\n    }\r\n    handleConfigurationSelectCommand() {\r\n        this.notifyWhenReady(() => {\r\n            ui.showConfigurations(this.configuration.ConfigurationNames)\r\n                .then((index) => {\r\n                if (index < 0) {\r\n                    return;\r\n                }\r\n                this.configuration.select(index);\r\n            });\r\n        });\r\n    }\r\n    handleConfigurationProviderSelectCommand() {\r\n        this.notifyWhenReady(() => {\r\n            ui.showConfigurationProviders(this.configuration.CurrentConfigurationProvider)\r\n                .then(extensionId => {\r\n                if (extensionId === undefined) {\r\n                    return;\r\n                }\r\n                this.configuration.updateCustomConfigurationProvider(extensionId)\r\n                    .then(() => {\r\n                    if (extensionId) {\r\n                        let provider = customProviders_1.getCustomConfigProviders().get(extensionId);\r\n                        this.updateCustomConfigurations(provider);\r\n                        this.updateCustomBrowseConfiguration(provider);\r\n                        telemetry.logLanguageServerEvent(\"customConfigurationProvider\", { \"providerId\": extensionId });\r\n                    }\r\n                    else {\r\n                        this.clearCustomConfigurations();\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n    handleShowParsingCommands() {\r\n        this.notifyWhenReady(() => {\r\n            ui.showParsingCommands()\r\n                .then((index) => {\r\n                if (index === 0) {\r\n                    this.pauseParsing();\r\n                }\r\n                else if (index === 1) {\r\n                    this.resumeParsing();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    handleConfigurationEditCommand() {\r\n        this.notifyWhenReady(() => this.configuration.handleConfigurationEditCommand(vscode.window.showTextDocument));\r\n    }\r\n    handleAddToIncludePathCommand(path) {\r\n        this.notifyWhenReady(() => this.configuration.addToIncludePathCommand(path));\r\n    }\r\n    onInterval() {\r\n        if (this.languageClient !== undefined && this.configuration !== undefined) {\r\n            this.languageClient.sendNotification(IntervalTimerNotification);\r\n            this.configuration.checkCppProperties();\r\n        }\r\n    }\r\n    dispose() {\r\n        let promise = (this.languageClient) ? this.languageClient.stop() : Promise.resolve();\r\n        return promise.then(() => {\r\n            this.disposables.forEach((d) => d.dispose());\r\n            this.disposables = [];\r\n            for (let key in this.model) {\r\n                if (this.model.hasOwnProperty(key)) {\r\n                    this.model[key].dispose();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction getLanguageServerFileName() {\r\n    let extensionProcessName = 'Microsoft.VSCode.CPP.Extension';\r\n    let plat = process.platform;\r\n    if (plat === 'linux') {\r\n        extensionProcessName += '.linux';\r\n    }\r\n    else if (plat === 'darwin') {\r\n        extensionProcessName += '.darwin';\r\n    }\r\n    else if (plat === 'win32') {\r\n        extensionProcessName += '.exe';\r\n    }\r\n    else {\r\n        throw \"Invalid Platform\";\r\n    }\r\n    return path.resolve(util.getExtensionFilePath(\"bin\"), extensionProcessName);\r\n}\r\nclass NullClient {\r\n    constructor() {\r\n        this.booleanEvent = new vscode.EventEmitter();\r\n        this.stringEvent = new vscode.EventEmitter();\r\n        this.RootPath = \"/\";\r\n        this.RootUri = vscode.Uri.file(\"/\");\r\n        this.Name = \"(empty)\";\r\n        this.TrackedDocuments = new Set();\r\n    }\r\n    get TagParsingChanged() { return this.booleanEvent.event; }\r\n    get IntelliSenseParsingChanged() { return this.booleanEvent.event; }\r\n    get NavigationLocationChanged() { return this.stringEvent.event; }\r\n    get TagParserStatusChanged() { return this.stringEvent.event; }\r\n    get ActiveConfigChanged() { return this.stringEvent.event; }\r\n    onDidChangeSettings() { return {}; }\r\n    onDidChangeVisibleTextEditors(editors) { }\r\n    onRegisterCustomConfigurationProvider(provider) { return Promise.resolve(); }\r\n    updateCustomConfigurations(requestingProvider) { return Promise.resolve(); }\r\n    updateCustomBrowseConfiguration(requestingProvider) { return Promise.resolve(); }\r\n    provideCustomConfiguration(document) { return Promise.resolve(); }\r\n    getCurrentConfigName() { return Promise.resolve(\"\"); }\r\n    getCompilerPath() { return Promise.resolve(\"\"); }\r\n    getKnownCompilers() { return Promise.resolve([]); }\r\n    takeOwnership(document) { }\r\n    queueTask(task) { return task(); }\r\n    requestWhenReady(request) { return; }\r\n    notifyWhenReady(notify) { }\r\n    requestGoToDeclaration() { return Promise.resolve(); }\r\n    requestSwitchHeaderSource(rootPath, fileName) { return Promise.resolve(\"\"); }\r\n    requestNavigationList(document) { return Promise.resolve(\"\"); }\r\n    activeDocumentChanged(document) { }\r\n    activate() { }\r\n    selectionChanged(selection) { }\r\n    resetDatabase() { }\r\n    deactivate() { }\r\n    pauseParsing() { }\r\n    resumeParsing() { }\r\n    handleConfigurationSelectCommand() { }\r\n    handleConfigurationProviderSelectCommand() { }\r\n    handleShowParsingCommands() { }\r\n    handleConfigurationEditCommand() { }\r\n    handleAddToIncludePathCommand(path) { }\r\n    onInterval() { }\r\n    dispose() {\r\n        this.booleanEvent.dispose();\r\n        this.stringEvent.dispose();\r\n        return Promise.resolve();\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvY2xpZW50LnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9MYW5ndWFnZVNlcnZlci9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEgPSByZXF1aXJlKFwidnNjb2RlLWxhbmd1YWdlY2xpZW50XCIpO1xyXG5jb25zdCB2c2NvZGVfY3BwdG9vbHNfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtY3BwdG9vbHNcIik7XHJcbmNvbnN0IHRlc3RBcGlfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtY3BwdG9vbHMvb3V0L3Rlc3RBcGlcIik7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBjb25maWdzID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbnNcIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY29uc3QgdGVsZW1ldHJ5ID0gcmVxdWlyZShcIi4uL3RlbGVtZXRyeVwiKTtcclxuY29uc3QgcGVyc2lzdGVudFN0YXRlXzEgPSByZXF1aXJlKFwiLi9wZXJzaXN0ZW50U3RhdGVcIik7XHJcbmNvbnN0IHVpXzEgPSByZXF1aXJlKFwiLi91aVwiKTtcclxuY29uc3QgcHJvdG9jb2xGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sRmlsdGVyXCIpO1xyXG5jb25zdCBkYXRhQmluZGluZ18xID0gcmVxdWlyZShcIi4vZGF0YUJpbmRpbmdcIik7XHJcbmNvbnN0IG1pbmltYXRjaCA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XHJcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmNvbnN0IGV4dGVuc2lvbl8xID0gcmVxdWlyZShcIi4vZXh0ZW5zaW9uXCIpO1xyXG5jb25zdCB2c2NvZGVfMSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHNldHRpbmdzVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NUcmFja2VyXCIpO1xyXG5jb25zdCB0ZXN0SG9va18xID0gcmVxdWlyZShcIi4uL3Rlc3RIb29rXCIpO1xyXG5jb25zdCBjdXN0b21Qcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi9MYW5ndWFnZVNlcnZlci9jdXN0b21Qcm92aWRlcnNcIik7XHJcbmNvbnN0IGFiVGVzdGluZ18xID0gcmVxdWlyZShcIi4uL2FiVGVzdGluZ1wiKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5sZXQgdWk7XHJcbmNvbnN0IGNvbmZpZ1Byb3ZpZGVyVGltZW91dCA9IDIwMDA7XHJcbmNvbnN0IE5hdmlnYXRpb25MaXN0UmVxdWVzdCA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5SZXF1ZXN0VHlwZSgnY3BwdG9vbHMvcmVxdWVzdE5hdmlnYXRpb25MaXN0Jyk7XHJcbmNvbnN0IEdvVG9EZWNsYXJhdGlvblJlcXVlc3QgPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuUmVxdWVzdFR5cGUoJ2NwcHRvb2xzL2dvVG9EZWNsYXJhdGlvbicpO1xyXG5jb25zdCBRdWVyeUNvbXBpbGVyRGVmYXVsdHNSZXF1ZXN0ID0gbmV3IHZzY29kZV9sYW5ndWFnZWNsaWVudF8xLlJlcXVlc3RUeXBlKCdjcHB0b29scy9xdWVyeUNvbXBpbGVyRGVmYXVsdHMnKTtcclxuY29uc3QgU3dpdGNoSGVhZGVyU291cmNlUmVxdWVzdCA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5SZXF1ZXN0VHlwZSgnY3BwdG9vbHMvZGlkU3dpdGNoSGVhZGVyU291cmNlJyk7XHJcbmNvbnN0IERpZE9wZW5Ob3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgndGV4dERvY3VtZW50L2RpZE9wZW4nKTtcclxuY29uc3QgRmlsZUNyZWF0ZWROb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvZmlsZUNyZWF0ZWQnKTtcclxuY29uc3QgRmlsZURlbGV0ZWROb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvZmlsZURlbGV0ZWQnKTtcclxuY29uc3QgUmVzZXREYXRhYmFzZU5vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9yZXNldERhdGFiYXNlJyk7XHJcbmNvbnN0IFBhdXNlUGFyc2luZ05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9wYXVzZVBhcnNpbmcnKTtcclxuY29uc3QgUmVzdW1lUGFyc2luZ05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9yZXN1bWVQYXJzaW5nJyk7XHJcbmNvbnN0IEFjdGl2ZURvY3VtZW50Q2hhbmdlTm90aWZpY2F0aW9uID0gbmV3IHZzY29kZV9sYW5ndWFnZWNsaWVudF8xLk5vdGlmaWNhdGlvblR5cGUoJ2NwcHRvb2xzL2FjdGl2ZURvY3VtZW50Q2hhbmdlJyk7XHJcbmNvbnN0IFRleHRFZGl0b3JTZWxlY3Rpb25DaGFuZ2VOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvdGV4dEVkaXRvclNlbGVjdGlvbkNoYW5nZScpO1xyXG5jb25zdCBDaGFuZ2VGb2xkZXJTZXR0aW5nc05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9kaWRDaGFuZ2VGb2xkZXJTZXR0aW5ncycpO1xyXG5jb25zdCBDaGFuZ2VDb21waWxlQ29tbWFuZHNOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvZGlkQ2hhbmdlQ29tcGlsZUNvbW1hbmRzJyk7XHJcbmNvbnN0IENoYW5nZVNlbGVjdGVkU2V0dGluZ05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9kaWRDaGFuZ2VTZWxlY3RlZFNldHRpbmcnKTtcclxuY29uc3QgSW50ZXJ2YWxUaW1lck5vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9vbkludGVydmFsVGltZXInKTtcclxuY29uc3QgQ3VzdG9tQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9kaWRDaGFuZ2VDdXN0b21Db25maWd1cmF0aW9uJyk7XHJcbmNvbnN0IEN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvZGlkQ2hhbmdlQ3VzdG9tQnJvd3NlQ29uZmlndXJhdGlvbicpO1xyXG5jb25zdCBDbGVhckN1c3RvbUNvbmZpZ3VyYXRpb25zTm90aWZpY2F0aW9uID0gbmV3IHZzY29kZV9sYW5ndWFnZWNsaWVudF8xLk5vdGlmaWNhdGlvblR5cGUoJ2NwcHRvb2xzL2NsZWFyQ3VzdG9tQ29uZmlndXJhdGlvbnMnKTtcclxuY29uc3QgUmVsb2FkV2luZG93Tm90aWZpY2F0aW9uID0gbmV3IHZzY29kZV9sYW5ndWFnZWNsaWVudF8xLk5vdGlmaWNhdGlvblR5cGUoJ2NwcHRvb2xzL3JlbG9hZFdpbmRvdycpO1xyXG5jb25zdCBMb2dUZWxlbWV0cnlOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvbG9nVGVsZW1ldHJ5Jyk7XHJcbmNvbnN0IFJlcG9ydE5hdmlnYXRpb25Ob3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvcmVwb3J0TmF2aWdhdGlvbicpO1xyXG5jb25zdCBSZXBvcnRUYWdQYXJzZVN0YXR1c05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9yZXBvcnRUYWdQYXJzZVN0YXR1cycpO1xyXG5jb25zdCBSZXBvcnRTdGF0dXNOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvcmVwb3J0U3RhdHVzJyk7XHJcbmNvbnN0IERlYnVnUHJvdG9jb2xOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvZGVidWdQcm90b2NvbCcpO1xyXG5jb25zdCBEZWJ1Z0xvZ05vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9kZWJ1Z0xvZycpO1xyXG5jb25zdCBJbmFjdGl2ZVJlZ2lvbk5vdGlmaWNhdGlvbiA9IG5ldyB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5Ob3RpZmljYXRpb25UeXBlKCdjcHB0b29scy9pbmFjdGl2ZVJlZ2lvbnMnKTtcclxuY29uc3QgQ29tcGlsZUNvbW1hbmRzUGF0aHNOb3RpZmljYXRpb24gPSBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTm90aWZpY2F0aW9uVHlwZSgnY3BwdG9vbHMvY29tcGlsZUNvbW1hbmRzUGF0aHMnKTtcclxuY29uc3QgVXBkYXRlQ2xhbmdGb3JtYXRQYXRoTm90aWZpY2F0aW9uID0gbmV3IHZzY29kZV9sYW5ndWFnZWNsaWVudF8xLk5vdGlmaWNhdGlvblR5cGUoJ2NwcHRvb2xzL3VwZGF0ZUNsYW5nRm9ybWF0UGF0aCcpO1xyXG5jbGFzcyBCbG9ja2luZ1Rhc2sge1xyXG4gICAgY29uc3RydWN0b3IodGFzaywgZGVwZW5kZW5jeSkge1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB5aWVsZCB0YXNrKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5O1xyXG4gICAgfVxyXG4gICAgZ2V0IERvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSAmJiAoIXRoaXMuZGVwZW5kZW5jeSB8fCB0aGlzLmRlcGVuZGVuY3kuRG9uZSk7XHJcbiAgICB9XHJcbiAgICB0aGVuKG9uU3VjY2VlZGVkLCBvblJlamVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS50aGVuKG9uU3VjY2VlZGVkLCBvblJlamVjdGVkKTtcclxuICAgIH1cclxufVxyXG5sZXQgZmFpbHVyZU1lc3NhZ2VTaG93biA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoYWxsQ2xpZW50cywgd29ya3NwYWNlRm9sZGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IERlZmF1bHRDbGllbnQoYWxsQ2xpZW50cywgd29ya3NwYWNlRm9sZGVyKTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudDtcclxuZnVuY3Rpb24gY3JlYXRlTnVsbENsaWVudCgpIHtcclxuICAgIHJldHVybiBuZXcgTnVsbENsaWVudCgpO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlTnVsbENsaWVudCA9IGNyZWF0ZU51bGxDbGllbnQ7XHJcbmNsYXNzIERlZmF1bHRDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoYWxsQ2xpZW50cywgd29ya3NwYWNlRm9sZGVyKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudHJhY2tlZERvY3VtZW50cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmNyYXNoVGltZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmlzU3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmluYWN0aXZlUmVnaW9uc0RlY29yYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSB7XHJcbiAgICAgICAgICAgIGlzVGFnUGFyc2luZzogbmV3IGRhdGFCaW5kaW5nXzEuRGF0YUJpbmRpbmcoZmFsc2UpLFxyXG4gICAgICAgICAgICBpc1VwZGF0aW5nSW50ZWxsaVNlbnNlOiBuZXcgZGF0YUJpbmRpbmdfMS5EYXRhQmluZGluZyhmYWxzZSksXHJcbiAgICAgICAgICAgIG5hdmlnYXRpb25Mb2NhdGlvbjogbmV3IGRhdGFCaW5kaW5nXzEuRGF0YUJpbmRpbmcoXCJcIiksXHJcbiAgICAgICAgICAgIHRhZ1BhcnNlclN0YXR1czogbmV3IGRhdGFCaW5kaW5nXzEuRGF0YUJpbmRpbmcoXCJcIiksXHJcbiAgICAgICAgICAgIGFjdGl2ZUNvbmZpZ05hbWU6IG5ldyBkYXRhQmluZGluZ18xLkRhdGFCaW5kaW5nKFwiXCIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY3JlYXRlIExhbmd1YWdlQ2xpZW50Jyk7XHJcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZUNsaWVudCA9IHRoaXMuY3JlYXRlTGFuZ3VhZ2VDbGllbnQoYWxsQ2xpZW50cywgd29ya3NwYWNlRm9sZGVyKTtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VDbGllbnQucmVnaXN0ZXJQcm9wb3NlZEZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgIGxhbmd1YWdlQ2xpZW50LnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHV0aWwuc2V0UHJvZ3Jlc3ModXRpbC5nZXRQcm9ncmVzc0V4ZWN1dGFibGVTdGFydGVkKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RGb2xkZXIgPSB3b3Jrc3BhY2VGb2xkZXI7XHJcbiAgICAgICAgICAgIHVpID0gdWlfMS5nZXRVSSgpO1xyXG4gICAgICAgICAgICB1aS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlQmxvY2tpbmdUYXNrKCgpID0+IGxhbmd1YWdlQ2xpZW50Lm9uUmVhZHkoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjbGllbnQgcmVhZHknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG5ldyBjb25maWdzLkNwcFByb3BlcnRpZXModGhpcy5Sb290VXJpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5Db25maWd1cmF0aW9uc0NoYW5nZWQoKGUpID0+IHRoaXMub25Db25maWd1cmF0aW9uc0NoYW5nZWQoZSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLlNlbGVjdGlvbkNoYW5nZWQoKGUpID0+IHRoaXMub25TZWxlY3RlZENvbmZpZ3VyYXRpb25DaGFuZ2VkKGUpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5Db21waWxlQ29tbWFuZHNDaGFuZ2VkKChlKSA9PiB0aGlzLm9uQ29tcGlsZUNvbW1hbmRzQ2hhbmdlZChlKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2godGhpcy5jb25maWd1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGxhbmd1YWdlQ2xpZW50LnNlbmRSZXF1ZXN0KFF1ZXJ5Q29tcGlsZXJEZWZhdWx0c1JlcXVlc3QsIHt9KS50aGVuKChjb21waWxlckRlZmF1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLkNvbXBpbGVyRGVmYXVsdHMgPSBjb21waWxlckRlZmF1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb21waWxlciBkZWZhdWx0cyByZWNlaXZlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbl8xLnJlZ2lzdGVyQ29tbWFuZHMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudCA9IGxhbmd1YWdlQ2xpZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1RyYWNrZXIgPSBzZXR0aW5nc1RyYWNrZXJfMS5nZXRUcmFja2VyKHRoaXMuUm9vdFVyaSk7XHJcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcIk5vbkRlZmF1bHRJbml0aWFsQ3BwU2V0dGluZ3NcIiwgdGhpcy5zZXR0aW5nc1RyYWNrZXIuZ2V0VXNlck1vZGlmaWVkU2V0dGluZ3MoKSk7XHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlTWVzc2FnZVNob3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyTm90aWZpY2F0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckZpbGVXYXRjaGVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVnaXN0ZXJlZCBzdHVmZicpO1xyXG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzU3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZhaWx1cmVNZXNzYWdlU2hvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlTWVzc2FnZVNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UoXCJVbmFibGUgdG8gc3RhcnQgdGhlIEMvQysrIGxhbmd1YWdlIHNlcnZlci4gSW50ZWxsaVNlbnNlIGZlYXR1cmVzIHdpbGwgYmUgZGlzYWJsZWQuIEVycm9yOiBcIiArIFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFmYWlsdXJlTWVzc2FnZVNob3duKSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlTWVzc2FnZVNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBhZGRpdGlvbmFsSW5mbztcclxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJFUEVSTVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEluZm8gPSBgRVBFUk06IENoZWNrIHBlcm1pc3Npb25zIGZvciAnJHtnZXRMYW5ndWFnZVNlcnZlckZpbGVOYW1lKCl9J2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsSW5mbyA9IFN0cmluZyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93RXJyb3JNZXNzYWdlKFwiVW5hYmxlIHRvIHN0YXJ0IHRoZSBDL0MrKyBsYW5ndWFnZSBzZXJ2ZXIuIEludGVsbGlTZW5zZSBmZWF0dXJlcyB3aWxsIGJlIGRpc2FibGVkLiBFcnJvcjogXCIgKyBhZGRpdGlvbmFsSW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgVGFnUGFyc2luZ0NoYW5nZWQoKSB7IHJldHVybiB0aGlzLm1vZGVsLmlzVGFnUGFyc2luZy5WYWx1ZUNoYW5nZWQ7IH1cclxuICAgIGdldCBJbnRlbGxpU2Vuc2VQYXJzaW5nQ2hhbmdlZCgpIHsgcmV0dXJuIHRoaXMubW9kZWwuaXNVcGRhdGluZ0ludGVsbGlTZW5zZS5WYWx1ZUNoYW5nZWQ7IH1cclxuICAgIGdldCBOYXZpZ2F0aW9uTG9jYXRpb25DaGFuZ2VkKCkgeyByZXR1cm4gdGhpcy5tb2RlbC5uYXZpZ2F0aW9uTG9jYXRpb24uVmFsdWVDaGFuZ2VkOyB9XHJcbiAgICBnZXQgVGFnUGFyc2VyU3RhdHVzQ2hhbmdlZCgpIHsgcmV0dXJuIHRoaXMubW9kZWwudGFnUGFyc2VyU3RhdHVzLlZhbHVlQ2hhbmdlZDsgfVxyXG4gICAgZ2V0IEFjdGl2ZUNvbmZpZ0NoYW5nZWQoKSB7IHJldHVybiB0aGlzLm1vZGVsLmFjdGl2ZUNvbmZpZ05hbWUuVmFsdWVDaGFuZ2VkOyB9XHJcbiAgICBnZXQgUm9vdFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RGb2xkZXIpID8gdGhpcy5yb290Rm9sZGVyLnVyaS5mc1BhdGggOiBcIlwiO1xyXG4gICAgfVxyXG4gICAgZ2V0IFJvb3RVcmkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RGb2xkZXIpID8gdGhpcy5yb290Rm9sZGVyLnVyaSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXROYW1lKHRoaXMucm9vdEZvbGRlcik7XHJcbiAgICB9XHJcbiAgICBnZXQgVHJhY2tlZERvY3VtZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFja2VkRG9jdW1lbnRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IEFkZGl0aW9uYWxFbnZpcm9ubWVudCgpIHtcclxuICAgICAgICByZXR1cm4geyB3b3Jrc3BhY2VGb2xkZXJCYXNlbmFtZTogdGhpcy5OYW1lIH07XHJcbiAgICB9XHJcbiAgICBnZXROYW1lKHdvcmtzcGFjZUZvbGRlcikge1xyXG4gICAgICAgIHJldHVybiB3b3Jrc3BhY2VGb2xkZXIgPyB3b3Jrc3BhY2VGb2xkZXIubmFtZSA6IFwidW50aXRsZWRcIjtcclxuICAgIH1cclxuICAgIGNyZWF0ZUxhbmd1YWdlQ2xpZW50KGFsbENsaWVudHMsIHdvcmtzcGFjZUZvbGRlcikge1xyXG4gICAgICAgIGxldCBzZXJ2ZXJNb2R1bGUgPSBnZXRMYW5ndWFnZVNlcnZlckZpbGVOYW1lKCk7XHJcbiAgICAgICAgbGV0IGV4ZUV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc2VydmVyTW9kdWxlKTtcclxuICAgICAgICBpZiAoIWV4ZUV4aXN0cykge1xyXG4gICAgICAgICAgICB0aHJvdyBTdHJpbmcoJ01pc3NpbmcgYmluYXJ5IGF0ICcgKyBzZXJ2ZXJNb2R1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2VydmVyTmFtZSA9IHRoaXMuZ2V0TmFtZSh3b3Jrc3BhY2VGb2xkZXIpO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBydW46IHsgY29tbWFuZDogc2VydmVyTW9kdWxlIH0sXHJcbiAgICAgICAgICAgIGRlYnVnOiB7IGNvbW1hbmQ6IHNlcnZlck1vZHVsZSwgYXJnczogW3NlcnZlck5hbWVdIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHdvcmtzcGFjZUZvbGRlciA/IHdvcmtzcGFjZUZvbGRlci51cmkgOiBudWxsKTtcclxuICAgICAgICBsZXQgb3RoZXIgPSBuZXcgc2V0dGluZ3NfMS5PdGhlclNldHRpbmdzKHdvcmtzcGFjZUZvbGRlciA/IHdvcmtzcGFjZUZvbGRlci51cmkgOiBudWxsKTtcclxuICAgICAgICBsZXQgc3RvcmFnZVBhdGggPSB1dGlsLmV4dGVuc2lvbkNvbnRleHQuc3RvcmFnZVBhdGg7XHJcbiAgICAgICAgaWYgKHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycyAmJiB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBzdG9yYWdlUGF0aCA9IHBhdGguam9pbihzdG9yYWdlUGF0aCwgc2VydmVyTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhYlRlc3RTZXR0aW5ncyA9IGFiVGVzdGluZ18xLmdldEFCVGVzdFNldHRpbmdzKCk7XHJcbiAgICAgICAgbGV0IGludGVsbGlTZW5zZUNhY2hlRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gXCJkYXJ3aW5cIikge1xyXG4gICAgICAgICAgICBjb25zdCByZWxlYXNlUGFydHMgPSBvcy5yZWxlYXNlKCkuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICBpZiAocmVsZWFzZVBhcnRzLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlbGxpU2Vuc2VDYWNoZURpc2FibGVkID0gcGFyc2VJbnQocmVsZWFzZVBhcnRzWzBdKSA8IDE3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjbGllbnRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkb2N1bWVudFNlbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7IHNjaGVtZTogJ2ZpbGUnLCBsYW5ndWFnZTogJ2NwcCcgfSxcclxuICAgICAgICAgICAgICAgIHsgc2NoZW1lOiAnZmlsZScsIGxhbmd1YWdlOiAnYycgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBzeW5jaHJvbml6ZToge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvblNlY3Rpb246IFsnQ19DcHAnLCAnZmlsZXMnLCAnc2VhcmNoJ11cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd29ya3NwYWNlRm9sZGVyOiB3b3Jrc3BhY2VGb2xkZXIsXHJcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgY2xhbmdfZm9ybWF0X3BhdGg6IHV0aWwucmVzb2x2ZVZhcmlhYmxlcyhzZXR0aW5ncy5jbGFuZ0Zvcm1hdFBhdGgsIHRoaXMuQWRkaXRpb25hbEVudmlyb25tZW50KSxcclxuICAgICAgICAgICAgICAgIGNsYW5nX2Zvcm1hdF9zdHlsZTogc2V0dGluZ3MuY2xhbmdGb3JtYXRTdHlsZSxcclxuICAgICAgICAgICAgICAgIGNsYW5nX2Zvcm1hdF9mYWxsYmFja1N0eWxlOiBzZXR0aW5ncy5jbGFuZ0Zvcm1hdEZhbGxiYWNrU3R5bGUsXHJcbiAgICAgICAgICAgICAgICBjbGFuZ19mb3JtYXRfc29ydEluY2x1ZGVzOiBzZXR0aW5ncy5jbGFuZ0Zvcm1hdFNvcnRJbmNsdWRlcyxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHNldHRpbmdzLmZvcm1hdHRpbmcsXHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb25fcGF0aDogdXRpbC5leHRlbnNpb25Db250ZXh0LmV4dGVuc2lvblBhdGgsXHJcbiAgICAgICAgICAgICAgICBleGNsdWRlX2ZpbGVzOiBvdGhlci5maWxlc0V4Y2x1ZGUsXHJcbiAgICAgICAgICAgICAgICBleGNsdWRlX3NlYXJjaDogb3RoZXIuc2VhcmNoRXhjbHVkZSxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VfcGF0aDogc3RvcmFnZVBhdGgsXHJcbiAgICAgICAgICAgICAgICB0YWJfc2l6ZTogb3RoZXIuZWRpdG9yVGFiU2l6ZSxcclxuICAgICAgICAgICAgICAgIGludGVsbGlTZW5zZUVuZ2luZTogc2V0dGluZ3MuaW50ZWxsaVNlbnNlRW5naW5lLFxyXG4gICAgICAgICAgICAgICAgaW50ZWxsaVNlbnNlRW5naW5lRmFsbGJhY2s6IHNldHRpbmdzLmludGVsbGlTZW5zZUVuZ2luZUZhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgaW50ZWxsaVNlbnNlQ2FjaGVEaXNhYmxlZDogaW50ZWxsaVNlbnNlQ2FjaGVEaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgIGludGVsbGlTZW5zZUNhY2hlUGF0aDogc2V0dGluZ3MuaW50ZWxsaVNlbnNlQ2FjaGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgaW50ZWxsaVNlbnNlQ2FjaGVTaXplOiBzZXR0aW5ncy5pbnRlbGxpU2Vuc2VDYWNoZVNpemUsXHJcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IHNldHRpbmdzLmF1dG9Db21wbGV0ZSxcclxuICAgICAgICAgICAgICAgIGVycm9yU3F1aWdnbGVzOiBzZXR0aW5ncy5lcnJvclNxdWlnZ2xlcyxcclxuICAgICAgICAgICAgICAgIGRpbUluYWN0aXZlUmVnaW9uczogc2V0dGluZ3MuZGltSW5hY3RpdmVSZWdpb25zLFxyXG4gICAgICAgICAgICAgICAgc3VnZ2VzdFNuaXBwZXRzOiBzZXR0aW5ncy5zdWdnZXN0U25pcHBldHMsXHJcbiAgICAgICAgICAgICAgICBsb2dnaW5nTGV2ZWw6IHNldHRpbmdzLmxvZ2dpbmdMZXZlbCxcclxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZVBhcnNpbmdQcmlvcml0eTogc2V0dGluZ3Mud29ya3NwYWNlUGFyc2luZ1ByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlU3ltYm9sczogc2V0dGluZ3Mud29ya3NwYWNlU3ltYm9scyxcclxuICAgICAgICAgICAgICAgIGV4Y2x1c2lvblBvbGljeTogc2V0dGluZ3MuZXhjbHVzaW9uUG9saWN5LFxyXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkUGF0aFNlcGFyYXRvcjogc2V0dGluZ3MucHJlZmVycmVkUGF0aFNlcGFyYXRvcixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBzeXN0ZW1JbmNsdWRlUGF0aDogc2V0dGluZ3MuZGVmYXVsdFN5c3RlbUluY2x1ZGVQYXRoXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdmNwa2dfcm9vdDogdXRpbC5nZXRWY3BrZ1Jvb3QoKSxcclxuICAgICAgICAgICAgICAgIGdvdG9EZWZJbnRlbGxpU2Vuc2U6IGFiVGVzdFNldHRpbmdzLlVzZUdvVG9EZWZJbnRlbGxpU2Vuc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWlkZGxld2FyZTogcHJvdG9jb2xGaWx0ZXJfMS5jcmVhdGVQcm90b2NvbEZpbHRlcih0aGlzLCBhbGxDbGllbnRzKSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogKCkgPT4gdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuRXJyb3JBY3Rpb24uQ29udGludWUsXHJcbiAgICAgICAgICAgICAgICBjbG9zZWQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyYXNoVGltZXMucHVzaChEYXRlLm5vdygpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jcmFzaFRpbWVzLmxlbmd0aCA8IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0NsaWVudCA9IGFsbENsaWVudHMucmVwbGFjZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2xpZW50LmNyYXNoVGltZXMgPSB0aGlzLmNyYXNoVGltZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxhcHNlZCA9IHRoaXMuY3Jhc2hUaW1lc1t0aGlzLmNyYXNoVGltZXMubGVuZ3RoIC0gMV0gLSB0aGlzLmNyYXNoVGltZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkIDw9IDMgKiA2MCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMgJiYgdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UoYFRoZSBsYW5ndWFnZSBzZXJ2ZXIgZm9yICcke3NlcnZlck5hbWV9JyBjcmFzaGVkIDUgdGltZXMgaW4gdGhlIGxhc3QgMyBtaW51dGVzLiBJdCB3aWxsIG5vdCBiZSByZXN0YXJ0ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UoYFRoZSBsYW5ndWFnZSBzZXJ2ZXIgY3Jhc2hlZCA1IHRpbWVzIGluIHRoZSBsYXN0IDMgbWludXRlcy4gSXQgd2lsbCBub3QgYmUgcmVzdGFydGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ2xpZW50cy5yZXBsYWNlKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jhc2hUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0NsaWVudCA9IGFsbENsaWVudHMucmVwbGFjZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NsaWVudC5jcmFzaFRpbWVzID0gdGhpcy5jcmFzaFRpbWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMS5DbG9zZUFjdGlvbi5Eb05vdFJlc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgdnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuTGFuZ3VhZ2VDbGllbnQoYGNwcHRvb2xzOiAke3NlcnZlck5hbWV9YCwgc2VydmVyT3B0aW9ucywgY2xpZW50T3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBvbkRpZENoYW5nZVNldHRpbmdzKCkge1xyXG4gICAgICAgIGxldCBjaGFuZ2VkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzVHJhY2tlci5nZXRDaGFuZ2VkU2V0dGluZ3MoKTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlZFNldHRpbmdzKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkU2V0dGluZ3NbXCJjb21tZW50Q29udGludWF0aW9uUGF0dGVybnNcIl0pIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbl8xLnVwZGF0ZUxhbmd1YWdlQ29uZmlndXJhdGlvbnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZFNldHRpbmdzW1wiY2xhbmdfZm9ybWF0X3BhdGhcIl0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHRoaXMuUm9vdFVyaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oVXBkYXRlQ2xhbmdGb3JtYXRQYXRoTm90aWZpY2F0aW9uLCB1dGlsLnJlc29sdmVWYXJpYWJsZXMoc2V0dGluZ3MuY2xhbmdGb3JtYXRQYXRoLCB0aGlzLkFkZGl0aW9uYWxFbnZpcm9ubWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5vbkRpZENoYW5nZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KFwiQ3BwU2V0dGluZ3NDaGFuZ2VcIiwgY2hhbmdlZFNldHRpbmdzLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRTZXR0aW5ncztcclxuICAgIH1cclxuICAgIG9uRGlkQ2hhbmdlVmlzaWJsZVRleHRFZGl0b3JzKGVkaXRvcnMpIHtcclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyh0aGlzLlJvb3RVcmkpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaW1JbmFjdGl2ZVJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBlZGl0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVQYWlyID0gdGhpcy5pbmFjdGl2ZVJlZ2lvbnNEZWNvcmF0aW9ucy5nZXQoZS5kb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVQYWlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zZXREZWNvcmF0aW9ucyh2YWx1ZVBhaXIuZGVjb3JhdGlvbiwgdmFsdWVQYWlyLnJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblJlZ2lzdGVyQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgbGV0IG9uUmVnaXN0ZXJlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnZlcnNpb24gPj0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52Mikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZVBhcnNpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLlJvb3RQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkUHJvdmlkZXIgPSB0aGlzLmNvbmZpZ3VyYXRpb24uQ3VycmVudENvbmZpZ3VyYXRpb25Qcm92aWRlcjtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXNrID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRGb2xkZXJTdGF0ZShcIkNsaWVudC5yZWdpc3RlclByb3ZpZGVyXCIsIHRydWUsIHRoaXMuUm9vdFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzay5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpLnNob3dDb25maWd1cmVDdXN0b21Qcm92aWRlck1lc3NhZ2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVyU3RyID0gKHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycyAmJiB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMubGVuZ3RoID4gMSkgPyBcInRoZSAnXCIgKyB0aGlzLk5hbWUgKyBcIidcIiA6IFwidGhpc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7cHJvdmlkZXIubmFtZX0gd291bGQgbGlrZSB0byBjb25maWd1cmUgSW50ZWxsaVNlbnNlIGZvciAke2ZvbGRlclN0cn0gZm9sZGVyLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ID0gXCJBbGxvd1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb250QWxsb3cgPSBcIkRvbid0IEFsbG93XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFza0xhdGVyID0gXCJBc2sgTWUgTGF0ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShtZXNzYWdlLCBhbGxvdywgZG9udEFsbG93LCBhc2tMYXRlcikudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGFsbG93OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi51cGRhdGVDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXIocHJvdmlkZXIuZXh0ZW5zaW9uSWQpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWdpc3RlcmVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcImN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlclwiLCB7IFwicHJvdmlkZXJJZFwiOiBwcm92aWRlci5leHRlbnNpb25JZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzay5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBkb250QWxsb3c6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNrLlZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4gYXNrLlZhbHVlID0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkUHJvdmlkZXIgPT09IHByb3ZpZGVyLmV4dGVuc2lvbklkKSB7XHJcbiAgICAgICAgICAgICAgICBvblJlZ2lzdGVyZWQoKTtcclxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KFwiY3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyXCIsIHsgXCJwcm92aWRlcklkXCI6IHByb3ZpZGVyLmV4dGVuc2lvbklkIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkUHJvdmlkZXIgPT09IHByb3ZpZGVyLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG9uUmVnaXN0ZXJlZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnVwZGF0ZUN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcihwcm92aWRlci5leHRlbnNpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUN1c3RvbUNvbmZpZ3VyYXRpb25zKHJlcXVlc3RpbmdQcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWd1cmF0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY3VycmVudFByb3ZpZGVyID0gY3VzdG9tUHJvdmlkZXJzXzEuZ2V0Q3VzdG9tQ29uZmlnUHJvdmlkZXJzKCkuZ2V0KHRoaXMuY29uZmlndXJhdGlvblByb3ZpZGVyKTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvdmlkZXIgfHwgKHJlcXVlc3RpbmdQcm92aWRlciAmJiByZXF1ZXN0aW5nUHJvdmlkZXIuZXh0ZW5zaW9uSWQgIT09IGN1cnJlbnRQcm92aWRlci5leHRlbnNpb25JZCkgfHwgdGhpcy50cmFja2VkRG9jdW1lbnRzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdG9rZW5Tb3VyY2UgPSBuZXcgdnNjb2RlXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcclxuICAgICAgICAgICAgbGV0IGRvY3VtZW50VXJpcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNrZWREb2N1bWVudHMuZm9yRWFjaChkb2N1bWVudCA9PiBkb2N1bWVudFVyaXMucHVzaChkb2N1bWVudC51cmkpKTtcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFByb3ZpZGVyLnByb3ZpZGVDb25maWd1cmF0aW9ucyhkb2N1bWVudFVyaXMsIHRva2VuU291cmNlLnRva2VuKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZVRhc2tXaXRoVGltZW91dCh0YXNrLCBjb25maWdQcm92aWRlclRpbWVvdXQsIHRva2VuU291cmNlKS50aGVuKGNvbmZpZ3MgPT4gdGhpcy5zZW5kQ3VzdG9tQ29uZmlndXJhdGlvbnMoY29uZmlncyksICgpID0+IHsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uKHJlcXVlc3RpbmdQcm92aWRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWd1cmF0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInVwZGF0ZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb25cIik7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKS5nZXQodGhpcy5jb25maWd1cmF0aW9uUHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm92aWRlciB8fCAocmVxdWVzdGluZ1Byb3ZpZGVyICYmIHJlcXVlc3RpbmdQcm92aWRlci5leHRlbnNpb25JZCAhPT0gY3VycmVudFByb3ZpZGVyLmV4dGVuc2lvbklkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB0b2tlblNvdXJjZSA9IG5ldyB2c2NvZGVfMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5aWVsZCBjdXJyZW50UHJvdmlkZXIuY2FuUHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24odG9rZW5Tb3VyY2UudG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm92aWRlci5wcm92aWRlQnJvd3NlQ29uZmlndXJhdGlvbih0b2tlblNvdXJjZS50b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3ZpZGVyLnZlcnNpb24gPj0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52Mikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImZhaWxlZCB0byBwcm92aWRlIGJyb3dzZSBjb25maWd1cmF0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZVRhc2tXaXRoVGltZW91dCh0YXNrLCBjb25maWdQcm92aWRlclRpbWVvdXQsIHRva2VuU291cmNlKS50aGVuKChjb25maWcpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZEN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24oY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lUGFyc2luZygpO1xyXG4gICAgICAgICAgICB9KSwgKCkgPT4geyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHByb3ZpZGVDdXN0b21Db25maWd1cmF0aW9uKGRvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IHRva2VuU291cmNlID0gbmV3IHZzY29kZV8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XHJcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKTtcclxuICAgICAgICAgICAgaWYgKHByb3ZpZGVycy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcm92aWRlQ3VzdG9tQ29uZmlndXJhdGlvblwiKTtcclxuICAgICAgICAgICAgbGV0IHByb3ZpZGVySWQgPSB5aWVsZCB0aGlzLmdldEN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcklkKCk7XHJcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwcm92aWRlck5hbWUgPSBwcm92aWRlcklkO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnTmFtZSA9IHlpZWxkIHRoaXMuZ2V0Q3VycmVudENvbmZpZ05hbWUoKTtcclxuICAgICAgICAgICAgY29uc3Qgbm90UmVhZHlNZXNzYWdlID0gYCR7cHJvdmlkZXJOYW1lfSBpcyBub3QgcmVhZHlgO1xyXG4gICAgICAgICAgICBsZXQgcHJvdmlkZUNvbmZpZ3VyYXRpb25Bc3luYyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb3ZpZGVyID0gcHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlci5pc1JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qobm90UmVhZHlNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck5hbWUgPSBwcm92aWRlci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWllbGQgcHJvdmlkZXIuY2FuUHJvdmlkZUNvbmZpZ3VyYXRpb24oZG9jdW1lbnQudXJpLCB0b2tlblNvdXJjZS50b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5wcm92aWRlQ29uZmlndXJhdGlvbnMoW2RvY3VtZW50LnVyaV0sIHRva2VuU291cmNlLnRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImZhaWxlZCB0byBwcm92aWRlIGNvbmZpZ3VyYXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVRhc2tXaXRoVGltZW91dChwcm92aWRlQ29uZmlndXJhdGlvbkFzeW5jLCBjb25maWdQcm92aWRlclRpbWVvdXQsIHRva2VuU291cmNlKS50aGVuKChjb25maWdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlncyAmJiBjb25maWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDdXN0b21Db25maWd1cmF0aW9ucyhjb25maWdzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gbm90UmVhZHlNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3ModGhpcy5Sb290VXJpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb25maWd1cmF0aW9uV2FybmluZ3MgPT09IFwiRW5hYmxlZFwiICYmICF0aGlzLmlzRXh0ZXJuYWxIZWFkZXIoZG9jdW1lbnQpICYmICF2c2NvZGUuZGVidWcuYWN0aXZlRGVidWdTZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzbWlzcyA9IFwiRGlzbWlzc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGUgPSBcIkRpc2FibGUgV2FybmluZ3NcIjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGAnJHtwcm92aWRlck5hbWV9JyBpcyB1bmFibGUgdG8gcHJvdmlkZSBJbnRlbGxpU2Vuc2UgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBmb3IgJyR7ZG9jdW1lbnQudXJpLmZzUGF0aH0nLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYFNldHRpbmdzIGZyb20gdGhlICcke2NvbmZpZ05hbWV9JyBjb25maWd1cmF0aW9uIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGAgKCR7ZXJyfSlgO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UobWVzc2FnZSwgZGlzbWlzcywgZGlzYWJsZSkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZGlzYWJsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRvZ2dsZVNldHRpbmcoXCJjb25maWd1cmF0aW9uV2FybmluZ3NcIiwgXCJFbmFibGVkXCIsIFwiRGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc0V4dGVybmFsSGVhZGVyKGRvY3VtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuaXNIZWFkZXIoZG9jdW1lbnQpICYmICFkb2N1bWVudC51cmkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHRoaXMuUm9vdFVyaS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGdldEN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcklkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlVGFzaygoKSA9PiBQcm9taXNlLnJlc29sdmUodGhpcy5jb25maWd1cmF0aW9uLkN1cnJlbnRDb25maWd1cmF0aW9uUHJvdmlkZXIpKTtcclxuICAgIH1cclxuICAgIGdldEN1cnJlbnRDb25maWdOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlVGFzaygoKSA9PiBQcm9taXNlLnJlc29sdmUodGhpcy5jb25maWd1cmF0aW9uLkN1cnJlbnRDb25maWd1cmF0aW9uLm5hbWUpKTtcclxuICAgIH1cclxuICAgIGdldENvbXBpbGVyUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVRhc2soKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29uZmlndXJhdGlvbi5Db21waWxlclBhdGgpKTtcclxuICAgIH1cclxuICAgIGdldEtub3duQ29tcGlsZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlVGFzaygoKSA9PiBQcm9taXNlLnJlc29sdmUodGhpcy5jb25maWd1cmF0aW9uLktub3duQ29tcGlsZXIpKTtcclxuICAgIH1cclxuICAgIHRha2VPd25lcnNoaXAoZG9jdW1lbnQpIHtcclxuICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICBsYW5ndWFnZUlkOiBkb2N1bWVudC5sYW5ndWFnZUlkLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogZG9jdW1lbnQudmVyc2lvbixcclxuICAgICAgICAgICAgICAgIHRleHQ6IGRvY3VtZW50LmdldFRleHQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oRGlkT3Blbk5vdGlmaWNhdGlvbiwgcGFyYW1zKSk7XHJcbiAgICAgICAgdGhpcy50cmFja2VkRG9jdW1lbnRzLmFkZChkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBxdWV1ZVRhc2sodGFzaykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0VGFzayA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRhc2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rhc2sgJiYgIXRoaXMucGVuZGluZ1Rhc2suRG9uZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1Rhc2sudGhlbihuZXh0VGFzaywgbmV4dFRhc2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFzayA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGFzaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbnN1cHBvcnRlZCBjbGllbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWVCbG9ja2luZ1Rhc2sodGFzaykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2sgPSBuZXcgQmxvY2tpbmdUYXNrKHRhc2ssIHRoaXMucGVuZGluZ1Rhc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVW5zdXBwb3J0ZWQgY2xpZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHF1ZXVlVGFza1dpdGhUaW1lb3V0KHRhc2ssIG1zLCBjYW5jZWxUb2tlbikge1xyXG4gICAgICAgIGxldCB0aW1lcjtcclxuICAgICAgICBsZXQgdGltZW91dCA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxUb2tlbi5jYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlamVjdChcIlRpbWVkIG91dCBpbiBcIiArIG1zICsgXCJtcy5cIik7XHJcbiAgICAgICAgICAgIH0sIG1zKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVRhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFt0YXNrKCksIHRpbWVvdXQoKV0pLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcXVlc3RXaGVuUmVhZHkocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlVGFzayhyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIG5vdGlmeVdoZW5SZWFkeShub3RpZnksIGJsb2NraW5nVGFzaykge1xyXG4gICAgICAgIGxldCB0YXNrID0gKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIG5vdGlmeSgpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGJsb2NraW5nVGFzaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZUJsb2NraW5nVGFzayh0YXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlVGFzayh0YXNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3Rlck5vdGlmaWNhdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5sYW5ndWFnZUNsaWVudCAhPT0gdW5kZWZpbmVkLCBcIlRoaXMgbWV0aG9kIG11c3Qgbm90IGJlIGNhbGxlZCB1bnRpbCB0aGlzLmxhbmd1YWdlQ2xpZW50IGlzIHNldCBpbiBcXFwib25SZWFkeVxcXCJcIik7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5vbk5vdGlmaWNhdGlvbihSZWxvYWRXaW5kb3dOb3RpZmljYXRpb24sICgpID0+IHV0aWwucHJvbXB0Rm9yUmVsb2FkV2luZG93RHVlVG9TZXR0aW5nc0NoYW5nZSgpKTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50Lm9uTm90aWZpY2F0aW9uKExvZ1RlbGVtZXRyeU5vdGlmaWNhdGlvbiwgKGUpID0+IHRoaXMubG9nVGVsZW1ldHJ5KGUpKTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50Lm9uTm90aWZpY2F0aW9uKFJlcG9ydE5hdmlnYXRpb25Ob3RpZmljYXRpb24sIChlKSA9PiB0aGlzLm5hdmlnYXRlKGUpKTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50Lm9uTm90aWZpY2F0aW9uKFJlcG9ydFN0YXR1c05vdGlmaWNhdGlvbiwgKGUpID0+IHRoaXMudXBkYXRlU3RhdHVzKGUpKTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50Lm9uTm90aWZpY2F0aW9uKFJlcG9ydFRhZ1BhcnNlU3RhdHVzTm90aWZpY2F0aW9uLCAoZSkgPT4gdGhpcy51cGRhdGVUYWdQYXJzZVN0YXR1cyhlKSk7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5vbk5vdGlmaWNhdGlvbihJbmFjdGl2ZVJlZ2lvbk5vdGlmaWNhdGlvbiwgKGUpID0+IHRoaXMudXBkYXRlSW5hY3RpdmVSZWdpb25zKGUpKTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50Lm9uTm90aWZpY2F0aW9uKENvbXBpbGVDb21tYW5kc1BhdGhzTm90aWZpY2F0aW9uLCAoZSkgPT4gdGhpcy5wcm9tcHRDb21waWxlQ29tbWFuZHMoZSkpO1xyXG4gICAgICAgIHRoaXMuc2V0dXBPdXRwdXRIYW5kbGVycygpO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJGaWxlV2F0Y2hlcigpIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmxhbmd1YWdlQ2xpZW50ICE9PSB1bmRlZmluZWQsIFwiVGhpcyBtZXRob2QgbXVzdCBub3QgYmUgY2FsbGVkIHVudGlsIHRoaXMubGFuZ3VhZ2VDbGllbnQgaXMgc2V0IGluIFxcXCJvblJlYWR5XFxcIlwiKTtcclxuICAgICAgICBpZiAodGhpcy5yb290Rm9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdFBhdGhGaWxlV2F0Y2hlciA9IHZzY29kZS53b3Jrc3BhY2UuY3JlYXRlRmlsZVN5c3RlbVdhdGNoZXIoXCIqKi8qXCIsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdFBhdGhGaWxlV2F0Y2hlci5vbkRpZENyZWF0ZSgodXJpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oRmlsZUNyZWF0ZWROb3RpZmljYXRpb24sIHsgdXJpOiB1cmkudG9TdHJpbmcoKSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdFBhdGhGaWxlV2F0Y2hlci5vbkRpZERlbGV0ZSgodXJpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oRmlsZURlbGV0ZWROb3RpZmljYXRpb24sIHsgdXJpOiB1cmkudG9TdHJpbmcoKSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaCh0aGlzLnJvb3RQYXRoRmlsZVdhdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yb290UGF0aEZpbGVXYXRjaGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldHVwT3V0cHV0SGFuZGxlcnMoKSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5sYW5ndWFnZUNsaWVudCAhPT0gdW5kZWZpbmVkLCBcIlRoaXMgbWV0aG9kIG11c3Qgbm90IGJlIGNhbGxlZCB1bnRpbCB0aGlzLmxhbmd1YWdlQ2xpZW50IGlzIHNldCBpbiBcXFwib25SZWFkeVxcXCJcIik7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5vbk5vdGlmaWNhdGlvbihEZWJ1Z1Byb3RvY29sTm90aWZpY2F0aW9uLCAob3V0cHV0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kZWJ1Z0NoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdDaGFubmVsID0gdnNjb2RlLndpbmRvdy5jcmVhdGVPdXRwdXRDaGFubmVsKGBDL0MrKyBEZWJ1ZyBQcm90b2NvbDogJHt0aGlzLk5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2godGhpcy5kZWJ1Z0NoYW5uZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWdDaGFubmVsLmFwcGVuZExpbmUoXCJcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWdDaGFubmVsLmFwcGVuZExpbmUoXCIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWdDaGFubmVsLmFwcGVuZChgJHtvdXRwdXR9YCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5vbk5vdGlmaWNhdGlvbihEZWJ1Z0xvZ05vdGlmaWNhdGlvbiwgKG91dHB1dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMub3V0cHV0Q2hhbm5lbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycyAmJiB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbCA9IHZzY29kZS53aW5kb3cuY3JlYXRlT3V0cHV0Q2hhbm5lbChgQy9DKys6ICR7dGhpcy5OYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsID0gbG9nZ2VyLmdldE91dHB1dENoYW5uZWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaCh0aGlzLm91dHB1dENoYW5uZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKGAke291dHB1dH1gKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGxvZ1RlbGVtZXRyeShub3RpZmljYXRpb25Cb2R5KSB7XHJcbiAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQobm90aWZpY2F0aW9uQm9keS5ldmVudCwgbm90aWZpY2F0aW9uQm9keS5wcm9wZXJ0aWVzLCBub3RpZmljYXRpb25Cb2R5Lm1ldHJpY3MpO1xyXG4gICAgfVxyXG4gICAgbmF2aWdhdGUocGF5bG9hZCkge1xyXG4gICAgICAgIGxldCBjcHBTZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHRoaXMuUm9vdFVyaSk7XHJcbiAgICAgICAgaWYgKGNwcFNldHRpbmdzLmF1dG9BZGRGaWxlQXNzb2NpYXRpb25zICYmIHBheWxvYWQubmF2aWdhdGlvbi5zdGFydHNXaXRoKFwiPGRlZlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEZpbGVBc3NvY2lhdGlvbnMocGF5bG9hZC5uYXZpZ2F0aW9uLnN1YnN0cig0KSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1cnJlbnROYXZpZ2F0aW9uID0gcGF5bG9hZC5uYXZpZ2F0aW9uO1xyXG4gICAgICAgIGxldCBtYXhMZW5ndGggPSBjcHBTZXR0aW5ncy5uYXZpZ2F0aW9uTGVuZ3RoO1xyXG4gICAgICAgIGlmIChjdXJyZW50TmF2aWdhdGlvbi5sZW5ndGggPiBtYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VycmVudE5hdmlnYXRpb24gPSBjdXJyZW50TmF2aWdhdGlvbi5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoIC0gMykuY29uY2F0KFwiLi4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLm5hdmlnYXRpb25Mb2NhdGlvbi5WYWx1ZSA9IGN1cnJlbnROYXZpZ2F0aW9uO1xyXG4gICAgfVxyXG4gICAgYWRkRmlsZUFzc29jaWF0aW9ucyhmaWxlQXNzb2NpYXRpb25zKSB7XHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuT3RoZXJTZXR0aW5ncyh0aGlzLlJvb3RVcmkpO1xyXG4gICAgICAgIGxldCBhc3NvY3MgPSBzZXR0aW5ncy5maWxlc0Fzc29jaWF0aW9ucztcclxuICAgICAgICBsZXQgaXNfYyA9IGZpbGVBc3NvY2lhdGlvbnMuc3RhcnRzV2l0aChcImNcIik7XHJcbiAgICAgICAgZmlsZUFzc29jaWF0aW9ucyA9IGZpbGVBc3NvY2lhdGlvbnMuc3Vic3RyKGlzX2MgPyAzIDogMik7XHJcbiAgICAgICAgbGV0IGZpbGVzQW5kUGF0aHMgPSBmaWxlQXNzb2NpYXRpb25zLnNwbGl0KFwiO1wiKTtcclxuICAgICAgICBsZXQgZm91bmROZXdBc3NvY2lhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXNBbmRQYXRocy5sZW5ndGggLSAxOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IGZpbGVBbmRQYXRoID0gZmlsZXNBbmRQYXRoc1tpXS5zcGxpdChcIkBcIik7XHJcbiAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZUFuZFBhdGhbMF07XHJcbiAgICAgICAgICAgIGxldCBmaWxlUGF0aCA9IGZpbGVBbmRQYXRoWzFdO1xyXG4gICAgICAgICAgICBpZiAoKGZpbGUgaW4gYXNzb2NzKSB8fCAoKFwiKiovXCIgKyBmaWxlKSBpbiBhc3NvY3MpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaiA9IGZpbGUubGFzdEluZGV4T2YoJy4nKTtcclxuICAgICAgICAgICAgaWYgKGogIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXh0ID0gZmlsZS5zdWJzdHIoaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKChcIipcIiArIGV4dCkgaW4gYXNzb2NzKSB8fCAoKFwiKiovKlwiICsgZXh0KSBpbiBhc3NvY3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGZvdW5kR2xvYk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGFzc29jIGluIGFzc29jcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbmltYXRjaChmaWxlUGF0aCwgYXNzb2MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRHbG9iTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZEdsb2JNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzb2NzW2ZpbGVdID0gaXNfYyA/IFwiY1wiIDogXCJjcHBcIjtcclxuICAgICAgICAgICAgZm91bmROZXdBc3NvY2lhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZE5ld0Fzc29jaWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmZpbGVzQXNzb2NpYXRpb25zID0gYXNzb2NzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVN0YXR1cyhub3RpZmljYXRpb25Cb2R5KSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBub3RpZmljYXRpb25Cb2R5LnN0YXR1cztcclxuICAgICAgICB1dGlsLnNldFByb2dyZXNzKHV0aWwuZ2V0UHJvZ3Jlc3NFeGVjdXRhYmxlU3VjY2VzcygpKTtcclxuICAgICAgICBsZXQgdGVzdEhvb2sgPSB0ZXN0SG9va18xLmdldFRlc3RIb29rKCk7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoXCJJbmRleGluZy4uLlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLmlzVGFnUGFyc2luZy5WYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRlc3RIb29rLnVwZGF0ZVN0YXR1cyh0ZXN0QXBpXzEuU3RhdHVzLlRhZ1BhcnNpbmdCZWd1bik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZW5kc1dpdGgoXCJVcGRhdGluZyBJbnRlbGxpU2Vuc2UuLi5cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5pc1VwZGF0aW5nSW50ZWxsaVNlbnNlLlZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGVzdEhvb2sudXBkYXRlU3RhdHVzKHRlc3RBcGlfMS5TdGF0dXMuSW50ZWxsaVNlbnNlQ29tcGlsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lbmRzV2l0aChcIkludGVsbGlTZW5zZSBSZWFkeVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLmlzVXBkYXRpbmdJbnRlbGxpU2Vuc2UuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGVzdEhvb2sudXBkYXRlU3RhdHVzKHRlc3RBcGlfMS5TdGF0dXMuSW50ZWxsaVNlbnNlUmVhZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVuZHNXaXRoKFwiUmVhZHlcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5pc1RhZ1BhcnNpbmcuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGVzdEhvb2sudXBkYXRlU3RhdHVzKHRlc3RBcGlfMS5TdGF0dXMuVGFnUGFyc2luZ0RvbmUpO1xyXG4gICAgICAgICAgICB1dGlsLnNldFByb2dyZXNzKHV0aWwuZ2V0UHJvZ3Jlc3NQYXJzZVJvb3RTdWNjZXNzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVuZHNXaXRoKFwiTm8gU3F1aWdnbGVzXCIpKSB7XHJcbiAgICAgICAgICAgIHV0aWwuc2V0SW50ZWxsaVNlbnNlUHJvZ3Jlc3ModXRpbC5nZXRQcm9ncmVzc0ludGVsbGlTZW5zZU5vU3F1aWdnbGVzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVuZHNXaXRoKFwiSW50ZWxsaVNlbnNlIEZhbGxiYWNrXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCBzaG93SW50ZWxsaVNlbnNlRmFsbGJhY2tNZXNzYWdlID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRTdGF0ZShcIkNQUC5zaG93SW50ZWxsaVNlbnNlRmFsbGJhY2tNZXNzYWdlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoc2hvd0ludGVsbGlTZW5zZUZhbGxiYWNrTWVzc2FnZS5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdWkuc2hvd0NvbmZpZ3VyZUluY2x1ZGVQYXRoTWVzc2FnZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlYXJuTW9yZVBhbmVsID0gXCJDb25maWd1cmF0aW9uIEhlbHBcIjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZG9udFNob3dBZ2FpbiA9IFwiRG9uJ3QgU2hvdyBBZ2FpblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWxsYmFja01zZyA9IHRoaXMuY29uZmlndXJhdGlvbi5WY3BrZ0luc3RhbGxlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVXBkYXRlIHlvdXIgSW50ZWxsaVNlbnNlIHNldHRpbmdzIG9yIHVzZSBWY3BrZyB0byBpbnN0YWxsIGxpYnJhcmllcyB0byBoZWxwIGZpbmQgbWlzc2luZyBoZWFkZXJzLlwiIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb25maWd1cmUgeW91ciBJbnRlbGxpU2Vuc2Ugc2V0dGluZ3MgdG8gaGVscCBmaW5kIG1pc3NpbmcgaGVhZGVycy5cIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdnNjb2RlLndpbmRvdy5zaG93SW5mb3JtYXRpb25NZXNzYWdlKGZhbGxiYWNrTXNnLCBsZWFybk1vcmVQYW5lbCwgZG9udFNob3dBZ2FpbikudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBsZWFybk1vcmVQYW5lbDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJpID0gdnNjb2RlLlVyaS5wYXJzZShgaHR0cHM6Ly9nby5taWNyb3NvZnQuY29tL2Z3bGluay8/bGlua2lkPTg2NDYzMWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZS5jb21tYW5kcy5leGVjdXRlQ29tbWFuZCgndnNjb2RlLm9wZW4nLCB1cmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZS5jb21tYW5kcy5nZXRDb21tYW5kcyh0cnVlKS50aGVuKChjb21tYW5kcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZHMuaW5kZXhPZihcIndvcmtiZW5jaC5hY3Rpb24ucHJvYmxlbXMuZm9jdXNcIikgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kKFwid29ya2JlbmNoLmFjdGlvbi5wcm9ibGVtcy5mb2N1c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkVkaXRDb21tYW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGRvbnRTaG93QWdhaW46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0ludGVsbGlTZW5zZUZhbGxiYWNrTWVzc2FnZS5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4gc2hvd0ludGVsbGlTZW5zZUZhbGxiYWNrTWVzc2FnZS5WYWx1ZSA9IGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVRhZ1BhcnNlU3RhdHVzKG5vdGlmaWNhdGlvbkJvZHkpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnRhZ1BhcnNlclN0YXR1cy5WYWx1ZSA9IG5vdGlmaWNhdGlvbkJvZHkuc3RhdHVzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW5hY3RpdmVSZWdpb25zKHBhcmFtcykge1xyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHRoaXMuUm9vdFVyaSk7XHJcbiAgICAgICAgbGV0IGRlY29yYXRpb24gPSB2c2NvZGUud2luZG93LmNyZWF0ZVRleHRFZGl0b3JEZWNvcmF0aW9uVHlwZSh7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHNldHRpbmdzLmluYWN0aXZlUmVnaW9uT3BhY2l0eS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHNldHRpbmdzLmluYWN0aXZlUmVnaW9uQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICBjb2xvcjogc2V0dGluZ3MuaW5hY3RpdmVSZWdpb25Gb3JlZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIHJhbmdlQmVoYXZpb3I6IHZzY29kZS5EZWNvcmF0aW9uUmFuZ2VCZWhhdmlvci5DbG9zZWRPcGVuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHBhcmFtcy5yZWdpb25zLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBuZXdSYW5nZSA9IG5ldyB2c2NvZGUuUmFuZ2UoZWxlbWVudC5zdGFydExpbmUsIDAsIGVsZW1lbnQuZW5kTGluZSwgMCk7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgdmFsdWVQYWlyID0gdGhpcy5pbmFjdGl2ZVJlZ2lvbnNEZWNvcmF0aW9ucy5nZXQocGFyYW1zLnVyaSk7XHJcbiAgICAgICAgaWYgKHZhbHVlUGFpcikge1xyXG4gICAgICAgICAgICB2YWx1ZVBhaXIuZGVjb3JhdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHZhbHVlUGFpci5kZWNvcmF0aW9uID0gZGVjb3JhdGlvbjtcclxuICAgICAgICAgICAgdmFsdWVQYWlyLnJhbmdlcyA9IHJhbmdlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0b0luc2VydCA9IHtcclxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IGRlY29yYXRpb24sXHJcbiAgICAgICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmluYWN0aXZlUmVnaW9uc0RlY29yYXRpb25zLnNldChwYXJhbXMudXJpLCB0b0luc2VydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaW1JbmFjdGl2ZVJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgbGV0IGVkaXRvcnMgPSB2c2NvZGUud2luZG93LnZpc2libGVUZXh0RWRpdG9ycy5maWx0ZXIoZSA9PiBlLmRvY3VtZW50LnVyaS50b1N0cmluZygpID09PSBwYXJhbXMudXJpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBlZGl0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBlLnNldERlY29yYXRpb25zKGRlY29yYXRpb24sIHJhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9tcHRDb21waWxlQ29tbWFuZHMocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5DdXJyZW50Q29uZmlndXJhdGlvbi5jb21waWxlQ29tbWFuZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhc2sgPSBuZXcgcGVyc2lzdGVudFN0YXRlXzEuUGVyc2lzdGVudFN0YXRlKFwiQ1BQLnNob3dDb21waWxlQ29tbWFuZHNTZWxlY3Rpb25cIiwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKCFhc2suVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29tcGlsZUNvbW1hbmRTdHIgPSBwYXJhbXMucGF0aHMubGVuZ3RoID4gMSA/IFwiYSBjb21waWxlX2NvbW1hbmRzLmpzb24gZmlsZVwiIDogcGFyYW1zLnBhdGhzWzBdO1xyXG4gICAgICAgIGxldCBmb2xkZXJTdHIgPSAodnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzICYmIHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycy5sZW5ndGggPiAxKSA/IFwidGhlICdcIiArIHRoaXMuTmFtZSArIFwiJ1wiIDogXCJ0aGlzXCI7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBXb3VsZCB5b3UgbGlrZSB0byB1c2UgJHtjb21waWxlQ29tbWFuZFN0cn0gdG8gYXV0by1jb25maWd1cmUgSW50ZWxsaVNlbnNlIGZvciAke2ZvbGRlclN0cn0gZm9sZGVyP2A7XHJcbiAgICAgICAgdWkuc2hvd0NvbmZpZ3VyZUNvbXBpbGVDb21tYW5kc01lc3NhZ2UoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB5ZXMgPSBcIlllc1wiO1xyXG4gICAgICAgICAgICBjb25zdCBubyA9IFwiTm9cIjtcclxuICAgICAgICAgICAgY29uc3QgYXNrTGF0ZXIgPSBcIkFzayBNZSBMYXRlclwiO1xyXG4gICAgICAgICAgICByZXR1cm4gdnNjb2RlLndpbmRvdy5zaG93SW5mb3JtYXRpb25NZXNzYWdlKG1lc3NhZ2UsIHllcywgbm8sIGFza0xhdGVyKS50aGVuKCh2YWx1ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgeWVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnBhdGhzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHlpZWxkIHVpLnNob3dDb21waWxlQ29tbWFuZHMocGFyYW1zLnBhdGhzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc2V0Q29tcGlsZUNvbW1hbmRzKHBhcmFtcy5wYXRoc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnNldENvbXBpbGVDb21tYW5kcyhwYXJhbXMucGF0aHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgYXNrTGF0ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugbm86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzay5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0sICgpID0+IGFzay5WYWx1ZSA9IGZhbHNlKTtcclxuICAgIH1cclxuICAgIHJlcXVlc3RHb1RvRGVjbGFyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdoZW5SZWFkeSgoKSA9PiB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmRSZXF1ZXN0KEdvVG9EZWNsYXJhdGlvblJlcXVlc3QsIG51bGwpKTtcclxuICAgIH1cclxuICAgIHJlcXVlc3RTd2l0Y2hIZWFkZXJTb3VyY2Uocm9vdFBhdGgsIGZpbGVOYW1lKSB7XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgcm9vdFBhdGg6IHJvb3RQYXRoLFxyXG4gICAgICAgICAgICBzd2l0Y2hIZWFkZXJTb3VyY2VGaWxlTmFtZTogZmlsZU5hbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RXaGVuUmVhZHkoKCkgPT4gdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kUmVxdWVzdChTd2l0Y2hIZWFkZXJTb3VyY2VSZXF1ZXN0LCBwYXJhbXMpKTtcclxuICAgIH1cclxuICAgIHJlcXVlc3ROYXZpZ2F0aW9uTGlzdChkb2N1bWVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RXaGVuUmVhZHkoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kUmVxdWVzdChOYXZpZ2F0aW9uTGlzdFJlcXVlc3QsIHRoaXMubGFuZ3VhZ2VDbGllbnQuY29kZTJQcm90b2NvbENvbnZlcnRlci5hc1RleHREb2N1bWVudElkZW50aWZpZXIoZG9jdW1lbnQpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFjdGl2ZURvY3VtZW50Q2hhbmdlZChkb2N1bWVudCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kTm90aWZpY2F0aW9uKEFjdGl2ZURvY3VtZW50Q2hhbmdlTm90aWZpY2F0aW9uLCB0aGlzLmxhbmd1YWdlQ2xpZW50LmNvZGUyUHJvdG9jb2xDb252ZXJ0ZXIuYXNUZXh0RG9jdW1lbnRJZGVudGlmaWVyKGRvY3VtZW50KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhY3RpdmF0ZSgpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5tb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsW2tleV0uYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3VtZVBhcnNpbmcoKTtcclxuICAgIH1cclxuICAgIHNlbGVjdGlvbkNoYW5nZWQoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlXaGVuUmVhZHkoKCkgPT4gdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kTm90aWZpY2F0aW9uKFRleHRFZGl0b3JTZWxlY3Rpb25DaGFuZ2VOb3RpZmljYXRpb24sIHNlbGVjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgcmVzZXREYXRhYmFzZSgpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oUmVzZXREYXRhYmFzZU5vdGlmaWNhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgZGVhY3RpdmF0ZSgpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5tb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsW2tleV0uZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGF1c2VQYXJzaW5nKCk7XHJcbiAgICB9XHJcbiAgICBwYXVzZVBhcnNpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlXaGVuUmVhZHkoKCkgPT4gdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kTm90aWZpY2F0aW9uKFBhdXNlUGFyc2luZ05vdGlmaWNhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lUGFyc2luZygpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oUmVzdW1lUGFyc2luZ05vdGlmaWNhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgb25Db25maWd1cmF0aW9uc0NoYW5nZWQoY29uZmlndXJhdGlvbnMpIHtcclxuICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uczogY29uZmlndXJhdGlvbnMsXHJcbiAgICAgICAgICAgIGN1cnJlbnRDb25maWd1cmF0aW9uOiB0aGlzLmNvbmZpZ3VyYXRpb24uQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ub3RpZnlXaGVuUmVhZHkoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oQ2hhbmdlRm9sZGVyU2V0dGluZ3NOb3RpZmljYXRpb24sIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuYWN0aXZlQ29uZmlnTmFtZS5WYWx1ZSA9IGNvbmZpZ3VyYXRpb25zW3BhcmFtcy5jdXJyZW50Q29uZmlndXJhdGlvbl0ubmFtZTtcclxuICAgICAgICB9KS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5ld1Byb3ZpZGVyID0gdGhpcy5jb25maWd1cmF0aW9uLkN1cnJlbnRDb25maWd1cmF0aW9uUHJvdmlkZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Qcm92aWRlciAhPT0gbmV3UHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblByb3ZpZGVyID0gbmV3UHJvdmlkZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbmZpZ3VyYXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25TZWxlY3RlZENvbmZpZ3VyYXRpb25DaGFuZ2VkKGluZGV4KSB7XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgY3VycmVudENvbmZpZ3VyYXRpb246IGluZGV4XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2VDbGllbnQuc2VuZE5vdGlmaWNhdGlvbihDaGFuZ2VTZWxlY3RlZFNldHRpbmdOb3RpZmljYXRpb24sIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuYWN0aXZlQ29uZmlnTmFtZS5WYWx1ZSA9IHRoaXMuY29uZmlndXJhdGlvbi5Db25maWd1cmF0aW9uTmFtZXNbaW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25Db21waWxlQ29tbWFuZHNDaGFuZ2VkKHBhdGgpIHtcclxuICAgICAgICBsZXQgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICB1cmk6IHBhdGhcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHRoaXMubGFuZ3VhZ2VDbGllbnQuc2VuZE5vdGlmaWNhdGlvbihDaGFuZ2VDb21waWxlQ29tbWFuZHNOb3RpZmljYXRpb24sIHBhcmFtcykpO1xyXG4gICAgfVxyXG4gICAgaXNTb3VyY2VGaWxlQ29uZmlndXJhdGlvbkl0ZW0oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gKGlucHV0ICYmICh1dGlsLmlzU3RyaW5nKGlucHV0LnVyaSkgfHwgdXRpbC5pc1VyaShpbnB1dC51cmkpKSAmJlxyXG4gICAgICAgICAgICBpbnB1dC5jb25maWd1cmF0aW9uICYmIHV0aWwuaXNBcnJheU9mU3RyaW5nKGlucHV0LmNvbmZpZ3VyYXRpb24uaW5jbHVkZVBhdGgpICYmIHV0aWwuaXNBcnJheU9mU3RyaW5nKGlucHV0LmNvbmZpZ3VyYXRpb24uZGVmaW5lcykgJiZcclxuICAgICAgICAgICAgdXRpbC5pc1N0cmluZyhpbnB1dC5jb25maWd1cmF0aW9uLmludGVsbGlTZW5zZU1vZGUpICYmIHV0aWwuaXNTdHJpbmcoaW5wdXQuY29uZmlndXJhdGlvbi5zdGFuZGFyZCkgJiYgdXRpbC5pc09wdGlvbmFsU3RyaW5nKGlucHV0LmNvbmZpZ3VyYXRpb24uY29tcGlsZXJQYXRoKSAmJlxyXG4gICAgICAgICAgICB1dGlsLmlzT3B0aW9uYWxBcnJheU9mU3RyaW5nKGlucHV0LmNvbmZpZ3VyYXRpb24uZm9yY2VkSW5jbHVkZSkpO1xyXG4gICAgfVxyXG4gICAgc2VuZEN1c3RvbUNvbmZpZ3VyYXRpb25zKGNvbmZpZ3MsIGJsb2NraW5nVGFzaykge1xyXG4gICAgICAgIGlmICghY29uZmlncyB8fCAhKGNvbmZpZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZGlzY2FyZGluZyBpbnZhbGlkIFNvdXJjZUZpbGVDb25maWd1cmF0aW9uSXRlbXNbXTogXCIgKyBjb25maWdzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyh0aGlzLlJvb3RVcmkpO1xyXG4gICAgICAgIGxldCBvdXQgPSBsb2dnZXIuZ2V0T3V0cHV0Q2hhbm5lbExvZ2dlcigpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2dnaW5nTGV2ZWwgPT09IFwiRGVidWdcIikge1xyXG4gICAgICAgICAgICBvdXQuYXBwZW5kTGluZShcIkN1c3RvbSBjb25maWd1cmF0aW9ucyByZWNlaXZlZDpcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzYW5pdGl6ZWQgPSBbXTtcclxuICAgICAgICBjb25maWdzLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU291cmNlRmlsZUNvbmZpZ3VyYXRpb25JdGVtKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBpdGVtLnVyaS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IGl0ZW0uY29uZmlndXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9nZ2luZ0xldmVsID09PSBcIkRlYnVnXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kTGluZShgICB1cmk6ICR7aXRlbS51cmkudG9TdHJpbmcoKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kTGluZShgICBjb25maWc6ICR7SlNPTi5zdHJpbmdpZnkoaXRlbS5jb25maWd1cmF0aW9uLCBudWxsLCAyKX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbmZpZ3VyYXRpb24uaW5jbHVkZVBhdGguc29tZShwYXRoID0+IHBhdGguZW5kc1dpdGgoJyoqJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY3VzdG9tIGluY2x1ZGUgcGF0aHMgc2hvdWxkIG5vdCB1c2UgcmVjdXJzaXZlIGluY2x1ZGVzICgnKionKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImRpc2NhcmRpbmcgaW52YWxpZCBTb3VyY2VGaWxlQ29uZmlndXJhdGlvbkl0ZW06IFwiICsgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2FuaXRpemVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25JdGVtczogc2FuaXRpemVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB0aGlzLmxhbmd1YWdlQ2xpZW50LnNlbmROb3RpZmljYXRpb24oQ3VzdG9tQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiwgcGFyYW1zKSwgYmxvY2tpbmdUYXNrKTtcclxuICAgIH1cclxuICAgIHNlbmRDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIGlmICghY29uZmlnIHx8IGNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImRpc2NhcmRpbmcgaW52YWxpZCBXb3Jrc3BhY2VCcm93c2VDb25maWd1cmF0aW9uOiBcIiArIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNhbml0aXplZCA9IGNvbmZpZztcclxuICAgICAgICBpZiAoIXV0aWwuaXNBcnJheU9mU3RyaW5nKHNhbml0aXplZC5icm93c2VQYXRoKSB8fCAhdXRpbC5pc09wdGlvbmFsU3RyaW5nKHNhbml0aXplZC5jb21waWxlclBhdGgpIHx8XHJcbiAgICAgICAgICAgICF1dGlsLmlzT3B0aW9uYWxTdHJpbmcoc2FuaXRpemVkLnN0YW5kYXJkKSB8fCAhdXRpbC5pc09wdGlvbmFsU3RyaW5nKHNhbml0aXplZC53aW5kb3dzU2RrVmVyc2lvbikpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZGlzY2FyZGluZyBpbnZhbGlkIFdvcmtzcGFjZUJyb3dzZUNvbmZpZ3VyYXRpb246IFwiICsgY29uZmlnKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyh0aGlzLlJvb3RVcmkpO1xyXG4gICAgICAgIGxldCBvdXQgPSBsb2dnZXIuZ2V0T3V0cHV0Q2hhbm5lbExvZ2dlcigpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2dnaW5nTGV2ZWwgPT09IFwiRGVidWdcIikge1xyXG4gICAgICAgICAgICBvdXQuYXBwZW5kTGluZShgQ3VzdG9tIGJyb3dzZSBjb25maWd1cmF0aW9uIHJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHNhbml0aXplZCwgbnVsbCwgMil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGJyb3dzZUNvbmZpZ3VyYXRpb246IHNhbml0aXplZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHRoaXMubGFuZ3VhZ2VDbGllbnQuc2VuZE5vdGlmaWNhdGlvbihDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLCBwYXJhbXMpKTtcclxuICAgIH1cclxuICAgIGNsZWFyQ3VzdG9tQ29uZmlndXJhdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlXaGVuUmVhZHkoKCkgPT4gdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kTm90aWZpY2F0aW9uKENsZWFyQ3VzdG9tQ29uZmlndXJhdGlvbnNOb3RpZmljYXRpb24pKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUNvbmZpZ3VyYXRpb25TZWxlY3RDb21tYW5kKCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgdWkuc2hvd0NvbmZpZ3VyYXRpb25zKHRoaXMuY29uZmlndXJhdGlvbi5Db25maWd1cmF0aW9uTmFtZXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc2VsZWN0KGluZGV4KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDb25maWd1cmF0aW9uUHJvdmlkZXJTZWxlY3RDb21tYW5kKCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgdWkuc2hvd0NvbmZpZ3VyYXRpb25Qcm92aWRlcnModGhpcy5jb25maWd1cmF0aW9uLkN1cnJlbnRDb25maWd1cmF0aW9uUHJvdmlkZXIpXHJcbiAgICAgICAgICAgICAgICAudGhlbihleHRlbnNpb25JZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi51cGRhdGVDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXIoZXh0ZW5zaW9uSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKS5nZXQoZXh0ZW5zaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbmZpZ3VyYXRpb25zKHByb3ZpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uKHByb3ZpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoXCJjdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXJcIiwgeyBcInByb3ZpZGVySWRcIjogZXh0ZW5zaW9uSWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ3VzdG9tQ29uZmlndXJhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVTaG93UGFyc2luZ0NvbW1hbmRzKCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgdWkuc2hvd1BhcnNpbmdDb21tYW5kcygpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VQYXJzaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lUGFyc2luZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZUNvbmZpZ3VyYXRpb25FZGl0Q29tbWFuZCgpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiB0aGlzLmNvbmZpZ3VyYXRpb24uaGFuZGxlQ29uZmlndXJhdGlvbkVkaXRDb21tYW5kKHZzY29kZS53aW5kb3cuc2hvd1RleHREb2N1bWVudCkpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQWRkVG9JbmNsdWRlUGF0aENvbW1hbmQocGF0aCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5V2hlblJlYWR5KCgpID0+IHRoaXMuY29uZmlndXJhdGlvbi5hZGRUb0luY2x1ZGVQYXRoQ29tbWFuZChwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBvbkludGVydmFsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlQ2xpZW50ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jb25maWd1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudC5zZW5kTm90aWZpY2F0aW9uKEludGVydmFsVGltZXJOb3RpZmljYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uY2hlY2tDcHBQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZSA9ICh0aGlzLmxhbmd1YWdlQ2xpZW50KSA/IHRoaXMubGFuZ3VhZ2VDbGllbnQuc3RvcCgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXMuZm9yRWFjaCgoZCkgPT4gZC5kaXNwb3NlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbFtrZXldLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldExhbmd1YWdlU2VydmVyRmlsZU5hbWUoKSB7XHJcbiAgICBsZXQgZXh0ZW5zaW9uUHJvY2Vzc05hbWUgPSAnTWljcm9zb2Z0LlZTQ29kZS5DUFAuRXh0ZW5zaW9uJztcclxuICAgIGxldCBwbGF0ID0gcHJvY2Vzcy5wbGF0Zm9ybTtcclxuICAgIGlmIChwbGF0ID09PSAnbGludXgnKSB7XHJcbiAgICAgICAgZXh0ZW5zaW9uUHJvY2Vzc05hbWUgKz0gJy5saW51eCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwbGF0ID09PSAnZGFyd2luJykge1xyXG4gICAgICAgIGV4dGVuc2lvblByb2Nlc3NOYW1lICs9ICcuZGFyd2luJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBsYXQgPT09ICd3aW4zMicpIHtcclxuICAgICAgICBleHRlbnNpb25Qcm9jZXNzTmFtZSArPSAnLmV4ZSc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBcIkludmFsaWQgUGxhdGZvcm1cIjtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUodXRpbC5nZXRFeHRlbnNpb25GaWxlUGF0aChcImJpblwiKSwgZXh0ZW5zaW9uUHJvY2Vzc05hbWUpO1xyXG59XHJcbmNsYXNzIE51bGxDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ib29sZWFuRXZlbnQgPSBuZXcgdnNjb2RlLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nRXZlbnQgPSBuZXcgdnNjb2RlLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuUm9vdFBhdGggPSBcIi9cIjtcclxuICAgICAgICB0aGlzLlJvb3RVcmkgPSB2c2NvZGUuVXJpLmZpbGUoXCIvXCIpO1xyXG4gICAgICAgIHRoaXMuTmFtZSA9IFwiKGVtcHR5KVwiO1xyXG4gICAgICAgIHRoaXMuVHJhY2tlZERvY3VtZW50cyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBUYWdQYXJzaW5nQ2hhbmdlZCgpIHsgcmV0dXJuIHRoaXMuYm9vbGVhbkV2ZW50LmV2ZW50OyB9XHJcbiAgICBnZXQgSW50ZWxsaVNlbnNlUGFyc2luZ0NoYW5nZWQoKSB7IHJldHVybiB0aGlzLmJvb2xlYW5FdmVudC5ldmVudDsgfVxyXG4gICAgZ2V0IE5hdmlnYXRpb25Mb2NhdGlvbkNoYW5nZWQoKSB7IHJldHVybiB0aGlzLnN0cmluZ0V2ZW50LmV2ZW50OyB9XHJcbiAgICBnZXQgVGFnUGFyc2VyU3RhdHVzQ2hhbmdlZCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nRXZlbnQuZXZlbnQ7IH1cclxuICAgIGdldCBBY3RpdmVDb25maWdDaGFuZ2VkKCkgeyByZXR1cm4gdGhpcy5zdHJpbmdFdmVudC5ldmVudDsgfVxyXG4gICAgb25EaWRDaGFuZ2VTZXR0aW5ncygpIHsgcmV0dXJuIHt9OyB9XHJcbiAgICBvbkRpZENoYW5nZVZpc2libGVUZXh0RWRpdG9ycyhlZGl0b3JzKSB7IH1cclxuICAgIG9uUmVnaXN0ZXJDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXIocHJvdmlkZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9XHJcbiAgICB1cGRhdGVDdXN0b21Db25maWd1cmF0aW9ucyhyZXF1ZXN0aW5nUHJvdmlkZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9XHJcbiAgICB1cGRhdGVDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uKHJlcXVlc3RpbmdQcm92aWRlcikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cclxuICAgIHByb3ZpZGVDdXN0b21Db25maWd1cmF0aW9uKGRvY3VtZW50KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfVxyXG4gICAgZ2V0Q3VycmVudENvbmZpZ05hbWUoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoXCJcIik7IH1cclxuICAgIGdldENvbXBpbGVyUGF0aCgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIlwiKTsgfVxyXG4gICAgZ2V0S25vd25Db21waWxlcnMoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pOyB9XHJcbiAgICB0YWtlT3duZXJzaGlwKGRvY3VtZW50KSB7IH1cclxuICAgIHF1ZXVlVGFzayh0YXNrKSB7IHJldHVybiB0YXNrKCk7IH1cclxuICAgIHJlcXVlc3RXaGVuUmVhZHkocmVxdWVzdCkgeyByZXR1cm47IH1cclxuICAgIG5vdGlmeVdoZW5SZWFkeShub3RpZnkpIHsgfVxyXG4gICAgcmVxdWVzdEdvVG9EZWNsYXJhdGlvbigpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9XHJcbiAgICByZXF1ZXN0U3dpdGNoSGVhZGVyU291cmNlKHJvb3RQYXRoLCBmaWxlTmFtZSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwiXCIpOyB9XHJcbiAgICByZXF1ZXN0TmF2aWdhdGlvbkxpc3QoZG9jdW1lbnQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIlwiKTsgfVxyXG4gICAgYWN0aXZlRG9jdW1lbnRDaGFuZ2VkKGRvY3VtZW50KSB7IH1cclxuICAgIGFjdGl2YXRlKCkgeyB9XHJcbiAgICBzZWxlY3Rpb25DaGFuZ2VkKHNlbGVjdGlvbikgeyB9XHJcbiAgICByZXNldERhdGFiYXNlKCkgeyB9XHJcbiAgICBkZWFjdGl2YXRlKCkgeyB9XHJcbiAgICBwYXVzZVBhcnNpbmcoKSB7IH1cclxuICAgIHJlc3VtZVBhcnNpbmcoKSB7IH1cclxuICAgIGhhbmRsZUNvbmZpZ3VyYXRpb25TZWxlY3RDb21tYW5kKCkgeyB9XHJcbiAgICBoYW5kbGVDb25maWd1cmF0aW9uUHJvdmlkZXJTZWxlY3RDb21tYW5kKCkgeyB9XHJcbiAgICBoYW5kbGVTaG93UGFyc2luZ0NvbW1hbmRzKCkgeyB9XHJcbiAgICBoYW5kbGVDb25maWd1cmF0aW9uRWRpdENvbW1hbmQoKSB7IH1cclxuICAgIGhhbmRsZUFkZFRvSW5jbHVkZVBhdGhDb21tYW5kKHBhdGgpIHsgfVxyXG4gICAgb25JbnRlcnZhbCgpIHsgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmJvb2xlYW5FdmVudC5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5zdHJpbmdFdmVudC5kaXNwb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/client.ts\n");

/***/ }),

/***/ "./src/LanguageServer/clientCollection.ts":
/*!************************************************!*\
  !*** ./src/LanguageServer/clientCollection.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nconst cpptools = __webpack_require__(/*! ./client */ \"./src/LanguageServer/client.ts\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst customProviders_1 = __webpack_require__(/*! ./customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nconst defaultClientKey = \"@@default@@\";\r\nclass ClientCollection {\r\n    constructor() {\r\n        this.disposables = [];\r\n        this.languageClients = new Map();\r\n        let key = defaultClientKey;\r\n        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {\r\n            let folder = vscode.workspace.workspaceFolders[0];\r\n            key = util.asFolder(folder.uri);\r\n            this.activeClient = cpptools.createClient(this, folder);\r\n        }\r\n        else {\r\n            this.activeClient = cpptools.createClient(this);\r\n        }\r\n        this.defaultClient = this.activeClient;\r\n        this.languageClients.set(key, this.activeClient);\r\n        this.disposables.push(vscode.workspace.onDidChangeWorkspaceFolders(e => this.onDidChangeWorkspaceFolders(e)));\r\n        this.disposables.push(vscode.workspace.onDidOpenTextDocument(d => this.onDidOpenTextDocument(d)));\r\n        this.disposables.push(vscode.workspace.onDidCloseTextDocument(d => this.onDidCloseTextDocument(d)));\r\n    }\r\n    get ActiveClient() { return this.activeClient; }\r\n    get Names() {\r\n        let result = [];\r\n        this.languageClients.forEach((client, key) => {\r\n            result.push({ name: client.Name, key: key });\r\n        });\r\n        return result;\r\n    }\r\n    get Count() { return this.languageClients.size; }\r\n    activeDocumentChanged(document) {\r\n        this.activeDocument = document;\r\n        let activeClient = this.getClientFor(document.uri);\r\n        activeClient.activeDocumentChanged(document);\r\n        if (activeClient !== this.activeClient) {\r\n            activeClient.activate();\r\n            this.activeClient.deactivate();\r\n            this.activeClient = activeClient;\r\n        }\r\n    }\r\n    get(key) {\r\n        if (this.languageClients.has(key)) {\r\n            return this.languageClients.get(key);\r\n        }\r\n        console.assert(\"key not found\");\r\n        return null;\r\n    }\r\n    forEach(callback) {\r\n        this.languageClients.forEach(callback);\r\n    }\r\n    checkOwnership(client, document) {\r\n        let owners = [];\r\n        this.languageClients.forEach(languageClient => {\r\n            if (document.uri.fsPath.startsWith(languageClient.RootPath + path.sep)) {\r\n                owners.push(languageClient);\r\n            }\r\n        });\r\n        if (owners.length === 0) {\r\n            owners.push(this.activeClient);\r\n        }\r\n        return (owners[0] === client);\r\n    }\r\n    replace(client, transferFileOwnership) {\r\n        let key = undefined;\r\n        for (let pair of this.languageClients) {\r\n            if (pair[1] === client) {\r\n                key = pair[0];\r\n                break;\r\n            }\r\n        }\r\n        if (key) {\r\n            this.languageClients.delete(key);\r\n            if (transferFileOwnership) {\r\n                client.TrackedDocuments.forEach(document => this.transferOwnership(document, client));\r\n                client.TrackedDocuments.clear();\r\n            }\r\n            else {\r\n                this.languageClients.set(key, cpptools.createNullClient());\r\n            }\r\n            if (this.activeClient === client && this.activeDocument) {\r\n                this.activeClient = this.getClientFor(this.activeDocument.uri);\r\n                this.activeClient.activeDocumentChanged(this.activeDocument);\r\n            }\r\n            client.dispose();\r\n            return this.languageClients.get(key);\r\n        }\r\n        else {\r\n            console.assert(key, \"unable to locate language client\");\r\n            return null;\r\n        }\r\n    }\r\n    onDidChangeWorkspaceFolders(e) {\r\n        let folderCount = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders.length : 0;\r\n        if (folderCount > 1) {\r\n            telemetry.logLanguageServerEvent(\"workspaceFoldersChange\", { \"count\": folderCount.toString() });\r\n        }\r\n        if (e !== undefined) {\r\n            e.removed.forEach(folder => {\r\n                let path = util.asFolder(folder.uri);\r\n                let client = this.languageClients.get(path);\r\n                if (client) {\r\n                    this.languageClients.delete(path);\r\n                    client.TrackedDocuments.forEach(document => this.transferOwnership(document, client));\r\n                    client.TrackedDocuments.clear();\r\n                    if (this.activeClient === client && this.activeDocument) {\r\n                        this.activeClient = this.getClientFor(this.activeDocument.uri);\r\n                        this.activeClient.activeDocumentChanged(this.activeDocument);\r\n                    }\r\n                    client.dispose();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    transferOwnership(document, oldOwner) {\r\n        let newOwner = this.getClientFor(document.uri);\r\n        console.assert(newOwner !== oldOwner, \"'oldOwner' should not be in the list of clients to consider\");\r\n        newOwner.takeOwnership(document);\r\n    }\r\n    onDidOpenTextDocument(document) {\r\n        if (document.languageId === \"c\" || document.languageId === \"cpp\"\r\n            || document.languageId === \"json\" && document.uri.fsPath.endsWith(\"c_cpp_properties.json\")) {\r\n            this.getClientFor(document.uri);\r\n        }\r\n    }\r\n    getClientFor(uri) {\r\n        let folder = vscode.workspace.getWorkspaceFolder(uri);\r\n        if (!folder) {\r\n            return this.defaultClient;\r\n        }\r\n        else {\r\n            let key = util.asFolder(folder.uri);\r\n            if (!this.languageClients.has(key)) {\r\n                let newClient = cpptools.createClient(this, folder);\r\n                this.languageClients.set(key, newClient);\r\n                customProviders_1.getCustomConfigProviders().forEach(provider => newClient.onRegisterCustomConfigurationProvider(provider));\r\n            }\r\n            return this.languageClients.get(key);\r\n        }\r\n    }\r\n    onDidCloseTextDocument(document) {\r\n    }\r\n    dispose() {\r\n        let promises = [];\r\n        this.defaultClient = undefined;\r\n        this.languageClients.forEach(client => promises.push(client.dispose()));\r\n        this.languageClients.clear();\r\n        return Promise.all(promises).then(() => undefined);\r\n    }\r\n}\r\nexports.ClientCollection = ClientCollection;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvY2xpZW50Q29sbGVjdGlvbi50cy5qcyIsInNvdXJjZXMiOlsiLi4vLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvY2xpZW50Q29sbGVjdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XHJcbmNvbnN0IHRlbGVtZXRyeSA9IHJlcXVpcmUoXCIuLi90ZWxlbWV0cnlcIik7XHJcbmNvbnN0IGNwcHRvb2xzID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IGN1c3RvbVByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vY3VzdG9tUHJvdmlkZXJzXCIpO1xyXG5jb25zdCBkZWZhdWx0Q2xpZW50S2V5ID0gXCJAQGRlZmF1bHRAQFwiO1xyXG5jbGFzcyBDbGllbnRDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBsZXQga2V5ID0gZGVmYXVsdENsaWVudEtleTtcclxuICAgICAgICBpZiAodnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzICYmIHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBmb2xkZXIgPSB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnNbMF07XHJcbiAgICAgICAgICAgIGtleSA9IHV0aWwuYXNGb2xkZXIoZm9sZGVyLnVyaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50ID0gY3BwdG9vbHMuY3JlYXRlQ2xpZW50KHRoaXMsIGZvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudCA9IGNwcHRvb2xzLmNyZWF0ZUNsaWVudCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q2xpZW50ID0gdGhpcy5hY3RpdmVDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudHMuc2V0KGtleSwgdGhpcy5hY3RpdmVDbGllbnQpO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUud29ya3NwYWNlLm9uRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyhlID0+IHRoaXMub25EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzKGUpKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKHZzY29kZS53b3Jrc3BhY2Uub25EaWRPcGVuVGV4dERvY3VtZW50KGQgPT4gdGhpcy5vbkRpZE9wZW5UZXh0RG9jdW1lbnQoZCkpKTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2godnNjb2RlLndvcmtzcGFjZS5vbkRpZENsb3NlVGV4dERvY3VtZW50KGQgPT4gdGhpcy5vbkRpZENsb3NlVGV4dERvY3VtZW50KGQpKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgQWN0aXZlQ2xpZW50KCkgeyByZXR1cm4gdGhpcy5hY3RpdmVDbGllbnQ7IH1cclxuICAgIGdldCBOYW1lcygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudHMuZm9yRWFjaCgoY2xpZW50LCBrZXkpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBjbGllbnQuTmFtZSwga2V5OiBrZXkgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldCBDb3VudCgpIHsgcmV0dXJuIHRoaXMubGFuZ3VhZ2VDbGllbnRzLnNpemU7IH1cclxuICAgIGFjdGl2ZURvY3VtZW50Q2hhbmdlZChkb2N1bWVudCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgICAgICBsZXQgYWN0aXZlQ2xpZW50ID0gdGhpcy5nZXRDbGllbnRGb3IoZG9jdW1lbnQudXJpKTtcclxuICAgICAgICBhY3RpdmVDbGllbnQuYWN0aXZlRG9jdW1lbnRDaGFuZ2VkKGRvY3VtZW50KTtcclxuICAgICAgICBpZiAoYWN0aXZlQ2xpZW50ICE9PSB0aGlzLmFjdGl2ZUNsaWVudCkge1xyXG4gICAgICAgICAgICBhY3RpdmVDbGllbnQuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVDbGllbnQuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudCA9IGFjdGl2ZUNsaWVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VDbGllbnRzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlQ2xpZW50cy5nZXQoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoXCJrZXkgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDbGllbnRzLmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgY2hlY2tPd25lcnNoaXAoY2xpZW50LCBkb2N1bWVudCkge1xyXG4gICAgICAgIGxldCBvd25lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmxhbmd1YWdlQ2xpZW50cy5mb3JFYWNoKGxhbmd1YWdlQ2xpZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnVyaS5mc1BhdGguc3RhcnRzV2l0aChsYW5ndWFnZUNsaWVudC5Sb290UGF0aCArIHBhdGguc2VwKSkge1xyXG4gICAgICAgICAgICAgICAgb3duZXJzLnB1c2gobGFuZ3VhZ2VDbGllbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG93bmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgb3duZXJzLnB1c2godGhpcy5hY3RpdmVDbGllbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKG93bmVyc1swXSA9PT0gY2xpZW50KTtcclxuICAgIH1cclxuICAgIHJlcGxhY2UoY2xpZW50LCB0cmFuc2ZlckZpbGVPd25lcnNoaXApIHtcclxuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAobGV0IHBhaXIgb2YgdGhpcy5sYW5ndWFnZUNsaWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKHBhaXJbMV0gPT09IGNsaWVudCkge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gcGFpclswXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudHMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckZpbGVPd25lcnNoaXApIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudC5UcmFja2VkRG9jdW1lbnRzLmZvckVhY2goZG9jdW1lbnQgPT4gdGhpcy50cmFuc2Zlck93bmVyc2hpcChkb2N1bWVudCwgY2xpZW50KSk7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQuVHJhY2tlZERvY3VtZW50cy5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudHMuc2V0KGtleSwgY3BwdG9vbHMuY3JlYXRlTnVsbENsaWVudCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVDbGllbnQgPT09IGNsaWVudCAmJiB0aGlzLmFjdGl2ZURvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50Rm9yKHRoaXMuYWN0aXZlRG9jdW1lbnQudXJpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50LmFjdGl2ZURvY3VtZW50Q2hhbmdlZCh0aGlzLmFjdGl2ZURvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbGllbnQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZUNsaWVudHMuZ2V0KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChrZXksIFwidW5hYmxlIHRvIGxvY2F0ZSBsYW5ndWFnZSBjbGllbnRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyhlKSB7XHJcbiAgICAgICAgbGV0IGZvbGRlckNvdW50ID0gdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzID8gdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgaWYgKGZvbGRlckNvdW50ID4gMSkge1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcIndvcmtzcGFjZUZvbGRlcnNDaGFuZ2VcIiwgeyBcImNvdW50XCI6IGZvbGRlckNvdW50LnRvU3RyaW5nKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZS5yZW1vdmVkLmZvckVhY2goZm9sZGVyID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gdXRpbC5hc0ZvbGRlcihmb2xkZXIudXJpKTtcclxuICAgICAgICAgICAgICAgIGxldCBjbGllbnQgPSB0aGlzLmxhbmd1YWdlQ2xpZW50cy5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW5ndWFnZUNsaWVudHMuZGVsZXRlKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5UcmFja2VkRG9jdW1lbnRzLmZvckVhY2goZG9jdW1lbnQgPT4gdGhpcy50cmFuc2Zlck93bmVyc2hpcChkb2N1bWVudCwgY2xpZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LlRyYWNrZWREb2N1bWVudHMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVDbGllbnQgPT09IGNsaWVudCAmJiB0aGlzLmFjdGl2ZURvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50ID0gdGhpcy5nZXRDbGllbnRGb3IodGhpcy5hY3RpdmVEb2N1bWVudC51cmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudC5hY3RpdmVEb2N1bWVudENoYW5nZWQodGhpcy5hY3RpdmVEb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyYW5zZmVyT3duZXJzaGlwKGRvY3VtZW50LCBvbGRPd25lcikge1xyXG4gICAgICAgIGxldCBuZXdPd25lciA9IHRoaXMuZ2V0Q2xpZW50Rm9yKGRvY3VtZW50LnVyaSk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQobmV3T3duZXIgIT09IG9sZE93bmVyLCBcIidvbGRPd25lcicgc2hvdWxkIG5vdCBiZSBpbiB0aGUgbGlzdCBvZiBjbGllbnRzIHRvIGNvbnNpZGVyXCIpO1xyXG4gICAgICAgIG5ld093bmVyLnRha2VPd25lcnNoaXAoZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgb25EaWRPcGVuVGV4dERvY3VtZW50KGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50Lmxhbmd1YWdlSWQgPT09IFwiY1wiIHx8IGRvY3VtZW50Lmxhbmd1YWdlSWQgPT09IFwiY3BwXCJcclxuICAgICAgICAgICAgfHwgZG9jdW1lbnQubGFuZ3VhZ2VJZCA9PT0gXCJqc29uXCIgJiYgZG9jdW1lbnQudXJpLmZzUGF0aC5lbmRzV2l0aChcImNfY3BwX3Byb3BlcnRpZXMuanNvblwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldENsaWVudEZvcihkb2N1bWVudC51cmkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENsaWVudEZvcih1cmkpIHtcclxuICAgICAgICBsZXQgZm9sZGVyID0gdnNjb2RlLndvcmtzcGFjZS5nZXRXb3Jrc3BhY2VGb2xkZXIodXJpKTtcclxuICAgICAgICBpZiAoIWZvbGRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Q2xpZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGtleSA9IHV0aWwuYXNGb2xkZXIoZm9sZGVyLnVyaSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5sYW5ndWFnZUNsaWVudHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDbGllbnQgPSBjcHB0b29scy5jcmVhdGVDbGllbnQodGhpcywgZm9sZGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFuZ3VhZ2VDbGllbnRzLnNldChrZXksIG5ld0NsaWVudCk7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKS5mb3JFYWNoKHByb3ZpZGVyID0+IG5ld0NsaWVudC5vblJlZ2lzdGVyQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyKHByb3ZpZGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VDbGllbnRzLmdldChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGlkQ2xvc2VUZXh0RG9jdW1lbnQoZG9jdW1lbnQpIHtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q2xpZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHByb21pc2VzLnB1c2goY2xpZW50LmRpc3Bvc2UoKSkpO1xyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDbGllbnRzLmNsZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbGllbnRDb2xsZWN0aW9uID0gQ2xpZW50Q29sbGVjdGlvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/clientCollection.ts\n");

/***/ }),

/***/ "./src/LanguageServer/configurations.ts":
/*!**********************************************!*\
  !*** ./src/LanguageServer/configurations.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nconst persistentState_1 = __webpack_require__(/*! ./persistentState */ \"./src/LanguageServer/persistentState.ts\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/LanguageServer/settings.ts\");\r\nconst abTesting_1 = __webpack_require__(/*! ../abTesting */ \"./src/abTesting.ts\");\r\nconst customProviders_1 = __webpack_require__(/*! ./customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst configVersion = 4;\r\nfunction getDefaultConfig() {\r\n    if (process.platform === 'darwin') {\r\n        return { name: \"Mac\" };\r\n    }\r\n    else if (process.platform === 'win32') {\r\n        return { name: \"Win32\" };\r\n    }\r\n    else {\r\n        return { name: \"Linux\" };\r\n    }\r\n}\r\nfunction getDefaultCppProperties() {\r\n    return {\r\n        configurations: [getDefaultConfig()],\r\n        version: configVersion\r\n    };\r\n}\r\nclass CppProperties {\r\n    constructor(rootUri) {\r\n        this.propertiesFile = undefined;\r\n        this.configurationJson = null;\r\n        this.configFileWatcher = null;\r\n        this.configFileWatcherFallbackTime = new Date();\r\n        this.compileCommandFileWatchers = [];\r\n        this.defaultCompilerPath = null;\r\n        this.knownCompilers = null;\r\n        this.defaultCStandard = null;\r\n        this.defaultCppStandard = null;\r\n        this.defaultIncludes = null;\r\n        this.defaultFrameworks = null;\r\n        this.defaultWindowsSdkVersion = null;\r\n        this.vcpkgIncludes = [];\r\n        this.vcpkgPathReady = false;\r\n        this.defaultIntelliSenseMode = null;\r\n        this.configurationGlobPattern = \"c_cpp_properties.json\";\r\n        this.disposables = [];\r\n        this.configurationsChanged = new vscode.EventEmitter();\r\n        this.selectionChanged = new vscode.EventEmitter();\r\n        this.compileCommandsChanged = new vscode.EventEmitter();\r\n        this.prevSquiggleMetrics = new Map();\r\n        this.rootfs = null;\r\n        this.configurationIncomplete = true;\r\n        console.assert(rootUri !== undefined);\r\n        this.rootUri = rootUri;\r\n        let rootPath = rootUri ? rootUri.fsPath : \"\";\r\n        this.currentConfigurationIndex = new persistentState_1.PersistentFolderState(\"CppProperties.currentConfigurationIndex\", -1, rootPath);\r\n        this.configFolder = path.join(rootPath, \".vscode\");\r\n        this.diagnosticCollection = vscode.languages.createDiagnosticCollection(rootPath);\r\n        this.buildVcpkgIncludePath();\r\n        this.disposables.push(vscode.Disposable.from(this.configurationsChanged, this.selectionChanged, this.compileCommandsChanged));\r\n    }\r\n    get ConfigurationsChanged() { return this.configurationsChanged.event; }\r\n    get SelectionChanged() { return this.selectionChanged.event; }\r\n    get CompileCommandsChanged() { return this.compileCommandsChanged.event; }\r\n    get Configurations() { return this.configurationJson ? this.configurationJson.configurations : null; }\r\n    get CurrentConfigurationIndex() { return this.currentConfigurationIndex.Value; }\r\n    get CurrentConfiguration() { return this.Configurations ? this.Configurations[this.CurrentConfigurationIndex] : null; }\r\n    get CompilerPath() { return this.CurrentConfiguration ? this.CurrentConfiguration.compilerPath : null; }\r\n    get KnownCompiler() { return this.knownCompilers; }\r\n    get CurrentConfigurationProvider() {\r\n        if (this.CurrentConfiguration.configurationProvider) {\r\n            return this.CurrentConfiguration.configurationProvider;\r\n        }\r\n        return new settings_1.CppSettings(this.rootUri).defaultConfigurationProvider;\r\n    }\r\n    get ConfigurationNames() {\r\n        let result = [];\r\n        this.configurationJson.configurations.forEach((config) => result.push(config.name));\r\n        return result;\r\n    }\r\n    set CompilerDefaults(compilerDefaults) {\r\n        this.defaultCompilerPath = compilerDefaults.compilerPath;\r\n        this.knownCompilers = compilerDefaults.knownCompilers;\r\n        this.defaultCStandard = compilerDefaults.cStandard;\r\n        this.defaultCppStandard = compilerDefaults.cppStandard;\r\n        this.defaultIncludes = compilerDefaults.includes;\r\n        this.defaultFrameworks = compilerDefaults.frameworks;\r\n        this.defaultWindowsSdkVersion = compilerDefaults.windowsSdkVersion;\r\n        this.defaultIntelliSenseMode = compilerDefaults.intelliSenseMode;\r\n        this.rootfs = compilerDefaults.rootfs;\r\n        let configFilePath = path.join(this.configFolder, \"c_cpp_properties.json\");\r\n        if (fs.existsSync(configFilePath)) {\r\n            this.propertiesFile = vscode.Uri.file(configFilePath);\r\n        }\r\n        else {\r\n            this.propertiesFile = null;\r\n        }\r\n        this.configFileWatcher = vscode.workspace.createFileSystemWatcher(path.join(this.configFolder, this.configurationGlobPattern));\r\n        this.disposables.push(this.configFileWatcher);\r\n        this.configFileWatcher.onDidCreate((uri) => {\r\n            this.propertiesFile = uri;\r\n            this.handleConfigurationChange();\r\n        });\r\n        this.configFileWatcher.onDidDelete(() => {\r\n            this.propertiesFile = null;\r\n            this.resetToDefaultSettings(true);\r\n            this.handleConfigurationChange();\r\n        });\r\n        this.configFileWatcher.onDidChange(() => {\r\n            this.handleConfigurationChange();\r\n        });\r\n        this.handleConfigurationChange();\r\n    }\r\n    get VcpkgInstalled() {\r\n        return this.vcpkgIncludes.length > 0;\r\n    }\r\n    onConfigurationsChanged() {\r\n        this.configurationsChanged.fire(this.Configurations);\r\n    }\r\n    onSelectionChanged() {\r\n        this.selectionChanged.fire(this.CurrentConfigurationIndex);\r\n        this.handleSquiggles();\r\n    }\r\n    onCompileCommandsChanged(path) {\r\n        this.compileCommandsChanged.fire(path);\r\n    }\r\n    onDidChangeSettings() {\r\n        if (!this.propertiesFile) {\r\n            this.resetToDefaultSettings(true);\r\n            this.handleConfigurationChange();\r\n        }\r\n        else if (!this.configurationIncomplete) {\r\n            this.handleConfigurationChange();\r\n        }\r\n    }\r\n    resetToDefaultSettings(resetIndex) {\r\n        this.configurationJson = getDefaultCppProperties();\r\n        if (resetIndex || this.CurrentConfigurationIndex < 0 ||\r\n            this.CurrentConfigurationIndex >= this.configurationJson.configurations.length) {\r\n            this.currentConfigurationIndex.Value = this.getConfigIndexForPlatform(this.configurationJson);\r\n        }\r\n        this.configurationIncomplete = true;\r\n    }\r\n    applyDefaultIncludePathsAndFrameworks() {\r\n        if (this.configurationIncomplete && this.defaultIncludes && this.defaultFrameworks && this.vcpkgPathReady) {\r\n            let configuration = this.CurrentConfiguration;\r\n            let settings = new settings_1.CppSettings(this.rootUri);\r\n            let isUnset = (input) => {\r\n                return input === null;\r\n            };\r\n            if (isUnset(settings.defaultIncludePath)) {\r\n                let abTestSettings = abTesting_1.getABTestSettings();\r\n                let rootFolder = abTestSettings.UseRecursiveIncludes ? \"${workspaceFolder}/**\" : \"${workspaceFolder}\";\r\n                configuration.includePath = [rootFolder].concat(this.vcpkgIncludes);\r\n            }\r\n            if (isUnset(settings.defaultDefines)) {\r\n                configuration.defines = (process.platform === 'win32') ? [\"_DEBUG\", \"UNICODE\", \"_UNICODE\"] : [];\r\n            }\r\n            if (isUnset(settings.defaultMacFrameworkPath) && process.platform === 'darwin') {\r\n                configuration.macFrameworkPath = this.defaultFrameworks;\r\n            }\r\n            if (isUnset(settings.defaultWindowsSdkVersion) && this.defaultWindowsSdkVersion && process.platform === 'win32') {\r\n                configuration.windowsSdkVersion = this.defaultWindowsSdkVersion;\r\n            }\r\n            if (isUnset(settings.defaultCompilerPath) && this.defaultCompilerPath &&\r\n                isUnset(settings.defaultCompileCommands) && !configuration.compileCommands) {\r\n                configuration.compilerPath = this.defaultCompilerPath;\r\n            }\r\n            if (this.knownCompilers) {\r\n                configuration.knownCompilers = this.knownCompilers;\r\n            }\r\n            if (isUnset(settings.defaultCStandard) && this.defaultCStandard) {\r\n                configuration.cStandard = this.defaultCStandard;\r\n            }\r\n            if (isUnset(settings.defaultCppStandard) && this.defaultCppStandard) {\r\n                configuration.cppStandard = this.defaultCppStandard;\r\n            }\r\n            if (isUnset(settings.defaultIntelliSenseMode)) {\r\n                configuration.intelliSenseMode = this.defaultIntelliSenseMode;\r\n            }\r\n            this.configurationIncomplete = false;\r\n        }\r\n    }\r\n    get ExtendedEnvironment() {\r\n        let result = {};\r\n        if (this.configurationJson.env) {\r\n            Object.assign(result, this.configurationJson.env);\r\n        }\r\n        result[\"workspaceFolderBasename\"] = this.rootUri ? path.basename(this.rootUri.fsPath) : \"\";\r\n        return result;\r\n    }\r\n    buildVcpkgIncludePath() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                let vcpkgRoot = util.getVcpkgRoot();\r\n                if (vcpkgRoot) {\r\n                    let list = yield util.readDir(vcpkgRoot);\r\n                    if (list !== undefined) {\r\n                        list.forEach((entry) => {\r\n                            if (entry !== \"vcpkg\") {\r\n                                let pathToCheck = path.join(vcpkgRoot, entry);\r\n                                if (fs.existsSync(pathToCheck)) {\r\n                                    let p = path.join(pathToCheck, \"include\");\r\n                                    if (fs.existsSync(p)) {\r\n                                        p = p.replace(/\\\\/g, \"/\");\r\n                                        p = p.replace(vcpkgRoot, \"${vcpkgRoot}\");\r\n                                        this.vcpkgIncludes.push(p);\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            catch (error) { }\r\n            finally {\r\n                this.vcpkgPathReady = true;\r\n                this.handleConfigurationChange();\r\n            }\r\n        });\r\n    }\r\n    getConfigIndexForPlatform(config) {\r\n        let plat;\r\n        if (process.platform === 'darwin') {\r\n            plat = \"Mac\";\r\n        }\r\n        else if (process.platform === 'win32') {\r\n            plat = \"Win32\";\r\n        }\r\n        else {\r\n            plat = \"Linux\";\r\n        }\r\n        for (let i = 0; i < this.configurationJson.configurations.length; i++) {\r\n            if (config.configurations[i].name === plat) {\r\n                return i;\r\n            }\r\n        }\r\n        return this.configurationJson.configurations.length - 1;\r\n    }\r\n    getIntelliSenseModeForPlatform(name) {\r\n        if (name === \"Linux\") {\r\n            return \"gcc-x64\";\r\n        }\r\n        else if (name === \"Mac\") {\r\n            return \"clang-x64\";\r\n        }\r\n        else if (name === \"Win32\") {\r\n            return \"msvc-x64\";\r\n        }\r\n        else if (process.platform === 'win32') {\r\n            return \"msvc-x64\";\r\n        }\r\n        else if (process.platform === 'darwin') {\r\n            return \"clang-x64\";\r\n        }\r\n        else {\r\n            return \"gcc-x64\";\r\n        }\r\n    }\r\n    addToIncludePathCommand(path) {\r\n        this.handleConfigurationEditCommand((document) => {\r\n            telemetry.logLanguageServerEvent(\"addToIncludePath\");\r\n            this.parsePropertiesFile();\r\n            let config = this.CurrentConfiguration;\r\n            if (config.includePath === undefined) {\r\n                config.includePath = [\"${default}\"];\r\n            }\r\n            config.includePath.splice(config.includePath.length, 0, path);\r\n            fs.writeFileSync(this.propertiesFile.fsPath, JSON.stringify(this.configurationJson, null, 4));\r\n            this.handleConfigurationChange();\r\n        });\r\n    }\r\n    updateCustomConfigurationProvider(providerId) {\r\n        return new Promise((resolve) => {\r\n            if (this.propertiesFile) {\r\n                this.handleConfigurationEditCommand((document) => {\r\n                    this.parsePropertiesFile();\r\n                    let config = this.CurrentConfiguration;\r\n                    if (providerId) {\r\n                        config.configurationProvider = providerId;\r\n                    }\r\n                    else {\r\n                        delete config.configurationProvider;\r\n                    }\r\n                    fs.writeFileSync(this.propertiesFile.fsPath, JSON.stringify(this.configurationJson, null, 4));\r\n                    this.handleConfigurationChange();\r\n                    resolve();\r\n                });\r\n            }\r\n            else {\r\n                let settings = new settings_1.CppSettings(this.rootUri);\r\n                if (providerId) {\r\n                    settings.update(\"default.configurationProvider\", providerId);\r\n                }\r\n                else {\r\n                    settings.update(\"default.configurationProvider\", undefined);\r\n                }\r\n                this.CurrentConfiguration.configurationProvider = providerId;\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    setCompileCommands(path) {\r\n        this.handleConfigurationEditCommand((document) => {\r\n            this.parsePropertiesFile();\r\n            let config = this.CurrentConfiguration;\r\n            config.compileCommands = path;\r\n            fs.writeFileSync(this.propertiesFile.fsPath, JSON.stringify(this.configurationJson, null, 4));\r\n            this.handleConfigurationChange();\r\n        });\r\n    }\r\n    select(index) {\r\n        if (index === this.configurationJson.configurations.length) {\r\n            this.handleConfigurationEditCommand(vscode.window.showTextDocument);\r\n            return;\r\n        }\r\n        this.currentConfigurationIndex.Value = index;\r\n        this.onSelectionChanged();\r\n    }\r\n    resolveDefaults(entries, defaultValue) {\r\n        let result = [];\r\n        entries.forEach(entry => {\r\n            if (entry === \"${default}\") {\r\n                if (defaultValue !== null) {\r\n                    result = result.concat(defaultValue);\r\n                }\r\n            }\r\n            else {\r\n                result.push(entry);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    resolveAndSplit(paths, defaultValue, env) {\r\n        let result = [];\r\n        if (paths) {\r\n            paths.forEach(entry => {\r\n                let entries = util.resolveVariables(entry, env).split(\";\").filter(e => e);\r\n                entries = this.resolveDefaults(entries, defaultValue);\r\n                result = result.concat(entries);\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    resolveVariables(input, defaultValue, env) {\r\n        if (input === undefined || input === \"${default}\") {\r\n            input = defaultValue;\r\n        }\r\n        if (typeof input === \"boolean\") {\r\n            return input;\r\n        }\r\n        return util.resolveVariables(input, env);\r\n    }\r\n    updateConfiguration(property, defaultValue, env) {\r\n        if (util.isString(property) || util.isString(defaultValue)) {\r\n            return this.resolveVariables(property, defaultValue, env);\r\n        }\r\n        else if (util.isBoolean(property) || util.isBoolean(defaultValue)) {\r\n            return this.resolveVariables(property, defaultValue, env);\r\n        }\r\n        else if (util.isArrayOfString(property) || util.isArrayOfString(defaultValue)) {\r\n            if (property) {\r\n                return this.resolveAndSplit(property, defaultValue, env);\r\n            }\r\n            else if (property === undefined && defaultValue) {\r\n                return this.resolveAndSplit(defaultValue, [], env);\r\n            }\r\n        }\r\n        return property;\r\n    }\r\n    updateServerOnFolderSettingsChange() {\r\n        if (!this.configurationJson) {\r\n            return;\r\n        }\r\n        let settings = new settings_1.CppSettings(this.rootUri);\r\n        let env = this.ExtendedEnvironment;\r\n        for (let i = 0; i < this.configurationJson.configurations.length; i++) {\r\n            let configuration = this.configurationJson.configurations[i];\r\n            configuration.includePath = this.updateConfiguration(configuration.includePath, settings.defaultIncludePath, env);\r\n            configuration.defines = this.updateConfiguration(configuration.defines, settings.defaultDefines, env);\r\n            configuration.macFrameworkPath = this.updateConfiguration(configuration.macFrameworkPath, settings.defaultMacFrameworkPath, env);\r\n            configuration.windowsSdkVersion = this.updateConfiguration(configuration.windowsSdkVersion, settings.defaultWindowsSdkVersion, env);\r\n            configuration.forcedInclude = this.updateConfiguration(configuration.forcedInclude, settings.defaultForcedInclude, env);\r\n            configuration.compileCommands = this.updateConfiguration(configuration.compileCommands, settings.defaultCompileCommands, env);\r\n            configuration.compilerPath = this.updateConfiguration(configuration.compilerPath, settings.defaultCompilerPath, env);\r\n            configuration.cStandard = this.updateConfiguration(configuration.cStandard, settings.defaultCStandard, env);\r\n            configuration.cppStandard = this.updateConfiguration(configuration.cppStandard, settings.defaultCppStandard, env);\r\n            configuration.intelliSenseMode = this.updateConfiguration(configuration.intelliSenseMode, settings.defaultIntelliSenseMode, env);\r\n            configuration.configurationProvider = this.updateConfiguration(configuration.configurationProvider, settings.defaultConfigurationProvider, env);\r\n            if (!configuration.browse) {\r\n                configuration.browse = {};\r\n            }\r\n            if (!configuration.browse.path) {\r\n                if (settings.defaultBrowsePath) {\r\n                    configuration.browse.path = settings.defaultBrowsePath;\r\n                }\r\n                else if (configuration.includePath) {\r\n                    configuration.browse.path = configuration.includePath.slice(0);\r\n                    if (-1 === configuration.includePath.findIndex((value, index) => {\r\n                        return !!value.match(/^\\$\\{(workspaceRoot|workspaceFolder)\\}(\\\\\\*{0,2}|\\/\\*{0,2})?$/g);\r\n                    })) {\r\n                        configuration.browse.path.push(\"${workspaceFolder}\");\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                configuration.browse.path = this.updateConfiguration(configuration.browse.path, settings.defaultBrowsePath, env);\r\n            }\r\n            configuration.browse.limitSymbolsToIncludedHeaders = this.updateConfiguration(configuration.browse.limitSymbolsToIncludedHeaders, settings.defaultLimitSymbolsToIncludedHeaders, env);\r\n            configuration.browse.databaseFilename = this.updateConfiguration(configuration.browse.databaseFilename, settings.defaultDatabaseFilename, env);\r\n        }\r\n        this.updateCompileCommandsFileWatchers();\r\n        if (!this.configurationIncomplete) {\r\n            this.onConfigurationsChanged();\r\n        }\r\n    }\r\n    updateCompileCommandsFileWatchers() {\r\n        this.compileCommandFileWatchers.forEach((watcher) => watcher.close());\r\n        this.compileCommandFileWatchers = [];\r\n        let filePaths = new Set();\r\n        this.configurationJson.configurations.forEach(c => {\r\n            if (c.compileCommands !== undefined && fs.existsSync(c.compileCommands)) {\r\n                filePaths.add(c.compileCommands);\r\n            }\r\n        });\r\n        try {\r\n            filePaths.forEach((path) => {\r\n                this.compileCommandFileWatchers.push(fs.watch(path, (event, filename) => {\r\n                    if (event !== \"rename\") {\r\n                        this.onCompileCommandsChanged(path);\r\n                    }\r\n                }));\r\n            });\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    handleConfigurationEditCommand(onSuccess) {\r\n        if (this.propertiesFile && fs.existsSync(this.propertiesFile.fsPath)) {\r\n            vscode.workspace.openTextDocument(this.propertiesFile).then((document) => {\r\n                onSuccess(document);\r\n            });\r\n        }\r\n        else {\r\n            fs.mkdir(this.configFolder, (e) => {\r\n                if (!e || e.code === 'EEXIST') {\r\n                    let fullPathToFile = path.join(this.configFolder, \"c_cpp_properties.json\");\r\n                    let filePath = vscode.Uri.file(fullPathToFile).with({ scheme: \"untitled\" });\r\n                    vscode.workspace.openTextDocument(filePath).then((document) => {\r\n                        let edit = new vscode.WorkspaceEdit();\r\n                        if (this.configurationJson) {\r\n                            this.resetToDefaultSettings(true);\r\n                        }\r\n                        this.applyDefaultIncludePathsAndFrameworks();\r\n                        let settings = new settings_1.CppSettings(this.rootUri);\r\n                        if (settings.defaultConfigurationProvider) {\r\n                            this.configurationJson.configurations.forEach(config => {\r\n                                config.configurationProvider = settings.defaultConfigurationProvider;\r\n                            });\r\n                            settings.update(\"default.configurationProvider\", undefined);\r\n                        }\r\n                        let savedKnownCompilers = this.configurationJson.configurations[0].knownCompilers;\r\n                        delete this.configurationJson.configurations[0].knownCompilers;\r\n                        edit.insert(document.uri, new vscode.Position(0, 0), JSON.stringify(this.configurationJson, null, 4));\r\n                        this.configurationJson.configurations[0].knownCompilers = savedKnownCompilers;\r\n                        vscode.workspace.applyEdit(edit).then((status) => {\r\n                            document.save().then(() => {\r\n                                this.propertiesFile = vscode.Uri.file(path.join(this.configFolder, \"c_cpp_properties.json\"));\r\n                                vscode.workspace.openTextDocument(this.propertiesFile).then((document) => {\r\n                                    onSuccess(document);\r\n                                });\r\n                            });\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    handleConfigurationChange() {\r\n        if (this.propertiesFile === undefined) {\r\n            return;\r\n        }\r\n        this.configFileWatcherFallbackTime = new Date();\r\n        if (this.propertiesFile) {\r\n            this.parsePropertiesFile();\r\n            if (this.configurationJson) {\r\n                if (this.CurrentConfigurationIndex < 0 ||\r\n                    this.CurrentConfigurationIndex >= this.configurationJson.configurations.length) {\r\n                    this.currentConfigurationIndex.Value = this.getConfigIndexForPlatform(this.configurationJson);\r\n                }\r\n            }\r\n        }\r\n        if (!this.configurationJson) {\r\n            this.resetToDefaultSettings(true);\r\n        }\r\n        this.applyDefaultIncludePathsAndFrameworks();\r\n        this.updateServerOnFolderSettingsChange();\r\n    }\r\n    parsePropertiesFile() {\r\n        try {\r\n            let readResults = fs.readFileSync(this.propertiesFile.fsPath, 'utf8');\r\n            if (readResults === \"\") {\r\n                return;\r\n            }\r\n            readResults = readResults.replace(/\\\\/g, '\\\\\\\\');\r\n            readResults = readResults.replace(/\\\\\\\\\"/g, '\\\\\"');\r\n            let newJson = JSON.parse(readResults);\r\n            if (!newJson || !newJson.configurations || newJson.configurations.length === 0) {\r\n                throw { message: \"Invalid configuration file. There must be at least one configuration present in the array.\" };\r\n            }\r\n            if (!this.configurationIncomplete && this.configurationJson && this.configurationJson.configurations &&\r\n                this.CurrentConfigurationIndex >= 0 && this.CurrentConfigurationIndex < this.configurationJson.configurations.length) {\r\n                for (let i = 0; i < newJson.configurations.length; i++) {\r\n                    if (newJson.configurations[i].name === this.configurationJson.configurations[this.CurrentConfigurationIndex].name) {\r\n                        this.currentConfigurationIndex.Value = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.configurationJson = newJson;\r\n            if (this.CurrentConfigurationIndex < 0 || this.CurrentConfigurationIndex >= newJson.configurations.length) {\r\n                this.currentConfigurationIndex.Value = this.getConfigIndexForPlatform(newJson);\r\n            }\r\n            let dirty = false;\r\n            for (let i = 0; i < this.configurationJson.configurations.length; i++) {\r\n                let newId = customProviders_1.getCustomConfigProviders().checkId(this.configurationJson.configurations[i].configurationProvider);\r\n                if (newId !== this.configurationJson.configurations[i].configurationProvider) {\r\n                    dirty = true;\r\n                    this.configurationJson.configurations[i].configurationProvider = newId;\r\n                }\r\n            }\r\n            if (this.configurationJson.env) {\r\n                delete this.configurationJson.env['workspaceRoot'];\r\n                delete this.configurationJson.env['workspaceFolder'];\r\n                delete this.configurationJson.env['workspaceFolderBasename'];\r\n                delete this.configurationJson.env['default'];\r\n            }\r\n            this.configurationIncomplete = false;\r\n            if (this.configurationJson.version !== configVersion) {\r\n                dirty = true;\r\n                if (this.configurationJson.version === undefined) {\r\n                    this.updateToVersion2();\r\n                }\r\n                if (this.configurationJson.version === 2) {\r\n                    this.updateToVersion3();\r\n                }\r\n                if (this.configurationJson.version === 3) {\r\n                    this.updateToVersion4();\r\n                }\r\n                else {\r\n                    this.configurationJson.version = configVersion;\r\n                    vscode.window.showErrorMessage('Unknown version number found in c_cpp_properties.json. Some features may not work as expected.');\r\n                }\r\n            }\r\n            if (dirty) {\r\n                try {\r\n                    fs.writeFileSync(this.propertiesFile.fsPath, JSON.stringify(this.configurationJson, null, 4));\r\n                }\r\n                catch (err) {\r\n                    vscode.window.showWarningMessage(`Attempt to update \"${this.propertiesFile.fsPath}\" failed (do you have write access?)`);\r\n                }\r\n            }\r\n            this.handleSquiggles();\r\n        }\r\n        catch (err) {\r\n            vscode.window.showErrorMessage(`Failed to parse \"${this.propertiesFile.fsPath}\": ${err.message}`);\r\n            throw err;\r\n        }\r\n    }\r\n    handleSquiggles() {\r\n        if (!this.propertiesFile) {\r\n            return;\r\n        }\r\n        vscode.workspace.openTextDocument(this.propertiesFile).then((document) => {\r\n            let diagnostics = new Array();\r\n            let curText = document.getText();\r\n            let curTextStartOffset = 0;\r\n            const configStart = curText.search(new RegExp(`{\\\\s*\"name\"\\\\s*:\\\\s*\"${this.CurrentConfiguration.name}\"`));\r\n            if (configStart === -1) {\r\n                telemetry.logLanguageServerEvent(\"ConfigSquiggles\", { \"error\": \"config name not first\" });\r\n                return;\r\n            }\r\n            curTextStartOffset = configStart + 1;\r\n            curText = curText.substr(curTextStartOffset);\r\n            const nameEnd = curText.indexOf(\":\");\r\n            curTextStartOffset += nameEnd + 1;\r\n            curText = curText.substr(nameEnd + 1);\r\n            const nextNameStart = curText.search(new RegExp('\"name\"\\\\s*:\\\\s*\"'));\r\n            if (nextNameStart !== -1) {\r\n                curText = curText.substr(0, nextNameStart + 6);\r\n                const nextNameStart2 = curText.search(new RegExp('\\\\s*}\\\\s*,\\\\s*{\\\\s*\"name\"'));\r\n                if (nextNameStart2 === -1) {\r\n                    telemetry.logLanguageServerEvent(\"ConfigSquiggles\", { \"error\": \"next config name not first\" });\r\n                    return;\r\n                }\r\n                curText = curText.substr(0, nextNameStart2);\r\n            }\r\n            let paths = new Set();\r\n            for (let pathArray of [(this.CurrentConfiguration.browse ? this.CurrentConfiguration.browse.path : undefined),\r\n                this.CurrentConfiguration.includePath, this.CurrentConfiguration.macFrameworkPath, this.CurrentConfiguration.forcedInclude]) {\r\n                if (pathArray) {\r\n                    for (let curPath of pathArray) {\r\n                        paths.add(`\"${curPath}\"`);\r\n                    }\r\n                }\r\n            }\r\n            if (this.CurrentConfiguration.compileCommands) {\r\n                paths.add(`\"${this.CurrentConfiguration.compileCommands}\"`);\r\n            }\r\n            const isWindows = os.platform() === 'win32';\r\n            if (this.CurrentConfiguration.compilerPath) {\r\n                let compilerPathAndArgs;\r\n                compilerPathAndArgs = util.extractCompilerPathAndArgs(this.CurrentConfiguration.compilerPath);\r\n                if (!(isWindows && compilerPathAndArgs.compilerPath.endsWith(\"cl.exe\"))) {\r\n                    paths.add(`${compilerPathAndArgs.compilerPath}`);\r\n                }\r\n            }\r\n            const forcedIncludeStart = curText.search(/\\s*\\\"forcedInclude\\\"\\s*:\\s*\\[/);\r\n            const forcedeIncludeEnd = forcedIncludeStart === -1 ? -1 : curText.indexOf(\"]\", forcedIncludeStart);\r\n            const compileCommandsStart = curText.search(/\\s*\\\"compileCommands\\\"\\s*:\\s*\\\"/);\r\n            const compileCommandsEnd = compileCommandsStart === -1 ? -1 : curText.indexOf('\"', curText.indexOf('\"', curText.indexOf(\":\", compileCommandsStart)) + 1);\r\n            const compilerPathStart = curText.search(/\\s*\\\"compilerPath\\\"\\s*:\\s*\\\"/);\r\n            const compilerPathEnd = compilerPathStart === -1 ? -1 : curText.indexOf('\"', curText.indexOf('\"', curText.indexOf(\":\", compilerPathStart)) + 1) + 1;\r\n            if (this.prevSquiggleMetrics[this.CurrentConfiguration.name] === undefined) {\r\n                this.prevSquiggleMetrics[this.CurrentConfiguration.name] = { PathNonExistent: 0, PathNotAFile: 0, PathNotADirectory: 0 };\r\n            }\r\n            let newSquiggleMetrics = { PathNonExistent: 0, PathNotAFile: 0, PathNotADirectory: 0 };\r\n            for (let curPath of paths) {\r\n                const isCompilerPath = !curPath.startsWith('\"');\r\n                let resolvedPath = curPath.substr((!isCompilerPath ? 1 : 0), curPath.length + (!isCompilerPath ? -2 : 0));\r\n                if (resolvedPath === \"${default}\") {\r\n                    continue;\r\n                }\r\n                resolvedPath = util.resolveVariables(resolvedPath, this.ExtendedEnvironment);\r\n                if (resolvedPath.includes(\"${workspaceFolder}\")) {\r\n                    resolvedPath = resolvedPath.replace(\"${workspaceFolder}\", this.rootUri.fsPath);\r\n                }\r\n                if (resolvedPath.includes(\"${workspaceRoot}\")) {\r\n                    resolvedPath = resolvedPath.replace(\"${workspaceRoot}\", this.rootUri.fsPath);\r\n                }\r\n                if (resolvedPath.includes(\"${vcpkgRoot}\")) {\r\n                    resolvedPath = resolvedPath.replace(\"${vcpkgRoot}\", util.getVcpkgRoot());\r\n                }\r\n                if (resolvedPath.includes(\"*\")) {\r\n                    resolvedPath = resolvedPath.replace(/\\*/g, \"\");\r\n                }\r\n                const isWSL = isWindows && resolvedPath.startsWith(\"/\");\r\n                if (isWSL) {\r\n                    const mntStr = \"/mnt/\";\r\n                    if (resolvedPath.length > \"/mnt/c/\".length && resolvedPath.substr(0, mntStr.length) === mntStr) {\r\n                        resolvedPath = resolvedPath.substr(mntStr.length);\r\n                        resolvedPath = resolvedPath.substr(0, 1) + \":\" + resolvedPath.substr(1);\r\n                    }\r\n                    else if (this.rootfs && this.rootfs.length > 0) {\r\n                        resolvedPath = this.rootfs + resolvedPath.substr(1);\r\n                        resolvedPath = resolvedPath.replace(/\\//g, path.sep);\r\n                    }\r\n                }\r\n                let pathExists = true;\r\n                let existsWithExeAdded = (path) => {\r\n                    return isCompilerPath && isWindows && !isWSL && fs.existsSync(path + \".exe\");\r\n                };\r\n                if (!fs.existsSync(resolvedPath)) {\r\n                    if (existsWithExeAdded(resolvedPath)) {\r\n                        resolvedPath += \".exe\";\r\n                    }\r\n                    else {\r\n                        const relativePath = this.rootUri.fsPath + path.sep + resolvedPath;\r\n                        if (!fs.existsSync(relativePath)) {\r\n                            if (existsWithExeAdded(resolvedPath)) {\r\n                                resolvedPath += \".exe\";\r\n                            }\r\n                            else {\r\n                                pathExists = false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            resolvedPath = relativePath;\r\n                        }\r\n                    }\r\n                }\r\n                for (let curOffset = curText.indexOf(curPath); curOffset !== -1; curOffset = curText.indexOf(curPath, curOffset + curPath.length)) {\r\n                    let message;\r\n                    if (!pathExists) {\r\n                        message = `Cannot find \"${resolvedPath}\".`;\r\n                        newSquiggleMetrics.PathNonExistent++;\r\n                    }\r\n                    else {\r\n                        if ((curOffset >= forcedIncludeStart && curOffset <= forcedeIncludeEnd) ||\r\n                            (curOffset >= compileCommandsStart && curOffset <= compileCommandsEnd) ||\r\n                            (curOffset >= compilerPathStart && curOffset <= compilerPathEnd)) {\r\n                            if (util.checkFileExistsSync(resolvedPath)) {\r\n                                continue;\r\n                            }\r\n                            message = `Path is not a file: \"${resolvedPath}\".`;\r\n                            newSquiggleMetrics.PathNotAFile++;\r\n                        }\r\n                        else {\r\n                            if (util.checkDirectoryExistsSync(resolvedPath)) {\r\n                                continue;\r\n                            }\r\n                            message = `Path is not a directory: \"${resolvedPath}\".`;\r\n                            newSquiggleMetrics.PathNotADirectory++;\r\n                        }\r\n                    }\r\n                    let diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(curTextStartOffset + curOffset), document.positionAt(curTextStartOffset + curOffset + curPath.length + (!isCompilerPath ? -1 : 0))), message, vscode.DiagnosticSeverity.Warning);\r\n                    diagnostics.push(diagnostic);\r\n                }\r\n            }\r\n            if (diagnostics.length !== 0) {\r\n                this.diagnosticCollection.set(document.uri, diagnostics);\r\n            }\r\n            else {\r\n                this.diagnosticCollection.clear();\r\n            }\r\n            let changedSquiggleMetrics = {};\r\n            if (newSquiggleMetrics.PathNonExistent !== this.prevSquiggleMetrics[this.CurrentConfiguration.name].PathNonExistent) {\r\n                changedSquiggleMetrics.PathNonExistent = newSquiggleMetrics.PathNonExistent;\r\n            }\r\n            if (newSquiggleMetrics.PathNotAFile !== this.prevSquiggleMetrics[this.CurrentConfiguration.name].PathNotAFile) {\r\n                changedSquiggleMetrics.PathNotAFile = newSquiggleMetrics.PathNotAFile;\r\n            }\r\n            if (newSquiggleMetrics.PathNotADirectory !== this.prevSquiggleMetrics[this.CurrentConfiguration.name].PathNotADirectory) {\r\n                changedSquiggleMetrics.PathNotADirectory = newSquiggleMetrics.PathNotADirectory;\r\n            }\r\n            if (Object.keys(changedSquiggleMetrics).length > 0) {\r\n                telemetry.logLanguageServerEvent(\"ConfigSquiggles\", null, changedSquiggleMetrics);\r\n            }\r\n            this.prevSquiggleMetrics[this.CurrentConfiguration.name] = newSquiggleMetrics;\r\n        });\r\n    }\r\n    updateToVersion2() {\r\n        this.configurationJson.version = 2;\r\n    }\r\n    updateToVersion3() {\r\n        this.configurationJson.version = 3;\r\n        for (let i = 0; i < this.configurationJson.configurations.length; i++) {\r\n            let config = this.configurationJson.configurations[i];\r\n            if (config.name === \"Mac\" || (process.platform === 'darwin' && config.name !== \"Win32\" && config.name !== \"Linux\")) {\r\n                if (config.macFrameworkPath === undefined) {\r\n                    config.macFrameworkPath = [\r\n                        \"/System/Library/Frameworks\",\r\n                        \"/Library/Frameworks\"\r\n                    ];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    updateToVersion4() {\r\n        this.configurationJson.version = 4;\r\n        let settings = new settings_1.CppSettings(this.rootUri);\r\n        for (let i = 0; i < this.configurationJson.configurations.length; i++) {\r\n            let config = this.configurationJson.configurations[i];\r\n            if (config.intelliSenseMode === undefined && !settings.defaultIntelliSenseMode) {\r\n                config.intelliSenseMode = this.getIntelliSenseModeForPlatform(config.name);\r\n            }\r\n            if (config.compilerPath === undefined && this.defaultCompilerPath && !config.compileCommands && !settings.defaultCompilerPath) {\r\n                config.compilerPath = this.defaultCompilerPath;\r\n            }\r\n            if (!config.cStandard && this.defaultCStandard && !settings.defaultCStandard) {\r\n                config.cStandard = this.defaultCStandard;\r\n            }\r\n            if (!config.cppStandard && this.defaultCppStandard && !settings.defaultCppStandard) {\r\n                config.cppStandard = this.defaultCppStandard;\r\n            }\r\n        }\r\n    }\r\n    checkCppProperties() {\r\n        let propertiesFile = path.join(this.configFolder, \"c_cpp_properties.json\");\r\n        fs.stat(propertiesFile, (err, stats) => {\r\n            if (err) {\r\n                if (this.propertiesFile) {\r\n                    this.propertiesFile = null;\r\n                    this.resetToDefaultSettings(true);\r\n                    this.handleConfigurationChange();\r\n                }\r\n            }\r\n            else if (stats.mtime > this.configFileWatcherFallbackTime) {\r\n                if (!this.propertiesFile) {\r\n                    this.propertiesFile = vscode.Uri.file(propertiesFile);\r\n                }\r\n                this.handleConfigurationChange();\r\n            }\r\n        });\r\n    }\r\n    dispose() {\r\n        this.disposables.forEach((d) => d.dispose());\r\n        this.disposables = [];\r\n        this.compileCommandFileWatchers.forEach((watcher) => watcher.close());\r\n        this.compileCommandFileWatchers = [];\r\n        this.diagnosticCollection.dispose();\r\n    }\r\n}\r\nexports.CppProperties = CppProperties;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvY29uZmlndXJhdGlvbnMudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL2NvbmZpZ3VyYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcclxuY29uc3QgdGVsZW1ldHJ5ID0gcmVxdWlyZShcIi4uL3RlbGVtZXRyeVwiKTtcclxuY29uc3QgcGVyc2lzdGVudFN0YXRlXzEgPSByZXF1aXJlKFwiLi9wZXJzaXN0ZW50U3RhdGVcIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY29uc3QgYWJUZXN0aW5nXzEgPSByZXF1aXJlKFwiLi4vYWJUZXN0aW5nXCIpO1xyXG5jb25zdCBjdXN0b21Qcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuL2N1c3RvbVByb3ZpZGVyc1wiKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IGNvbmZpZ1ZlcnNpb24gPSA0O1xyXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnKCkge1xyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJNYWNcIiB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICAgIHJldHVybiB7IG5hbWU6IFwiV2luMzJcIiB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJMaW51eFwiIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdENwcFByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbmZpZ3VyYXRpb25zOiBbZ2V0RGVmYXVsdENvbmZpZygpXSxcclxuICAgICAgICB2ZXJzaW9uOiBjb25maWdWZXJzaW9uXHJcbiAgICB9O1xyXG59XHJcbmNsYXNzIENwcFByb3BlcnRpZXMge1xyXG4gICAgY29uc3RydWN0b3Iocm9vdFVyaSkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSnNvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWdGaWxlV2F0Y2hlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWdGaWxlV2F0Y2hlckZhbGxiYWNrVGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5jb21waWxlQ29tbWFuZEZpbGVXYXRjaGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbXBpbGVyUGF0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rbm93bkNvbXBpbGVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q1N0YW5kYXJkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlZmF1bHRDcHBTdGFuZGFyZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SW5jbHVkZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEZyYW1ld29ya3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFdpbmRvd3NTZGtWZXJzaW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZjcGtnSW5jbHVkZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnZjcGtnUGF0aFJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SW50ZWxsaVNlbnNlTW9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uR2xvYlBhdHRlcm4gPSBcImNfY3BwX3Byb3BlcnRpZXMuanNvblwiO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zQ2hhbmdlZCA9IG5ldyB2c2NvZGUuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gbmV3IHZzY29kZS5FdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmNvbXBpbGVDb21tYW5kc0NoYW5nZWQgPSBuZXcgdnNjb2RlLkV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMucHJldlNxdWlnZ2xlTWV0cmljcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJvb3RmcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSW5jb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocm9vdFVyaSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnJvb3RVcmkgPSByb290VXJpO1xyXG4gICAgICAgIGxldCByb290UGF0aCA9IHJvb3RVcmkgPyByb290VXJpLmZzUGF0aCA6IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29uZmlndXJhdGlvbkluZGV4ID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRGb2xkZXJTdGF0ZShcIkNwcFByb3BlcnRpZXMuY3VycmVudENvbmZpZ3VyYXRpb25JbmRleFwiLCAtMSwgcm9vdFBhdGgpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRm9sZGVyID0gcGF0aC5qb2luKHJvb3RQYXRoLCBcIi52c2NvZGVcIik7XHJcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljQ29sbGVjdGlvbiA9IHZzY29kZS5sYW5ndWFnZXMuY3JlYXRlRGlhZ25vc3RpY0NvbGxlY3Rpb24ocm9vdFBhdGgpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRWY3BrZ0luY2x1ZGVQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5EaXNwb3NhYmxlLmZyb20odGhpcy5jb25maWd1cmF0aW9uc0NoYW5nZWQsIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCwgdGhpcy5jb21waWxlQ29tbWFuZHNDaGFuZ2VkKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgQ29uZmlndXJhdGlvbnNDaGFuZ2VkKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uc0NoYW5nZWQuZXZlbnQ7IH1cclxuICAgIGdldCBTZWxlY3Rpb25DaGFuZ2VkKCkgeyByZXR1cm4gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkLmV2ZW50OyB9XHJcbiAgICBnZXQgQ29tcGlsZUNvbW1hbmRzQ2hhbmdlZCgpIHsgcmV0dXJuIHRoaXMuY29tcGlsZUNvbW1hbmRzQ2hhbmdlZC5ldmVudDsgfVxyXG4gICAgZ2V0IENvbmZpZ3VyYXRpb25zKCkgeyByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uSnNvbiA/IHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMgOiBudWxsOyB9XHJcbiAgICBnZXQgQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleCgpIHsgcmV0dXJuIHRoaXMuY3VycmVudENvbmZpZ3VyYXRpb25JbmRleC5WYWx1ZTsgfVxyXG4gICAgZ2V0IEN1cnJlbnRDb25maWd1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5Db25maWd1cmF0aW9ucyA/IHRoaXMuQ29uZmlndXJhdGlvbnNbdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbkluZGV4XSA6IG51bGw7IH1cclxuICAgIGdldCBDb21waWxlclBhdGgoKSB7IHJldHVybiB0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uID8gdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb21waWxlclBhdGggOiBudWxsOyB9XHJcbiAgICBnZXQgS25vd25Db21waWxlcigpIHsgcmV0dXJuIHRoaXMua25vd25Db21waWxlcnM7IH1cclxuICAgIGdldCBDdXJyZW50Q29uZmlndXJhdGlvblByb3ZpZGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLmNvbmZpZ3VyYXRpb25Qcm92aWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb25maWd1cmF0aW9uUHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyh0aGlzLnJvb3RVcmkpLmRlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgQ29uZmlndXJhdGlvbk5hbWVzKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmZvckVhY2goKGNvbmZpZykgPT4gcmVzdWx0LnB1c2goY29uZmlnLm5hbWUpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc2V0IENvbXBpbGVyRGVmYXVsdHMoY29tcGlsZXJEZWZhdWx0cykge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbXBpbGVyUGF0aCA9IGNvbXBpbGVyRGVmYXVsdHMuY29tcGlsZXJQYXRoO1xyXG4gICAgICAgIHRoaXMua25vd25Db21waWxlcnMgPSBjb21waWxlckRlZmF1bHRzLmtub3duQ29tcGlsZXJzO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdENTdGFuZGFyZCA9IGNvbXBpbGVyRGVmYXVsdHMuY1N0YW5kYXJkO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdENwcFN0YW5kYXJkID0gY29tcGlsZXJEZWZhdWx0cy5jcHBTdGFuZGFyZDtcclxuICAgICAgICB0aGlzLmRlZmF1bHRJbmNsdWRlcyA9IGNvbXBpbGVyRGVmYXVsdHMuaW5jbHVkZXM7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWV3b3JrcyA9IGNvbXBpbGVyRGVmYXVsdHMuZnJhbWV3b3JrcztcclxuICAgICAgICB0aGlzLmRlZmF1bHRXaW5kb3dzU2RrVmVyc2lvbiA9IGNvbXBpbGVyRGVmYXVsdHMud2luZG93c1Nka1ZlcnNpb247XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0SW50ZWxsaVNlbnNlTW9kZSA9IGNvbXBpbGVyRGVmYXVsdHMuaW50ZWxsaVNlbnNlTW9kZTtcclxuICAgICAgICB0aGlzLnJvb3RmcyA9IGNvbXBpbGVyRGVmYXVsdHMucm9vdGZzO1xyXG4gICAgICAgIGxldCBjb25maWdGaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZ0ZvbGRlciwgXCJjX2NwcF9wcm9wZXJ0aWVzLmpzb25cIik7XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoY29uZmlnRmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSB2c2NvZGUuVXJpLmZpbGUoY29uZmlnRmlsZVBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzRmlsZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnRmlsZVdhdGNoZXIgPSB2c2NvZGUud29ya3NwYWNlLmNyZWF0ZUZpbGVTeXN0ZW1XYXRjaGVyKHBhdGguam9pbih0aGlzLmNvbmZpZ0ZvbGRlciwgdGhpcy5jb25maWd1cmF0aW9uR2xvYlBhdHRlcm4pKTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLnB1c2godGhpcy5jb25maWdGaWxlV2F0Y2hlcik7XHJcbiAgICAgICAgdGhpcy5jb25maWdGaWxlV2F0Y2hlci5vbkRpZENyZWF0ZSgodXJpKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSB1cmk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkNoYW5nZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY29uZmlnRmlsZVdhdGNoZXIub25EaWREZWxldGUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNGaWxlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFRvRGVmYXVsdFNldHRpbmdzKHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyYXRpb25DaGFuZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbmZpZ0ZpbGVXYXRjaGVyLm9uRGlkQ2hhbmdlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgVmNwa2dJbnN0YWxsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmNwa2dJbmNsdWRlcy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgb25Db25maWd1cmF0aW9uc0NoYW5nZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uc0NoYW5nZWQuZmlyZSh0aGlzLkNvbmZpZ3VyYXRpb25zKTtcclxuICAgIH1cclxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlZCgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQuZmlyZSh0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU3F1aWdnbGVzKCk7XHJcbiAgICB9XHJcbiAgICBvbkNvbXBpbGVDb21tYW5kc0NoYW5nZWQocGF0aCkge1xyXG4gICAgICAgIHRoaXMuY29tcGlsZUNvbW1hbmRzQ2hhbmdlZC5maXJlKHBhdGgpO1xyXG4gICAgfVxyXG4gICAgb25EaWRDaGFuZ2VTZXR0aW5ncygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllc0ZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFRvRGVmYXVsdFNldHRpbmdzKHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyYXRpb25DaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29uZmlndXJhdGlvbkluY29tcGxldGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzZXRUb0RlZmF1bHRTZXR0aW5ncyhyZXNldEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSnNvbiA9IGdldERlZmF1bHRDcHBQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgaWYgKHJlc2V0SW5kZXggfHwgdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbkluZGV4IDwgMCB8fFxyXG4gICAgICAgICAgICB0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXggPj0gdGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29uZmlndXJhdGlvbkluZGV4LlZhbHVlID0gdGhpcy5nZXRDb25maWdJbmRleEZvclBsYXRmb3JtKHRoaXMuY29uZmlndXJhdGlvbkpzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25JbmNvbXBsZXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFwcGx5RGVmYXVsdEluY2x1ZGVQYXRoc0FuZEZyYW1ld29ya3MoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbkluY29tcGxldGUgJiYgdGhpcy5kZWZhdWx0SW5jbHVkZXMgJiYgdGhpcy5kZWZhdWx0RnJhbWV3b3JrcyAmJiB0aGlzLnZjcGtnUGF0aFJlYWR5KSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbjtcclxuICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3ModGhpcy5yb290VXJpKTtcclxuICAgICAgICAgICAgbGV0IGlzVW5zZXQgPSAoaW5wdXQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PT0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGlzVW5zZXQoc2V0dGluZ3MuZGVmYXVsdEluY2x1ZGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFiVGVzdFNldHRpbmdzID0gYWJUZXN0aW5nXzEuZ2V0QUJUZXN0U2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIGxldCByb290Rm9sZGVyID0gYWJUZXN0U2V0dGluZ3MuVXNlUmVjdXJzaXZlSW5jbHVkZXMgPyBcIiR7d29ya3NwYWNlRm9sZGVyfS8qKlwiIDogXCIke3dvcmtzcGFjZUZvbGRlcn1cIjtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uaW5jbHVkZVBhdGggPSBbcm9vdEZvbGRlcl0uY29uY2F0KHRoaXMudmNwa2dJbmNsdWRlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVW5zZXQoc2V0dGluZ3MuZGVmYXVsdERlZmluZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmRlZmluZXMgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyBbXCJfREVCVUdcIiwgXCJVTklDT0RFXCIsIFwiX1VOSUNPREVcIl0gOiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNVbnNldChzZXR0aW5ncy5kZWZhdWx0TWFjRnJhbWV3b3JrUGF0aCkgJiYgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24ubWFjRnJhbWV3b3JrUGF0aCA9IHRoaXMuZGVmYXVsdEZyYW1ld29ya3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVW5zZXQoc2V0dGluZ3MuZGVmYXVsdFdpbmRvd3NTZGtWZXJzaW9uKSAmJiB0aGlzLmRlZmF1bHRXaW5kb3dzU2RrVmVyc2lvbiAmJiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLndpbmRvd3NTZGtWZXJzaW9uID0gdGhpcy5kZWZhdWx0V2luZG93c1Nka1ZlcnNpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVW5zZXQoc2V0dGluZ3MuZGVmYXVsdENvbXBpbGVyUGF0aCkgJiYgdGhpcy5kZWZhdWx0Q29tcGlsZXJQYXRoICYmXHJcbiAgICAgICAgICAgICAgICBpc1Vuc2V0KHNldHRpbmdzLmRlZmF1bHRDb21waWxlQ29tbWFuZHMpICYmICFjb25maWd1cmF0aW9uLmNvbXBpbGVDb21tYW5kcykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5jb21waWxlclBhdGggPSB0aGlzLmRlZmF1bHRDb21waWxlclBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMua25vd25Db21waWxlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24ua25vd25Db21waWxlcnMgPSB0aGlzLmtub3duQ29tcGlsZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Vuc2V0KHNldHRpbmdzLmRlZmF1bHRDU3RhbmRhcmQpICYmIHRoaXMuZGVmYXVsdENTdGFuZGFyZCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5jU3RhbmRhcmQgPSB0aGlzLmRlZmF1bHRDU3RhbmRhcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVW5zZXQoc2V0dGluZ3MuZGVmYXVsdENwcFN0YW5kYXJkKSAmJiB0aGlzLmRlZmF1bHRDcHBTdGFuZGFyZCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5jcHBTdGFuZGFyZCA9IHRoaXMuZGVmYXVsdENwcFN0YW5kYXJkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Vuc2V0KHNldHRpbmdzLmRlZmF1bHRJbnRlbGxpU2Vuc2VNb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5pbnRlbGxpU2Vuc2VNb2RlID0gdGhpcy5kZWZhdWx0SW50ZWxsaVNlbnNlTW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25JbmNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IEV4dGVuZGVkRW52aXJvbm1lbnQoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmVudikge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy5jb25maWd1cmF0aW9uSnNvbi5lbnYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHRbXCJ3b3Jrc3BhY2VGb2xkZXJCYXNlbmFtZVwiXSA9IHRoaXMucm9vdFVyaSA/IHBhdGguYmFzZW5hbWUodGhpcy5yb290VXJpLmZzUGF0aCkgOiBcIlwiO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBidWlsZFZjcGtnSW5jbHVkZVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxldCB2Y3BrZ1Jvb3QgPSB1dGlsLmdldFZjcGtnUm9vdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZjcGtnUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0geWllbGQgdXRpbC5yZWFkRGlyKHZjcGtnUm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LmZvckVhY2goKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkgIT09IFwidmNwa2dcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoVG9DaGVjayA9IHBhdGguam9pbih2Y3BrZ1Jvb3QsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoVG9DaGVjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSBwYXRoLmpvaW4ocGF0aFRvQ2hlY2ssIFwiaW5jbHVkZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAucmVwbGFjZSh2Y3BrZ1Jvb3QsIFwiJHt2Y3BrZ1Jvb3R9XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52Y3BrZ0luY2x1ZGVzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmNwa2dQYXRoUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENvbmZpZ0luZGV4Rm9yUGxhdGZvcm0oY29uZmlnKSB7XHJcbiAgICAgICAgbGV0IHBsYXQ7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XHJcbiAgICAgICAgICAgIHBsYXQgPSBcIk1hY1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgIHBsYXQgPSBcIldpbjMyXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwbGF0ID0gXCJMaW51eFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jb25maWd1cmF0aW9uc1tpXS5uYW1lID09PSBwbGF0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9ucy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG4gICAgZ2V0SW50ZWxsaVNlbnNlTW9kZUZvclBsYXRmb3JtKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gXCJMaW51eFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImdjYy14NjRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gXCJNYWNcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJjbGFuZy14NjRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gXCJXaW4zMlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIm1zdmMteDY0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwibXN2Yy14NjRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiY2xhbmcteDY0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJnY2MteDY0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkVG9JbmNsdWRlUGF0aENvbW1hbmQocGF0aCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkVkaXRDb21tYW5kKChkb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcImFkZFRvSW5jbHVkZVBhdGhcIik7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0aWVzRmlsZSgpO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbjtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5pbmNsdWRlUGF0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuaW5jbHVkZVBhdGggPSBbXCIke2RlZmF1bHR9XCJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbmZpZy5pbmNsdWRlUGF0aC5zcGxpY2UoY29uZmlnLmluY2x1ZGVQYXRoLmxlbmd0aCwgMCwgcGF0aCk7XHJcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wcm9wZXJ0aWVzRmlsZS5mc1BhdGgsIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlndXJhdGlvbkpzb24sIG51bGwsIDQpKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXIocHJvdmlkZXJJZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uRWRpdENvbW1hbmQoKGRvY3VtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVByb3BlcnRpZXNGaWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNvbmZpZ3VyYXRpb25Qcm92aWRlciA9IHByb3ZpZGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmNvbmZpZ3VyYXRpb25Qcm92aWRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnByb3BlcnRpZXNGaWxlLmZzUGF0aCwgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWd1cmF0aW9uSnNvbiwgbnVsbCwgNCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3ModGhpcy5yb290VXJpKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudXBkYXRlKFwiZGVmYXVsdC5jb25maWd1cmF0aW9uUHJvdmlkZXJcIiwgcHJvdmlkZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy51cGRhdGUoXCJkZWZhdWx0LmNvbmZpZ3VyYXRpb25Qcm92aWRlclwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb25maWd1cmF0aW9uUHJvdmlkZXIgPSBwcm92aWRlcklkO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXRDb21waWxlQ29tbWFuZHMocGF0aCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkVkaXRDb21tYW5kKChkb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlUHJvcGVydGllc0ZpbGUoKTtcclxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgICAgIGNvbmZpZy5jb21waWxlQ29tbWFuZHMgPSBwYXRoO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucHJvcGVydGllc0ZpbGUuZnNQYXRoLCBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLCBudWxsLCA0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29uZmlndXJhdGlvbkNoYW5nZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VsZWN0KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyYXRpb25FZGl0Q29tbWFuZCh2c2NvZGUud2luZG93LnNob3dUZXh0RG9jdW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudENvbmZpZ3VyYXRpb25JbmRleC5WYWx1ZSA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2VkKCk7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlRGVmYXVsdHMoZW50cmllcywgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gXCIke2RlZmF1bHR9XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZUFuZFNwbGl0KHBhdGhzLCBkZWZhdWx0VmFsdWUsIGVudikge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBpZiAocGF0aHMpIHtcclxuICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW50cmllcyA9IHV0aWwucmVzb2x2ZVZhcmlhYmxlcyhlbnRyeSwgZW52KS5zcGxpdChcIjtcIikuZmlsdGVyKGUgPT4gZSk7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5yZXNvbHZlRGVmYXVsdHMoZW50cmllcywgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZW50cmllcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZVZhcmlhYmxlcyhpbnB1dCwgZGVmYXVsdFZhbHVlLCBlbnYpIHtcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBpbnB1dCA9PT0gXCIke2RlZmF1bHR9XCIpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHV0aWwucmVzb2x2ZVZhcmlhYmxlcyhpbnB1dCwgZW52KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNvbmZpZ3VyYXRpb24ocHJvcGVydHksIGRlZmF1bHRWYWx1ZSwgZW52KSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocHJvcGVydHkpIHx8IHV0aWwuaXNTdHJpbmcoZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlVmFyaWFibGVzKHByb3BlcnR5LCBkZWZhdWx0VmFsdWUsIGVudik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHV0aWwuaXNCb29sZWFuKHByb3BlcnR5KSB8fCB1dGlsLmlzQm9vbGVhbihkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVWYXJpYWJsZXMocHJvcGVydHksIGRlZmF1bHRWYWx1ZSwgZW52KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc0FycmF5T2ZTdHJpbmcocHJvcGVydHkpIHx8IHV0aWwuaXNBcnJheU9mU3RyaW5nKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQW5kU3BsaXQocHJvcGVydHksIGRlZmF1bHRWYWx1ZSwgZW52KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUFuZFNwbGl0KGRlZmF1bHRWYWx1ZSwgW10sIGVudik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2VydmVyT25Gb2xkZXJTZXR0aW5nc0NoYW5nZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29uZmlndXJhdGlvbkpzb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyh0aGlzLnJvb3RVcmkpO1xyXG4gICAgICAgIGxldCBlbnYgPSB0aGlzLkV4dGVuZGVkRW52aXJvbm1lbnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9uc1tpXTtcclxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5pbmNsdWRlUGF0aCA9IHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uLmluY2x1ZGVQYXRoLCBzZXR0aW5ncy5kZWZhdWx0SW5jbHVkZVBhdGgsIGVudik7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uZGVmaW5lcyA9IHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uLmRlZmluZXMsIHNldHRpbmdzLmRlZmF1bHREZWZpbmVzLCBlbnYpO1xyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLm1hY0ZyYW1ld29ya1BhdGggPSB0aGlzLnVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbi5tYWNGcmFtZXdvcmtQYXRoLCBzZXR0aW5ncy5kZWZhdWx0TWFjRnJhbWV3b3JrUGF0aCwgZW52KTtcclxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi53aW5kb3dzU2RrVmVyc2lvbiA9IHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uLndpbmRvd3NTZGtWZXJzaW9uLCBzZXR0aW5ncy5kZWZhdWx0V2luZG93c1Nka1ZlcnNpb24sIGVudik7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uZm9yY2VkSW5jbHVkZSA9IHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uLmZvcmNlZEluY2x1ZGUsIHNldHRpbmdzLmRlZmF1bHRGb3JjZWRJbmNsdWRlLCBlbnYpO1xyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLmNvbXBpbGVDb21tYW5kcyA9IHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uLmNvbXBpbGVDb21tYW5kcywgc2V0dGluZ3MuZGVmYXVsdENvbXBpbGVDb21tYW5kcywgZW52KTtcclxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5jb21waWxlclBhdGggPSB0aGlzLnVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbi5jb21waWxlclBhdGgsIHNldHRpbmdzLmRlZmF1bHRDb21waWxlclBhdGgsIGVudik7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uY1N0YW5kYXJkID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uY1N0YW5kYXJkLCBzZXR0aW5ncy5kZWZhdWx0Q1N0YW5kYXJkLCBlbnYpO1xyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLmNwcFN0YW5kYXJkID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uY3BwU3RhbmRhcmQsIHNldHRpbmdzLmRlZmF1bHRDcHBTdGFuZGFyZCwgZW52KTtcclxuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5pbnRlbGxpU2Vuc2VNb2RlID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uaW50ZWxsaVNlbnNlTW9kZSwgc2V0dGluZ3MuZGVmYXVsdEludGVsbGlTZW5zZU1vZGUsIGVudik7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uY29uZmlndXJhdGlvblByb3ZpZGVyID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uY29uZmlndXJhdGlvblByb3ZpZGVyLCBzZXR0aW5ncy5kZWZhdWx0Q29uZmlndXJhdGlvblByb3ZpZGVyLCBlbnYpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uYnJvd3NlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmJyb3dzZSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbi5icm93c2UucGF0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRCcm93c2VQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5icm93c2UucGF0aCA9IHNldHRpbmdzLmRlZmF1bHRCcm93c2VQYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlndXJhdGlvbi5pbmNsdWRlUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uYnJvd3NlLnBhdGggPSBjb25maWd1cmF0aW9uLmluY2x1ZGVQYXRoLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gY29uZmlndXJhdGlvbi5pbmNsdWRlUGF0aC5maW5kSW5kZXgoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZS5tYXRjaCgvXlxcJFxceyh3b3Jrc3BhY2VSb290fHdvcmtzcGFjZUZvbGRlcilcXH0oXFxcXFxcKnswLDJ9fFxcL1xcKnswLDJ9KT8kL2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uYnJvd3NlLnBhdGgucHVzaChcIiR7d29ya3NwYWNlRm9sZGVyfVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmJyb3dzZS5wYXRoID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uYnJvd3NlLnBhdGgsIHNldHRpbmdzLmRlZmF1bHRCcm93c2VQYXRoLCBlbnYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uYnJvd3NlLmxpbWl0U3ltYm9sc1RvSW5jbHVkZWRIZWFkZXJzID0gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24uYnJvd3NlLmxpbWl0U3ltYm9sc1RvSW5jbHVkZWRIZWFkZXJzLCBzZXR0aW5ncy5kZWZhdWx0TGltaXRTeW1ib2xzVG9JbmNsdWRlZEhlYWRlcnMsIGVudik7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24uYnJvd3NlLmRhdGFiYXNlRmlsZW5hbWUgPSB0aGlzLnVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbi5icm93c2UuZGF0YWJhc2VGaWxlbmFtZSwgc2V0dGluZ3MuZGVmYXVsdERhdGFiYXNlRmlsZW5hbWUsIGVudik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQ29tcGlsZUNvbW1hbmRzRmlsZVdhdGNoZXJzKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRpb25JbmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db25maWd1cmF0aW9uc0NoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb21waWxlQ29tbWFuZHNGaWxlV2F0Y2hlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5jb21waWxlQ29tbWFuZEZpbGVXYXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyKSA9PiB3YXRjaGVyLmNsb3NlKCkpO1xyXG4gICAgICAgIHRoaXMuY29tcGlsZUNvbW1hbmRGaWxlV2F0Y2hlcnMgPSBbXTtcclxuICAgICAgICBsZXQgZmlsZVBhdGhzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMuZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgaWYgKGMuY29tcGlsZUNvbW1hbmRzICE9PSB1bmRlZmluZWQgJiYgZnMuZXhpc3RzU3luYyhjLmNvbXBpbGVDb21tYW5kcykpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVQYXRocy5hZGQoYy5jb21waWxlQ29tbWFuZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZmlsZVBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZUNvbW1hbmRGaWxlV2F0Y2hlcnMucHVzaChmcy53YXRjaChwYXRoLCAoZXZlbnQsIGZpbGVuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50ICE9PSBcInJlbmFtZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21waWxlQ29tbWFuZHNDaGFuZ2VkKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlQ29uZmlndXJhdGlvbkVkaXRDb21tYW5kKG9uU3VjY2Vzcykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNGaWxlICYmIGZzLmV4aXN0c1N5bmModGhpcy5wcm9wZXJ0aWVzRmlsZS5mc1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHZzY29kZS53b3Jrc3BhY2Uub3BlblRleHREb2N1bWVudCh0aGlzLnByb3BlcnRpZXNGaWxlKS50aGVuKChkb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzKGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmcy5ta2Rpcih0aGlzLmNvbmZpZ0ZvbGRlciwgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZSB8fCBlLmNvZGUgPT09ICdFRVhJU1QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bGxQYXRoVG9GaWxlID0gcGF0aC5qb2luKHRoaXMuY29uZmlnRm9sZGVyLCBcImNfY3BwX3Byb3BlcnRpZXMuanNvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZVBhdGggPSB2c2NvZGUuVXJpLmZpbGUoZnVsbFBhdGhUb0ZpbGUpLndpdGgoeyBzY2hlbWU6IFwidW50aXRsZWRcIiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud29ya3NwYWNlLm9wZW5UZXh0RG9jdW1lbnQoZmlsZVBhdGgpLnRoZW4oKGRvY3VtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGl0ID0gbmV3IHZzY29kZS5Xb3Jrc3BhY2VFZGl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VG9EZWZhdWx0U2V0dGluZ3ModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseURlZmF1bHRJbmNsdWRlUGF0aHNBbmRGcmFtZXdvcmtzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHRoaXMucm9vdFVyaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0Q29uZmlndXJhdGlvblByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmZvckVhY2goY29uZmlnID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuY29uZmlndXJhdGlvblByb3ZpZGVyID0gc2V0dGluZ3MuZGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudXBkYXRlKFwiZGVmYXVsdC5jb25maWd1cmF0aW9uUHJvdmlkZXJcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2F2ZWRLbm93bkNvbXBpbGVycyA9IHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnNbMF0ua25vd25Db21waWxlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zWzBdLmtub3duQ29tcGlsZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0Lmluc2VydChkb2N1bWVudC51cmksIG5ldyB2c2NvZGUuUG9zaXRpb24oMCwgMCksIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlndXJhdGlvbkpzb24sIG51bGwsIDQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9uc1swXS5rbm93bkNvbXBpbGVycyA9IHNhdmVkS25vd25Db21waWxlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZS53b3Jrc3BhY2UuYXBwbHlFZGl0KGVkaXQpLnRoZW4oKHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuc2F2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSB2c2NvZGUuVXJpLmZpbGUocGF0aC5qb2luKHRoaXMuY29uZmlnRm9sZGVyLCBcImNfY3BwX3Byb3BlcnRpZXMuanNvblwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlLndvcmtzcGFjZS5vcGVuVGV4dERvY3VtZW50KHRoaXMucHJvcGVydGllc0ZpbGUpLnRoZW4oKGRvY3VtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzcyhkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZUNvbmZpZ3VyYXRpb25DaGFuZ2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc0ZpbGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnRmlsZVdhdGNoZXJGYWxsYmFja1RpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0aWVzRmlsZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uSnNvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleCA8IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXggPj0gdGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXguVmFsdWUgPSB0aGlzLmdldENvbmZpZ0luZGV4Rm9yUGxhdGZvcm0odGhpcy5jb25maWd1cmF0aW9uSnNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZ3VyYXRpb25Kc29uKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRUb0RlZmF1bHRTZXR0aW5ncyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBseURlZmF1bHRJbmNsdWRlUGF0aHNBbmRGcmFtZXdvcmtzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZXJ2ZXJPbkZvbGRlclNldHRpbmdzQ2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgICBwYXJzZVByb3BlcnRpZXNGaWxlKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCByZWFkUmVzdWx0cyA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnByb3BlcnRpZXNGaWxlLmZzUGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgaWYgKHJlYWRSZXN1bHRzID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZFJlc3VsdHMgPSByZWFkUmVzdWx0cy5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xyXG4gICAgICAgICAgICByZWFkUmVzdWx0cyA9IHJlYWRSZXN1bHRzLnJlcGxhY2UoL1xcXFxcXFxcXCIvZywgJ1xcXFxcIicpO1xyXG4gICAgICAgICAgICBsZXQgbmV3SnNvbiA9IEpTT04ucGFyc2UocmVhZFJlc3VsdHMpO1xyXG4gICAgICAgICAgICBpZiAoIW5ld0pzb24gfHwgIW5ld0pzb24uY29uZmlndXJhdGlvbnMgfHwgbmV3SnNvbi5jb25maWd1cmF0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gZmlsZS4gVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgY29uZmlndXJhdGlvbiBwcmVzZW50IGluIHRoZSBhcnJheS5cIiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWd1cmF0aW9uSW5jb21wbGV0ZSAmJiB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uICYmIHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleCA+PSAwICYmIHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleCA8IHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0pzb24uY29uZmlndXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SnNvbi5jb25maWd1cmF0aW9uc1tpXS5uYW1lID09PSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zW3RoaXMuQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleF0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXguVmFsdWUgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSnNvbiA9IG5ld0pzb247XHJcbiAgICAgICAgICAgIGlmICh0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uSW5kZXggPCAwIHx8IHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb25JbmRleCA+PSBuZXdKc29uLmNvbmZpZ3VyYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29uZmlndXJhdGlvbkluZGV4LlZhbHVlID0gdGhpcy5nZXRDb25maWdJbmRleEZvclBsYXRmb3JtKG5ld0pzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlndXJhdGlvbkpzb24uY29uZmlndXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdJZCA9IGN1c3RvbVByb3ZpZGVyc18xLmdldEN1c3RvbUNvbmZpZ1Byb3ZpZGVycygpLmNoZWNrSWQodGhpcy5jb25maWd1cmF0aW9uSnNvbi5jb25maWd1cmF0aW9uc1tpXS5jb25maWd1cmF0aW9uUHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0lkICE9PSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zW2ldLmNvbmZpZ3VyYXRpb25Qcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zW2ldLmNvbmZpZ3VyYXRpb25Qcm92aWRlciA9IG5ld0lkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmVudikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlndXJhdGlvbkpzb24uZW52Wyd3b3Jrc3BhY2VSb290J107XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25maWd1cmF0aW9uSnNvbi5lbnZbJ3dvcmtzcGFjZUZvbGRlciddO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlndXJhdGlvbkpzb24uZW52Wyd3b3Jrc3BhY2VGb2xkZXJCYXNlbmFtZSddO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlndXJhdGlvbkpzb24uZW52WydkZWZhdWx0J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uSW5jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uSnNvbi52ZXJzaW9uICE9PSBjb25maWdWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uSnNvbi52ZXJzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRvVmVyc2lvbjIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLnZlcnNpb24gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRvVmVyc2lvbjMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLnZlcnNpb24gPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRvVmVyc2lvbjQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbkpzb24udmVyc2lvbiA9IGNvbmZpZ1ZlcnNpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93RXJyb3JNZXNzYWdlKCdVbmtub3duIHZlcnNpb24gbnVtYmVyIGZvdW5kIGluIGNfY3BwX3Byb3BlcnRpZXMuanNvbi4gU29tZSBmZWF0dXJlcyBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wcm9wZXJ0aWVzRmlsZS5mc1BhdGgsIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlndXJhdGlvbkpzb24sIG51bGwsIDQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dXYXJuaW5nTWVzc2FnZShgQXR0ZW1wdCB0byB1cGRhdGUgXCIke3RoaXMucHJvcGVydGllc0ZpbGUuZnNQYXRofVwiIGZhaWxlZCAoZG8geW91IGhhdmUgd3JpdGUgYWNjZXNzPylgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNxdWlnZ2xlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0Vycm9yTWVzc2FnZShgRmFpbGVkIHRvIHBhcnNlIFwiJHt0aGlzLnByb3BlcnRpZXNGaWxlLmZzUGF0aH1cIjogJHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVNxdWlnZ2xlcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucHJvcGVydGllc0ZpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2c2NvZGUud29ya3NwYWNlLm9wZW5UZXh0RG9jdW1lbnQodGhpcy5wcm9wZXJ0aWVzRmlsZSkudGhlbigoZG9jdW1lbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGxldCBjdXJUZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgICBsZXQgY3VyVGV4dFN0YXJ0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnU3RhcnQgPSBjdXJUZXh0LnNlYXJjaChuZXcgUmVnRXhwKGB7XFxcXHMqXCJuYW1lXCJcXFxccyo6XFxcXHMqXCIke3RoaXMuQ3VycmVudENvbmZpZ3VyYXRpb24ubmFtZX1cImApKTtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZ1N0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoXCJDb25maWdTcXVpZ2dsZXNcIiwgeyBcImVycm9yXCI6IFwiY29uZmlnIG5hbWUgbm90IGZpcnN0XCIgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyVGV4dFN0YXJ0T2Zmc2V0ID0gY29uZmlnU3RhcnQgKyAxO1xyXG4gICAgICAgICAgICBjdXJUZXh0ID0gY3VyVGV4dC5zdWJzdHIoY3VyVGV4dFN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZUVuZCA9IGN1clRleHQuaW5kZXhPZihcIjpcIik7XHJcbiAgICAgICAgICAgIGN1clRleHRTdGFydE9mZnNldCArPSBuYW1lRW5kICsgMTtcclxuICAgICAgICAgICAgY3VyVGV4dCA9IGN1clRleHQuc3Vic3RyKG5hbWVFbmQgKyAxKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE5hbWVTdGFydCA9IGN1clRleHQuc2VhcmNoKG5ldyBSZWdFeHAoJ1wibmFtZVwiXFxcXHMqOlxcXFxzKlwiJykpO1xyXG4gICAgICAgICAgICBpZiAobmV4dE5hbWVTdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGN1clRleHQgPSBjdXJUZXh0LnN1YnN0cigwLCBuZXh0TmFtZVN0YXJ0ICsgNik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0TmFtZVN0YXJ0MiA9IGN1clRleHQuc2VhcmNoKG5ldyBSZWdFeHAoJ1xcXFxzKn1cXFxccyosXFxcXHMqe1xcXFxzKlwibmFtZVwiJykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHROYW1lU3RhcnQyID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KFwiQ29uZmlnU3F1aWdnbGVzXCIsIHsgXCJlcnJvclwiOiBcIm5leHQgY29uZmlnIG5hbWUgbm90IGZpcnN0XCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VyVGV4dCA9IGN1clRleHQuc3Vic3RyKDAsIG5leHROYW1lU3RhcnQyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcGF0aHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHBhdGhBcnJheSBvZiBbKHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb24uYnJvd3NlID8gdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5icm93c2UucGF0aCA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLmluY2x1ZGVQYXRoLCB0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLm1hY0ZyYW1ld29ya1BhdGgsIHRoaXMuQ3VycmVudENvbmZpZ3VyYXRpb24uZm9yY2VkSW5jbHVkZV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjdXJQYXRoIG9mIHBhdGhBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5hZGQoYFwiJHtjdXJQYXRofVwiYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLmNvbXBpbGVDb21tYW5kcykge1xyXG4gICAgICAgICAgICAgICAgcGF0aHMuYWRkKGBcIiR7dGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb21waWxlQ29tbWFuZHN9XCJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpc1dpbmRvd3MgPSBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb21waWxlclBhdGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21waWxlclBhdGhBbmRBcmdzO1xyXG4gICAgICAgICAgICAgICAgY29tcGlsZXJQYXRoQW5kQXJncyA9IHV0aWwuZXh0cmFjdENvbXBpbGVyUGF0aEFuZEFyZ3ModGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5jb21waWxlclBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNXaW5kb3dzICYmIGNvbXBpbGVyUGF0aEFuZEFyZ3MuY29tcGlsZXJQYXRoLmVuZHNXaXRoKFwiY2wuZXhlXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLmFkZChgJHtjb21waWxlclBhdGhBbmRBcmdzLmNvbXBpbGVyUGF0aH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmb3JjZWRJbmNsdWRlU3RhcnQgPSBjdXJUZXh0LnNlYXJjaCgvXFxzKlxcXCJmb3JjZWRJbmNsdWRlXFxcIlxccyo6XFxzKlxcWy8pO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JjZWRlSW5jbHVkZUVuZCA9IGZvcmNlZEluY2x1ZGVTdGFydCA9PT0gLTEgPyAtMSA6IGN1clRleHQuaW5kZXhPZihcIl1cIiwgZm9yY2VkSW5jbHVkZVN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgY29tcGlsZUNvbW1hbmRzU3RhcnQgPSBjdXJUZXh0LnNlYXJjaCgvXFxzKlxcXCJjb21waWxlQ29tbWFuZHNcXFwiXFxzKjpcXHMqXFxcIi8pO1xyXG4gICAgICAgICAgICBjb25zdCBjb21waWxlQ29tbWFuZHNFbmQgPSBjb21waWxlQ29tbWFuZHNTdGFydCA9PT0gLTEgPyAtMSA6IGN1clRleHQuaW5kZXhPZignXCInLCBjdXJUZXh0LmluZGV4T2YoJ1wiJywgY3VyVGV4dC5pbmRleE9mKFwiOlwiLCBjb21waWxlQ29tbWFuZHNTdGFydCkpICsgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVyUGF0aFN0YXJ0ID0gY3VyVGV4dC5zZWFyY2goL1xccypcXFwiY29tcGlsZXJQYXRoXFxcIlxccyo6XFxzKlxcXCIvKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcGlsZXJQYXRoRW5kID0gY29tcGlsZXJQYXRoU3RhcnQgPT09IC0xID8gLTEgOiBjdXJUZXh0LmluZGV4T2YoJ1wiJywgY3VyVGV4dC5pbmRleE9mKCdcIicsIGN1clRleHQuaW5kZXhPZihcIjpcIiwgY29tcGlsZXJQYXRoU3RhcnQpKSArIDEpICsgMTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldlNxdWlnZ2xlTWV0cmljc1t0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLm5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlNxdWlnZ2xlTWV0cmljc1t0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLm5hbWVdID0geyBQYXRoTm9uRXhpc3RlbnQ6IDAsIFBhdGhOb3RBRmlsZTogMCwgUGF0aE5vdEFEaXJlY3Rvcnk6IDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmV3U3F1aWdnbGVNZXRyaWNzID0geyBQYXRoTm9uRXhpc3RlbnQ6IDAsIFBhdGhOb3RBRmlsZTogMCwgUGF0aE5vdEFEaXJlY3Rvcnk6IDAgfTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY3VyUGF0aCBvZiBwYXRocykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb21waWxlclBhdGggPSAhY3VyUGF0aC5zdGFydHNXaXRoKCdcIicpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc29sdmVkUGF0aCA9IGN1clBhdGguc3Vic3RyKCghaXNDb21waWxlclBhdGggPyAxIDogMCksIGN1clBhdGgubGVuZ3RoICsgKCFpc0NvbXBpbGVyUGF0aCA/IC0yIDogMCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUGF0aCA9PT0gXCIke2RlZmF1bHR9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHV0aWwucmVzb2x2ZVZhcmlhYmxlcyhyZXNvbHZlZFBhdGgsIHRoaXMuRXh0ZW5kZWRFbnZpcm9ubWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmluY2x1ZGVzKFwiJHt3b3Jrc3BhY2VGb2xkZXJ9XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZWRQYXRoLnJlcGxhY2UoXCIke3dvcmtzcGFjZUZvbGRlcn1cIiwgdGhpcy5yb290VXJpLmZzUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmluY2x1ZGVzKFwiJHt3b3Jrc3BhY2VSb290fVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHJlc29sdmVkUGF0aC5yZXBsYWNlKFwiJHt3b3Jrc3BhY2VSb290fVwiLCB0aGlzLnJvb3RVcmkuZnNQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguaW5jbHVkZXMoXCIke3ZjcGtnUm9vdH1cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGggPSByZXNvbHZlZFBhdGgucmVwbGFjZShcIiR7dmNwa2dSb290fVwiLCB1dGlsLmdldFZjcGtnUm9vdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguaW5jbHVkZXMoXCIqXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZWRQYXRoLnJlcGxhY2UoL1xcKi9nLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzV1NMID0gaXNXaW5kb3dzICYmIHJlc29sdmVkUGF0aC5zdGFydHNXaXRoKFwiL1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1dTTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1udFN0ciA9IFwiL21udC9cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IFwiL21udC9jL1wiLmxlbmd0aCAmJiByZXNvbHZlZFBhdGguc3Vic3RyKDAsIG1udFN0ci5sZW5ndGgpID09PSBtbnRTdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZWRQYXRoLnN1YnN0cihtbnRTdHIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZWRQYXRoLnN1YnN0cigwLCAxKSArIFwiOlwiICsgcmVzb2x2ZWRQYXRoLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yb290ZnMgJiYgdGhpcy5yb290ZnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGggPSB0aGlzLnJvb3RmcyArIHJlc29sdmVkUGF0aC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHJlc29sdmVkUGF0aC5yZXBsYWNlKC9cXC8vZywgcGF0aC5zZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBwYXRoRXhpc3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBleGlzdHNXaXRoRXhlQWRkZWQgPSAocGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0NvbXBpbGVyUGF0aCAmJiBpc1dpbmRvd3MgJiYgIWlzV1NMICYmIGZzLmV4aXN0c1N5bmMocGF0aCArIFwiLmV4ZVwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocmVzb2x2ZWRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdHNXaXRoRXhlQWRkZWQocmVzb2x2ZWRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGggKz0gXCIuZXhlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSB0aGlzLnJvb3RVcmkuZnNQYXRoICsgcGF0aC5zZXAgKyByZXNvbHZlZFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RzV2l0aEV4ZUFkZGVkKHJlc29sdmVkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGggKz0gXCIuZXhlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGggPSByZWxhdGl2ZVBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjdXJPZmZzZXQgPSBjdXJUZXh0LmluZGV4T2YoY3VyUGF0aCk7IGN1ck9mZnNldCAhPT0gLTE7IGN1ck9mZnNldCA9IGN1clRleHQuaW5kZXhPZihjdXJQYXRoLCBjdXJPZmZzZXQgKyBjdXJQYXRoLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGhFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBDYW5ub3QgZmluZCBcIiR7cmVzb2x2ZWRQYXRofVwiLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NxdWlnZ2xlTWV0cmljcy5QYXRoTm9uRXhpc3RlbnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VyT2Zmc2V0ID49IGZvcmNlZEluY2x1ZGVTdGFydCAmJiBjdXJPZmZzZXQgPD0gZm9yY2VkZUluY2x1ZGVFbmQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VyT2Zmc2V0ID49IGNvbXBpbGVDb21tYW5kc1N0YXJ0ICYmIGN1ck9mZnNldCA8PSBjb21waWxlQ29tbWFuZHNFbmQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VyT2Zmc2V0ID49IGNvbXBpbGVyUGF0aFN0YXJ0ICYmIGN1ck9mZnNldCA8PSBjb21waWxlclBhdGhFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5jaGVja0ZpbGVFeGlzdHNTeW5jKHJlc29sdmVkUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgUGF0aCBpcyBub3QgYSBmaWxlOiBcIiR7cmVzb2x2ZWRQYXRofVwiLmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTcXVpZ2dsZU1ldHJpY3MuUGF0aE5vdEFGaWxlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5jaGVja0RpcmVjdG9yeUV4aXN0c1N5bmMocmVzb2x2ZWRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBQYXRoIGlzIG5vdCBhIGRpcmVjdG9yeTogXCIke3Jlc29sdmVkUGF0aH1cIi5gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3F1aWdnbGVNZXRyaWNzLlBhdGhOb3RBRGlyZWN0b3J5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpYWdub3N0aWMgPSBuZXcgdnNjb2RlLkRpYWdub3N0aWMobmV3IHZzY29kZS5SYW5nZShkb2N1bWVudC5wb3NpdGlvbkF0KGN1clRleHRTdGFydE9mZnNldCArIGN1ck9mZnNldCksIGRvY3VtZW50LnBvc2l0aW9uQXQoY3VyVGV4dFN0YXJ0T2Zmc2V0ICsgY3VyT2Zmc2V0ICsgY3VyUGF0aC5sZW5ndGggKyAoIWlzQ29tcGlsZXJQYXRoID8gLTEgOiAwKSkpLCBtZXNzYWdlLCB2c2NvZGUuRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljQ29sbGVjdGlvbi5zZXQoZG9jdW1lbnQudXJpLCBkaWFnbm9zdGljcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdub3N0aWNDb2xsZWN0aW9uLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRTcXVpZ2dsZU1ldHJpY3MgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG5ld1NxdWlnZ2xlTWV0cmljcy5QYXRoTm9uRXhpc3RlbnQgIT09IHRoaXMucHJldlNxdWlnZ2xlTWV0cmljc1t0aGlzLkN1cnJlbnRDb25maWd1cmF0aW9uLm5hbWVdLlBhdGhOb25FeGlzdGVudCkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZFNxdWlnZ2xlTWV0cmljcy5QYXRoTm9uRXhpc3RlbnQgPSBuZXdTcXVpZ2dsZU1ldHJpY3MuUGF0aE5vbkV4aXN0ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdTcXVpZ2dsZU1ldHJpY3MuUGF0aE5vdEFGaWxlICE9PSB0aGlzLnByZXZTcXVpZ2dsZU1ldHJpY3NbdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5uYW1lXS5QYXRoTm90QUZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRTcXVpZ2dsZU1ldHJpY3MuUGF0aE5vdEFGaWxlID0gbmV3U3F1aWdnbGVNZXRyaWNzLlBhdGhOb3RBRmlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3U3F1aWdnbGVNZXRyaWNzLlBhdGhOb3RBRGlyZWN0b3J5ICE9PSB0aGlzLnByZXZTcXVpZ2dsZU1ldHJpY3NbdGhpcy5DdXJyZW50Q29uZmlndXJhdGlvbi5uYW1lXS5QYXRoTm90QURpcmVjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZFNxdWlnZ2xlTWV0cmljcy5QYXRoTm90QURpcmVjdG9yeSA9IG5ld1NxdWlnZ2xlTWV0cmljcy5QYXRoTm90QURpcmVjdG9yeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlZFNxdWlnZ2xlTWV0cmljcykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoXCJDb25maWdTcXVpZ2dsZXNcIiwgbnVsbCwgY2hhbmdlZFNxdWlnZ2xlTWV0cmljcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcmV2U3F1aWdnbGVNZXRyaWNzW3RoaXMuQ3VycmVudENvbmZpZ3VyYXRpb24ubmFtZV0gPSBuZXdTcXVpZ2dsZU1ldHJpY3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUb1ZlcnNpb24yKCkge1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbkpzb24udmVyc2lvbiA9IDI7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUb1ZlcnNpb24zKCkge1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbkpzb24udmVyc2lvbiA9IDM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLm5hbWUgPT09IFwiTWFjXCIgfHwgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nICYmIGNvbmZpZy5uYW1lICE9PSBcIldpbjMyXCIgJiYgY29uZmlnLm5hbWUgIT09IFwiTGludXhcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubWFjRnJhbWV3b3JrUGF0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1hY0ZyYW1ld29ya1BhdGggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiL1N5c3RlbS9MaWJyYXJ5L0ZyYW1ld29ya3NcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIvTGlicmFyeS9GcmFtZXdvcmtzXCJcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlVG9WZXJzaW9uNCgpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLnZlcnNpb24gPSA0O1xyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKHRoaXMucm9vdFVyaSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZ3VyYXRpb25Kc29uLmNvbmZpZ3VyYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmludGVsbGlTZW5zZU1vZGUgPT09IHVuZGVmaW5lZCAmJiAhc2V0dGluZ3MuZGVmYXVsdEludGVsbGlTZW5zZU1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5pbnRlbGxpU2Vuc2VNb2RlID0gdGhpcy5nZXRJbnRlbGxpU2Vuc2VNb2RlRm9yUGxhdGZvcm0oY29uZmlnLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuY29tcGlsZXJQYXRoID09PSB1bmRlZmluZWQgJiYgdGhpcy5kZWZhdWx0Q29tcGlsZXJQYXRoICYmICFjb25maWcuY29tcGlsZUNvbW1hbmRzICYmICFzZXR0aW5ncy5kZWZhdWx0Q29tcGlsZXJQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuY29tcGlsZXJQYXRoID0gdGhpcy5kZWZhdWx0Q29tcGlsZXJQYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmNTdGFuZGFyZCAmJiB0aGlzLmRlZmF1bHRDU3RhbmRhcmQgJiYgIXNldHRpbmdzLmRlZmF1bHRDU3RhbmRhcmQpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5jU3RhbmRhcmQgPSB0aGlzLmRlZmF1bHRDU3RhbmRhcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuY3BwU3RhbmRhcmQgJiYgdGhpcy5kZWZhdWx0Q3BwU3RhbmRhcmQgJiYgIXNldHRpbmdzLmRlZmF1bHRDcHBTdGFuZGFyZCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmNwcFN0YW5kYXJkID0gdGhpcy5kZWZhdWx0Q3BwU3RhbmRhcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVja0NwcFByb3BlcnRpZXMoKSB7XHJcbiAgICAgICAgbGV0IHByb3BlcnRpZXNGaWxlID0gcGF0aC5qb2luKHRoaXMuY29uZmlnRm9sZGVyLCBcImNfY3BwX3Byb3BlcnRpZXMuanNvblwiKTtcclxuICAgICAgICBmcy5zdGF0KHByb3BlcnRpZXNGaWxlLCAoZXJyLCBzdGF0cykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUb0RlZmF1bHRTZXR0aW5ncyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvbmZpZ3VyYXRpb25DaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0cy5tdGltZSA+IHRoaXMuY29uZmlnRmlsZVdhdGNoZXJGYWxsYmFja1RpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0ZpbGUgPSB2c2NvZGUuVXJpLmZpbGUocHJvcGVydGllc0ZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25maWd1cmF0aW9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5mb3JFYWNoKChkKSA9PiBkLmRpc3Bvc2UoKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29tcGlsZUNvbW1hbmRGaWxlV2F0Y2hlcnMuZm9yRWFjaCgod2F0Y2hlcikgPT4gd2F0Y2hlci5jbG9zZSgpKTtcclxuICAgICAgICB0aGlzLmNvbXBpbGVDb21tYW5kRmlsZVdhdGNoZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljQ29sbGVjdGlvbi5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DcHBQcm9wZXJ0aWVzID0gQ3BwUHJvcGVydGllcztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/configurations.ts\n");

/***/ }),

/***/ "./src/LanguageServer/customProviders.ts":
/*!***********************************************!*\
  !*** ./src/LanguageServer/customProviders.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_cpptools_1 = __webpack_require__(/*! vscode-cpptools */ \"./node_modules/vscode-cpptools/out/api.js\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/LanguageServer/settings.ts\");\r\nclass CustomProviderWrapper {\r\n    constructor(provider, version) {\r\n        this._isReady = version < vscode_cpptools_1.Version.v2;\r\n        this.provider = provider;\r\n        if (provider.extensionId && version === vscode_cpptools_1.Version.v0) {\r\n            version = vscode_cpptools_1.Version.v1;\r\n        }\r\n        this._version = version;\r\n    }\r\n    get isReady() {\r\n        return this._isReady;\r\n    }\r\n    set isReady(ready) {\r\n        this._isReady = ready;\r\n    }\r\n    get isValid() {\r\n        let valid = !!(this.provider.name && this.provider.canProvideConfiguration && this.provider.provideConfigurations);\r\n        if (valid && this._version > vscode_cpptools_1.Version.v0) {\r\n            valid = !!(this.provider.extensionId && this.provider.dispose);\r\n        }\r\n        if (valid && this._version > vscode_cpptools_1.Version.v1) {\r\n            valid = !!(this.provider.canProvideBrowseConfiguration && this.provider.provideBrowseConfiguration);\r\n        }\r\n        return valid;\r\n    }\r\n    get version() {\r\n        return this._version;\r\n    }\r\n    get name() {\r\n        return this.provider.name;\r\n    }\r\n    get extensionId() {\r\n        return this._version === vscode_cpptools_1.Version.v0 ? this.provider.name : this.provider.extensionId;\r\n    }\r\n    canProvideConfiguration(uri, token) {\r\n        return this.provider.canProvideConfiguration(uri, token);\r\n    }\r\n    provideConfigurations(uris, token) {\r\n        return this.provider.provideConfigurations(uris, token);\r\n    }\r\n    canProvideBrowseConfiguration(token) {\r\n        return this._version < vscode_cpptools_1.Version.v2 ? Promise.resolve(false) : this.provider.canProvideBrowseConfiguration(token);\r\n    }\r\n    provideBrowseConfiguration(token) {\r\n        console.assert(this._version >= vscode_cpptools_1.Version.v2);\r\n        return this._version < vscode_cpptools_1.Version.v2 ? Promise.resolve({ browsePath: [] }) : this.provider.provideBrowseConfiguration(token);\r\n    }\r\n    dispose() {\r\n        if (this._version !== vscode_cpptools_1.Version.v0) {\r\n            this.provider.dispose();\r\n        }\r\n    }\r\n}\r\nclass CustomConfigurationProviderCollection {\r\n    constructor() {\r\n        this.providers = new Map();\r\n    }\r\n    logProblems(provider, version) {\r\n        let missing = [];\r\n        if (!provider.name) {\r\n            missing.push(\"'name'\");\r\n        }\r\n        if (version !== vscode_cpptools_1.Version.v0 && !provider.extensionId) {\r\n            missing.push(\"'extensionId'\");\r\n        }\r\n        if (!provider.canProvideConfiguration) {\r\n            missing.push(\"'canProvideConfiguration'\");\r\n        }\r\n        if (!provider.provideConfigurations) {\r\n            missing.push(\"'canProvideConfiguration'\");\r\n        }\r\n        if (version !== vscode_cpptools_1.Version.v0 && !provider.dispose) {\r\n            missing.push(\"'dispose'\");\r\n        }\r\n        if (version >= vscode_cpptools_1.Version.v2 && !provider.canProvideBrowseConfiguration) {\r\n            missing.push(\"'canProvideBrowseConfiguration'\");\r\n        }\r\n        if (version >= vscode_cpptools_1.Version.v2 && !provider.provideBrowseConfiguration) {\r\n            missing.push(\"'provideBrowseConfiguration'\");\r\n        }\r\n        console.error(`CustomConfigurationProvider was not registered. The following properties are missing from the implementation: ${missing.join(\", \")}.`);\r\n    }\r\n    getId(provider) {\r\n        if (typeof provider === \"string\") {\r\n            return provider;\r\n        }\r\n        else if (provider.extensionId) {\r\n            return provider.extensionId;\r\n        }\r\n        else if (provider.name) {\r\n            return provider.name;\r\n        }\r\n        else {\r\n            console.error(`invalid provider: ${provider}`);\r\n            return \"\";\r\n        }\r\n    }\r\n    get size() {\r\n        return this.providers.size;\r\n    }\r\n    add(provider, version) {\r\n        if (new settings_1.CppSettings().intelliSenseEngine === \"Disabled\") {\r\n            console.warn(\"IntelliSense is disabled. Provider will not be registered.\");\r\n            return false;\r\n        }\r\n        let wrapper = new CustomProviderWrapper(provider, version);\r\n        if (!wrapper.isValid) {\r\n            this.logProblems(provider, version);\r\n            return false;\r\n        }\r\n        let exists = this.providers.has(wrapper.extensionId);\r\n        if (exists) {\r\n            let existing = this.providers.get(wrapper.extensionId);\r\n            exists = (existing.version === vscode_cpptools_1.Version.v0 && wrapper.version === vscode_cpptools_1.Version.v0);\r\n        }\r\n        if (!exists) {\r\n            this.providers.set(wrapper.extensionId, wrapper);\r\n        }\r\n        else {\r\n            console.error(`CustomConfigurationProvider '${wrapper.extensionId}' has already been registered.`);\r\n        }\r\n        return !exists;\r\n    }\r\n    get(provider) {\r\n        let id = this.getId(provider);\r\n        if (this.providers.has(id)) {\r\n            return this.providers.get(id);\r\n        }\r\n        return null;\r\n    }\r\n    forEach(func) {\r\n        this.providers.forEach(provider => func(provider));\r\n    }\r\n    remove(provider) {\r\n        let id = this.getId(provider);\r\n        if (this.providers.has(id)) {\r\n            this.providers.delete(id);\r\n        }\r\n        else {\r\n            console.warn(`${id} is not registered`);\r\n        }\r\n    }\r\n    checkId(providerId) {\r\n        if (!providerId) {\r\n            return providerId;\r\n        }\r\n        let found = [];\r\n        let noUpdate = false;\r\n        this.forEach(provider => {\r\n            if (provider.extensionId === providerId) {\r\n                noUpdate = true;\r\n            }\r\n            else if (provider.name === providerId && provider.version !== vscode_cpptools_1.Version.v0) {\r\n                found.push(provider);\r\n            }\r\n        });\r\n        if (noUpdate) {\r\n            return providerId;\r\n        }\r\n        if (found.length === 1) {\r\n            return found[0].extensionId;\r\n        }\r\n        else if (found.length > 1) {\r\n            console.warn(\"duplicate provider name found. Not upgrading.\");\r\n        }\r\n        return providerId;\r\n    }\r\n}\r\nexports.CustomConfigurationProviderCollection = CustomConfigurationProviderCollection;\r\nlet providerCollection = new CustomConfigurationProviderCollection();\r\nfunction getCustomConfigProviders() {\r\n    return providerCollection;\r\n}\r\nexports.getCustomConfigProviders = getCustomConfigProviders;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvY3VzdG9tUHJvdmlkZXJzLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9MYW5ndWFnZVNlcnZlci9jdXN0b21Qcm92aWRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZV9jcHB0b29sc18xID0gcmVxdWlyZShcInZzY29kZS1jcHB0b29sc1wiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jbGFzcyBDdXN0b21Qcm92aWRlcldyYXBwZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHZlcnNpb24pIHtcclxuICAgICAgICB0aGlzLl9pc1JlYWR5ID0gdmVyc2lvbiA8IHZzY29kZV9jcHB0b29sc18xLlZlcnNpb24udjI7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIGlmIChwcm92aWRlci5leHRlbnNpb25JZCAmJiB2ZXJzaW9uID09PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwKSB7XHJcbiAgICAgICAgICAgIHZlcnNpb24gPSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIH1cclxuICAgIGdldCBpc1JlYWR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1JlYWR5O1xyXG4gICAgfVxyXG4gICAgc2V0IGlzUmVhZHkocmVhZHkpIHtcclxuICAgICAgICB0aGlzLl9pc1JlYWR5ID0gcmVhZHk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNWYWxpZCgpIHtcclxuICAgICAgICBsZXQgdmFsaWQgPSAhISh0aGlzLnByb3ZpZGVyLm5hbWUgJiYgdGhpcy5wcm92aWRlci5jYW5Qcm92aWRlQ29uZmlndXJhdGlvbiAmJiB0aGlzLnByb3ZpZGVyLnByb3ZpZGVDb25maWd1cmF0aW9ucyk7XHJcbiAgICAgICAgaWYgKHZhbGlkICYmIHRoaXMuX3ZlcnNpb24gPiB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gISEodGhpcy5wcm92aWRlci5leHRlbnNpb25JZCAmJiB0aGlzLnByb3ZpZGVyLmRpc3Bvc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsaWQgJiYgdGhpcy5fdmVyc2lvbiA+IHZzY29kZV9jcHB0b29sc18xLlZlcnNpb24udjEpIHtcclxuICAgICAgICAgICAgdmFsaWQgPSAhISh0aGlzLnByb3ZpZGVyLmNhblByb3ZpZGVCcm93c2VDb25maWd1cmF0aW9uICYmIHRoaXMucHJvdmlkZXIucHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmVyc2lvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLm5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZXh0ZW5zaW9uSWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb24gPT09IHZzY29kZV9jcHB0b29sc18xLlZlcnNpb24udjAgPyB0aGlzLnByb3ZpZGVyLm5hbWUgOiB0aGlzLnByb3ZpZGVyLmV4dGVuc2lvbklkO1xyXG4gICAgfVxyXG4gICAgY2FuUHJvdmlkZUNvbmZpZ3VyYXRpb24odXJpLCB0b2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmNhblByb3ZpZGVDb25maWd1cmF0aW9uKHVyaSwgdG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcHJvdmlkZUNvbmZpZ3VyYXRpb25zKHVyaXMsIHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucHJvdmlkZUNvbmZpZ3VyYXRpb25zKHVyaXMsIHRva2VuKTtcclxuICAgIH1cclxuICAgIGNhblByb3ZpZGVCcm93c2VDb25maWd1cmF0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb24gPCB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYyID8gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKSA6IHRoaXMucHJvdmlkZXIuY2FuUHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24odG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24odG9rZW4pIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLl92ZXJzaW9uID49IHZzY29kZV9jcHB0b29sc18xLlZlcnNpb24udjIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uIDwgdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MiA/IFByb21pc2UucmVzb2x2ZSh7IGJyb3dzZVBhdGg6IFtdIH0pIDogdGhpcy5wcm92aWRlci5wcm92aWRlQnJvd3NlQ29uZmlndXJhdGlvbih0b2tlbik7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92ZXJzaW9uICE9PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXJDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgbG9nUHJvYmxlbXMocHJvdmlkZXIsIHZlcnNpb24pIHtcclxuICAgICAgICBsZXQgbWlzc2luZyA9IFtdO1xyXG4gICAgICAgIGlmICghcHJvdmlkZXIubmFtZSkge1xyXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCInbmFtZSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwICYmICFwcm92aWRlci5leHRlbnNpb25JZCkge1xyXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCInZXh0ZW5zaW9uSWQnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByb3ZpZGVyLmNhblByb3ZpZGVDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcIidjYW5Qcm92aWRlQ29uZmlndXJhdGlvbidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJvdmlkZXIucHJvdmlkZUNvbmZpZ3VyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcIidjYW5Qcm92aWRlQ29uZmlndXJhdGlvbidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwICYmICFwcm92aWRlci5kaXNwb3NlKSB7XHJcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcIidkaXNwb3NlJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPj0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MiAmJiAhcHJvdmlkZXIuY2FuUHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiJ2NhblByb3ZpZGVCcm93c2VDb25maWd1cmF0aW9uJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPj0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MiAmJiAhcHJvdmlkZXIucHJvdmlkZUJyb3dzZUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiJ3Byb3ZpZGVCcm93c2VDb25maWd1cmF0aW9uJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyIHdhcyBub3QgcmVnaXN0ZXJlZC4gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBtaXNzaW5nIGZyb20gdGhlIGltcGxlbWVudGF0aW9uOiAke21pc3Npbmcuam9pbihcIiwgXCIpfS5gKTtcclxuICAgIH1cclxuICAgIGdldElkKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLmV4dGVuc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5leHRlbnNpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIubmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGludmFsaWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5zaXplO1xyXG4gICAgfVxyXG4gICAgYWRkKHByb3ZpZGVyLCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKCkuaW50ZWxsaVNlbnNlRW5naW5lID09PSBcIkRpc2FibGVkXCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSW50ZWxsaVNlbnNlIGlzIGRpc2FibGVkLiBQcm92aWRlciB3aWxsIG5vdCBiZSByZWdpc3RlcmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgd3JhcHBlciA9IG5ldyBDdXN0b21Qcm92aWRlcldyYXBwZXIocHJvdmlkZXIsIHZlcnNpb24pO1xyXG4gICAgICAgIGlmICghd3JhcHBlci5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nUHJvYmxlbXMocHJvdmlkZXIsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBleGlzdHMgPSB0aGlzLnByb3ZpZGVycy5oYXMod3JhcHBlci5leHRlbnNpb25JZCk7XHJcbiAgICAgICAgaWYgKGV4aXN0cykge1xyXG4gICAgICAgICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnByb3ZpZGVycy5nZXQod3JhcHBlci5leHRlbnNpb25JZCk7XHJcbiAgICAgICAgICAgIGV4aXN0cyA9IChleGlzdGluZy52ZXJzaW9uID09PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYwICYmIHdyYXBwZXIudmVyc2lvbiA9PT0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldCh3cmFwcGVyLmV4dGVuc2lvbklkLCB3cmFwcGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlciAnJHt3cmFwcGVyLmV4dGVuc2lvbklkfScgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIWV4aXN0cztcclxuICAgIH1cclxuICAgIGdldChwcm92aWRlcikge1xyXG4gICAgICAgIGxldCBpZCA9IHRoaXMuZ2V0SWQocHJvdmlkZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZvckVhY2goZnVuYykge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLmZvckVhY2gocHJvdmlkZXIgPT4gZnVuYyhwcm92aWRlcikpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgbGV0IGlkID0gdGhpcy5nZXRJZChwcm92aWRlcik7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXJzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpZH0gaXMgbm90IHJlZ2lzdGVyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVja0lkKHByb3ZpZGVySWQpIHtcclxuICAgICAgICBpZiAoIXByb3ZpZGVySWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVySWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xyXG4gICAgICAgIGxldCBub1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChwcm92aWRlciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5leHRlbnNpb25JZCA9PT0gcHJvdmlkZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgbm9VcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLm5hbWUgPT09IHByb3ZpZGVySWQgJiYgcHJvdmlkZXIudmVyc2lvbiAhPT0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MCkge1xyXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChwcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobm9VcGRhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVySWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kWzBdLmV4dGVuc2lvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmb3VuZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImR1cGxpY2F0ZSBwcm92aWRlciBuYW1lIGZvdW5kLiBOb3QgdXBncmFkaW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVySWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXJDb2xsZWN0aW9uID0gQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyQ29sbGVjdGlvbjtcclxubGV0IHByb3ZpZGVyQ29sbGVjdGlvbiA9IG5ldyBDdXN0b21Db25maWd1cmF0aW9uUHJvdmlkZXJDb2xsZWN0aW9uKCk7XHJcbmZ1bmN0aW9uIGdldEN1c3RvbUNvbmZpZ1Byb3ZpZGVycygpIHtcclxuICAgIHJldHVybiBwcm92aWRlckNvbGxlY3Rpb247XHJcbn1cclxuZXhwb3J0cy5nZXRDdXN0b21Db25maWdQcm92aWRlcnMgPSBnZXRDdXN0b21Db25maWdQcm92aWRlcnM7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LanguageServer/customProviders.ts\n");

/***/ }),

/***/ "./src/LanguageServer/dataBinding.ts":
/*!*******************************************!*\
  !*** ./src/LanguageServer/dataBinding.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass DataBinding {\r\n    constructor(value) {\r\n        this.valueChanged = new vscode.EventEmitter();\r\n        this.isActive = true;\r\n        this.value = value;\r\n        this.isActive = true;\r\n    }\r\n    get Value() {\r\n        return this.value;\r\n    }\r\n    set Value(value) {\r\n        if (value !== this.value) {\r\n            this.value = value;\r\n            if (this.isActive) {\r\n                this.valueChanged.fire(this.value);\r\n            }\r\n        }\r\n    }\r\n    get ValueChanged() {\r\n        return this.valueChanged.event;\r\n    }\r\n    activate() {\r\n        this.isActive = true;\r\n        this.valueChanged.fire(this.value);\r\n    }\r\n    deactivate() {\r\n        this.isActive = false;\r\n    }\r\n    dispose() {\r\n        this.deactivate();\r\n        this.valueChanged.dispose();\r\n    }\r\n}\r\nexports.DataBinding = DataBinding;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvZGF0YUJpbmRpbmcudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL2RhdGFCaW5kaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY2xhc3MgRGF0YUJpbmRpbmcge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCA9IG5ldyB2c2NvZGUuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkLmZpcmUodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgVmFsdWVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2hhbmdlZC5ldmVudDtcclxuICAgIH1cclxuICAgIGFjdGl2YXRlKCkge1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkLmZpcmUodGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBkZWFjdGl2YXRlKCkge1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRGF0YUJpbmRpbmcgPSBEYXRhQmluZGluZztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LanguageServer/dataBinding.ts\n");

/***/ }),

/***/ "./src/LanguageServer/extension.ts":
/*!*****************************************!*\
  !*** ./src/LanguageServer/extension.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst telemetry = __webpack_require__(/*! ../telemetry */ \"./src/telemetry.ts\");\r\nconst ui_1 = __webpack_require__(/*! ./ui */ \"./src/LanguageServer/ui.ts\");\r\nconst clientCollection_1 = __webpack_require__(/*! ./clientCollection */ \"./src/LanguageServer/clientCollection.ts\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/LanguageServer/settings.ts\");\r\nconst persistentState_1 = __webpack_require__(/*! ./persistentState */ \"./src/LanguageServer/persistentState.ts\");\r\nconst languageConfig_1 = __webpack_require__(/*! ./languageConfig */ \"./src/LanguageServer/languageConfig.ts\");\r\nconst customProviders_1 = __webpack_require__(/*! ./customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nconst platform_1 = __webpack_require__(/*! ../platform */ \"./src/platform.ts\");\r\nconst vscode_languageclient_1 = __webpack_require__(/*! vscode-languageclient */ \"./node_modules/vscode-languageclient/lib/main.js\");\r\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst tmp = __webpack_require__(/*! tmp */ \"./node_modules/tmp/lib/tmp.js\");\r\nconst githubAPI_1 = __webpack_require__(/*! ../githubAPI */ \"./src/githubAPI.ts\");\r\nconst packageVersion_1 = __webpack_require__(/*! ../packageVersion */ \"./src/packageVersion.ts\");\r\nconst commands_1 = __webpack_require__(/*! ../commands */ \"./src/commands.ts\");\r\nlet prevCrashFile;\r\nlet clients;\r\nlet activeDocument;\r\nlet ui;\r\nlet disposables = [];\r\nlet languageConfigurations = [];\r\nlet intervalTimer;\r\nlet insiderUpdateTimer;\r\nlet realActivationOccurred = false;\r\nlet tempCommands = [];\r\nlet activatedPreviously;\r\nconst insiderUpdateTimerInterval = 1000 * 60 * 60;\r\nlet buildInfoCache = null;\r\nconst taskSourceStr = \"C/C++\";\r\nconst cppInstallVsixStr = 'C/C++: Install vsix -- ';\r\nlet taskProvider;\r\nfunction activate(activationEventOccurred) {\r\n    if (realActivationOccurred) {\r\n        return;\r\n    }\r\n    activatedPreviously = new persistentState_1.PersistentWorkspaceState(\"activatedPreviously\", false);\r\n    if (activatedPreviously.Value) {\r\n        activatedPreviously.Value = false;\r\n        realActivation();\r\n    }\r\n    if (tempCommands.length === 0) {\r\n        tempCommands.push(vscode.workspace.onDidOpenTextDocument(d => onDidOpenTextDocument(d)));\r\n    }\r\n    if (activationEventOccurred) {\r\n        onActivationEvent();\r\n        return;\r\n    }\r\n    taskProvider = vscode.tasks.registerTaskProvider(taskSourceStr, {\r\n        provideTasks: () => {\r\n            return getBuildTasks();\r\n        },\r\n        resolveTask(task) {\r\n            return undefined;\r\n        }\r\n    });\r\n    vscode.tasks.onDidStartTask(event => {\r\n        if (event.execution.task.source === taskSourceStr) {\r\n            telemetry.logLanguageServerEvent('buildTaskStarted');\r\n        }\r\n    });\r\n    if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {\r\n        for (let i = 0; i < vscode.workspace.workspaceFolders.length; ++i) {\r\n            let config = path.join(vscode.workspace.workspaceFolders[i].uri.fsPath, \".vscode/c_cpp_properties.json\");\r\n            if (fs.existsSync(config)) {\r\n                onActivationEvent();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (vscode.workspace.textDocuments !== undefined && vscode.workspace.textDocuments.length > 0) {\r\n        for (let i = 0; i < vscode.workspace.textDocuments.length; ++i) {\r\n            let document = vscode.workspace.textDocuments[i];\r\n            if (document.languageId === \"cpp\" || document.languageId === \"c\") {\r\n                onActivationEvent();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.activate = activate;\r\nfunction getBuildTasks() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (!editor) {\r\n            return [];\r\n        }\r\n        const fileExt = path.extname(editor.document.fileName);\r\n        if (!fileExt) {\r\n            return;\r\n        }\r\n        const fileExtLower = fileExt.toLowerCase();\r\n        const isHeader = !fileExt || [\".hpp\", \".hh\", \".hxx\", \".h\", \".inl\", \"\"].some(ext => fileExtLower === ext);\r\n        if (isHeader) {\r\n            return [];\r\n        }\r\n        let fileIsCpp;\r\n        let fileIsC;\r\n        if (fileExt === \".C\") {\r\n            fileIsCpp = true;\r\n            fileIsC = true;\r\n        }\r\n        else {\r\n            fileIsCpp = [\".cpp\", \".cc\", \".cxx\", \".mm\", \".ino\"].some(ext => fileExtLower === ext);\r\n            fileIsC = fileExtLower === \".c\";\r\n        }\r\n        if (!(fileIsCpp || fileIsC)) {\r\n            return [];\r\n        }\r\n        let compilerPaths;\r\n        const isWindows = os.platform() === 'win32';\r\n        const activeClient = getActiveClient();\r\n        let userCompilerPath = yield activeClient.getCompilerPath();\r\n        if (userCompilerPath) {\r\n            userCompilerPath = userCompilerPath.trim();\r\n            if (isWindows && userCompilerPath.startsWith(\"/\")) {\r\n                userCompilerPath = null;\r\n            }\r\n            else {\r\n                userCompilerPath = userCompilerPath.replace(/\\\\\\\\/g, \"\\\\\");\r\n            }\r\n        }\r\n        let knownCompilers = yield activeClient.getKnownCompilers();\r\n        if (knownCompilers) {\r\n            knownCompilers = knownCompilers.filter(info => {\r\n                return ((fileIsCpp && !info.isC) || (fileIsC && info.isC)) &&\r\n                    (!isWindows || !info.path.startsWith(\"/\"));\r\n            });\r\n            compilerPaths = knownCompilers.map(info => { return info.path; });\r\n            let map = new Map();\r\n            const insertOrAssignEntry = (compilerPath) => {\r\n                const basename = path.basename(compilerPath);\r\n                map.set(basename, compilerPath);\r\n            };\r\n            compilerPaths.forEach(insertOrAssignEntry);\r\n            if (userCompilerPath) {\r\n                insertOrAssignEntry(userCompilerPath);\r\n            }\r\n            compilerPaths = [...map.values()];\r\n        }\r\n        else if (userCompilerPath) {\r\n            compilerPaths = [userCompilerPath];\r\n        }\r\n        if (!compilerPaths) {\r\n            telemetry.logLanguageServerEvent('noCompilerFound');\r\n            return [];\r\n        }\r\n        return compilerPaths.map(compilerPath => {\r\n            let compilerPathAndArgs = util.extractCompilerPathAndArgs(compilerPath);\r\n            compilerPath = compilerPathAndArgs.compilerPath;\r\n            const filePath = path.join('${fileDirname}', '${fileBasenameNoExtension}');\r\n            const compilerPathBase = path.basename(compilerPath);\r\n            const taskName = compilerPathBase + \" build active file\";\r\n            const isCl = taskName.startsWith(\"cl.exe\");\r\n            let args = isCl ? ['/Zi', '/EHsc', '/Fe:', filePath + '.exe', '${file}'] : ['-g', '${file}', '-o', filePath + (isWindows ? '.exe' : '')];\r\n            if (compilerPathAndArgs.additionalArgs) {\r\n                args = args.concat(compilerPathAndArgs.additionalArgs);\r\n            }\r\n            const cwd = isCl ? \"\" : path.dirname(compilerPath);\r\n            const kind = {\r\n                type: 'shell',\r\n                label: taskName,\r\n                command: isCl ? compilerPathBase : compilerPath,\r\n                args: args,\r\n                options: isCl ? undefined : { \"cwd\": cwd },\r\n                compilerPath: isCl ? compilerPathBase : compilerPath\r\n            };\r\n            const command = new vscode.ShellExecution(compilerPath, [...args], { cwd: cwd });\r\n            const target = vscode.workspace.getWorkspaceFolder(clients.ActiveClient.RootUri);\r\n            let task = new vscode.Task(kind, target, taskName, taskSourceStr, command, '$gcc');\r\n            task.definition = kind;\r\n            task.group = vscode.TaskGroup.Build;\r\n            return task;\r\n        });\r\n    });\r\n}\r\nexports.getBuildTasks = getBuildTasks;\r\nfunction onDidOpenTextDocument(document) {\r\n    if (document.languageId === \"c\" || document.languageId === \"cpp\") {\r\n        onActivationEvent();\r\n    }\r\n}\r\nfunction onActivationEvent() {\r\n    if (tempCommands.length === 0) {\r\n        return;\r\n    }\r\n    tempCommands.forEach((command) => {\r\n        command.dispose();\r\n    });\r\n    tempCommands = [];\r\n    if (!realActivationOccurred) {\r\n        realActivation();\r\n    }\r\n    activatedPreviously.Value = true;\r\n}\r\nfunction realActivation() {\r\n    if (new settings_1.CppSettings().intelliSenseEngine === \"Disabled\") {\r\n        throw new Error(\"Do not activate the extension when IntelliSense is disabled.\");\r\n    }\r\n    else {\r\n        console.log(\"activating extension\");\r\n        let checkForConflictingExtensions = new persistentState_1.PersistentState(\"CPP.\" + util.packageJson.version + \".checkForConflictingExtensions\", true);\r\n        if (checkForConflictingExtensions.Value) {\r\n            checkForConflictingExtensions.Value = false;\r\n            let clangCommandAdapterActive = vscode.extensions.all.some((extension, index, array) => {\r\n                return extension.isActive && extension.id === \"mitaki28.vscode-clang\";\r\n            });\r\n            if (clangCommandAdapterActive) {\r\n                telemetry.logLanguageServerEvent(\"conflictingExtension\");\r\n            }\r\n        }\r\n    }\r\n    realActivationOccurred = true;\r\n    console.log(\"starting language server\");\r\n    clients = new clientCollection_1.ClientCollection();\r\n    ui = ui_1.getUI();\r\n    if (vscode.workspace.textDocuments !== undefined && vscode.workspace.textDocuments.length > 0) {\r\n        onDidChangeActiveTextEditor(vscode.window.activeTextEditor);\r\n    }\r\n    clients.forEach(client => {\r\n        customProviders_1.getCustomConfigProviders().forEach(provider => client.onRegisterCustomConfigurationProvider(provider));\r\n    });\r\n    disposables.push(vscode.workspace.onDidChangeConfiguration(onDidChangeSettings));\r\n    disposables.push(vscode.workspace.onDidSaveTextDocument(onDidSaveTextDocument));\r\n    disposables.push(vscode.window.onDidChangeActiveTextEditor(onDidChangeActiveTextEditor));\r\n    disposables.push(vscode.window.onDidChangeTextEditorSelection(onDidChangeTextEditorSelection));\r\n    disposables.push(vscode.window.onDidChangeVisibleTextEditors(onDidChangeVisibleTextEditors));\r\n    updateLanguageConfigurations();\r\n    reportMacCrashes();\r\n    const settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);\r\n    if (settings.updateChannel === 'Default') {\r\n        suggestInsidersChannel();\r\n    }\r\n    else if (settings.updateChannel === 'Insiders') {\r\n        insiderUpdateTimer = setInterval(checkAndApplyUpdate, insiderUpdateTimerInterval, settings.updateChannel);\r\n        checkAndApplyUpdate(settings.updateChannel);\r\n    }\r\n    intervalTimer = setInterval(onInterval, 2500);\r\n}\r\nfunction updateLanguageConfigurations() {\r\n    languageConfigurations.forEach(d => d.dispose());\r\n    languageConfigurations = [];\r\n    languageConfigurations.push(vscode.languages.setLanguageConfiguration('c', languageConfig_1.getLanguageConfig('c', clients.ActiveClient.RootUri)));\r\n    languageConfigurations.push(vscode.languages.setLanguageConfiguration('cpp', languageConfig_1.getLanguageConfig('cpp', clients.ActiveClient.RootUri)));\r\n}\r\nexports.updateLanguageConfigurations = updateLanguageConfigurations;\r\nfunction onDidChangeSettings() {\r\n    const changedActiveClientSettings = clients.ActiveClient.onDidChangeSettings();\r\n    clients.forEach(client => client.onDidChangeSettings());\r\n    const newUpdateChannel = changedActiveClientSettings['updateChannel'];\r\n    if (newUpdateChannel) {\r\n        if (newUpdateChannel === 'Default') {\r\n            clearInterval(insiderUpdateTimer);\r\n        }\r\n        else if (newUpdateChannel === 'Insiders') {\r\n            insiderUpdateTimer = setInterval(checkAndApplyUpdate, insiderUpdateTimerInterval);\r\n        }\r\n        checkAndApplyUpdate(newUpdateChannel);\r\n    }\r\n}\r\nlet saveMessageShown = false;\r\nfunction onDidSaveTextDocument(doc) {\r\n    if (!vscode.window.activeTextEditor || doc !== vscode.window.activeTextEditor.document || (doc.languageId !== \"cpp\" && doc.languageId !== \"c\")) {\r\n        return;\r\n    }\r\n    if (!saveMessageShown && new settings_1.CppSettings(doc.uri).clangFormatOnSave) {\r\n        saveMessageShown = true;\r\n        vscode.window.showInformationMessage(\"\\\"C_Cpp.clang_format_formatOnSave\\\" has been removed. Please use \\\"editor.formatOnSave\\\" instead.\");\r\n    }\r\n}\r\nfunction onDidChangeActiveTextEditor(editor) {\r\n    console.assert(clients !== undefined, \"client should be available before active editor is changed\");\r\n    if (clients === undefined) {\r\n        return;\r\n    }\r\n    let activeEditor = vscode.window.activeTextEditor;\r\n    if (!activeEditor || (activeEditor.document.languageId !== \"cpp\" && activeEditor.document.languageId !== \"c\")) {\r\n        activeDocument = \"\";\r\n    }\r\n    else {\r\n        activeDocument = editor.document.uri.toString();\r\n        clients.activeDocumentChanged(editor.document);\r\n        clients.ActiveClient.selectionChanged(vscode_languageclient_1.Range.create(editor.selection.start, editor.selection.end));\r\n    }\r\n    ui.activeDocumentChanged();\r\n}\r\nfunction onDidChangeTextEditorSelection(event) {\r\n    if (!event.textEditor || !vscode.window.activeTextEditor || event.textEditor.document.uri !== vscode.window.activeTextEditor.document.uri ||\r\n        (event.textEditor.document.languageId !== \"cpp\" && event.textEditor.document.languageId !== \"c\")) {\r\n        return;\r\n    }\r\n    if (activeDocument !== event.textEditor.document.uri.toString()) {\r\n        activeDocument = event.textEditor.document.uri.toString();\r\n        clients.activeDocumentChanged(event.textEditor.document);\r\n        ui.activeDocumentChanged();\r\n    }\r\n    clients.ActiveClient.selectionChanged(vscode_languageclient_1.Range.create(event.selections[0].start, event.selections[0].end));\r\n}\r\nfunction onDidChangeVisibleTextEditors(editors) {\r\n    clients.forEach(client => client.onDidChangeVisibleTextEditors(editors));\r\n}\r\nfunction onInterval() {\r\n    clients.ActiveClient.onInterval();\r\n}\r\nfunction installVsix(vsixLocation, updateChannel) {\r\n    return platform_1.PlatformInformation.GetPlatformInformation().then((platformInfo) => {\r\n        const vsCodeScriptPath = function (platformInfo) {\r\n            if (platformInfo.platform === 'win32') {\r\n                const vsCodeBinName = path.basename(process.execPath);\r\n                let cmdFile;\r\n                if (vsCodeBinName === 'Code - Insiders.exe') {\r\n                    cmdFile = 'code-insiders.cmd';\r\n                }\r\n                else if (vsCodeBinName === 'Code - Exploration.exe') {\r\n                    cmdFile = 'code-exploration.cmd';\r\n                }\r\n                else {\r\n                    cmdFile = 'code.cmd';\r\n                }\r\n                const vsCodeExeDir = path.dirname(process.execPath);\r\n                return path.join(vsCodeExeDir, 'bin', cmdFile);\r\n            }\r\n            else if (platformInfo.platform === 'darwin') {\r\n                return path.join(process.execPath, '..', '..', '..', '..', '..', 'Resources', 'app', 'bin', 'code');\r\n            }\r\n            else {\r\n                const vsCodeBinName = path.basename(process.execPath);\r\n                try {\r\n                    const stdout = child_process_1.execSync('which ' + vsCodeBinName);\r\n                    return stdout.toString().trim();\r\n                }\r\n                catch (error) {\r\n                    return undefined;\r\n                }\r\n            }\r\n        }(platformInfo);\r\n        if (!vsCodeScriptPath) {\r\n            return Promise.reject(new Error('Failed to find VS Code script'));\r\n        }\r\n        let userVersion = new packageVersion_1.PackageVersion(vscode.version);\r\n        let breakingVersion = new packageVersion_1.PackageVersion('1.28.0');\r\n        if (userVersion.isGreaterThan(breakingVersion, 'insider')) {\r\n            return new Promise((resolve, reject) => {\r\n                let process;\r\n                try {\r\n                    process = child_process_1.spawn(vsCodeScriptPath, ['--install-extension', vsixLocation, '--force']);\r\n                    const timer = setTimeout(() => {\r\n                        process.kill();\r\n                        reject(new Error('Failed to receive response from VS Code script process for installation within 30s.'));\r\n                    }, 30000);\r\n                    process.on('exit', (code) => {\r\n                        clearInterval(timer);\r\n                        if (code !== 0) {\r\n                            reject(new Error(`VS Code script exited with error code ${code}`));\r\n                        }\r\n                        else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                    if (process.pid === undefined) {\r\n                        throw new Error();\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    reject(new Error('Failed to launch VS Code script process for installation'));\r\n                    return;\r\n                }\r\n            });\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let process;\r\n            try {\r\n                process = child_process_1.spawn(vsCodeScriptPath, ['--install-extension', vsixLocation]);\r\n                if (process.pid === undefined) {\r\n                    throw new Error();\r\n                }\r\n            }\r\n            catch (error) {\r\n                reject(new Error('Failed to launch VS Code script process for installation'));\r\n                return;\r\n            }\r\n            const timer = setTimeout(() => {\r\n                process.kill();\r\n                reject(new Error('Failed to receive response from VS Code script process for installation within 30s.'));\r\n            }, 30000);\r\n            let sentOverride = false;\r\n            process.stdout.on('data', () => {\r\n                if (sentOverride) {\r\n                    return;\r\n                }\r\n                process.stdin.write('0\\n');\r\n                sentOverride = true;\r\n                clearInterval(timer);\r\n                resolve();\r\n            });\r\n        });\r\n    });\r\n}\r\nfunction suggestInsidersChannel() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let suggestInsiders = new persistentState_1.PersistentState(\"CPP.suggestInsiders\", true);\r\n        if (!suggestInsiders.Value) {\r\n            return;\r\n        }\r\n        let buildInfo;\r\n        try {\r\n            buildInfo = yield githubAPI_1.getTargetBuildInfo(\"Insiders\");\r\n        }\r\n        catch (error) {\r\n            console.log(`${cppInstallVsixStr}${error.message}`);\r\n            if (error.message.indexOf('/') !== -1 || error.message.indexOf('\\\\') !== -1) {\r\n                error.message = \"Potential PII hidden\";\r\n            }\r\n            telemetry.logLanguageServerEvent('suggestInsiders', { 'error': error.message, 'success': 'false' });\r\n        }\r\n        if (!buildInfo) {\r\n            return;\r\n        }\r\n        const message = `Insiders version ${buildInfo.name} is available. Would you like to switch to the Insiders channel and install this update?`;\r\n        const yes = \"Yes\";\r\n        const askLater = \"Ask Me Later\";\r\n        const dontShowAgain = \"Don't Show Again\";\r\n        let selection = yield vscode.window.showInformationMessage(message, yes, askLater, dontShowAgain);\r\n        switch (selection) {\r\n            case yes:\r\n                buildInfoCache = buildInfo;\r\n                vscode.workspace.getConfiguration(\"C_Cpp\").update(\"updateChannel\", \"Insiders\", vscode.ConfigurationTarget.Global);\r\n                break;\r\n            case dontShowAgain:\r\n                suggestInsiders.Value = false;\r\n                break;\r\n            case askLater:\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    });\r\n}\r\nfunction applyUpdate(buildInfo, updateChannel) {\r\n    return new Promise((resolve, reject) => {\r\n        tmp.file({ postfix: '.vsix' }, (err, vsixPath, fd, cleanupCallback) => __awaiter(this, void 0, void 0, function* () {\r\n            if (err) {\r\n                reject(new Error('Failed to create vsix file'));\r\n                return;\r\n            }\r\n            let config = vscode.workspace.getConfiguration();\r\n            let originalProxySupport = config.inspect('http.proxySupport').globalValue;\r\n            while (true) {\r\n                try {\r\n                    yield util.downloadFileToDestination(buildInfo.downloadUrl, vsixPath);\r\n                }\r\n                catch (_a) {\r\n                    if (originalProxySupport !== config.inspect('http.proxySupport').globalValue) {\r\n                        config.update('http.proxySupport', originalProxySupport, true);\r\n                        reject(new Error('Failed to download VSIX package with proxySupport off'));\r\n                        return;\r\n                    }\r\n                    if (config.get('http.proxySupport') !== \"off\" && originalProxySupport !== \"off\") {\r\n                        config.update('http.proxySupport', \"off\", true);\r\n                        continue;\r\n                    }\r\n                    reject(new Error('Failed to download VSIX package'));\r\n                    return;\r\n                }\r\n                if (originalProxySupport !== config.inspect('http.proxySupport').globalValue) {\r\n                    config.update('http.proxySupport', originalProxySupport, true);\r\n                    telemetry.logLanguageServerEvent('installVsix', { 'error': \"Success with proxySupport off\", 'success': 'true' });\r\n                }\r\n                break;\r\n            }\r\n            try {\r\n                yield installVsix(vsixPath, updateChannel);\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n                return;\r\n            }\r\n            clearInterval(insiderUpdateTimer);\r\n            const message = `The C/C++ Extension has been updated to version ${buildInfo.name}. Please reload the window for the changes to take effect.`;\r\n            util.promptReloadWindow(message);\r\n            telemetry.logLanguageServerEvent('installVsix', { 'success': 'true' });\r\n            resolve();\r\n        }));\r\n    }).catch(error => {\r\n        console.error(`${cppInstallVsixStr}${error.message}`);\r\n        if (error.message.indexOf('/') !== -1 || error.message.indexOf('\\\\') !== -1) {\r\n            error.message = \"Potential PII hidden\";\r\n        }\r\n        telemetry.logLanguageServerEvent('installVsix', { 'error': error.message, 'success': 'false' });\r\n    });\r\n}\r\nfunction checkAndApplyUpdate(updateChannel) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let buildInfo = buildInfoCache;\r\n        buildInfoCache = null;\r\n        if (!buildInfo) {\r\n            try {\r\n                buildInfo = yield githubAPI_1.getTargetBuildInfo(updateChannel);\r\n            }\r\n            catch (error) {\r\n                telemetry.logLanguageServerEvent('installVsix', { 'error': error.message, 'success': 'false' });\r\n            }\r\n        }\r\n        if (!buildInfo) {\r\n            return;\r\n        }\r\n        yield applyUpdate(buildInfo, updateChannel);\r\n    });\r\n}\r\nlet commandsRegistered = false;\r\nfunction registerCommands() {\r\n    if (commandsRegistered) {\r\n        return;\r\n    }\r\n    commandsRegistered = true;\r\n    commands_1.getTemporaryCommandRegistrarInstance().clearTempCommands();\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.Navigate', onNavigate));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.GoToDeclaration', onGoToDeclaration));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.PeekDeclaration', onPeekDeclaration));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.SwitchHeaderSource', onSwitchHeaderSource));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ResetDatabase', onResetDatabase));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationSelect', onSelectConfiguration));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationProviderSelect', onSelectConfigurationProvider));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationEdit', onEditConfiguration));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.AddToIncludePath', onAddToIncludePath));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ToggleErrorSquiggles', onToggleSquiggles));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ToggleIncludeFallback', onToggleIncludeFallback));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ToggleDimInactiveRegions', onToggleDimInactiveRegions));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowReleaseNotes', onShowReleaseNotes));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.PauseParsing', onPauseParsing));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ResumeParsing', onResumeParsing));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowParsingCommands', onShowParsingCommands));\r\n    disposables.push(vscode.commands.registerCommand('C_Cpp.TakeSurvey', onTakeSurvey));\r\n    disposables.push(vscode.commands.registerCommand('cpptools.activeConfigName', onGetActiveConfigName));\r\n    commands_1.getTemporaryCommandRegistrarInstance().executeDelayedCommands();\r\n}\r\nexports.registerCommands = registerCommands;\r\nfunction onNavigate() {\r\n    onActivationEvent();\r\n    let activeEditor = vscode.window.activeTextEditor;\r\n    if (!activeEditor) {\r\n        return;\r\n    }\r\n    clients.ActiveClient.requestNavigationList(activeEditor.document).then((navigationList) => {\r\n        ui.showNavigationOptions(navigationList);\r\n    });\r\n}\r\nfunction onGoToDeclaration() {\r\n    onActivationEvent();\r\n    clients.ActiveClient.requestGoToDeclaration().then(() => vscode.commands.executeCommand(\"editor.action.goToDeclaration\"));\r\n}\r\nfunction onPeekDeclaration() {\r\n    onActivationEvent();\r\n    clients.ActiveClient.requestGoToDeclaration().then(() => vscode.commands.executeCommand(\"editor.action.previewDeclaration\"));\r\n}\r\nfunction onSwitchHeaderSource() {\r\n    onActivationEvent();\r\n    let activeEditor = vscode.window.activeTextEditor;\r\n    if (!activeEditor || !activeEditor.document) {\r\n        return;\r\n    }\r\n    if (activeEditor.document.languageId !== \"cpp\" && activeEditor.document.languageId !== \"c\") {\r\n        return;\r\n    }\r\n    let rootPath = clients.ActiveClient.RootPath;\r\n    let fileName = activeEditor.document.fileName;\r\n    if (!rootPath) {\r\n        rootPath = path.dirname(fileName);\r\n    }\r\n    clients.ActiveClient.requestSwitchHeaderSource(rootPath, fileName).then((targetFileName) => {\r\n        vscode.workspace.openTextDocument(targetFileName).then((document) => {\r\n            let foundEditor = false;\r\n            vscode.window.visibleTextEditors.forEach((editor, index, array) => {\r\n                if (editor.document === document && !foundEditor) {\r\n                    foundEditor = true;\r\n                    vscode.window.showTextDocument(document, editor.viewColumn);\r\n                }\r\n            });\r\n            if (!foundEditor) {\r\n                if (vscode.window.activeTextEditor !== undefined) {\r\n                    vscode.window.showTextDocument(document, vscode.window.activeTextEditor.viewColumn);\r\n                }\r\n                else {\r\n                    vscode.window.showTextDocument(document);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction selectClient() {\r\n    if (clients.Count === 1) {\r\n        return Promise.resolve(clients.ActiveClient);\r\n    }\r\n    else {\r\n        return ui.showWorkspaces(clients.Names).then(key => {\r\n            if (key !== \"\") {\r\n                let client = clients.get(key);\r\n                if (client) {\r\n                    return client;\r\n                }\r\n                else {\r\n                    console.assert(\"client not found\");\r\n                }\r\n            }\r\n            return Promise.reject(\"client not found\");\r\n        });\r\n    }\r\n}\r\nfunction onResetDatabase() {\r\n    onActivationEvent();\r\n    selectClient().then(client => client.resetDatabase(), rejected => { });\r\n}\r\nfunction onSelectConfiguration() {\r\n    onActivationEvent();\r\n    if (!isFolderOpen()) {\r\n        vscode.window.showInformationMessage('Open a folder first to select a configuration');\r\n    }\r\n    else {\r\n        clients.ActiveClient.handleConfigurationSelectCommand();\r\n    }\r\n}\r\nfunction onSelectConfigurationProvider() {\r\n    onActivationEvent();\r\n    if (!isFolderOpen()) {\r\n        vscode.window.showInformationMessage('Open a folder first to select a configuration provider');\r\n    }\r\n    else {\r\n        selectClient().then(client => client.handleConfigurationProviderSelectCommand(), rejected => { });\r\n    }\r\n}\r\nfunction onEditConfiguration() {\r\n    onActivationEvent();\r\n    if (!isFolderOpen()) {\r\n        vscode.window.showInformationMessage('Open a folder first to edit configurations');\r\n    }\r\n    else {\r\n        selectClient().then(client => client.handleConfigurationEditCommand(), rejected => { });\r\n    }\r\n}\r\nfunction onAddToIncludePath(path) {\r\n    if (!isFolderOpen()) {\r\n        vscode.window.showInformationMessage('Open a folder first to add to includePath');\r\n    }\r\n    else {\r\n        clients.ActiveClient.handleAddToIncludePathCommand(path);\r\n    }\r\n}\r\nfunction onToggleSquiggles() {\r\n    onActivationEvent();\r\n    let settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);\r\n    settings.toggleSetting(\"errorSquiggles\", \"Enabled\", \"Disabled\");\r\n}\r\nfunction onToggleIncludeFallback() {\r\n    onActivationEvent();\r\n    let settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);\r\n    settings.toggleSetting(\"intelliSenseEngineFallback\", \"Enabled\", \"Disabled\");\r\n}\r\nfunction onToggleDimInactiveRegions() {\r\n    onActivationEvent();\r\n    let settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);\r\n    settings.update(\"dimInactiveRegions\", !settings.dimInactiveRegions);\r\n}\r\nfunction onShowReleaseNotes() {\r\n    onActivationEvent();\r\n    util.showReleaseNotes();\r\n}\r\nfunction onPauseParsing() {\r\n    onActivationEvent();\r\n    selectClient().then(client => client.pauseParsing(), rejected => { });\r\n}\r\nfunction onResumeParsing() {\r\n    onActivationEvent();\r\n    selectClient().then(client => client.resumeParsing(), rejected => { });\r\n}\r\nfunction onShowParsingCommands() {\r\n    onActivationEvent();\r\n    selectClient().then(client => client.handleShowParsingCommands(), rejected => { });\r\n}\r\nfunction onTakeSurvey() {\r\n    onActivationEvent();\r\n    telemetry.logLanguageServerEvent(\"onTakeSurvey\");\r\n    let uri = vscode.Uri.parse(`https://www.research.net/r/VBVV6C6?o=${os.platform()}&m=${vscode.env.machineId}`);\r\n    vscode.commands.executeCommand('vscode.open', uri);\r\n}\r\nfunction onGetActiveConfigName() {\r\n    return clients.ActiveClient.getCurrentConfigName();\r\n}\r\nfunction reportMacCrashes() {\r\n    if (process.platform === \"darwin\") {\r\n        prevCrashFile = \"\";\r\n        let crashFolder = path.resolve(process.env.HOME, \"Library/Logs/DiagnosticReports\");\r\n        fs.stat(crashFolder, (err, stats) => {\r\n            let crashObject = {};\r\n            if (err) {\r\n                crashObject[\"fs.stat: err.code\"] = err.code;\r\n                telemetry.logLanguageServerEvent(\"MacCrash\", crashObject, null);\r\n                return;\r\n            }\r\n            try {\r\n                fs.watch(crashFolder, (event, filename) => {\r\n                    if (event !== \"rename\") {\r\n                        return;\r\n                    }\r\n                    if (filename === prevCrashFile) {\r\n                        return;\r\n                    }\r\n                    prevCrashFile = filename;\r\n                    if (!filename.startsWith(\"Microsoft.VSCode.CPP.\")) {\r\n                        return;\r\n                    }\r\n                    setTimeout(() => {\r\n                        fs.readFile(path.resolve(crashFolder, filename), 'utf8', (err, data) => {\r\n                            if (err) {\r\n                                fs.readFile(path.resolve(crashFolder, filename), 'utf8', handleCrashFileRead);\r\n                                return;\r\n                            }\r\n                            handleCrashFileRead(err, data);\r\n                        });\r\n                    }, 5000);\r\n                });\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction logCrashTelemetry(data) {\r\n    let crashObject = {};\r\n    crashObject[\"CrashingThreadCallStack\"] = data;\r\n    telemetry.logLanguageServerEvent(\"MacCrash\", crashObject, null);\r\n}\r\nfunction handleCrashFileRead(err, data) {\r\n    if (err) {\r\n        return logCrashTelemetry(\"readFile: \" + err.code);\r\n    }\r\n    const crashStart = \" Crashed:\";\r\n    let startCrash = data.indexOf(crashStart);\r\n    if (startCrash < 0) {\r\n        return logCrashTelemetry(\"No crash start\");\r\n    }\r\n    startCrash += crashStart.length + 1;\r\n    let endCrash = data.indexOf(\"Thread \", startCrash);\r\n    if (endCrash < 0) {\r\n        endCrash = data.length - 1;\r\n    }\r\n    if (endCrash <= startCrash) {\r\n        return logCrashTelemetry(\"No crash end\");\r\n    }\r\n    data = data.substr(startCrash, endCrash - startCrash);\r\n    data = data.replace(/0x................ /g, \"\");\r\n    data = data.replace(/0x1........ \\+ 0/g, \"\");\r\n    const process1 = \"Microsoft.VSCode.CPP.IntelliSense.Msvc.darwin\\t\";\r\n    const process2 = \"Microsoft.VSCode.CPP.Extension.darwin\\t\";\r\n    if (data.includes(process1)) {\r\n        data = data.replace(new RegExp(process1, \"g\"), \"\");\r\n        data = process1 + \"\\n\" + data;\r\n    }\r\n    else if (data.includes(process2)) {\r\n        data = data.replace(new RegExp(process2, \"g\"), \"\");\r\n        data = process2 + \"\\n\" + data;\r\n    }\r\n    else {\r\n        return logCrashTelemetry(\"No process\");\r\n    }\r\n    let lines = data.split(\"\\n\");\r\n    data = \"\";\r\n    lines.forEach((line) => {\r\n        if (!line.includes(\".dylib\") && !line.includes(\"???\")) {\r\n            line = line.replace(/^\\d+\\s+/, \"\");\r\n            line = line.replace(/std::__1::/g, \"std::\");\r\n            data += (line + \"\\n\");\r\n        }\r\n    });\r\n    data = data.trimRight();\r\n    if (data.length > 8192) {\r\n        data = data.substr(0, 8189) + \"...\";\r\n    }\r\n    logCrashTelemetry(data);\r\n}\r\nfunction deactivate() {\r\n    console.log(\"deactivating extension\");\r\n    telemetry.logLanguageServerEvent(\"LanguageServerShutdown\");\r\n    clearInterval(intervalTimer);\r\n    clearInterval(insiderUpdateTimer);\r\n    disposables.forEach(d => d.dispose());\r\n    languageConfigurations.forEach(d => d.dispose());\r\n    ui.dispose();\r\n    if (taskProvider) {\r\n        taskProvider.dispose();\r\n    }\r\n    return clients.dispose();\r\n}\r\nexports.deactivate = deactivate;\r\nfunction isFolderOpen() {\r\n    return vscode.workspace.workspaceFolders !== undefined && vscode.workspace.workspaceFolders.length > 0;\r\n}\r\nexports.isFolderOpen = isFolderOpen;\r\nfunction getClients() {\r\n    if (!realActivationOccurred) {\r\n        realActivation();\r\n    }\r\n    return clients;\r\n}\r\nexports.getClients = getClients;\r\nfunction getActiveClient() {\r\n    if (!realActivationOccurred) {\r\n        realActivation();\r\n    }\r\n    return clients.ActiveClient;\r\n}\r\nexports.getActiveClient = getActiveClient;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvZXh0ZW5zaW9uLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9MYW5ndWFnZVNlcnZlci9leHRlbnNpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcclxuY29uc3QgdGVsZW1ldHJ5ID0gcmVxdWlyZShcIi4uL3RlbGVtZXRyeVwiKTtcclxuY29uc3QgdWlfMSA9IHJlcXVpcmUoXCIuL3VpXCIpO1xyXG5jb25zdCBjbGllbnRDb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jbGllbnRDb2xsZWN0aW9uXCIpO1xyXG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XHJcbmNvbnN0IHBlcnNpc3RlbnRTdGF0ZV8xID0gcmVxdWlyZShcIi4vcGVyc2lzdGVudFN0YXRlXCIpO1xyXG5jb25zdCBsYW5ndWFnZUNvbmZpZ18xID0gcmVxdWlyZShcIi4vbGFuZ3VhZ2VDb25maWdcIik7XHJcbmNvbnN0IGN1c3RvbVByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vY3VzdG9tUHJvdmlkZXJzXCIpO1xyXG5jb25zdCBwbGF0Zm9ybV8xID0gcmVxdWlyZShcIi4uL3BsYXRmb3JtXCIpO1xyXG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VjbGllbnRfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtbGFuZ3VhZ2VjbGllbnRcIik7XHJcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCB0bXAgPSByZXF1aXJlKFwidG1wXCIpO1xyXG5jb25zdCBnaXRodWJBUElfMSA9IHJlcXVpcmUoXCIuLi9naXRodWJBUElcIik7XHJcbmNvbnN0IHBhY2thZ2VWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vcGFja2FnZVZlcnNpb25cIik7XHJcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi4vY29tbWFuZHNcIik7XHJcbmxldCBwcmV2Q3Jhc2hGaWxlO1xyXG5sZXQgY2xpZW50cztcclxubGV0IGFjdGl2ZURvY3VtZW50O1xyXG5sZXQgdWk7XHJcbmxldCBkaXNwb3NhYmxlcyA9IFtdO1xyXG5sZXQgbGFuZ3VhZ2VDb25maWd1cmF0aW9ucyA9IFtdO1xyXG5sZXQgaW50ZXJ2YWxUaW1lcjtcclxubGV0IGluc2lkZXJVcGRhdGVUaW1lcjtcclxubGV0IHJlYWxBY3RpdmF0aW9uT2NjdXJyZWQgPSBmYWxzZTtcclxubGV0IHRlbXBDb21tYW5kcyA9IFtdO1xyXG5sZXQgYWN0aXZhdGVkUHJldmlvdXNseTtcclxuY29uc3QgaW5zaWRlclVwZGF0ZVRpbWVySW50ZXJ2YWwgPSAxMDAwICogNjAgKiA2MDtcclxubGV0IGJ1aWxkSW5mb0NhY2hlID0gbnVsbDtcclxuY29uc3QgdGFza1NvdXJjZVN0ciA9IFwiQy9DKytcIjtcclxuY29uc3QgY3BwSW5zdGFsbFZzaXhTdHIgPSAnQy9DKys6IEluc3RhbGwgdnNpeCAtLSAnO1xyXG5sZXQgdGFza1Byb3ZpZGVyO1xyXG5mdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0aW9uRXZlbnRPY2N1cnJlZCkge1xyXG4gICAgaWYgKHJlYWxBY3RpdmF0aW9uT2NjdXJyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhY3RpdmF0ZWRQcmV2aW91c2x5ID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRXb3Jrc3BhY2VTdGF0ZShcImFjdGl2YXRlZFByZXZpb3VzbHlcIiwgZmFsc2UpO1xyXG4gICAgaWYgKGFjdGl2YXRlZFByZXZpb3VzbHkuVmFsdWUpIHtcclxuICAgICAgICBhY3RpdmF0ZWRQcmV2aW91c2x5LlZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgcmVhbEFjdGl2YXRpb24oKTtcclxuICAgIH1cclxuICAgIGlmICh0ZW1wQ29tbWFuZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGVtcENvbW1hbmRzLnB1c2godnNjb2RlLndvcmtzcGFjZS5vbkRpZE9wZW5UZXh0RG9jdW1lbnQoZCA9PiBvbkRpZE9wZW5UZXh0RG9jdW1lbnQoZCkpKTtcclxuICAgIH1cclxuICAgIGlmIChhY3RpdmF0aW9uRXZlbnRPY2N1cnJlZCkge1xyXG4gICAgICAgIG9uQWN0aXZhdGlvbkV2ZW50KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGFza1Byb3ZpZGVyID0gdnNjb2RlLnRhc2tzLnJlZ2lzdGVyVGFza1Byb3ZpZGVyKHRhc2tTb3VyY2VTdHIsIHtcclxuICAgICAgICBwcm92aWRlVGFza3M6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEJ1aWxkVGFza3MoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc29sdmVUYXNrKHRhc2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZzY29kZS50YXNrcy5vbkRpZFN0YXJ0VGFzayhldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmV4ZWN1dGlvbi50YXNrLnNvdXJjZSA9PT0gdGFza1NvdXJjZVN0cikge1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudCgnYnVpbGRUYXNrU3RhcnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycyAmJiB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBwYXRoLmpvaW4odnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzW2ldLnVyaS5mc1BhdGgsIFwiLnZzY29kZS9jX2NwcF9wcm9wZXJ0aWVzLmpzb25cIik7XHJcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGNvbmZpZykpIHtcclxuICAgICAgICAgICAgICAgIG9uQWN0aXZhdGlvbkV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodnNjb2RlLndvcmtzcGFjZS50ZXh0RG9jdW1lbnRzICE9PSB1bmRlZmluZWQgJiYgdnNjb2RlLndvcmtzcGFjZS50ZXh0RG9jdW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZzY29kZS53b3Jrc3BhY2UudGV4dERvY3VtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgZG9jdW1lbnQgPSB2c2NvZGUud29ya3NwYWNlLnRleHREb2N1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5sYW5ndWFnZUlkID09PSBcImNwcFwiIHx8IGRvY3VtZW50Lmxhbmd1YWdlSWQgPT09IFwiY1wiKSB7XHJcbiAgICAgICAgICAgICAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYWN0aXZhdGUgPSBhY3RpdmF0ZTtcclxuZnVuY3Rpb24gZ2V0QnVpbGRUYXNrcygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yO1xyXG4gICAgICAgIGlmICghZWRpdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmlsZUV4dCA9IHBhdGguZXh0bmFtZShlZGl0b3IuZG9jdW1lbnQuZmlsZU5hbWUpO1xyXG4gICAgICAgIGlmICghZmlsZUV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbGVFeHRMb3dlciA9IGZpbGVFeHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBpc0hlYWRlciA9ICFmaWxlRXh0IHx8IFtcIi5ocHBcIiwgXCIuaGhcIiwgXCIuaHh4XCIsIFwiLmhcIiwgXCIuaW5sXCIsIFwiXCJdLnNvbWUoZXh0ID0+IGZpbGVFeHRMb3dlciA9PT0gZXh0KTtcclxuICAgICAgICBpZiAoaXNIZWFkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlsZUlzQ3BwO1xyXG4gICAgICAgIGxldCBmaWxlSXNDO1xyXG4gICAgICAgIGlmIChmaWxlRXh0ID09PSBcIi5DXCIpIHtcclxuICAgICAgICAgICAgZmlsZUlzQ3BwID0gdHJ1ZTtcclxuICAgICAgICAgICAgZmlsZUlzQyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmaWxlSXNDcHAgPSBbXCIuY3BwXCIsIFwiLmNjXCIsIFwiLmN4eFwiLCBcIi5tbVwiLCBcIi5pbm9cIl0uc29tZShleHQgPT4gZmlsZUV4dExvd2VyID09PSBleHQpO1xyXG4gICAgICAgICAgICBmaWxlSXNDID0gZmlsZUV4dExvd2VyID09PSBcIi5jXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKGZpbGVJc0NwcCB8fCBmaWxlSXNDKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb21waWxlclBhdGhzO1xyXG4gICAgICAgIGNvbnN0IGlzV2luZG93cyA9IG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMic7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlQ2xpZW50ID0gZ2V0QWN0aXZlQ2xpZW50KCk7XHJcbiAgICAgICAgbGV0IHVzZXJDb21waWxlclBhdGggPSB5aWVsZCBhY3RpdmVDbGllbnQuZ2V0Q29tcGlsZXJQYXRoKCk7XHJcbiAgICAgICAgaWYgKHVzZXJDb21waWxlclBhdGgpIHtcclxuICAgICAgICAgICAgdXNlckNvbXBpbGVyUGF0aCA9IHVzZXJDb21waWxlclBhdGgudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNXaW5kb3dzICYmIHVzZXJDb21waWxlclBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJDb21waWxlclBhdGggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXNlckNvbXBpbGVyUGF0aCA9IHVzZXJDb21waWxlclBhdGgucmVwbGFjZSgvXFxcXFxcXFwvZywgXCJcXFxcXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBrbm93bkNvbXBpbGVycyA9IHlpZWxkIGFjdGl2ZUNsaWVudC5nZXRLbm93bkNvbXBpbGVycygpO1xyXG4gICAgICAgIGlmIChrbm93bkNvbXBpbGVycykge1xyXG4gICAgICAgICAgICBrbm93bkNvbXBpbGVycyA9IGtub3duQ29tcGlsZXJzLmZpbHRlcihpbmZvID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKGZpbGVJc0NwcCAmJiAhaW5mby5pc0MpIHx8IChmaWxlSXNDICYmIGluZm8uaXNDKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIWlzV2luZG93cyB8fCAhaW5mby5wYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbXBpbGVyUGF0aHMgPSBrbm93bkNvbXBpbGVycy5tYXAoaW5mbyA9PiB7IHJldHVybiBpbmZvLnBhdGg7IH0pO1xyXG4gICAgICAgICAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnNlcnRPckFzc2lnbkVudHJ5ID0gKGNvbXBpbGVyUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGNvbXBpbGVyUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGJhc2VuYW1lLCBjb21waWxlclBhdGgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb21waWxlclBhdGhzLmZvckVhY2goaW5zZXJ0T3JBc3NpZ25FbnRyeSk7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQ29tcGlsZXJQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRPckFzc2lnbkVudHJ5KHVzZXJDb21waWxlclBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbXBpbGVyUGF0aHMgPSBbLi4ubWFwLnZhbHVlcygpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXNlckNvbXBpbGVyUGF0aCkge1xyXG4gICAgICAgICAgICBjb21waWxlclBhdGhzID0gW3VzZXJDb21waWxlclBhdGhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbXBpbGVyUGF0aHMpIHtcclxuICAgICAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoJ25vQ29tcGlsZXJGb3VuZCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21waWxlclBhdGhzLm1hcChjb21waWxlclBhdGggPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29tcGlsZXJQYXRoQW5kQXJncyA9IHV0aWwuZXh0cmFjdENvbXBpbGVyUGF0aEFuZEFyZ3MoY29tcGlsZXJQYXRoKTtcclxuICAgICAgICAgICAgY29tcGlsZXJQYXRoID0gY29tcGlsZXJQYXRoQW5kQXJncy5jb21waWxlclBhdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKCcke2ZpbGVEaXJuYW1lfScsICcke2ZpbGVCYXNlbmFtZU5vRXh0ZW5zaW9ufScpO1xyXG4gICAgICAgICAgICBjb25zdCBjb21waWxlclBhdGhCYXNlID0gcGF0aC5iYXNlbmFtZShjb21waWxlclBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXNrTmFtZSA9IGNvbXBpbGVyUGF0aEJhc2UgKyBcIiBidWlsZCBhY3RpdmUgZmlsZVwiO1xyXG4gICAgICAgICAgICBjb25zdCBpc0NsID0gdGFza05hbWUuc3RhcnRzV2l0aChcImNsLmV4ZVwiKTtcclxuICAgICAgICAgICAgbGV0IGFyZ3MgPSBpc0NsID8gWycvWmknLCAnL0VIc2MnLCAnL0ZlOicsIGZpbGVQYXRoICsgJy5leGUnLCAnJHtmaWxlfSddIDogWyctZycsICcke2ZpbGV9JywgJy1vJywgZmlsZVBhdGggKyAoaXNXaW5kb3dzID8gJy5leGUnIDogJycpXTtcclxuICAgICAgICAgICAgaWYgKGNvbXBpbGVyUGF0aEFuZEFyZ3MuYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChjb21waWxlclBhdGhBbmRBcmdzLmFkZGl0aW9uYWxBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjd2QgPSBpc0NsID8gXCJcIiA6IHBhdGguZGlybmFtZShjb21waWxlclBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBraW5kID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NoZWxsJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB0YXNrTmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGlzQ2wgPyBjb21waWxlclBhdGhCYXNlIDogY29tcGlsZXJQYXRoLFxyXG4gICAgICAgICAgICAgICAgYXJnczogYXJncyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGlzQ2wgPyB1bmRlZmluZWQgOiB7IFwiY3dkXCI6IGN3ZCB9LFxyXG4gICAgICAgICAgICAgICAgY29tcGlsZXJQYXRoOiBpc0NsID8gY29tcGlsZXJQYXRoQmFzZSA6IGNvbXBpbGVyUGF0aFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBjb21tYW5kID0gbmV3IHZzY29kZS5TaGVsbEV4ZWN1dGlvbihjb21waWxlclBhdGgsIFsuLi5hcmdzXSwgeyBjd2Q6IGN3ZCB9KTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdnNjb2RlLndvcmtzcGFjZS5nZXRXb3Jrc3BhY2VGb2xkZXIoY2xpZW50cy5BY3RpdmVDbGllbnQuUm9vdFVyaSk7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gbmV3IHZzY29kZS5UYXNrKGtpbmQsIHRhcmdldCwgdGFza05hbWUsIHRhc2tTb3VyY2VTdHIsIGNvbW1hbmQsICckZ2NjJyk7XHJcbiAgICAgICAgICAgIHRhc2suZGVmaW5pdGlvbiA9IGtpbmQ7XHJcbiAgICAgICAgICAgIHRhc2suZ3JvdXAgPSB2c2NvZGUuVGFza0dyb3VwLkJ1aWxkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFzaztcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZ2V0QnVpbGRUYXNrcyA9IGdldEJ1aWxkVGFza3M7XHJcbmZ1bmN0aW9uIG9uRGlkT3BlblRleHREb2N1bWVudChkb2N1bWVudCkge1xyXG4gICAgaWYgKGRvY3VtZW50Lmxhbmd1YWdlSWQgPT09IFwiY1wiIHx8IGRvY3VtZW50Lmxhbmd1YWdlSWQgPT09IFwiY3BwXCIpIHtcclxuICAgICAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGlvbkV2ZW50KCkge1xyXG4gICAgaWYgKHRlbXBDb21tYW5kcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0ZW1wQ29tbWFuZHMuZm9yRWFjaCgoY29tbWFuZCkgPT4ge1xyXG4gICAgICAgIGNvbW1hbmQuZGlzcG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgICB0ZW1wQ29tbWFuZHMgPSBbXTtcclxuICAgIGlmICghcmVhbEFjdGl2YXRpb25PY2N1cnJlZCkge1xyXG4gICAgICAgIHJlYWxBY3RpdmF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBhY3RpdmF0ZWRQcmV2aW91c2x5LlZhbHVlID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZWFsQWN0aXZhdGlvbigpIHtcclxuICAgIGlmIChuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncygpLmludGVsbGlTZW5zZUVuZ2luZSA9PT0gXCJEaXNhYmxlZFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGFjdGl2YXRlIHRoZSBleHRlbnNpb24gd2hlbiBJbnRlbGxpU2Vuc2UgaXMgZGlzYWJsZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJhY3RpdmF0aW5nIGV4dGVuc2lvblwiKTtcclxuICAgICAgICBsZXQgY2hlY2tGb3JDb25mbGljdGluZ0V4dGVuc2lvbnMgPSBuZXcgcGVyc2lzdGVudFN0YXRlXzEuUGVyc2lzdGVudFN0YXRlKFwiQ1BQLlwiICsgdXRpbC5wYWNrYWdlSnNvbi52ZXJzaW9uICsgXCIuY2hlY2tGb3JDb25mbGljdGluZ0V4dGVuc2lvbnNcIiwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGNoZWNrRm9yQ29uZmxpY3RpbmdFeHRlbnNpb25zLlZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRm9yQ29uZmxpY3RpbmdFeHRlbnNpb25zLlZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjbGFuZ0NvbW1hbmRBZGFwdGVyQWN0aXZlID0gdnNjb2RlLmV4dGVuc2lvbnMuYWxsLnNvbWUoKGV4dGVuc2lvbiwgaW5kZXgsIGFycmF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLmlzQWN0aXZlICYmIGV4dGVuc2lvbi5pZCA9PT0gXCJtaXRha2kyOC52c2NvZGUtY2xhbmdcIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjbGFuZ0NvbW1hbmRBZGFwdGVyQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcImNvbmZsaWN0aW5nRXh0ZW5zaW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVhbEFjdGl2YXRpb25PY2N1cnJlZCA9IHRydWU7XHJcbiAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIGxhbmd1YWdlIHNlcnZlclwiKTtcclxuICAgIGNsaWVudHMgPSBuZXcgY2xpZW50Q29sbGVjdGlvbl8xLkNsaWVudENvbGxlY3Rpb24oKTtcclxuICAgIHVpID0gdWlfMS5nZXRVSSgpO1xyXG4gICAgaWYgKHZzY29kZS53b3Jrc3BhY2UudGV4dERvY3VtZW50cyAhPT0gdW5kZWZpbmVkICYmIHZzY29kZS53b3Jrc3BhY2UudGV4dERvY3VtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgb25EaWRDaGFuZ2VBY3RpdmVUZXh0RWRpdG9yKHZzY29kZS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvcik7XHJcbiAgICB9XHJcbiAgICBjbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcclxuICAgICAgICBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKS5mb3JFYWNoKHByb3ZpZGVyID0+IGNsaWVudC5vblJlZ2lzdGVyQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyKHByb3ZpZGVyKSk7XHJcbiAgICB9KTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLndvcmtzcGFjZS5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24ob25EaWRDaGFuZ2VTZXR0aW5ncykpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUud29ya3NwYWNlLm9uRGlkU2F2ZVRleHREb2N1bWVudChvbkRpZFNhdmVUZXh0RG9jdW1lbnQpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLndpbmRvdy5vbkRpZENoYW5nZUFjdGl2ZVRleHRFZGl0b3Iob25EaWRDaGFuZ2VBY3RpdmVUZXh0RWRpdG9yKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS53aW5kb3cub25EaWRDaGFuZ2VUZXh0RWRpdG9yU2VsZWN0aW9uKG9uRGlkQ2hhbmdlVGV4dEVkaXRvclNlbGVjdGlvbikpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUud2luZG93Lm9uRGlkQ2hhbmdlVmlzaWJsZVRleHRFZGl0b3JzKG9uRGlkQ2hhbmdlVmlzaWJsZVRleHRFZGl0b3JzKSk7XHJcbiAgICB1cGRhdGVMYW5ndWFnZUNvbmZpZ3VyYXRpb25zKCk7XHJcbiAgICByZXBvcnRNYWNDcmFzaGVzKCk7XHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBzZXR0aW5nc18xLkNwcFNldHRpbmdzKGNsaWVudHMuQWN0aXZlQ2xpZW50LlJvb3RVcmkpO1xyXG4gICAgaWYgKHNldHRpbmdzLnVwZGF0ZUNoYW5uZWwgPT09ICdEZWZhdWx0Jykge1xyXG4gICAgICAgIHN1Z2dlc3RJbnNpZGVyc0NoYW5uZWwoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNldHRpbmdzLnVwZGF0ZUNoYW5uZWwgPT09ICdJbnNpZGVycycpIHtcclxuICAgICAgICBpbnNpZGVyVXBkYXRlVGltZXIgPSBzZXRJbnRlcnZhbChjaGVja0FuZEFwcGx5VXBkYXRlLCBpbnNpZGVyVXBkYXRlVGltZXJJbnRlcnZhbCwgc2V0dGluZ3MudXBkYXRlQ2hhbm5lbCk7XHJcbiAgICAgICAgY2hlY2tBbmRBcHBseVVwZGF0ZShzZXR0aW5ncy51cGRhdGVDaGFubmVsKTtcclxuICAgIH1cclxuICAgIGludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChvbkludGVydmFsLCAyNTAwKTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVMYW5ndWFnZUNvbmZpZ3VyYXRpb25zKCkge1xyXG4gICAgbGFuZ3VhZ2VDb25maWd1cmF0aW9ucy5mb3JFYWNoKGQgPT4gZC5kaXNwb3NlKCkpO1xyXG4gICAgbGFuZ3VhZ2VDb25maWd1cmF0aW9ucyA9IFtdO1xyXG4gICAgbGFuZ3VhZ2VDb25maWd1cmF0aW9ucy5wdXNoKHZzY29kZS5sYW5ndWFnZXMuc2V0TGFuZ3VhZ2VDb25maWd1cmF0aW9uKCdjJywgbGFuZ3VhZ2VDb25maWdfMS5nZXRMYW5ndWFnZUNvbmZpZygnYycsIGNsaWVudHMuQWN0aXZlQ2xpZW50LlJvb3RVcmkpKSk7XHJcbiAgICBsYW5ndWFnZUNvbmZpZ3VyYXRpb25zLnB1c2godnNjb2RlLmxhbmd1YWdlcy5zZXRMYW5ndWFnZUNvbmZpZ3VyYXRpb24oJ2NwcCcsIGxhbmd1YWdlQ29uZmlnXzEuZ2V0TGFuZ3VhZ2VDb25maWcoJ2NwcCcsIGNsaWVudHMuQWN0aXZlQ2xpZW50LlJvb3RVcmkpKSk7XHJcbn1cclxuZXhwb3J0cy51cGRhdGVMYW5ndWFnZUNvbmZpZ3VyYXRpb25zID0gdXBkYXRlTGFuZ3VhZ2VDb25maWd1cmF0aW9ucztcclxuZnVuY3Rpb24gb25EaWRDaGFuZ2VTZXR0aW5ncygpIHtcclxuICAgIGNvbnN0IGNoYW5nZWRBY3RpdmVDbGllbnRTZXR0aW5ncyA9IGNsaWVudHMuQWN0aXZlQ2xpZW50Lm9uRGlkQ2hhbmdlU2V0dGluZ3MoKTtcclxuICAgIGNsaWVudHMuZm9yRWFjaChjbGllbnQgPT4gY2xpZW50Lm9uRGlkQ2hhbmdlU2V0dGluZ3MoKSk7XHJcbiAgICBjb25zdCBuZXdVcGRhdGVDaGFubmVsID0gY2hhbmdlZEFjdGl2ZUNsaWVudFNldHRpbmdzWyd1cGRhdGVDaGFubmVsJ107XHJcbiAgICBpZiAobmV3VXBkYXRlQ2hhbm5lbCkge1xyXG4gICAgICAgIGlmIChuZXdVcGRhdGVDaGFubmVsID09PSAnRGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnNpZGVyVXBkYXRlVGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdVcGRhdGVDaGFubmVsID09PSAnSW5zaWRlcnMnKSB7XHJcbiAgICAgICAgICAgIGluc2lkZXJVcGRhdGVUaW1lciA9IHNldEludGVydmFsKGNoZWNrQW5kQXBwbHlVcGRhdGUsIGluc2lkZXJVcGRhdGVUaW1lckludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tBbmRBcHBseVVwZGF0ZShuZXdVcGRhdGVDaGFubmVsKTtcclxuICAgIH1cclxufVxyXG5sZXQgc2F2ZU1lc3NhZ2VTaG93biA9IGZhbHNlO1xyXG5mdW5jdGlvbiBvbkRpZFNhdmVUZXh0RG9jdW1lbnQoZG9jKSB7XHJcbiAgICBpZiAoIXZzY29kZS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvciB8fCBkb2MgIT09IHZzY29kZS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvci5kb2N1bWVudCB8fCAoZG9jLmxhbmd1YWdlSWQgIT09IFwiY3BwXCIgJiYgZG9jLmxhbmd1YWdlSWQgIT09IFwiY1wiKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghc2F2ZU1lc3NhZ2VTaG93biAmJiBuZXcgc2V0dGluZ3NfMS5DcHBTZXR0aW5ncyhkb2MudXJpKS5jbGFuZ0Zvcm1hdE9uU2F2ZSkge1xyXG4gICAgICAgIHNhdmVNZXNzYWdlU2hvd24gPSB0cnVlO1xyXG4gICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShcIlxcXCJDX0NwcC5jbGFuZ19mb3JtYXRfZm9ybWF0T25TYXZlXFxcIiBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIFxcXCJlZGl0b3IuZm9ybWF0T25TYXZlXFxcIiBpbnN0ZWFkLlwiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBvbkRpZENoYW5nZUFjdGl2ZVRleHRFZGl0b3IoZWRpdG9yKSB7XHJcbiAgICBjb25zb2xlLmFzc2VydChjbGllbnRzICE9PSB1bmRlZmluZWQsIFwiY2xpZW50IHNob3VsZCBiZSBhdmFpbGFibGUgYmVmb3JlIGFjdGl2ZSBlZGl0b3IgaXMgY2hhbmdlZFwiKTtcclxuICAgIGlmIChjbGllbnRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgYWN0aXZlRWRpdG9yID0gdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yO1xyXG4gICAgaWYgKCFhY3RpdmVFZGl0b3IgfHwgKGFjdGl2ZUVkaXRvci5kb2N1bWVudC5sYW5ndWFnZUlkICE9PSBcImNwcFwiICYmIGFjdGl2ZUVkaXRvci5kb2N1bWVudC5sYW5ndWFnZUlkICE9PSBcImNcIikpIHtcclxuICAgICAgICBhY3RpdmVEb2N1bWVudCA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY3RpdmVEb2N1bWVudCA9IGVkaXRvci5kb2N1bWVudC51cmkudG9TdHJpbmcoKTtcclxuICAgICAgICBjbGllbnRzLmFjdGl2ZURvY3VtZW50Q2hhbmdlZChlZGl0b3IuZG9jdW1lbnQpO1xyXG4gICAgICAgIGNsaWVudHMuQWN0aXZlQ2xpZW50LnNlbGVjdGlvbkNoYW5nZWQodnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuUmFuZ2UuY3JlYXRlKGVkaXRvci5zZWxlY3Rpb24uc3RhcnQsIGVkaXRvci5zZWxlY3Rpb24uZW5kKSk7XHJcbiAgICB9XHJcbiAgICB1aS5hY3RpdmVEb2N1bWVudENoYW5nZWQoKTtcclxufVxyXG5mdW5jdGlvbiBvbkRpZENoYW5nZVRleHRFZGl0b3JTZWxlY3Rpb24oZXZlbnQpIHtcclxuICAgIGlmICghZXZlbnQudGV4dEVkaXRvciB8fCAhdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yIHx8IGV2ZW50LnRleHRFZGl0b3IuZG9jdW1lbnQudXJpICE9PSB2c2NvZGUud2luZG93LmFjdGl2ZVRleHRFZGl0b3IuZG9jdW1lbnQudXJpIHx8XHJcbiAgICAgICAgKGV2ZW50LnRleHRFZGl0b3IuZG9jdW1lbnQubGFuZ3VhZ2VJZCAhPT0gXCJjcHBcIiAmJiBldmVudC50ZXh0RWRpdG9yLmRvY3VtZW50Lmxhbmd1YWdlSWQgIT09IFwiY1wiKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChhY3RpdmVEb2N1bWVudCAhPT0gZXZlbnQudGV4dEVkaXRvci5kb2N1bWVudC51cmkudG9TdHJpbmcoKSkge1xyXG4gICAgICAgIGFjdGl2ZURvY3VtZW50ID0gZXZlbnQudGV4dEVkaXRvci5kb2N1bWVudC51cmkudG9TdHJpbmcoKTtcclxuICAgICAgICBjbGllbnRzLmFjdGl2ZURvY3VtZW50Q2hhbmdlZChldmVudC50ZXh0RWRpdG9yLmRvY3VtZW50KTtcclxuICAgICAgICB1aS5hY3RpdmVEb2N1bWVudENoYW5nZWQoKTtcclxuICAgIH1cclxuICAgIGNsaWVudHMuQWN0aXZlQ2xpZW50LnNlbGVjdGlvbkNoYW5nZWQodnNjb2RlX2xhbmd1YWdlY2xpZW50XzEuUmFuZ2UuY3JlYXRlKGV2ZW50LnNlbGVjdGlvbnNbMF0uc3RhcnQsIGV2ZW50LnNlbGVjdGlvbnNbMF0uZW5kKSk7XHJcbn1cclxuZnVuY3Rpb24gb25EaWRDaGFuZ2VWaXNpYmxlVGV4dEVkaXRvcnMoZWRpdG9ycykge1xyXG4gICAgY2xpZW50cy5mb3JFYWNoKGNsaWVudCA9PiBjbGllbnQub25EaWRDaGFuZ2VWaXNpYmxlVGV4dEVkaXRvcnMoZWRpdG9ycykpO1xyXG59XHJcbmZ1bmN0aW9uIG9uSW50ZXJ2YWwoKSB7XHJcbiAgICBjbGllbnRzLkFjdGl2ZUNsaWVudC5vbkludGVydmFsKCk7XHJcbn1cclxuZnVuY3Rpb24gaW5zdGFsbFZzaXgodnNpeExvY2F0aW9uLCB1cGRhdGVDaGFubmVsKSB7XHJcbiAgICByZXR1cm4gcGxhdGZvcm1fMS5QbGF0Zm9ybUluZm9ybWF0aW9uLkdldFBsYXRmb3JtSW5mb3JtYXRpb24oKS50aGVuKChwbGF0Zm9ybUluZm8pID0+IHtcclxuICAgICAgICBjb25zdCB2c0NvZGVTY3JpcHRQYXRoID0gZnVuY3Rpb24gKHBsYXRmb3JtSW5mbykge1xyXG4gICAgICAgICAgICBpZiAocGxhdGZvcm1JbmZvLnBsYXRmb3JtID09PSAnd2luMzInKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2c0NvZGVCaW5OYW1lID0gcGF0aC5iYXNlbmFtZShwcm9jZXNzLmV4ZWNQYXRoKTtcclxuICAgICAgICAgICAgICAgIGxldCBjbWRGaWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZzQ29kZUJpbk5hbWUgPT09ICdDb2RlIC0gSW5zaWRlcnMuZXhlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZEZpbGUgPSAnY29kZS1pbnNpZGVycy5jbWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodnNDb2RlQmluTmFtZSA9PT0gJ0NvZGUgLSBFeHBsb3JhdGlvbi5leGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY21kRmlsZSA9ICdjb2RlLWV4cGxvcmF0aW9uLmNtZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjbWRGaWxlID0gJ2NvZGUuY21kJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZzQ29kZUV4ZURpciA9IHBhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4odnNDb2RlRXhlRGlyLCAnYmluJywgY21kRmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGxhdGZvcm1JbmZvLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihwcm9jZXNzLmV4ZWNQYXRoLCAnLi4nLCAnLi4nLCAnLi4nLCAnLi4nLCAnLi4nLCAnUmVzb3VyY2VzJywgJ2FwcCcsICdiaW4nLCAnY29kZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdnNDb2RlQmluTmFtZSA9IHBhdGguYmFzZW5hbWUocHJvY2Vzcy5leGVjUGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZG91dCA9IGNoaWxkX3Byb2Nlc3NfMS5leGVjU3luYygnd2hpY2ggJyArIHZzQ29kZUJpbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGRvdXQudG9TdHJpbmcoKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfShwbGF0Zm9ybUluZm8pO1xyXG4gICAgICAgIGlmICghdnNDb2RlU2NyaXB0UGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBWUyBDb2RlIHNjcmlwdCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHVzZXJWZXJzaW9uID0gbmV3IHBhY2thZ2VWZXJzaW9uXzEuUGFja2FnZVZlcnNpb24odnNjb2RlLnZlcnNpb24pO1xyXG4gICAgICAgIGxldCBicmVha2luZ1ZlcnNpb24gPSBuZXcgcGFja2FnZVZlcnNpb25fMS5QYWNrYWdlVmVyc2lvbignMS4yOC4wJyk7XHJcbiAgICAgICAgaWYgKHVzZXJWZXJzaW9uLmlzR3JlYXRlclRoYW4oYnJlYWtpbmdWZXJzaW9uLCAnaW5zaWRlcicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2VzcztcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyA9IGNoaWxkX3Byb2Nlc3NfMS5zcGF3bih2c0NvZGVTY3JpcHRQYXRoLCBbJy0taW5zdGFsbC1leHRlbnNpb24nLCB2c2l4TG9jYXRpb24sICctLWZvcmNlJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Mua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVjZWl2ZSByZXNwb25zZSBmcm9tIFZTIENvZGUgc2NyaXB0IHByb2Nlc3MgZm9yIGluc3RhbGxhdGlvbiB3aXRoaW4gMzBzLicpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAzMDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5vbignZXhpdCcsIChjb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVlMgQ29kZSBzY3JpcHQgZXhpdGVkIHdpdGggZXJyb3IgY29kZSAke2NvZGV9YCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MucGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxhdW5jaCBWUyBDb2RlIHNjcmlwdCBwcm9jZXNzIGZvciBpbnN0YWxsYXRpb24nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHByb2Nlc3M7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzID0gY2hpbGRfcHJvY2Vzc18xLnNwYXduKHZzQ29kZVNjcmlwdFBhdGgsIFsnLS1pbnN0YWxsLWV4dGVuc2lvbicsIHZzaXhMb2NhdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MucGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsYXVuY2ggVlMgQ29kZSBzY3JpcHQgcHJvY2VzcyBmb3IgaW5zdGFsbGF0aW9uJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWNlaXZlIHJlc3BvbnNlIGZyb20gVlMgQ29kZSBzY3JpcHQgcHJvY2VzcyBmb3IgaW5zdGFsbGF0aW9uIHdpdGhpbiAzMHMuJykpO1xyXG4gICAgICAgICAgICB9LCAzMDAwMCk7XHJcbiAgICAgICAgICAgIGxldCBzZW50T3ZlcnJpZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VudE92ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRpbi53cml0ZSgnMFxcbicpO1xyXG4gICAgICAgICAgICAgICAgc2VudE92ZXJyaWRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHN1Z2dlc3RJbnNpZGVyc0NoYW5uZWwoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBzdWdnZXN0SW5zaWRlcnMgPSBuZXcgcGVyc2lzdGVudFN0YXRlXzEuUGVyc2lzdGVudFN0YXRlKFwiQ1BQLnN1Z2dlc3RJbnNpZGVyc1wiLCB0cnVlKTtcclxuICAgICAgICBpZiAoIXN1Z2dlc3RJbnNpZGVycy5WYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBidWlsZEluZm87XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYnVpbGRJbmZvID0geWllbGQgZ2l0aHViQVBJXzEuZ2V0VGFyZ2V0QnVpbGRJbmZvKFwiSW5zaWRlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtjcHBJbnN0YWxsVnNpeFN0cn0ke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoJy8nKSAhPT0gLTEgfHwgZXJyb3IubWVzc2FnZS5pbmRleE9mKCdcXFxcJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gXCJQb3RlbnRpYWwgUElJIGhpZGRlblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KCdzdWdnZXN0SW5zaWRlcnMnLCB7ICdlcnJvcic6IGVycm9yLm1lc3NhZ2UsICdzdWNjZXNzJzogJ2ZhbHNlJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFidWlsZEluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEluc2lkZXJzIHZlcnNpb24gJHtidWlsZEluZm8ubmFtZX0gaXMgYXZhaWxhYmxlLiBXb3VsZCB5b3UgbGlrZSB0byBzd2l0Y2ggdG8gdGhlIEluc2lkZXJzIGNoYW5uZWwgYW5kIGluc3RhbGwgdGhpcyB1cGRhdGU/YDtcclxuICAgICAgICBjb25zdCB5ZXMgPSBcIlllc1wiO1xyXG4gICAgICAgIGNvbnN0IGFza0xhdGVyID0gXCJBc2sgTWUgTGF0ZXJcIjtcclxuICAgICAgICBjb25zdCBkb250U2hvd0FnYWluID0gXCJEb24ndCBTaG93IEFnYWluXCI7XHJcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHlpZWxkIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShtZXNzYWdlLCB5ZXMsIGFza0xhdGVyLCBkb250U2hvd0FnYWluKTtcclxuICAgICAgICBzd2l0Y2ggKHNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIHllczpcclxuICAgICAgICAgICAgICAgIGJ1aWxkSW5mb0NhY2hlID0gYnVpbGRJbmZvO1xyXG4gICAgICAgICAgICAgICAgdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKFwiQ19DcHBcIikudXBkYXRlKFwidXBkYXRlQ2hhbm5lbFwiLCBcIkluc2lkZXJzXCIsIHZzY29kZS5Db25maWd1cmF0aW9uVGFyZ2V0Lkdsb2JhbCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBkb250U2hvd0FnYWluOlxyXG4gICAgICAgICAgICAgICAgc3VnZ2VzdEluc2lkZXJzLlZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBhc2tMYXRlcjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlVcGRhdGUoYnVpbGRJbmZvLCB1cGRhdGVDaGFubmVsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRtcC5maWxlKHsgcG9zdGZpeDogJy52c2l4JyB9LCAoZXJyLCB2c2l4UGF0aCwgZmQsIGNsZWFudXBDYWxsYmFjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHZzaXggZmlsZScpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFByb3h5U3VwcG9ydCA9IGNvbmZpZy5pbnNwZWN0KCdodHRwLnByb3h5U3VwcG9ydCcpLmdsb2JhbFZhbHVlO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB1dGlsLmRvd25sb2FkRmlsZVRvRGVzdGluYXRpb24oYnVpbGRJbmZvLmRvd25sb2FkVXJsLCB2c2l4UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxQcm94eVN1cHBvcnQgIT09IGNvbmZpZy5pbnNwZWN0KCdodHRwLnByb3h5U3VwcG9ydCcpLmdsb2JhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy51cGRhdGUoJ2h0dHAucHJveHlTdXBwb3J0Jywgb3JpZ2luYWxQcm94eVN1cHBvcnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgVlNJWCBwYWNrYWdlIHdpdGggcHJveHlTdXBwb3J0IG9mZicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmdldCgnaHR0cC5wcm94eVN1cHBvcnQnKSAhPT0gXCJvZmZcIiAmJiBvcmlnaW5hbFByb3h5U3VwcG9ydCAhPT0gXCJvZmZcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudXBkYXRlKCdodHRwLnByb3h5U3VwcG9ydCcsIFwib2ZmXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIFZTSVggcGFja2FnZScpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxQcm94eVN1cHBvcnQgIT09IGNvbmZpZy5pbnNwZWN0KCdodHRwLnByb3h5U3VwcG9ydCcpLmdsb2JhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnVwZGF0ZSgnaHR0cC5wcm94eVN1cHBvcnQnLCBvcmlnaW5hbFByb3h5U3VwcG9ydCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoJ2luc3RhbGxWc2l4JywgeyAnZXJyb3InOiBcIlN1Y2Nlc3Mgd2l0aCBwcm94eVN1cHBvcnQgb2ZmXCIsICdzdWNjZXNzJzogJ3RydWUnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGluc3RhbGxWc2l4KHZzaXhQYXRoLCB1cGRhdGVDaGFubmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnNpZGVyVXBkYXRlVGltZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBDL0MrKyBFeHRlbnNpb24gaGFzIGJlZW4gdXBkYXRlZCB0byB2ZXJzaW9uICR7YnVpbGRJbmZvLm5hbWV9LiBQbGVhc2UgcmVsb2FkIHRoZSB3aW5kb3cgZm9yIHRoZSBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LmA7XHJcbiAgICAgICAgICAgIHV0aWwucHJvbXB0UmVsb2FkV2luZG93KG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudCgnaW5zdGFsbFZzaXgnLCB7ICdzdWNjZXNzJzogJ3RydWUnIH0pO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7Y3BwSW5zdGFsbFZzaXhTdHJ9JHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluZGV4T2YoJy8nKSAhPT0gLTEgfHwgZXJyb3IubWVzc2FnZS5pbmRleE9mKCdcXFxcJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBcIlBvdGVudGlhbCBQSUkgaGlkZGVuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KCdpbnN0YWxsVnNpeCcsIHsgJ2Vycm9yJzogZXJyb3IubWVzc2FnZSwgJ3N1Y2Nlc3MnOiAnZmFsc2UnIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tBbmRBcHBseVVwZGF0ZSh1cGRhdGVDaGFubmVsKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBidWlsZEluZm8gPSBidWlsZEluZm9DYWNoZTtcclxuICAgICAgICBidWlsZEluZm9DYWNoZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFidWlsZEluZm8pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkSW5mbyA9IHlpZWxkIGdpdGh1YkFQSV8xLmdldFRhcmdldEJ1aWxkSW5mbyh1cGRhdGVDaGFubmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KCdpbnN0YWxsVnNpeCcsIHsgJ2Vycm9yJzogZXJyb3IubWVzc2FnZSwgJ3N1Y2Nlc3MnOiAnZmFsc2UnIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYnVpbGRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgYXBwbHlVcGRhdGUoYnVpbGRJbmZvLCB1cGRhdGVDaGFubmVsKTtcclxuICAgIH0pO1xyXG59XHJcbmxldCBjb21tYW5kc1JlZ2lzdGVyZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcygpIHtcclxuICAgIGlmIChjb21tYW5kc1JlZ2lzdGVyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb21tYW5kc1JlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgY29tbWFuZHNfMS5nZXRUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFySW5zdGFuY2UoKS5jbGVhclRlbXBDb21tYW5kcygpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdDX0NwcC5OYXZpZ2F0ZScsIG9uTmF2aWdhdGUpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuR29Ub0RlY2xhcmF0aW9uJywgb25Hb1RvRGVjbGFyYXRpb24pKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuUGVla0RlY2xhcmF0aW9uJywgb25QZWVrRGVjbGFyYXRpb24pKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuU3dpdGNoSGVhZGVyU291cmNlJywgb25Td2l0Y2hIZWFkZXJTb3VyY2UpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuUmVzZXREYXRhYmFzZScsIG9uUmVzZXREYXRhYmFzZSkpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdDX0NwcC5Db25maWd1cmF0aW9uU2VsZWN0Jywgb25TZWxlY3RDb25maWd1cmF0aW9uKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoJ0NfQ3BwLkNvbmZpZ3VyYXRpb25Qcm92aWRlclNlbGVjdCcsIG9uU2VsZWN0Q29uZmlndXJhdGlvblByb3ZpZGVyKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoJ0NfQ3BwLkNvbmZpZ3VyYXRpb25FZGl0Jywgb25FZGl0Q29uZmlndXJhdGlvbikpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdDX0NwcC5BZGRUb0luY2x1ZGVQYXRoJywgb25BZGRUb0luY2x1ZGVQYXRoKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoJ0NfQ3BwLlRvZ2dsZUVycm9yU3F1aWdnbGVzJywgb25Ub2dnbGVTcXVpZ2dsZXMpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuVG9nZ2xlSW5jbHVkZUZhbGxiYWNrJywgb25Ub2dnbGVJbmNsdWRlRmFsbGJhY2spKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuVG9nZ2xlRGltSW5hY3RpdmVSZWdpb25zJywgb25Ub2dnbGVEaW1JbmFjdGl2ZVJlZ2lvbnMpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuU2hvd1JlbGVhc2VOb3RlcycsIG9uU2hvd1JlbGVhc2VOb3RlcykpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdDX0NwcC5QYXVzZVBhcnNpbmcnLCBvblBhdXNlUGFyc2luZykpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdDX0NwcC5SZXN1bWVQYXJzaW5nJywgb25SZXN1bWVQYXJzaW5nKSk7XHJcbiAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoJ0NfQ3BwLlNob3dQYXJzaW5nQ29tbWFuZHMnLCBvblNob3dQYXJzaW5nQ29tbWFuZHMpKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLmNvbW1hbmRzLnJlZ2lzdGVyQ29tbWFuZCgnQ19DcHAuVGFrZVN1cnZleScsIG9uVGFrZVN1cnZleSkpO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaCh2c2NvZGUuY29tbWFuZHMucmVnaXN0ZXJDb21tYW5kKCdjcHB0b29scy5hY3RpdmVDb25maWdOYW1lJywgb25HZXRBY3RpdmVDb25maWdOYW1lKSk7XHJcbiAgICBjb21tYW5kc18xLmdldFRlbXBvcmFyeUNvbW1hbmRSZWdpc3RyYXJJbnN0YW5jZSgpLmV4ZWN1dGVEZWxheWVkQ29tbWFuZHMoKTtcclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyQ29tbWFuZHMgPSByZWdpc3RlckNvbW1hbmRzO1xyXG5mdW5jdGlvbiBvbk5hdmlnYXRlKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIGxldCBhY3RpdmVFZGl0b3IgPSB2c2NvZGUud2luZG93LmFjdGl2ZVRleHRFZGl0b3I7XHJcbiAgICBpZiAoIWFjdGl2ZUVkaXRvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNsaWVudHMuQWN0aXZlQ2xpZW50LnJlcXVlc3ROYXZpZ2F0aW9uTGlzdChhY3RpdmVFZGl0b3IuZG9jdW1lbnQpLnRoZW4oKG5hdmlnYXRpb25MaXN0KSA9PiB7XHJcbiAgICAgICAgdWkuc2hvd05hdmlnYXRpb25PcHRpb25zKG5hdmlnYXRpb25MaXN0KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG9uR29Ub0RlY2xhcmF0aW9uKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIGNsaWVudHMuQWN0aXZlQ2xpZW50LnJlcXVlc3RHb1RvRGVjbGFyYXRpb24oKS50aGVuKCgpID0+IHZzY29kZS5jb21tYW5kcy5leGVjdXRlQ29tbWFuZChcImVkaXRvci5hY3Rpb24uZ29Ub0RlY2xhcmF0aW9uXCIpKTtcclxufVxyXG5mdW5jdGlvbiBvblBlZWtEZWNsYXJhdGlvbigpIHtcclxuICAgIG9uQWN0aXZhdGlvbkV2ZW50KCk7XHJcbiAgICBjbGllbnRzLkFjdGl2ZUNsaWVudC5yZXF1ZXN0R29Ub0RlY2xhcmF0aW9uKCkudGhlbigoKSA9PiB2c2NvZGUuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmQoXCJlZGl0b3IuYWN0aW9uLnByZXZpZXdEZWNsYXJhdGlvblwiKSk7XHJcbn1cclxuZnVuY3Rpb24gb25Td2l0Y2hIZWFkZXJTb3VyY2UoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgbGV0IGFjdGl2ZUVkaXRvciA9IHZzY29kZS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvcjtcclxuICAgIGlmICghYWN0aXZlRWRpdG9yIHx8ICFhY3RpdmVFZGl0b3IuZG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aXZlRWRpdG9yLmRvY3VtZW50Lmxhbmd1YWdlSWQgIT09IFwiY3BwXCIgJiYgYWN0aXZlRWRpdG9yLmRvY3VtZW50Lmxhbmd1YWdlSWQgIT09IFwiY1wiKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHJvb3RQYXRoID0gY2xpZW50cy5BY3RpdmVDbGllbnQuUm9vdFBhdGg7XHJcbiAgICBsZXQgZmlsZU5hbWUgPSBhY3RpdmVFZGl0b3IuZG9jdW1lbnQuZmlsZU5hbWU7XHJcbiAgICBpZiAoIXJvb3RQYXRoKSB7XHJcbiAgICAgICAgcm9vdFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZU5hbWUpO1xyXG4gICAgfVxyXG4gICAgY2xpZW50cy5BY3RpdmVDbGllbnQucmVxdWVzdFN3aXRjaEhlYWRlclNvdXJjZShyb290UGF0aCwgZmlsZU5hbWUpLnRoZW4oKHRhcmdldEZpbGVOYW1lKSA9PiB7XHJcbiAgICAgICAgdnNjb2RlLndvcmtzcGFjZS5vcGVuVGV4dERvY3VtZW50KHRhcmdldEZpbGVOYW1lKS50aGVuKChkb2N1bWVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZm91bmRFZGl0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy52aXNpYmxlVGV4dEVkaXRvcnMuZm9yRWFjaCgoZWRpdG9yLCBpbmRleCwgYXJyYXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuZG9jdW1lbnQgPT09IGRvY3VtZW50ICYmICFmb3VuZEVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRWRpdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dUZXh0RG9jdW1lbnQoZG9jdW1lbnQsIGVkaXRvci52aWV3Q29sdW1uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghZm91bmRFZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2c2NvZGUud2luZG93LmFjdGl2ZVRleHRFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd1RleHREb2N1bWVudChkb2N1bWVudCwgdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yLnZpZXdDb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93VGV4dERvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0Q2xpZW50KCkge1xyXG4gICAgaWYgKGNsaWVudHMuQ291bnQgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsaWVudHMuQWN0aXZlQ2xpZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1aS5zaG93V29ya3NwYWNlcyhjbGllbnRzLk5hbWVzKS50aGVuKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjbGllbnQgPSBjbGllbnRzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChcImNsaWVudCBub3QgZm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiY2xpZW50IG5vdCBmb3VuZFwiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBvblJlc2V0RGF0YWJhc2UoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgc2VsZWN0Q2xpZW50KCkudGhlbihjbGllbnQgPT4gY2xpZW50LnJlc2V0RGF0YWJhc2UoKSwgcmVqZWN0ZWQgPT4geyB9KTtcclxufVxyXG5mdW5jdGlvbiBvblNlbGVjdENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgaWYgKCFpc0ZvbGRlck9wZW4oKSkge1xyXG4gICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZSgnT3BlbiBhIGZvbGRlciBmaXJzdCB0byBzZWxlY3QgYSBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjbGllbnRzLkFjdGl2ZUNsaWVudC5oYW5kbGVDb25maWd1cmF0aW9uU2VsZWN0Q29tbWFuZCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG9uU2VsZWN0Q29uZmlndXJhdGlvblByb3ZpZGVyKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIGlmICghaXNGb2xkZXJPcGVuKCkpIHtcclxuICAgICAgICB2c2NvZGUud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UoJ09wZW4gYSBmb2xkZXIgZmlyc3QgdG8gc2VsZWN0IGEgY29uZmlndXJhdGlvbiBwcm92aWRlcicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VsZWN0Q2xpZW50KCkudGhlbihjbGllbnQgPT4gY2xpZW50LmhhbmRsZUNvbmZpZ3VyYXRpb25Qcm92aWRlclNlbGVjdENvbW1hbmQoKSwgcmVqZWN0ZWQgPT4geyB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBvbkVkaXRDb25maWd1cmF0aW9uKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIGlmICghaXNGb2xkZXJPcGVuKCkpIHtcclxuICAgICAgICB2c2NvZGUud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UoJ09wZW4gYSBmb2xkZXIgZmlyc3QgdG8gZWRpdCBjb25maWd1cmF0aW9ucycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VsZWN0Q2xpZW50KCkudGhlbihjbGllbnQgPT4gY2xpZW50LmhhbmRsZUNvbmZpZ3VyYXRpb25FZGl0Q29tbWFuZCgpLCByZWplY3RlZCA9PiB7IH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG9uQWRkVG9JbmNsdWRlUGF0aChwYXRoKSB7XHJcbiAgICBpZiAoIWlzRm9sZGVyT3BlbigpKSB7XHJcbiAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93SW5mb3JtYXRpb25NZXNzYWdlKCdPcGVuIGEgZm9sZGVyIGZpcnN0IHRvIGFkZCB0byBpbmNsdWRlUGF0aCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2xpZW50cy5BY3RpdmVDbGllbnQuaGFuZGxlQWRkVG9JbmNsdWRlUGF0aENvbW1hbmQocGF0aCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gb25Ub2dnbGVTcXVpZ2dsZXMoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3MoY2xpZW50cy5BY3RpdmVDbGllbnQuUm9vdFVyaSk7XHJcbiAgICBzZXR0aW5ncy50b2dnbGVTZXR0aW5nKFwiZXJyb3JTcXVpZ2dsZXNcIiwgXCJFbmFibGVkXCIsIFwiRGlzYWJsZWRcIik7XHJcbn1cclxuZnVuY3Rpb24gb25Ub2dnbGVJbmNsdWRlRmFsbGJhY2soKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3MoY2xpZW50cy5BY3RpdmVDbGllbnQuUm9vdFVyaSk7XHJcbiAgICBzZXR0aW5ncy50b2dnbGVTZXR0aW5nKFwiaW50ZWxsaVNlbnNlRW5naW5lRmFsbGJhY2tcIiwgXCJFbmFibGVkXCIsIFwiRGlzYWJsZWRcIik7XHJcbn1cclxuZnVuY3Rpb24gb25Ub2dnbGVEaW1JbmFjdGl2ZVJlZ2lvbnMoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3MoY2xpZW50cy5BY3RpdmVDbGllbnQuUm9vdFVyaSk7XHJcbiAgICBzZXR0aW5ncy51cGRhdGUoXCJkaW1JbmFjdGl2ZVJlZ2lvbnNcIiwgIXNldHRpbmdzLmRpbUluYWN0aXZlUmVnaW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25TaG93UmVsZWFzZU5vdGVzKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIHV0aWwuc2hvd1JlbGVhc2VOb3RlcygpO1xyXG59XHJcbmZ1bmN0aW9uIG9uUGF1c2VQYXJzaW5nKCkge1xyXG4gICAgb25BY3RpdmF0aW9uRXZlbnQoKTtcclxuICAgIHNlbGVjdENsaWVudCgpLnRoZW4oY2xpZW50ID0+IGNsaWVudC5wYXVzZVBhcnNpbmcoKSwgcmVqZWN0ZWQgPT4geyB9KTtcclxufVxyXG5mdW5jdGlvbiBvblJlc3VtZVBhcnNpbmcoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgc2VsZWN0Q2xpZW50KCkudGhlbihjbGllbnQgPT4gY2xpZW50LnJlc3VtZVBhcnNpbmcoKSwgcmVqZWN0ZWQgPT4geyB9KTtcclxufVxyXG5mdW5jdGlvbiBvblNob3dQYXJzaW5nQ29tbWFuZHMoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgc2VsZWN0Q2xpZW50KCkudGhlbihjbGllbnQgPT4gY2xpZW50LmhhbmRsZVNob3dQYXJzaW5nQ29tbWFuZHMoKSwgcmVqZWN0ZWQgPT4geyB9KTtcclxufVxyXG5mdW5jdGlvbiBvblRha2VTdXJ2ZXkoKSB7XHJcbiAgICBvbkFjdGl2YXRpb25FdmVudCgpO1xyXG4gICAgdGVsZW1ldHJ5LmxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoXCJvblRha2VTdXJ2ZXlcIik7XHJcbiAgICBsZXQgdXJpID0gdnNjb2RlLlVyaS5wYXJzZShgaHR0cHM6Ly93d3cucmVzZWFyY2gubmV0L3IvVkJWVjZDNj9vPSR7b3MucGxhdGZvcm0oKX0mbT0ke3ZzY29kZS5lbnYubWFjaGluZUlkfWApO1xyXG4gICAgdnNjb2RlLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kKCd2c2NvZGUub3BlbicsIHVyaSk7XHJcbn1cclxuZnVuY3Rpb24gb25HZXRBY3RpdmVDb25maWdOYW1lKCkge1xyXG4gICAgcmV0dXJuIGNsaWVudHMuQWN0aXZlQ2xpZW50LmdldEN1cnJlbnRDb25maWdOYW1lKCk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb3J0TWFjQ3Jhc2hlcygpIHtcclxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImRhcndpblwiKSB7XHJcbiAgICAgICAgcHJldkNyYXNoRmlsZSA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGNyYXNoRm9sZGVyID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuZW52LkhPTUUsIFwiTGlicmFyeS9Mb2dzL0RpYWdub3N0aWNSZXBvcnRzXCIpO1xyXG4gICAgICAgIGZzLnN0YXQoY3Jhc2hGb2xkZXIsIChlcnIsIHN0YXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjcmFzaE9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjcmFzaE9iamVjdFtcImZzLnN0YXQ6IGVyci5jb2RlXCJdID0gZXJyLmNvZGU7XHJcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcIk1hY0NyYXNoXCIsIGNyYXNoT2JqZWN0LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZnMud2F0Y2goY3Jhc2hGb2xkZXIsIChldmVudCwgZmlsZW5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgIT09IFwicmVuYW1lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09IHByZXZDcmFzaEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcmV2Q3Jhc2hGaWxlID0gZmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlbmFtZS5zdGFydHNXaXRoKFwiTWljcm9zb2Z0LlZTQ29kZS5DUFAuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlKHBhdGgucmVzb2x2ZShjcmFzaEZvbGRlciwgZmlsZW5hbWUpLCAndXRmOCcsIChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZShwYXRoLnJlc29sdmUoY3Jhc2hGb2xkZXIsIGZpbGVuYW1lKSwgJ3V0ZjgnLCBoYW5kbGVDcmFzaEZpbGVSZWFkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDcmFzaEZpbGVSZWFkKGVyciwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMDApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxvZ0NyYXNoVGVsZW1ldHJ5KGRhdGEpIHtcclxuICAgIGxldCBjcmFzaE9iamVjdCA9IHt9O1xyXG4gICAgY3Jhc2hPYmplY3RbXCJDcmFzaGluZ1RocmVhZENhbGxTdGFja1wiXSA9IGRhdGE7XHJcbiAgICB0ZWxlbWV0cnkubG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudChcIk1hY0NyYXNoXCIsIGNyYXNoT2JqZWN0LCBudWxsKTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVDcmFzaEZpbGVSZWFkKGVyciwgZGF0YSkge1xyXG4gICAgaWYgKGVycikge1xyXG4gICAgICAgIHJldHVybiBsb2dDcmFzaFRlbGVtZXRyeShcInJlYWRGaWxlOiBcIiArIGVyci5jb2RlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNyYXNoU3RhcnQgPSBcIiBDcmFzaGVkOlwiO1xyXG4gICAgbGV0IHN0YXJ0Q3Jhc2ggPSBkYXRhLmluZGV4T2YoY3Jhc2hTdGFydCk7XHJcbiAgICBpZiAoc3RhcnRDcmFzaCA8IDApIHtcclxuICAgICAgICByZXR1cm4gbG9nQ3Jhc2hUZWxlbWV0cnkoXCJObyBjcmFzaCBzdGFydFwiKTtcclxuICAgIH1cclxuICAgIHN0YXJ0Q3Jhc2ggKz0gY3Jhc2hTdGFydC5sZW5ndGggKyAxO1xyXG4gICAgbGV0IGVuZENyYXNoID0gZGF0YS5pbmRleE9mKFwiVGhyZWFkIFwiLCBzdGFydENyYXNoKTtcclxuICAgIGlmIChlbmRDcmFzaCA8IDApIHtcclxuICAgICAgICBlbmRDcmFzaCA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgIH1cclxuICAgIGlmIChlbmRDcmFzaCA8PSBzdGFydENyYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvZ0NyYXNoVGVsZW1ldHJ5KFwiTm8gY3Jhc2ggZW5kXCIpO1xyXG4gICAgfVxyXG4gICAgZGF0YSA9IGRhdGEuc3Vic3RyKHN0YXJ0Q3Jhc2gsIGVuZENyYXNoIC0gc3RhcnRDcmFzaCk7XHJcbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8weC4uLi4uLi4uLi4uLi4uLi4gL2csIFwiXCIpO1xyXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvMHgxLi4uLi4uLi4gXFwrIDAvZywgXCJcIik7XHJcbiAgICBjb25zdCBwcm9jZXNzMSA9IFwiTWljcm9zb2Z0LlZTQ29kZS5DUFAuSW50ZWxsaVNlbnNlLk1zdmMuZGFyd2luXFx0XCI7XHJcbiAgICBjb25zdCBwcm9jZXNzMiA9IFwiTWljcm9zb2Z0LlZTQ29kZS5DUFAuRXh0ZW5zaW9uLmRhcndpblxcdFwiO1xyXG4gICAgaWYgKGRhdGEuaW5jbHVkZXMocHJvY2VzczEpKSB7XHJcbiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZShuZXcgUmVnRXhwKHByb2Nlc3MxLCBcImdcIiksIFwiXCIpO1xyXG4gICAgICAgIGRhdGEgPSBwcm9jZXNzMSArIFwiXFxuXCIgKyBkYXRhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGF0YS5pbmNsdWRlcyhwcm9jZXNzMikpIHtcclxuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKG5ldyBSZWdFeHAocHJvY2VzczIsIFwiZ1wiKSwgXCJcIik7XHJcbiAgICAgICAgZGF0YSA9IHByb2Nlc3MyICsgXCJcXG5cIiArIGRhdGE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9nQ3Jhc2hUZWxlbWV0cnkoXCJObyBwcm9jZXNzXCIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKTtcclxuICAgIGRhdGEgPSBcIlwiO1xyXG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xyXG4gICAgICAgIGlmICghbGluZS5pbmNsdWRlcyhcIi5keWxpYlwiKSAmJiAhbGluZS5pbmNsdWRlcyhcIj8/P1wiKSkge1xyXG4gICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eXFxkK1xccysvLCBcIlwiKTtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvc3RkOjpfXzE6Oi9nLCBcInN0ZDo6XCIpO1xyXG4gICAgICAgICAgICBkYXRhICs9IChsaW5lICsgXCJcXG5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBkYXRhID0gZGF0YS50cmltUmlnaHQoKTtcclxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgxOTIpIHtcclxuICAgICAgICBkYXRhID0gZGF0YS5zdWJzdHIoMCwgODE4OSkgKyBcIi4uLlwiO1xyXG4gICAgfVxyXG4gICAgbG9nQ3Jhc2hUZWxlbWV0cnkoZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZSgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiZGVhY3RpdmF0aW5nIGV4dGVuc2lvblwiKTtcclxuICAgIHRlbGVtZXRyeS5sb2dMYW5ndWFnZVNlcnZlckV2ZW50KFwiTGFuZ3VhZ2VTZXJ2ZXJTaHV0ZG93blwiKTtcclxuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxUaW1lcik7XHJcbiAgICBjbGVhckludGVydmFsKGluc2lkZXJVcGRhdGVUaW1lcik7XHJcbiAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKGQgPT4gZC5kaXNwb3NlKCkpO1xyXG4gICAgbGFuZ3VhZ2VDb25maWd1cmF0aW9ucy5mb3JFYWNoKGQgPT4gZC5kaXNwb3NlKCkpO1xyXG4gICAgdWkuZGlzcG9zZSgpO1xyXG4gICAgaWYgKHRhc2tQcm92aWRlcikge1xyXG4gICAgICAgIHRhc2tQcm92aWRlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xpZW50cy5kaXNwb3NlKCk7XHJcbn1cclxuZXhwb3J0cy5kZWFjdGl2YXRlID0gZGVhY3RpdmF0ZTtcclxuZnVuY3Rpb24gaXNGb2xkZXJPcGVuKCkge1xyXG4gICAgcmV0dXJuIHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycyAhPT0gdW5kZWZpbmVkICYmIHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycy5sZW5ndGggPiAwO1xyXG59XHJcbmV4cG9ydHMuaXNGb2xkZXJPcGVuID0gaXNGb2xkZXJPcGVuO1xyXG5mdW5jdGlvbiBnZXRDbGllbnRzKCkge1xyXG4gICAgaWYgKCFyZWFsQWN0aXZhdGlvbk9jY3VycmVkKSB7XHJcbiAgICAgICAgcmVhbEFjdGl2YXRpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGllbnRzO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q2xpZW50cyA9IGdldENsaWVudHM7XHJcbmZ1bmN0aW9uIGdldEFjdGl2ZUNsaWVudCgpIHtcclxuICAgIGlmICghcmVhbEFjdGl2YXRpb25PY2N1cnJlZCkge1xyXG4gICAgICAgIHJlYWxBY3RpdmF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xpZW50cy5BY3RpdmVDbGllbnQ7XHJcbn1cclxuZXhwb3J0cy5nZXRBY3RpdmVDbGllbnQgPSBnZXRBY3RpdmVDbGllbnQ7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/extension.ts\n");

/***/ }),

/***/ "./src/LanguageServer/languageConfig.ts":
/*!**********************************************!*\
  !*** ./src/LanguageServer/languageConfig.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/LanguageServer/settings.ts\");\r\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/logger.ts\");\r\nconst escapeChars = /[\\\\\\^\\$\\*\\+\\?\\{\\}\\(\\)\\.\\!\\=\\|\\[\\]\\ \\/]/;\r\nfunction escape(chars) {\r\n    let result = \"\";\r\n    for (let char of chars) {\r\n        if (char.match(escapeChars)) {\r\n            result += `\\\\${char}`;\r\n        }\r\n        else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getMLBeginPattern(insert) {\r\n    if (insert && insert.startsWith(\"/*\")) {\r\n        let match = escape(insert.substr(2));\r\n        return `^\\\\s*\\\\/\\\\*${match}(?!\\\\/)([^\\\\*]|\\\\*(?!\\\\/))*$`;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLSplitAfterPattern() {\r\n    return \"^\\\\s*\\\\*\\\\/$\";\r\n}\r\nfunction getMLContinuePattern(insert) {\r\n    if (insert) {\r\n        let match = escape(insert.trimRight());\r\n        if (match) {\r\n            let right = escape(insert.substr(insert.trimRight().length));\r\n            return `^\\\\s*${match}(${right}([^\\\\*]|\\\\*(?!\\\\/))*)?$`;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLEndPattern(insert) {\r\n    if (insert) {\r\n        let match = escape(insert.trimRight().trimLeft());\r\n        if (match) {\r\n            return `^\\\\s*${match}[^/]*\\\\*\\\\/\\\\s*$`;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLEmptyEndPattern(insert) {\r\n    if (insert) {\r\n        insert = insert.trimRight();\r\n        if (insert) {\r\n            if (insert.endsWith('*')) {\r\n                insert = insert.substr(0, insert.length - 1);\r\n            }\r\n            let match = escape(insert.trimRight());\r\n            return `^\\\\s*${match}\\\\*\\\\/\\\\s*$`;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLBeginPattern(insert) {\r\n    if (insert) {\r\n        let match = escape(insert.trimRight());\r\n        return `^\\\\s*${match}.*$`;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLContinuePattern(insert) {\r\n    if (insert) {\r\n        let match = escape(insert.trimRight());\r\n        return `^\\\\s*${match}.+$`;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLEndPattern(insert) {\r\n    if (insert) {\r\n        let match = escape(insert);\r\n        let trimmed = escape(insert.trimRight());\r\n        if (match !== trimmed) {\r\n            match = `(${match}|${trimmed})`;\r\n        }\r\n        return `^\\\\s*${match}$`;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLSplitRule(comment) {\r\n    if (comment) {\r\n        let beforePattern = getMLBeginPattern(comment.begin);\r\n        if (beforePattern) {\r\n            return {\r\n                beforeText: new RegExp(beforePattern),\r\n                afterText: new RegExp(getMLSplitAfterPattern()),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.IndentOutdent,\r\n                    appendText: comment.continue ? comment.continue : ''\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLFirstLineRule(comment) {\r\n    if (comment) {\r\n        let beforePattern = getMLBeginPattern(comment.begin);\r\n        if (beforePattern) {\r\n            return {\r\n                beforeText: new RegExp(beforePattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    appendText: comment.continue ? comment.continue : ''\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLContinuationRule(comment) {\r\n    if (comment) {\r\n        let continuePattern = getMLContinuePattern(comment.continue);\r\n        if (continuePattern) {\r\n            return {\r\n                beforeText: new RegExp(continuePattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    appendText: comment.continue.trimLeft()\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLEndRule(comment) {\r\n    if (comment) {\r\n        let endPattern = getMLEndPattern(comment.continue);\r\n        if (endPattern) {\r\n            return {\r\n                beforeText: new RegExp(endPattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    removeText: comment.continue.length - comment.continue.trimLeft().length\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getMLEmptyEndRule(comment) {\r\n    if (comment) {\r\n        let endPattern = getMLEmptyEndPattern(comment.continue);\r\n        if (endPattern) {\r\n            return {\r\n                beforeText: new RegExp(endPattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    removeText: comment.continue.length - comment.continue.trimLeft().length\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLFirstLineRule(comment) {\r\n    if (comment) {\r\n        let continuePattern = getSLBeginPattern(comment.begin);\r\n        if (continuePattern) {\r\n            return {\r\n                beforeText: new RegExp(continuePattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    appendText: comment.continue.trimLeft()\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLContinuationRule(comment) {\r\n    if (comment) {\r\n        let continuePattern = getSLContinuePattern(comment.continue);\r\n        if (continuePattern) {\r\n            return {\r\n                beforeText: new RegExp(continuePattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    appendText: comment.continue.trimLeft()\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getSLEndRule(comment) {\r\n    if (comment) {\r\n        let endPattern = getSLEndPattern(comment.continue);\r\n        if (endPattern) {\r\n            return {\r\n                beforeText: new RegExp(endPattern),\r\n                action: {\r\n                    indentAction: vscode.IndentAction.None,\r\n                    removeText: comment.continue.length - comment.continue.trimLeft().length\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction getLanguageConfig(languageId, resource) {\r\n    let settings = new settings_1.CppSettings(resource);\r\n    let patterns = settings.commentContinuationPatterns;\r\n    return getLanguageConfigFromPatterns(languageId, patterns);\r\n}\r\nexports.getLanguageConfig = getLanguageConfig;\r\nfunction getLanguageConfigFromPatterns(languageId, patterns) {\r\n    let beginPatterns = [];\r\n    let continuePatterns = [];\r\n    let duplicates = false;\r\n    let beginRules = [];\r\n    let continueRules = [];\r\n    let endRules = [];\r\n    patterns.forEach(pattern => {\r\n        let c = (typeof pattern === \"string\") ? { begin: pattern, continue: pattern.startsWith('/*') ? \" * \" : pattern } : pattern;\r\n        let r = constructCommentRules(c, languageId);\r\n        if (beginPatterns.indexOf(c.begin) < 0) {\r\n            if (r.begin && r.begin.length > 0) {\r\n                beginRules = beginRules.concat(r.begin);\r\n            }\r\n            beginPatterns.push(c.begin);\r\n        }\r\n        else {\r\n            duplicates = true;\r\n        }\r\n        if (continuePatterns.indexOf(c.continue) < 0) {\r\n            if (r.continue && r.continue.length > 0) {\r\n                continueRules = continueRules.concat(r.continue);\r\n            }\r\n            if (r.end && r.end.length > 0) {\r\n                endRules = endRules.concat(r.end);\r\n            }\r\n            continuePatterns.push(c.continue);\r\n        }\r\n    });\r\n    if (duplicates) {\r\n        logger_1.getOutputChannel().appendLine(\"Duplicate multiline comment patterns detected.\");\r\n    }\r\n    return { onEnterRules: beginRules.concat(continueRules).concat(endRules).filter(e => (e)) };\r\n}\r\nexports.getLanguageConfigFromPatterns = getLanguageConfigFromPatterns;\r\nfunction constructCommentRules(comment, languageId) {\r\n    if (comment && comment.begin && comment.begin.startsWith('/*') && (languageId === 'c' || languageId === 'cpp')) {\r\n        return {\r\n            begin: [\r\n                getMLSplitRule(comment),\r\n                getMLFirstLineRule(comment)\r\n            ],\r\n            continue: [getMLContinuationRule(comment)],\r\n            end: [\r\n                getMLEmptyEndRule(comment),\r\n                getMLEndRule(comment)\r\n            ]\r\n        };\r\n    }\r\n    else if (comment && comment.begin && comment.begin.startsWith('//') && languageId === 'cpp') {\r\n        return {\r\n            begin: (comment.begin === comment.continue) ? [] : [getSLFirstLineRule(comment)],\r\n            continue: [getSLContinuationRule(comment)],\r\n            end: [getSLEndRule(comment)]\r\n        };\r\n    }\r\n    return {\r\n        begin: [],\r\n        continue: [],\r\n        end: []\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvbGFuZ3VhZ2VDb25maWcudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL2xhbmd1YWdlQ29uZmlnLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XHJcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuY29uc3QgZXNjYXBlQ2hhcnMgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHtcXH1cXChcXClcXC5cXCFcXD1cXHxcXFtcXF1cXCBcXC9dLztcclxuZnVuY3Rpb24gZXNjYXBlKGNoYXJzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgIGZvciAobGV0IGNoYXIgb2YgY2hhcnMpIHtcclxuICAgICAgICBpZiAoY2hhci5tYXRjaChlc2NhcGVDaGFycykpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGBcXFxcJHtjaGFyfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gY2hhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MQmVnaW5QYXR0ZXJuKGluc2VydCkge1xyXG4gICAgaWYgKGluc2VydCAmJiBpbnNlcnQuc3RhcnRzV2l0aChcIi8qXCIpKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gZXNjYXBlKGluc2VydC5zdWJzdHIoMikpO1xyXG4gICAgICAgIHJldHVybiBgXlxcXFxzKlxcXFwvXFxcXCoke21hdGNofSg/IVxcXFwvKShbXlxcXFwqXXxcXFxcKig/IVxcXFwvKSkqJGA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MU3BsaXRBZnRlclBhdHRlcm4oKSB7XHJcbiAgICByZXR1cm4gXCJeXFxcXHMqXFxcXCpcXFxcLyRcIjtcclxufVxyXG5mdW5jdGlvbiBnZXRNTENvbnRpbnVlUGF0dGVybihpbnNlcnQpIHtcclxuICAgIGlmIChpbnNlcnQpIHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBlc2NhcGUoaW5zZXJ0LnRyaW1SaWdodCgpKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gZXNjYXBlKGluc2VydC5zdWJzdHIoaW5zZXJ0LnRyaW1SaWdodCgpLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYF5cXFxccyoke21hdGNofSgke3JpZ2h0fShbXlxcXFwqXXxcXFxcKig/IVxcXFwvKSkqKT8kYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MRW5kUGF0dGVybihpbnNlcnQpIHtcclxuICAgIGlmIChpbnNlcnQpIHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBlc2NhcGUoaW5zZXJ0LnRyaW1SaWdodCgpLnRyaW1MZWZ0KCkpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF5cXFxccyoke21hdGNofVteL10qXFxcXCpcXFxcL1xcXFxzKiRgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TUxFbXB0eUVuZFBhdHRlcm4oaW5zZXJ0KSB7XHJcbiAgICBpZiAoaW5zZXJ0KSB7XHJcbiAgICAgICAgaW5zZXJ0ID0gaW5zZXJ0LnRyaW1SaWdodCgpO1xyXG4gICAgICAgIGlmIChpbnNlcnQpIHtcclxuICAgICAgICAgICAgaWYgKGluc2VydC5lbmRzV2l0aCgnKicpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBpbnNlcnQuc3Vic3RyKDAsIGluc2VydC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBlc2NhcGUoaW5zZXJ0LnRyaW1SaWdodCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGBeXFxcXHMqJHttYXRjaH1cXFxcKlxcXFwvXFxcXHMqJGA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXRTTEJlZ2luUGF0dGVybihpbnNlcnQpIHtcclxuICAgIGlmIChpbnNlcnQpIHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBlc2NhcGUoaW5zZXJ0LnRyaW1SaWdodCgpKTtcclxuICAgICAgICByZXR1cm4gYF5cXFxccyoke21hdGNofS4qJGA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNMQ29udGludWVQYXR0ZXJuKGluc2VydCkge1xyXG4gICAgaWYgKGluc2VydCkge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IGVzY2FwZShpbnNlcnQudHJpbVJpZ2h0KCkpO1xyXG4gICAgICAgIHJldHVybiBgXlxcXFxzKiR7bWF0Y2h9LiskYDtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U0xFbmRQYXR0ZXJuKGluc2VydCkge1xyXG4gICAgaWYgKGluc2VydCkge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IGVzY2FwZShpbnNlcnQpO1xyXG4gICAgICAgIGxldCB0cmltbWVkID0gZXNjYXBlKGluc2VydC50cmltUmlnaHQoKSk7XHJcbiAgICAgICAgaWYgKG1hdGNoICE9PSB0cmltbWVkKSB7XHJcbiAgICAgICAgICAgIG1hdGNoID0gYCgke21hdGNofXwke3RyaW1tZWR9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgXlxcXFxzKiR7bWF0Y2h9JGA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MU3BsaXRSdWxlKGNvbW1lbnQpIHtcclxuICAgIGlmIChjb21tZW50KSB7XHJcbiAgICAgICAgbGV0IGJlZm9yZVBhdHRlcm4gPSBnZXRNTEJlZ2luUGF0dGVybihjb21tZW50LmJlZ2luKTtcclxuICAgICAgICBpZiAoYmVmb3JlUGF0dGVybikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlVGV4dDogbmV3IFJlZ0V4cChiZWZvcmVQYXR0ZXJuKSxcclxuICAgICAgICAgICAgICAgIGFmdGVyVGV4dDogbmV3IFJlZ0V4cChnZXRNTFNwbGl0QWZ0ZXJQYXR0ZXJuKCkpLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50QWN0aW9uOiB2c2NvZGUuSW5kZW50QWN0aW9uLkluZGVudE91dGRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVGV4dDogY29tbWVudC5jb250aW51ZSA/IGNvbW1lbnQuY29udGludWUgOiAnJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TUxGaXJzdExpbmVSdWxlKGNvbW1lbnQpIHtcclxuICAgIGlmIChjb21tZW50KSB7XHJcbiAgICAgICAgbGV0IGJlZm9yZVBhdHRlcm4gPSBnZXRNTEJlZ2luUGF0dGVybihjb21tZW50LmJlZ2luKTtcclxuICAgICAgICBpZiAoYmVmb3JlUGF0dGVybikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlVGV4dDogbmV3IFJlZ0V4cChiZWZvcmVQYXR0ZXJuKSxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGVudEFjdGlvbjogdnNjb2RlLkluZGVudEFjdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFRleHQ6IGNvbW1lbnQuY29udGludWUgPyBjb21tZW50LmNvbnRpbnVlIDogJydcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MQ29udGludWF0aW9uUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBjb250aW51ZVBhdHRlcm4gPSBnZXRNTENvbnRpbnVlUGF0dGVybihjb21tZW50LmNvbnRpbnVlKTtcclxuICAgICAgICBpZiAoY29udGludWVQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKGNvbnRpbnVlUGF0dGVybiksXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRBY3Rpb246IHZzY29kZS5JbmRlbnRBY3Rpb24uTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBjb21tZW50LmNvbnRpbnVlLnRyaW1MZWZ0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1MRW5kUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBlbmRQYXR0ZXJuID0gZ2V0TUxFbmRQYXR0ZXJuKGNvbW1lbnQuY29udGludWUpO1xyXG4gICAgICAgIGlmIChlbmRQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKGVuZFBhdHRlcm4pLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50QWN0aW9uOiB2c2NvZGUuSW5kZW50QWN0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVGV4dDogY29tbWVudC5jb250aW51ZS5sZW5ndGggLSBjb21tZW50LmNvbnRpbnVlLnRyaW1MZWZ0KCkubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXRNTEVtcHR5RW5kUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBlbmRQYXR0ZXJuID0gZ2V0TUxFbXB0eUVuZFBhdHRlcm4oY29tbWVudC5jb250aW51ZSk7XHJcbiAgICAgICAgaWYgKGVuZFBhdHRlcm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJlZm9yZVRleHQ6IG5ldyBSZWdFeHAoZW5kUGF0dGVybiksXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRBY3Rpb246IHZzY29kZS5JbmRlbnRBY3Rpb24uTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVUZXh0OiBjb21tZW50LmNvbnRpbnVlLmxlbmd0aCAtIGNvbW1lbnQuY29udGludWUudHJpbUxlZnQoKS5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNMRmlyc3RMaW5lUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBjb250aW51ZVBhdHRlcm4gPSBnZXRTTEJlZ2luUGF0dGVybihjb21tZW50LmJlZ2luKTtcclxuICAgICAgICBpZiAoY29udGludWVQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKGNvbnRpbnVlUGF0dGVybiksXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRBY3Rpb246IHZzY29kZS5JbmRlbnRBY3Rpb24uTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBjb21tZW50LmNvbnRpbnVlLnRyaW1MZWZ0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNMQ29udGludWF0aW9uUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBjb250aW51ZVBhdHRlcm4gPSBnZXRTTENvbnRpbnVlUGF0dGVybihjb21tZW50LmNvbnRpbnVlKTtcclxuICAgICAgICBpZiAoY29udGludWVQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKGNvbnRpbnVlUGF0dGVybiksXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRBY3Rpb246IHZzY29kZS5JbmRlbnRBY3Rpb24uTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUZXh0OiBjb21tZW50LmNvbnRpbnVlLnRyaW1MZWZ0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNMRW5kUnVsZShjb21tZW50KSB7XHJcbiAgICBpZiAoY29tbWVudCkge1xyXG4gICAgICAgIGxldCBlbmRQYXR0ZXJuID0gZ2V0U0xFbmRQYXR0ZXJuKGNvbW1lbnQuY29udGludWUpO1xyXG4gICAgICAgIGlmIChlbmRQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUZXh0OiBuZXcgUmVnRXhwKGVuZFBhdHRlcm4pLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50QWN0aW9uOiB2c2NvZGUuSW5kZW50QWN0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVGV4dDogY29tbWVudC5jb250aW51ZS5sZW5ndGggLSBjb21tZW50LmNvbnRpbnVlLnRyaW1MZWZ0KCkubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXRMYW5ndWFnZUNvbmZpZyhsYW5ndWFnZUlkLCByZXNvdXJjZSkge1xyXG4gICAgbGV0IHNldHRpbmdzID0gbmV3IHNldHRpbmdzXzEuQ3BwU2V0dGluZ3MocmVzb3VyY2UpO1xyXG4gICAgbGV0IHBhdHRlcm5zID0gc2V0dGluZ3MuY29tbWVudENvbnRpbnVhdGlvblBhdHRlcm5zO1xyXG4gICAgcmV0dXJuIGdldExhbmd1YWdlQ29uZmlnRnJvbVBhdHRlcm5zKGxhbmd1YWdlSWQsIHBhdHRlcm5zKTtcclxufVxyXG5leHBvcnRzLmdldExhbmd1YWdlQ29uZmlnID0gZ2V0TGFuZ3VhZ2VDb25maWc7XHJcbmZ1bmN0aW9uIGdldExhbmd1YWdlQ29uZmlnRnJvbVBhdHRlcm5zKGxhbmd1YWdlSWQsIHBhdHRlcm5zKSB7XHJcbiAgICBsZXQgYmVnaW5QYXR0ZXJucyA9IFtdO1xyXG4gICAgbGV0IGNvbnRpbnVlUGF0dGVybnMgPSBbXTtcclxuICAgIGxldCBkdXBsaWNhdGVzID0gZmFsc2U7XHJcbiAgICBsZXQgYmVnaW5SdWxlcyA9IFtdO1xyXG4gICAgbGV0IGNvbnRpbnVlUnVsZXMgPSBbXTtcclxuICAgIGxldCBlbmRSdWxlcyA9IFtdO1xyXG4gICAgcGF0dGVybnMuZm9yRWFjaChwYXR0ZXJuID0+IHtcclxuICAgICAgICBsZXQgYyA9ICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikgPyB7IGJlZ2luOiBwYXR0ZXJuLCBjb250aW51ZTogcGF0dGVybi5zdGFydHNXaXRoKCcvKicpID8gXCIgKiBcIiA6IHBhdHRlcm4gfSA6IHBhdHRlcm47XHJcbiAgICAgICAgbGV0IHIgPSBjb25zdHJ1Y3RDb21tZW50UnVsZXMoYywgbGFuZ3VhZ2VJZCk7XHJcbiAgICAgICAgaWYgKGJlZ2luUGF0dGVybnMuaW5kZXhPZihjLmJlZ2luKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKHIuYmVnaW4gJiYgci5iZWdpbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBiZWdpblJ1bGVzID0gYmVnaW5SdWxlcy5jb25jYXQoci5iZWdpbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmVnaW5QYXR0ZXJucy5wdXNoKGMuYmVnaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZHVwbGljYXRlcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250aW51ZVBhdHRlcm5zLmluZGV4T2YoYy5jb250aW51ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChyLmNvbnRpbnVlICYmIHIuY29udGludWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVSdWxlcyA9IGNvbnRpbnVlUnVsZXMuY29uY2F0KHIuY29udGludWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyLmVuZCAmJiByLmVuZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRSdWxlcyA9IGVuZFJ1bGVzLmNvbmNhdChyLmVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWVQYXR0ZXJucy5wdXNoKGMuY29udGludWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKGR1cGxpY2F0ZXMpIHtcclxuICAgICAgICBsb2dnZXJfMS5nZXRPdXRwdXRDaGFubmVsKCkuYXBwZW5kTGluZShcIkR1cGxpY2F0ZSBtdWx0aWxpbmUgY29tbWVudCBwYXR0ZXJucyBkZXRlY3RlZC5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBvbkVudGVyUnVsZXM6IGJlZ2luUnVsZXMuY29uY2F0KGNvbnRpbnVlUnVsZXMpLmNvbmNhdChlbmRSdWxlcykuZmlsdGVyKGUgPT4gKGUpKSB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0TGFuZ3VhZ2VDb25maWdGcm9tUGF0dGVybnMgPSBnZXRMYW5ndWFnZUNvbmZpZ0Zyb21QYXR0ZXJucztcclxuZnVuY3Rpb24gY29uc3RydWN0Q29tbWVudFJ1bGVzKGNvbW1lbnQsIGxhbmd1YWdlSWQpIHtcclxuICAgIGlmIChjb21tZW50ICYmIGNvbW1lbnQuYmVnaW4gJiYgY29tbWVudC5iZWdpbi5zdGFydHNXaXRoKCcvKicpICYmIChsYW5ndWFnZUlkID09PSAnYycgfHwgbGFuZ3VhZ2VJZCA9PT0gJ2NwcCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYmVnaW46IFtcclxuICAgICAgICAgICAgICAgIGdldE1MU3BsaXRSdWxlKGNvbW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgZ2V0TUxGaXJzdExpbmVSdWxlKGNvbW1lbnQpXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGNvbnRpbnVlOiBbZ2V0TUxDb250aW51YXRpb25SdWxlKGNvbW1lbnQpXSxcclxuICAgICAgICAgICAgZW5kOiBbXHJcbiAgICAgICAgICAgICAgICBnZXRNTEVtcHR5RW5kUnVsZShjb21tZW50KSxcclxuICAgICAgICAgICAgICAgIGdldE1MRW5kUnVsZShjb21tZW50KVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbW1lbnQgJiYgY29tbWVudC5iZWdpbiAmJiBjb21tZW50LmJlZ2luLnN0YXJ0c1dpdGgoJy8vJykgJiYgbGFuZ3VhZ2VJZCA9PT0gJ2NwcCcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBiZWdpbjogKGNvbW1lbnQuYmVnaW4gPT09IGNvbW1lbnQuY29udGludWUpID8gW10gOiBbZ2V0U0xGaXJzdExpbmVSdWxlKGNvbW1lbnQpXSxcclxuICAgICAgICAgICAgY29udGludWU6IFtnZXRTTENvbnRpbnVhdGlvblJ1bGUoY29tbWVudCldLFxyXG4gICAgICAgICAgICBlbmQ6IFtnZXRTTEVuZFJ1bGUoY29tbWVudCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmVnaW46IFtdLFxyXG4gICAgICAgIGNvbnRpbnVlOiBbXSxcclxuICAgICAgICBlbmQ6IFtdXHJcbiAgICB9O1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LanguageServer/languageConfig.ts\n");

/***/ }),

/***/ "./src/LanguageServer/persistentState.ts":
/*!***********************************************!*\
  !*** ./src/LanguageServer/persistentState.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nclass PersistentStateBase {\r\n    constructor(key, defaultValue, state) {\r\n        this.key = key;\r\n        this.defaultvalue = defaultValue;\r\n        this.state = state;\r\n    }\r\n    get Value() {\r\n        return this.state.get(this.key, this.defaultvalue);\r\n    }\r\n    set Value(newValue) {\r\n        this.state.update(this.key, newValue);\r\n    }\r\n    get DefaultValue() {\r\n        return this.defaultvalue;\r\n    }\r\n}\r\nclass PersistentState extends PersistentStateBase {\r\n    constructor(key, defaultValue) {\r\n        super(key, defaultValue, util.extensionContext.globalState);\r\n    }\r\n}\r\nexports.PersistentState = PersistentState;\r\nclass PersistentWorkspaceState extends PersistentStateBase {\r\n    constructor(key, defaultValue) {\r\n        super(key, defaultValue, util.extensionContext.workspaceState);\r\n    }\r\n}\r\nexports.PersistentWorkspaceState = PersistentWorkspaceState;\r\nclass PersistentFolderState extends PersistentWorkspaceState {\r\n    constructor(key, defaultValue, folder) {\r\n        let newKey = key + (folder ? `-${path.basename(folder)}` : \"-untitled\");\r\n        super(newKey, defaultValue);\r\n    }\r\n}\r\nexports.PersistentFolderState = PersistentFolderState;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvcGVyc2lzdGVudFN0YXRlLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9MYW5ndWFnZVNlcnZlci9wZXJzaXN0ZW50U3RhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNsYXNzIFBlcnNpc3RlbnRTdGF0ZUJhc2Uge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkZWZhdWx0VmFsdWUsIHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0dmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0IFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmdldCh0aGlzLmtleSwgdGhpcy5kZWZhdWx0dmFsdWUpO1xyXG4gICAgfVxyXG4gICAgc2V0IFZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGUodGhpcy5rZXksIG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCBEZWZhdWx0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBlcnNpc3RlbnRTdGF0ZSBleHRlbmRzIFBlcnNpc3RlbnRTdGF0ZUJhc2Uge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBzdXBlcihrZXksIGRlZmF1bHRWYWx1ZSwgdXRpbC5leHRlbnNpb25Db250ZXh0Lmdsb2JhbFN0YXRlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBlcnNpc3RlbnRTdGF0ZSA9IFBlcnNpc3RlbnRTdGF0ZTtcclxuY2xhc3MgUGVyc2lzdGVudFdvcmtzcGFjZVN0YXRlIGV4dGVuZHMgUGVyc2lzdGVudFN0YXRlQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKGtleSwgZGVmYXVsdFZhbHVlLCB1dGlsLmV4dGVuc2lvbkNvbnRleHQud29ya3NwYWNlU3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGVyc2lzdGVudFdvcmtzcGFjZVN0YXRlID0gUGVyc2lzdGVudFdvcmtzcGFjZVN0YXRlO1xyXG5jbGFzcyBQZXJzaXN0ZW50Rm9sZGVyU3RhdGUgZXh0ZW5kcyBQZXJzaXN0ZW50V29ya3NwYWNlU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkZWZhdWx0VmFsdWUsIGZvbGRlcikge1xyXG4gICAgICAgIGxldCBuZXdLZXkgPSBrZXkgKyAoZm9sZGVyID8gYC0ke3BhdGguYmFzZW5hbWUoZm9sZGVyKX1gIDogXCItdW50aXRsZWRcIik7XHJcbiAgICAgICAgc3VwZXIobmV3S2V5LCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGVyc2lzdGVudEZvbGRlclN0YXRlID0gUGVyc2lzdGVudEZvbGRlclN0YXRlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/persistentState.ts\n");

/***/ }),

/***/ "./src/LanguageServer/protocolFilter.ts":
/*!**********************************************!*\
  !*** ./src/LanguageServer/protocolFilter.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createProtocolFilter(me, clients) {\r\n    let defaultHandler = (data, callback) => { if (clients.ActiveClient === me) {\r\n        me.notifyWhenReady(() => callback(data));\r\n    } };\r\n    let invoke1 = (a, callback) => { if (clients.ActiveClient === me) {\r\n        return me.requestWhenReady(() => callback(a));\r\n    } return null; };\r\n    let invoke2 = (a, b, callback) => { if (clients.ActiveClient === me) {\r\n        return me.requestWhenReady(() => callback(a, b));\r\n    } return null; };\r\n    let invoke3 = (a, b, c, callback) => { if (clients.ActiveClient === me) {\r\n        return me.requestWhenReady(() => callback(a, b, c));\r\n    } return null; };\r\n    let invoke4 = (a, b, c, d, callback) => { if (clients.ActiveClient === me) {\r\n        return me.requestWhenReady(() => callback(a, b, c, d));\r\n    } return null; };\r\n    let invoke5 = (a, b, c, d, e, callback) => { if (clients.ActiveClient === me) {\r\n        return me.requestWhenReady(() => callback(a, b, c, d, e));\r\n    } return null; };\r\n    return {\r\n        didOpen: (document, sendMessage) => {\r\n            if (clients.checkOwnership(me, document)) {\r\n                me.TrackedDocuments.add(document);\r\n                me.provideCustomConfiguration(document).then(() => {\r\n                    sendMessage(document);\r\n                }, () => {\r\n                    sendMessage(document);\r\n                });\r\n            }\r\n        },\r\n        didChange: defaultHandler,\r\n        willSave: defaultHandler,\r\n        willSaveWaitUntil: (event, sendMessage) => {\r\n            if (clients.ActiveClient === me) {\r\n                return me.requestWhenReady(() => sendMessage(event));\r\n            }\r\n            return Promise.resolve([]);\r\n        },\r\n        didSave: defaultHandler,\r\n        didClose: (document, sendMessage) => {\r\n            if (clients.ActiveClient === me) {\r\n                console.assert(me.TrackedDocuments.has(document));\r\n                me.TrackedDocuments.delete(document);\r\n                me.notifyWhenReady(() => sendMessage(document));\r\n            }\r\n        },\r\n        provideCompletionItem: invoke4,\r\n        resolveCompletionItem: invoke2,\r\n        provideHover: invoke3,\r\n        provideSignatureHelp: invoke3,\r\n        provideDefinition: invoke3,\r\n        provideReferences: invoke4,\r\n        provideDocumentHighlights: invoke3,\r\n        provideDocumentSymbols: invoke2,\r\n        provideWorkspaceSymbols: invoke2,\r\n        provideCodeActions: invoke4,\r\n        provideCodeLenses: invoke2,\r\n        resolveCodeLens: invoke2,\r\n        provideDocumentFormattingEdits: invoke3,\r\n        provideDocumentRangeFormattingEdits: invoke4,\r\n        provideOnTypeFormattingEdits: invoke5,\r\n        provideRenameEdits: invoke4,\r\n        provideDocumentLinks: invoke2,\r\n        resolveDocumentLink: invoke2,\r\n    };\r\n}\r\nexports.createProtocolFilter = createProtocolFilter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvcHJvdG9jb2xGaWx0ZXIudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL3Byb3RvY29sRmlsdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbEZpbHRlcihtZSwgY2xpZW50cykge1xyXG4gICAgbGV0IGRlZmF1bHRIYW5kbGVyID0gKGRhdGEsIGNhbGxiYWNrKSA9PiB7IGlmIChjbGllbnRzLkFjdGl2ZUNsaWVudCA9PT0gbWUpIHtcclxuICAgICAgICBtZS5ub3RpZnlXaGVuUmVhZHkoKCkgPT4gY2FsbGJhY2soZGF0YSkpO1xyXG4gICAgfSB9O1xyXG4gICAgbGV0IGludm9rZTEgPSAoYSwgY2FsbGJhY2spID0+IHsgaWYgKGNsaWVudHMuQWN0aXZlQ2xpZW50ID09PSBtZSkge1xyXG4gICAgICAgIHJldHVybiBtZS5yZXF1ZXN0V2hlblJlYWR5KCgpID0+IGNhbGxiYWNrKGEpKTtcclxuICAgIH0gcmV0dXJuIG51bGw7IH07XHJcbiAgICBsZXQgaW52b2tlMiA9IChhLCBiLCBjYWxsYmFjaykgPT4geyBpZiAoY2xpZW50cy5BY3RpdmVDbGllbnQgPT09IG1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lLnJlcXVlc3RXaGVuUmVhZHkoKCkgPT4gY2FsbGJhY2soYSwgYikpO1xyXG4gICAgfSByZXR1cm4gbnVsbDsgfTtcclxuICAgIGxldCBpbnZva2UzID0gKGEsIGIsIGMsIGNhbGxiYWNrKSA9PiB7IGlmIChjbGllbnRzLkFjdGl2ZUNsaWVudCA9PT0gbWUpIHtcclxuICAgICAgICByZXR1cm4gbWUucmVxdWVzdFdoZW5SZWFkeSgoKSA9PiBjYWxsYmFjayhhLCBiLCBjKSk7XHJcbiAgICB9IHJldHVybiBudWxsOyB9O1xyXG4gICAgbGV0IGludm9rZTQgPSAoYSwgYiwgYywgZCwgY2FsbGJhY2spID0+IHsgaWYgKGNsaWVudHMuQWN0aXZlQ2xpZW50ID09PSBtZSkge1xyXG4gICAgICAgIHJldHVybiBtZS5yZXF1ZXN0V2hlblJlYWR5KCgpID0+IGNhbGxiYWNrKGEsIGIsIGMsIGQpKTtcclxuICAgIH0gcmV0dXJuIG51bGw7IH07XHJcbiAgICBsZXQgaW52b2tlNSA9IChhLCBiLCBjLCBkLCBlLCBjYWxsYmFjaykgPT4geyBpZiAoY2xpZW50cy5BY3RpdmVDbGllbnQgPT09IG1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lLnJlcXVlc3RXaGVuUmVhZHkoKCkgPT4gY2FsbGJhY2soYSwgYiwgYywgZCwgZSkpO1xyXG4gICAgfSByZXR1cm4gbnVsbDsgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGlkT3BlbjogKGRvY3VtZW50LCBzZW5kTWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50cy5jaGVja093bmVyc2hpcChtZSwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBtZS5UcmFja2VkRG9jdW1lbnRzLmFkZChkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICBtZS5wcm92aWRlQ3VzdG9tQ29uZmlndXJhdGlvbihkb2N1bWVudCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2UoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWRDaGFuZ2U6IGRlZmF1bHRIYW5kbGVyLFxyXG4gICAgICAgIHdpbGxTYXZlOiBkZWZhdWx0SGFuZGxlcixcclxuICAgICAgICB3aWxsU2F2ZVdhaXRVbnRpbDogKGV2ZW50LCBzZW5kTWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50cy5BY3RpdmVDbGllbnQgPT09IG1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUucmVxdWVzdFdoZW5SZWFkeSgoKSA9PiBzZW5kTWVzc2FnZShldmVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlkU2F2ZTogZGVmYXVsdEhhbmRsZXIsXHJcbiAgICAgICAgZGlkQ2xvc2U6IChkb2N1bWVudCwgc2VuZE1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNsaWVudHMuQWN0aXZlQ2xpZW50ID09PSBtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobWUuVHJhY2tlZERvY3VtZW50cy5oYXMoZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIG1lLlRyYWNrZWREb2N1bWVudHMuZGVsZXRlKGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIG1lLm5vdGlmeVdoZW5SZWFkeSgoKSA9PiBzZW5kTWVzc2FnZShkb2N1bWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm92aWRlQ29tcGxldGlvbkl0ZW06IGludm9rZTQsXHJcbiAgICAgICAgcmVzb2x2ZUNvbXBsZXRpb25JdGVtOiBpbnZva2UyLFxyXG4gICAgICAgIHByb3ZpZGVIb3ZlcjogaW52b2tlMyxcclxuICAgICAgICBwcm92aWRlU2lnbmF0dXJlSGVscDogaW52b2tlMyxcclxuICAgICAgICBwcm92aWRlRGVmaW5pdGlvbjogaW52b2tlMyxcclxuICAgICAgICBwcm92aWRlUmVmZXJlbmNlczogaW52b2tlNCxcclxuICAgICAgICBwcm92aWRlRG9jdW1lbnRIaWdobGlnaHRzOiBpbnZva2UzLFxyXG4gICAgICAgIHByb3ZpZGVEb2N1bWVudFN5bWJvbHM6IGludm9rZTIsXHJcbiAgICAgICAgcHJvdmlkZVdvcmtzcGFjZVN5bWJvbHM6IGludm9rZTIsXHJcbiAgICAgICAgcHJvdmlkZUNvZGVBY3Rpb25zOiBpbnZva2U0LFxyXG4gICAgICAgIHByb3ZpZGVDb2RlTGVuc2VzOiBpbnZva2UyLFxyXG4gICAgICAgIHJlc29sdmVDb2RlTGVuczogaW52b2tlMixcclxuICAgICAgICBwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHM6IGludm9rZTMsXHJcbiAgICAgICAgcHJvdmlkZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdHM6IGludm9rZTQsXHJcbiAgICAgICAgcHJvdmlkZU9uVHlwZUZvcm1hdHRpbmdFZGl0czogaW52b2tlNSxcclxuICAgICAgICBwcm92aWRlUmVuYW1lRWRpdHM6IGludm9rZTQsXHJcbiAgICAgICAgcHJvdmlkZURvY3VtZW50TGlua3M6IGludm9rZTIsXHJcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50TGluazogaW52b2tlMixcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbEZpbHRlciA9IGNyZWF0ZVByb3RvY29sRmlsdGVyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LanguageServer/protocolFilter.ts\n");

/***/ }),

/***/ "./src/LanguageServer/settings.ts":
/*!****************************************!*\
  !*** ./src/LanguageServer/settings.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nfunction getTarget() {\r\n    return (vscode.workspace.workspaceFolders) ? vscode.ConfigurationTarget.WorkspaceFolder : vscode.ConfigurationTarget.Global;\r\n}\r\nclass Settings {\r\n    constructor(section, resource) {\r\n        this.settings = vscode.workspace.getConfiguration(section, resource ? resource : null);\r\n    }\r\n    get Section() { return this.settings; }\r\n}\r\nclass CppSettings extends Settings {\r\n    constructor(resource) {\r\n        super(\"C_Cpp\", resource);\r\n    }\r\n    get clangFormatPath() { return super.Section.get(\"clang_format_path\"); }\r\n    get clangFormatStyle() { return super.Section.get(\"clang_format_style\"); }\r\n    get clangFormatFallbackStyle() { return super.Section.get(\"clang_format_fallbackStyle\"); }\r\n    get clangFormatSortIncludes() { return super.Section.get(\"clang_format_sortIncludes\"); }\r\n    get clangFormatOnSave() { return super.Section.get(\"clang_format_formatOnSave\"); }\r\n    get formatting() { return super.Section.get(\"formatting\"); }\r\n    get suggestSnippets() { return super.Section.get(\"suggestSnippets\"); }\r\n    get intelliSenseEngine() { return super.Section.get(\"intelliSenseEngine\"); }\r\n    get intelliSenseEngineFallback() { return super.Section.get(\"intelliSenseEngineFallback\"); }\r\n    get intelliSenseCachePath() { return super.Section.get(\"intelliSenseCachePath\"); }\r\n    get intelliSenseCacheSize() { return super.Section.get(\"intelliSenseCacheSize\"); }\r\n    get errorSquiggles() { return super.Section.get(\"errorSquiggles\"); }\r\n    get dimInactiveRegions() { return super.Section.get(\"dimInactiveRegions\"); }\r\n    get inactiveRegionOpacity() { return super.Section.get(\"inactiveRegionOpacity\"); }\r\n    get inactiveRegionForegroundColor() { return super.Section.get(\"inactiveRegionForegroundColor\"); }\r\n    get inactiveRegionBackgroundColor() { return super.Section.get(\"inactiveRegionBackgroundColor\"); }\r\n    get autoComplete() { return super.Section.get(\"autocomplete\"); }\r\n    get loggingLevel() { return super.Section.get(\"loggingLevel\"); }\r\n    get navigationLength() { return super.Section.get(\"navigation.length\", 60); }\r\n    get autoAddFileAssociations() { return super.Section.get(\"autoAddFileAssociations\"); }\r\n    get workspaceParsingPriority() { return super.Section.get(\"workspaceParsingPriority\"); }\r\n    get workspaceSymbols() { return super.Section.get(\"workspaceSymbols\"); }\r\n    get exclusionPolicy() { return super.Section.get(\"exclusionPolicy\"); }\r\n    get commentContinuationPatterns() { return super.Section.get(\"commentContinuationPatterns\"); }\r\n    get configurationWarnings() { return super.Section.get(\"configurationWarnings\"); }\r\n    get preferredPathSeparator() { return super.Section.get(\"preferredPathSeparator\"); }\r\n    get updateChannel() { return super.Section.get(\"updateChannel\"); }\r\n    get defaultIncludePath() { return super.Section.get(\"default.includePath\"); }\r\n    get defaultDefines() { return super.Section.get(\"default.defines\"); }\r\n    get defaultMacFrameworkPath() { return super.Section.get(\"default.macFrameworkPath\"); }\r\n    get defaultWindowsSdkVersion() { return super.Section.get(\"default.windowsSdkVersion\"); }\r\n    get defaultCompileCommands() { return super.Section.get(\"default.compileCommands\"); }\r\n    get defaultForcedInclude() { return super.Section.get(\"default.forcedInclude\"); }\r\n    get defaultIntelliSenseMode() { return super.Section.get(\"default.intelliSenseMode\"); }\r\n    get defaultCompilerPath() { return super.Section.get(\"default.compilerPath\"); }\r\n    get defaultCStandard() { return super.Section.get(\"default.cStandard\"); }\r\n    get defaultCppStandard() { return super.Section.get(\"default.cppStandard\"); }\r\n    get defaultConfigurationProvider() { return super.Section.get(\"default.configurationProvider\"); }\r\n    get defaultBrowsePath() { return super.Section.get(\"default.browse.path\"); }\r\n    get defaultDatabaseFilename() { return super.Section.get(\"default.browse.databaseFilename\"); }\r\n    get defaultLimitSymbolsToIncludedHeaders() { return super.Section.get(\"default.browse.limitSymbolsToIncludedHeaders\"); }\r\n    get defaultSystemIncludePath() { return super.Section.get(\"default.systemIncludePath\"); }\r\n    toggleSetting(name, value1, value2) {\r\n        let value = super.Section.get(name);\r\n        super.Section.update(name, value === value1 ? value2 : value1, getTarget());\r\n    }\r\n    update(name, value) {\r\n        super.Section.update(name, value);\r\n    }\r\n}\r\nexports.CppSettings = CppSettings;\r\nclass OtherSettings {\r\n    constructor(resource) {\r\n        if (!resource) {\r\n            resource = null;\r\n        }\r\n        this.resource = resource;\r\n    }\r\n    get editorTabSize() { return vscode.workspace.getConfiguration(\"editor\", this.resource).get(\"tabSize\"); }\r\n    get filesAssociations() { return vscode.workspace.getConfiguration(\"files\", null).get(\"associations\"); }\r\n    get filesExclude() { return vscode.workspace.getConfiguration(\"files\", this.resource).get(\"exclude\"); }\r\n    get searchExclude() { return vscode.workspace.getConfiguration(\"search\", this.resource).get(\"exclude\"); }\r\n    set filesAssociations(value) {\r\n        vscode.workspace.getConfiguration(\"files\", null).update(\"associations\", value, vscode.ConfigurationTarget.Workspace);\r\n    }\r\n}\r\nexports.OtherSettings = OtherSettings;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvc2V0dGluZ3MudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL3NldHRpbmdzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5mdW5jdGlvbiBnZXRUYXJnZXQoKSB7XHJcbiAgICByZXR1cm4gKHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycykgPyB2c2NvZGUuQ29uZmlndXJhdGlvblRhcmdldC5Xb3Jrc3BhY2VGb2xkZXIgOiB2c2NvZGUuQ29uZmlndXJhdGlvblRhcmdldC5HbG9iYWw7XHJcbn1cclxuY2xhc3MgU2V0dGluZ3Mge1xyXG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbiwgcmVzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKHNlY3Rpb24sIHJlc291cmNlID8gcmVzb3VyY2UgOiBudWxsKTtcclxuICAgIH1cclxuICAgIGdldCBTZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZXR0aW5nczsgfVxyXG59XHJcbmNsYXNzIENwcFNldHRpbmdzIGV4dGVuZHMgU2V0dGluZ3Mge1xyXG4gICAgY29uc3RydWN0b3IocmVzb3VyY2UpIHtcclxuICAgICAgICBzdXBlcihcIkNfQ3BwXCIsIHJlc291cmNlKTtcclxuICAgIH1cclxuICAgIGdldCBjbGFuZ0Zvcm1hdFBhdGgoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImNsYW5nX2Zvcm1hdF9wYXRoXCIpOyB9XHJcbiAgICBnZXQgY2xhbmdGb3JtYXRTdHlsZSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiY2xhbmdfZm9ybWF0X3N0eWxlXCIpOyB9XHJcbiAgICBnZXQgY2xhbmdGb3JtYXRGYWxsYmFja1N0eWxlKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJjbGFuZ19mb3JtYXRfZmFsbGJhY2tTdHlsZVwiKTsgfVxyXG4gICAgZ2V0IGNsYW5nRm9ybWF0U29ydEluY2x1ZGVzKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJjbGFuZ19mb3JtYXRfc29ydEluY2x1ZGVzXCIpOyB9XHJcbiAgICBnZXQgY2xhbmdGb3JtYXRPblNhdmUoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImNsYW5nX2Zvcm1hdF9mb3JtYXRPblNhdmVcIik7IH1cclxuICAgIGdldCBmb3JtYXR0aW5nKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJmb3JtYXR0aW5nXCIpOyB9XHJcbiAgICBnZXQgc3VnZ2VzdFNuaXBwZXRzKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJzdWdnZXN0U25pcHBldHNcIik7IH1cclxuICAgIGdldCBpbnRlbGxpU2Vuc2VFbmdpbmUoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImludGVsbGlTZW5zZUVuZ2luZVwiKTsgfVxyXG4gICAgZ2V0IGludGVsbGlTZW5zZUVuZ2luZUZhbGxiYWNrKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJpbnRlbGxpU2Vuc2VFbmdpbmVGYWxsYmFja1wiKTsgfVxyXG4gICAgZ2V0IGludGVsbGlTZW5zZUNhY2hlUGF0aCgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiaW50ZWxsaVNlbnNlQ2FjaGVQYXRoXCIpOyB9XHJcbiAgICBnZXQgaW50ZWxsaVNlbnNlQ2FjaGVTaXplKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJpbnRlbGxpU2Vuc2VDYWNoZVNpemVcIik7IH1cclxuICAgIGdldCBlcnJvclNxdWlnZ2xlcygpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZXJyb3JTcXVpZ2dsZXNcIik7IH1cclxuICAgIGdldCBkaW1JbmFjdGl2ZVJlZ2lvbnMoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRpbUluYWN0aXZlUmVnaW9uc1wiKTsgfVxyXG4gICAgZ2V0IGluYWN0aXZlUmVnaW9uT3BhY2l0eSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiaW5hY3RpdmVSZWdpb25PcGFjaXR5XCIpOyB9XHJcbiAgICBnZXQgaW5hY3RpdmVSZWdpb25Gb3JlZ3JvdW5kQ29sb3IoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImluYWN0aXZlUmVnaW9uRm9yZWdyb3VuZENvbG9yXCIpOyB9XHJcbiAgICBnZXQgaW5hY3RpdmVSZWdpb25CYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImluYWN0aXZlUmVnaW9uQmFja2dyb3VuZENvbG9yXCIpOyB9XHJcbiAgICBnZXQgYXV0b0NvbXBsZXRlKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJhdXRvY29tcGxldGVcIik7IH1cclxuICAgIGdldCBsb2dnaW5nTGV2ZWwoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImxvZ2dpbmdMZXZlbFwiKTsgfVxyXG4gICAgZ2V0IG5hdmlnYXRpb25MZW5ndGgoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcIm5hdmlnYXRpb24ubGVuZ3RoXCIsIDYwKTsgfVxyXG4gICAgZ2V0IGF1dG9BZGRGaWxlQXNzb2NpYXRpb25zKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJhdXRvQWRkRmlsZUFzc29jaWF0aW9uc1wiKTsgfVxyXG4gICAgZ2V0IHdvcmtzcGFjZVBhcnNpbmdQcmlvcml0eSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwid29ya3NwYWNlUGFyc2luZ1ByaW9yaXR5XCIpOyB9XHJcbiAgICBnZXQgd29ya3NwYWNlU3ltYm9scygpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwid29ya3NwYWNlU3ltYm9sc1wiKTsgfVxyXG4gICAgZ2V0IGV4Y2x1c2lvblBvbGljeSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZXhjbHVzaW9uUG9saWN5XCIpOyB9XHJcbiAgICBnZXQgY29tbWVudENvbnRpbnVhdGlvblBhdHRlcm5zKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJjb21tZW50Q29udGludWF0aW9uUGF0dGVybnNcIik7IH1cclxuICAgIGdldCBjb25maWd1cmF0aW9uV2FybmluZ3MoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImNvbmZpZ3VyYXRpb25XYXJuaW5nc1wiKTsgfVxyXG4gICAgZ2V0IHByZWZlcnJlZFBhdGhTZXBhcmF0b3IoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcInByZWZlcnJlZFBhdGhTZXBhcmF0b3JcIik7IH1cclxuICAgIGdldCB1cGRhdGVDaGFubmVsKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJ1cGRhdGVDaGFubmVsXCIpOyB9XHJcbiAgICBnZXQgZGVmYXVsdEluY2x1ZGVQYXRoKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJkZWZhdWx0LmluY2x1ZGVQYXRoXCIpOyB9XHJcbiAgICBnZXQgZGVmYXVsdERlZmluZXMoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRlZmF1bHQuZGVmaW5lc1wiKTsgfVxyXG4gICAgZ2V0IGRlZmF1bHRNYWNGcmFtZXdvcmtQYXRoKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJkZWZhdWx0Lm1hY0ZyYW1ld29ya1BhdGhcIik7IH1cclxuICAgIGdldCBkZWZhdWx0V2luZG93c1Nka1ZlcnNpb24oKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRlZmF1bHQud2luZG93c1Nka1ZlcnNpb25cIik7IH1cclxuICAgIGdldCBkZWZhdWx0Q29tcGlsZUNvbW1hbmRzKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJkZWZhdWx0LmNvbXBpbGVDb21tYW5kc1wiKTsgfVxyXG4gICAgZ2V0IGRlZmF1bHRGb3JjZWRJbmNsdWRlKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJkZWZhdWx0LmZvcmNlZEluY2x1ZGVcIik7IH1cclxuICAgIGdldCBkZWZhdWx0SW50ZWxsaVNlbnNlTW9kZSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZGVmYXVsdC5pbnRlbGxpU2Vuc2VNb2RlXCIpOyB9XHJcbiAgICBnZXQgZGVmYXVsdENvbXBpbGVyUGF0aCgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZGVmYXVsdC5jb21waWxlclBhdGhcIik7IH1cclxuICAgIGdldCBkZWZhdWx0Q1N0YW5kYXJkKCkgeyByZXR1cm4gc3VwZXIuU2VjdGlvbi5nZXQoXCJkZWZhdWx0LmNTdGFuZGFyZFwiKTsgfVxyXG4gICAgZ2V0IGRlZmF1bHRDcHBTdGFuZGFyZCgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZGVmYXVsdC5jcHBTdGFuZGFyZFwiKTsgfVxyXG4gICAgZ2V0IGRlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRlZmF1bHQuY29uZmlndXJhdGlvblByb3ZpZGVyXCIpOyB9XHJcbiAgICBnZXQgZGVmYXVsdEJyb3dzZVBhdGgoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRlZmF1bHQuYnJvd3NlLnBhdGhcIik7IH1cclxuICAgIGdldCBkZWZhdWx0RGF0YWJhc2VGaWxlbmFtZSgpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZGVmYXVsdC5icm93c2UuZGF0YWJhc2VGaWxlbmFtZVwiKTsgfVxyXG4gICAgZ2V0IGRlZmF1bHRMaW1pdFN5bWJvbHNUb0luY2x1ZGVkSGVhZGVycygpIHsgcmV0dXJuIHN1cGVyLlNlY3Rpb24uZ2V0KFwiZGVmYXVsdC5icm93c2UubGltaXRTeW1ib2xzVG9JbmNsdWRlZEhlYWRlcnNcIik7IH1cclxuICAgIGdldCBkZWZhdWx0U3lzdGVtSW5jbHVkZVBhdGgoKSB7IHJldHVybiBzdXBlci5TZWN0aW9uLmdldChcImRlZmF1bHQuc3lzdGVtSW5jbHVkZVBhdGhcIik7IH1cclxuICAgIHRvZ2dsZVNldHRpbmcobmFtZSwgdmFsdWUxLCB2YWx1ZTIpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBzdXBlci5TZWN0aW9uLmdldChuYW1lKTtcclxuICAgICAgICBzdXBlci5TZWN0aW9uLnVwZGF0ZShuYW1lLCB2YWx1ZSA9PT0gdmFsdWUxID8gdmFsdWUyIDogdmFsdWUxLCBnZXRUYXJnZXQoKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlci5TZWN0aW9uLnVwZGF0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DcHBTZXR0aW5ncyA9IENwcFNldHRpbmdzO1xyXG5jbGFzcyBPdGhlclNldHRpbmdzIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlKSB7XHJcbiAgICAgICAgaWYgKCFyZXNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcclxuICAgIH1cclxuICAgIGdldCBlZGl0b3JUYWJTaXplKCkgeyByZXR1cm4gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKFwiZWRpdG9yXCIsIHRoaXMucmVzb3VyY2UpLmdldChcInRhYlNpemVcIik7IH1cclxuICAgIGdldCBmaWxlc0Fzc29jaWF0aW9ucygpIHsgcmV0dXJuIHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihcImZpbGVzXCIsIG51bGwpLmdldChcImFzc29jaWF0aW9uc1wiKTsgfVxyXG4gICAgZ2V0IGZpbGVzRXhjbHVkZSgpIHsgcmV0dXJuIHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihcImZpbGVzXCIsIHRoaXMucmVzb3VyY2UpLmdldChcImV4Y2x1ZGVcIik7IH1cclxuICAgIGdldCBzZWFyY2hFeGNsdWRlKCkgeyByZXR1cm4gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKFwic2VhcmNoXCIsIHRoaXMucmVzb3VyY2UpLmdldChcImV4Y2x1ZGVcIik7IH1cclxuICAgIHNldCBmaWxlc0Fzc29jaWF0aW9ucyh2YWx1ZSkge1xyXG4gICAgICAgIHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihcImZpbGVzXCIsIG51bGwpLnVwZGF0ZShcImFzc29jaWF0aW9uc1wiLCB2YWx1ZSwgdnNjb2RlLkNvbmZpZ3VyYXRpb25UYXJnZXQuV29ya3NwYWNlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk90aGVyU2V0dGluZ3MgPSBPdGhlclNldHRpbmdzO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LanguageServer/settings.ts\n");

/***/ }),

/***/ "./src/LanguageServer/settingsTracker.ts":
/*!***********************************************!*\
  !*** ./src/LanguageServer/settingsTracker.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst util = __webpack_require__(/*! ../common */ \"./src/common.ts\");\r\nconst maxSettingLengthForTelemetry = 50;\r\nlet cache = undefined;\r\nclass SettingsTracker {\r\n    constructor(resource) {\r\n        this.previousCppSettings = {};\r\n        this.resource = resource;\r\n        this.collectSettings(() => true);\r\n    }\r\n    getUserModifiedSettings() {\r\n        let filter = (key, val, settings) => {\r\n            return !this.areEqual(val, settings.inspect(key).defaultValue);\r\n        };\r\n        return this.collectSettings(filter);\r\n    }\r\n    getChangedSettings() {\r\n        let filter = (key, val) => {\r\n            return !(key in this.previousCppSettings) || !this.areEqual(val, this.previousCppSettings[key]);\r\n        };\r\n        return this.collectSettings(filter);\r\n    }\r\n    collectSettings(filter) {\r\n        let settings = vscode.workspace.getConfiguration(\"C_Cpp\", this.resource);\r\n        let result = {};\r\n        for (let key in settings) {\r\n            let val = this.getSetting(settings, key);\r\n            if (val === undefined) {\r\n                continue;\r\n            }\r\n            if (val instanceof Object && !(val instanceof Array)) {\r\n                for (let subKey in val) {\r\n                    let newKey = key + \".\" + subKey;\r\n                    let subVal = this.getSetting(settings, newKey);\r\n                    if (subVal === undefined) {\r\n                        continue;\r\n                    }\r\n                    let entry = this.filterAndSanitize(newKey, subVal, settings, filter);\r\n                    if (entry && entry.key && entry.value) {\r\n                        result[entry.key] = entry.value;\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            let entry = this.filterAndSanitize(key, val, settings, filter);\r\n            if (entry && entry.key && entry.value) {\r\n                result[entry.key] = entry.value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getSetting(settings, key) {\r\n        if (settings.inspect(key).defaultValue !== undefined) {\r\n            let val = settings.get(key);\r\n            if (val instanceof Object) {\r\n                return val;\r\n            }\r\n            let curSetting = util.packageJson.contributes.configuration.properties[\"C_Cpp.\" + key];\r\n            if (curSetting) {\r\n                let type = this.typeMatch(val, curSetting[\"type\"]);\r\n                if (type) {\r\n                    if (type !== \"string\") {\r\n                        return val;\r\n                    }\r\n                    let curEnum = curSetting[\"enum\"];\r\n                    if (curEnum && curEnum.indexOf(val) === -1) {\r\n                        return \"<invalid>\";\r\n                    }\r\n                    return val;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    typeMatch(value, type) {\r\n        if (type) {\r\n            if (type instanceof Array) {\r\n                for (let i = 0; i < type.length; i++) {\r\n                    let t = type[i];\r\n                    if (t) {\r\n                        if (typeof value === t) {\r\n                            return t;\r\n                        }\r\n                        if (t === \"array\" && value instanceof Array) {\r\n                            return t;\r\n                        }\r\n                        if (t === \"null\" && value === null) {\r\n                            return t;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (typeof type === \"string\" && typeof value === type) {\r\n                return type;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    filterAndSanitize(key, val, settings, filter) {\r\n        if (filter(key, val, settings)) {\r\n            let value;\r\n            this.previousCppSettings[key] = val;\r\n            switch (key) {\r\n                case \"clang_format_style\":\r\n                case \"clang_format_fallbackStyle\": {\r\n                    let newKey = key + \"2\";\r\n                    if (val) {\r\n                        switch (String(val).toLowerCase()) {\r\n                            case \"visual studio\":\r\n                            case \"llvm\":\r\n                            case \"google\":\r\n                            case \"chromium\":\r\n                            case \"mozilla\":\r\n                            case \"webkit\":\r\n                            case \"file\":\r\n                            case \"none\": {\r\n                                value = String(this.previousCppSettings[key]);\r\n                                break;\r\n                            }\r\n                            default: {\r\n                                value = \"...\";\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        value = \"null\";\r\n                    }\r\n                    key = newKey;\r\n                    break;\r\n                }\r\n                case \"commentContinuationPatterns\": {\r\n                    value = this.areEqual(val, settings.inspect(key).defaultValue) ? \"<default>\" : \"...\";\r\n                    break;\r\n                }\r\n                default: {\r\n                    if (key === \"clang_format_path\" || key === \"intelliSenseCachePath\" || key.startsWith(\"default.\")) {\r\n                        value = this.areEqual(val, settings.inspect(key).defaultValue) ? \"<default>\" : \"...\";\r\n                    }\r\n                    else {\r\n                        value = String(this.previousCppSettings[key]);\r\n                    }\r\n                }\r\n            }\r\n            if (value && value.length > maxSettingLengthForTelemetry) {\r\n                value = value.substr(0, maxSettingLengthForTelemetry) + \"...\";\r\n            }\r\n            return { key: key, value: value };\r\n        }\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (value1 instanceof Object && value2 instanceof Object) {\r\n            return JSON.stringify(value1) === JSON.stringify(value2);\r\n        }\r\n        return value1 === value2;\r\n    }\r\n}\r\nexports.SettingsTracker = SettingsTracker;\r\nfunction getTracker(resource) {\r\n    if (!cache) {\r\n        cache = new SettingsTracker(resource);\r\n    }\r\n    return cache;\r\n}\r\nexports.getTracker = getTracker;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvc2V0dGluZ3NUcmFja2VyLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9MYW5ndWFnZVNlcnZlci9zZXR0aW5nc1RyYWNrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xyXG5jb25zdCBtYXhTZXR0aW5nTGVuZ3RoRm9yVGVsZW1ldHJ5ID0gNTA7XHJcbmxldCBjYWNoZSA9IHVuZGVmaW5lZDtcclxuY2xhc3MgU2V0dGluZ3NUcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0NwcFNldHRpbmdzID0ge307XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xyXG4gICAgICAgIHRoaXMuY29sbGVjdFNldHRpbmdzKCgpID0+IHRydWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0VXNlck1vZGlmaWVkU2V0dGluZ3MoKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlciA9IChrZXksIHZhbCwgc2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmFyZUVxdWFsKHZhbCwgc2V0dGluZ3MuaW5zcGVjdChrZXkpLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0U2V0dGluZ3MoZmlsdGVyKTtcclxuICAgIH1cclxuICAgIGdldENoYW5nZWRTZXR0aW5ncygpIHtcclxuICAgICAgICBsZXQgZmlsdGVyID0gKGtleSwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKGtleSBpbiB0aGlzLnByZXZpb3VzQ3BwU2V0dGluZ3MpIHx8ICF0aGlzLmFyZUVxdWFsKHZhbCwgdGhpcy5wcmV2aW91c0NwcFNldHRpbmdzW2tleV0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdFNldHRpbmdzKGZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBjb2xsZWN0U2V0dGluZ3MoZmlsdGVyKSB7XHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKFwiQ19DcHBcIiwgdGhpcy5yZXNvdXJjZSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy5nZXRTZXR0aW5nKHNldHRpbmdzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YktleSBpbiB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3S2V5ID0ga2V5ICsgXCIuXCIgKyBzdWJLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlZhbCA9IHRoaXMuZ2V0U2V0dGluZyhzZXR0aW5ncywgbmV3S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuZmlsdGVyQW5kU2FuaXRpemUobmV3S2V5LCBzdWJWYWwsIHNldHRpbmdzLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5rZXkgJiYgZW50cnkudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2VudHJ5LmtleV0gPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLmZpbHRlckFuZFNhbml0aXplKGtleSwgdmFsLCBzZXR0aW5ncywgZmlsdGVyKTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LmtleSAmJiBlbnRyeS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2VudHJ5LmtleV0gPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0U2V0dGluZyhzZXR0aW5ncywga2V5KSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmluc3BlY3Qoa2V5KS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gc2V0dGluZ3MuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGN1clNldHRpbmcgPSB1dGlsLnBhY2thZ2VKc29uLmNvbnRyaWJ1dGVzLmNvbmZpZ3VyYXRpb24ucHJvcGVydGllc1tcIkNfQ3BwLlwiICsga2V5XTtcclxuICAgICAgICAgICAgaWYgKGN1clNldHRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy50eXBlTWF0Y2godmFsLCBjdXJTZXR0aW5nW1widHlwZVwiXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJFbnVtID0gY3VyU2V0dGluZ1tcImVudW1cIl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckVudW0gJiYgY3VyRW51bS5pbmRleE9mKHZhbCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxpbnZhbGlkPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB0eXBlTWF0Y2godmFsdWUsIHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHR5cGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT09IFwiYXJyYXlcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PT0gXCJudWxsXCIgJiYgdmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZpbHRlckFuZFNhbml0aXplKGtleSwgdmFsLCBzZXR0aW5ncywgZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlcihrZXksIHZhbCwgc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NwcFNldHRpbmdzW2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xhbmdfZm9ybWF0X3N0eWxlXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xhbmdfZm9ybWF0X2ZhbGxiYWNrU3R5bGVcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdLZXkgPSBrZXkgKyBcIjJcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInZpc3VhbCBzdHVkaW9cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsbHZtXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ29vZ2xlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2hyb21pdW1cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3ppbGxhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2Via2l0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHRoaXMucHJldmlvdXNDcHBTZXR0aW5nc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiLi4uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJudWxsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5ld0tleTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50Q29udGludWF0aW9uUGF0dGVybnNcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hcmVFcXVhbCh2YWwsIHNldHRpbmdzLmluc3BlY3Qoa2V5KS5kZWZhdWx0VmFsdWUpID8gXCI8ZGVmYXVsdD5cIiA6IFwiLi4uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJjbGFuZ19mb3JtYXRfcGF0aFwiIHx8IGtleSA9PT0gXCJpbnRlbGxpU2Vuc2VDYWNoZVBhdGhcIiB8fCBrZXkuc3RhcnRzV2l0aChcImRlZmF1bHQuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5hcmVFcXVhbCh2YWwsIHNldHRpbmdzLmluc3BlY3Qoa2V5KS5kZWZhdWx0VmFsdWUpID8gXCI8ZGVmYXVsdD5cIiA6IFwiLi4uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh0aGlzLnByZXZpb3VzQ3BwU2V0dGluZ3Nba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiBtYXhTZXR0aW5nTGVuZ3RoRm9yVGVsZW1ldHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBtYXhTZXR0aW5nTGVuZ3RoRm9yVGVsZW1ldHJ5KSArIFwiLi4uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFyZUVxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlMSBpbnN0YW5jZW9mIE9iamVjdCAmJiB2YWx1ZTIgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlMSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNldHRpbmdzVHJhY2tlciA9IFNldHRpbmdzVHJhY2tlcjtcclxuZnVuY3Rpb24gZ2V0VHJhY2tlcihyZXNvdXJjZSkge1xyXG4gICAgaWYgKCFjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlID0gbmV3IFNldHRpbmdzVHJhY2tlcihyZXNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbn1cclxuZXhwb3J0cy5nZXRUcmFja2VyID0gZ2V0VHJhY2tlcjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LanguageServer/settingsTracker.ts\n");

/***/ }),

/***/ "./src/LanguageServer/ui.ts":
/*!**********************************!*\
  !*** ./src/LanguageServer/ui.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst customProviders_1 = __webpack_require__(/*! ./customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nlet ui;\r\nvar ConfigurationPriority;\r\n(function (ConfigurationPriority) {\r\n    ConfigurationPriority[ConfigurationPriority[\"IncludePath\"] = 1] = \"IncludePath\";\r\n    ConfigurationPriority[ConfigurationPriority[\"CompileCommands\"] = 2] = \"CompileCommands\";\r\n    ConfigurationPriority[ConfigurationPriority[\"CustomProvider\"] = 3] = \"CustomProvider\";\r\n})(ConfigurationPriority || (ConfigurationPriority = {}));\r\nclass UI {\r\n    constructor() {\r\n        this.navigationStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 1000);\r\n        this.navigationStatusBarItem.tooltip = \"C/C++ Navigation\";\r\n        this.navigationStatusBarItem.command = \"C_Cpp.Navigate\";\r\n        this.ShowNavigation = true;\r\n        this.configStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 2);\r\n        this.configStatusBarItem.command = \"C_Cpp.ConfigurationSelect\";\r\n        this.configStatusBarItem.tooltip = \"C/C++ Configuration\";\r\n        this.ShowConfiguration = true;\r\n        this.intelliSenseStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 1);\r\n        this.intelliSenseStatusBarItem.text = \"\";\r\n        this.intelliSenseStatusBarItem.tooltip = \"Updating IntelliSense...\";\r\n        this.intelliSenseStatusBarItem.color = \"Red\";\r\n        this.ShowFlameIcon = true;\r\n        this.browseEngineStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 0);\r\n        this.browseEngineStatusBarItem.text = \"\";\r\n        this.browseEngineStatusBarItem.tooltip = \"Discovering files...\";\r\n        this.browseEngineStatusBarItem.color = new vscode.ThemeColor(\"statusBar.foreground\");\r\n        this.browseEngineStatusBarItem.command = \"C_Cpp.ShowParsingCommands\";\r\n        this.ShowDBIcon = true;\r\n    }\r\n    set NavigationLocation(location) {\r\n        this.navigationStatusBarItem.text = location;\r\n    }\r\n    set ActiveConfig(label) {\r\n        this.configStatusBarItem.text = label;\r\n    }\r\n    set TagParseStatus(label) {\r\n        this.browseEngineStatusBarItem.tooltip = label;\r\n    }\r\n    get IsTagParsing() {\r\n        return this.browseEngineStatusBarItem.text !== \"\";\r\n    }\r\n    set IsTagParsing(val) {\r\n        this.browseEngineStatusBarItem.text = val ? \"$(database)\" : \"\";\r\n        this.ShowDBIcon = val;\r\n    }\r\n    get IsUpdatingIntelliSense() {\r\n        return this.intelliSenseStatusBarItem.text !== \"\";\r\n    }\r\n    set IsUpdatingIntelliSense(val) {\r\n        this.intelliSenseStatusBarItem.text = val ? \"$(flame)\" : \"\";\r\n        this.ShowFlameIcon = val;\r\n    }\r\n    set ShowNavigation(show) {\r\n        if (show) {\r\n            this.navigationStatusBarItem.show();\r\n        }\r\n        else {\r\n            this.navigationStatusBarItem.hide();\r\n        }\r\n    }\r\n    set ShowDBIcon(show) {\r\n        if (show && this.IsTagParsing) {\r\n            this.browseEngineStatusBarItem.show();\r\n        }\r\n        else {\r\n            this.browseEngineStatusBarItem.hide();\r\n        }\r\n    }\r\n    set ShowFlameIcon(show) {\r\n        if (show && this.IsUpdatingIntelliSense) {\r\n            this.intelliSenseStatusBarItem.show();\r\n        }\r\n        else {\r\n            this.intelliSenseStatusBarItem.hide();\r\n        }\r\n    }\r\n    set ShowConfiguration(show) {\r\n        if (show) {\r\n            this.configStatusBarItem.show();\r\n        }\r\n        else {\r\n            this.configStatusBarItem.hide();\r\n        }\r\n    }\r\n    activeDocumentChanged() {\r\n        let activeEditor = vscode.window.activeTextEditor;\r\n        let isCpp = (activeEditor && (activeEditor.document.languageId === \"cpp\" || activeEditor.document.languageId === \"c\"));\r\n        let isSettingsJson = (activeEditor && (activeEditor.document.fileName.endsWith(\"c_cpp_properties.json\") || activeEditor.document.fileName.endsWith(\"settings.json\")));\r\n        this.ShowConfiguration = isCpp || isSettingsJson;\r\n        this.ShowDBIcon = isCpp || isSettingsJson;\r\n        this.ShowFlameIcon = isCpp || isSettingsJson;\r\n        this.ShowNavigation = isCpp;\r\n    }\r\n    bind(client) {\r\n        client.TagParsingChanged(value => { this.IsTagParsing = value; });\r\n        client.IntelliSenseParsingChanged(value => { this.IsUpdatingIntelliSense = value; });\r\n        client.NavigationLocationChanged(value => { this.NavigationLocation = value; });\r\n        client.TagParserStatusChanged(value => { this.TagParseStatus = value; });\r\n        client.ActiveConfigChanged(value => { this.ActiveConfig = value; });\r\n    }\r\n    showNavigationOptions(navigationList) {\r\n        let options = {};\r\n        options.placeHolder = \"Select where to navigate to\";\r\n        let items = [];\r\n        let navlist = navigationList.split(\";\");\r\n        for (let i = 0; i < navlist.length - 1; i += 2) {\r\n            items.push({ label: navlist[i], description: \"\", index: Number(navlist[i + 1]) });\r\n        }\r\n        vscode.window.showQuickPick(items, options)\r\n            .then(selection => {\r\n            if (!selection) {\r\n                return;\r\n            }\r\n            vscode.window.activeTextEditor.revealRange(new vscode.Range(selection.index, 0, selection.index, 0), vscode.TextEditorRevealType.InCenter);\r\n            vscode.window.activeTextEditor.selection = new vscode.Selection(new vscode.Position(selection.index, 0), new vscode.Position(selection.index, 0));\r\n        });\r\n    }\r\n    showConfigurations(configurationNames) {\r\n        let options = {};\r\n        options.placeHolder = \"Select a Configuration...\";\r\n        let items = [];\r\n        for (let i = 0; i < configurationNames.length; i++) {\r\n            items.push({ label: configurationNames[i], description: \"\", index: i });\r\n        }\r\n        items.push({ label: \"Edit Configurations...\", description: \"\", index: configurationNames.length });\r\n        return vscode.window.showQuickPick(items, options)\r\n            .then(selection => (selection) ? selection.index : -1);\r\n    }\r\n    showConfigurationProviders(currentProvider) {\r\n        let options = {};\r\n        options.placeHolder = \"Select a Configuration Provider...\";\r\n        let providers = customProviders_1.getCustomConfigProviders();\r\n        let items = [];\r\n        providers.forEach(provider => {\r\n            let label = provider.name;\r\n            if (provider.extensionId === currentProvider) {\r\n                label += \" (active)\";\r\n            }\r\n            items.push({ label: label, description: \"\", key: provider.extensionId });\r\n        });\r\n        items.push({ label: \"(none)\", description: \"Disable the active configuration provider, if applicable.\", key: \"\" });\r\n        return vscode.window.showQuickPick(items, options)\r\n            .then(selection => (selection) ? selection.key : undefined);\r\n    }\r\n    showCompileCommands(paths) {\r\n        let options = {};\r\n        options.placeHolder = \"Select a compile_commands.json...\";\r\n        let items = [];\r\n        for (let i = 0; i < paths.length; i++) {\r\n            items.push({ label: paths[i], description: \"\", index: i });\r\n        }\r\n        return vscode.window.showQuickPick(items, options)\r\n            .then(selection => (selection) ? selection.index : -1);\r\n    }\r\n    showWorkspaces(workspaceNames) {\r\n        let options = {};\r\n        options.placeHolder = \"Select a Workspace...\";\r\n        let items = [];\r\n        workspaceNames.forEach(name => items.push({ label: name.name, description: \"\", key: name.key }));\r\n        return vscode.window.showQuickPick(items, options)\r\n            .then(selection => (selection) ? selection.key : \"\");\r\n    }\r\n    showParsingCommands() {\r\n        let options = {};\r\n        options.placeHolder = \"Select a parsing command...\";\r\n        let items;\r\n        items = [];\r\n        if (this.browseEngineStatusBarItem.tooltip === \"Parsing paused\") {\r\n            items.push({ label: \"Resume Parsing\", description: \"\", index: 1 });\r\n        }\r\n        else {\r\n            items.push({ label: \"Pause Parsing\", description: \"\", index: 0 });\r\n        }\r\n        return vscode.window.showQuickPick(items, options)\r\n            .then(selection => (selection) ? selection.index : -1);\r\n    }\r\n    showConfigureIncludePathMessage(prompt, onSkip) {\r\n        setTimeout(() => {\r\n            this.showConfigurationPrompt(ConfigurationPriority.IncludePath, prompt, onSkip);\r\n        }, 10000);\r\n    }\r\n    showConfigureCompileCommandsMessage(prompt, onSkip) {\r\n        setTimeout(() => {\r\n            this.showConfigurationPrompt(ConfigurationPriority.CompileCommands, prompt, onSkip);\r\n        }, 5000);\r\n    }\r\n    showConfigureCustomProviderMessage(prompt, onSkip) {\r\n        this.showConfigurationPrompt(ConfigurationPriority.CustomProvider, prompt, onSkip);\r\n    }\r\n    showConfigurationPrompt(priority, prompt, onSkip) {\r\n        let showPrompt = () => __awaiter(this, void 0, void 0, function* () {\r\n            let configured = yield prompt();\r\n            return Promise.resolve({\r\n                priority: priority,\r\n                configured: configured\r\n            });\r\n        });\r\n        if (this.configurationUIPromise) {\r\n            this.configurationUIPromise = this.configurationUIPromise.then(result => {\r\n                if (priority > result.priority) {\r\n                    return showPrompt();\r\n                }\r\n                else if (!result.configured) {\r\n                    return showPrompt();\r\n                }\r\n                onSkip();\r\n                return Promise.resolve({\r\n                    priority: result.priority,\r\n                    configured: true\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this.configurationUIPromise = showPrompt();\r\n        }\r\n    }\r\n    dispose() {\r\n        this.configStatusBarItem.dispose();\r\n        this.browseEngineStatusBarItem.dispose();\r\n        this.intelliSenseStatusBarItem.dispose();\r\n        this.navigationStatusBarItem.dispose();\r\n    }\r\n}\r\nexports.UI = UI;\r\nfunction getUI() {\r\n    if (ui === undefined) {\r\n        ui = new UI();\r\n    }\r\n    return ui;\r\n}\r\nexports.getUI = getUI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGFuZ3VhZ2VTZXJ2ZXIvdWkudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL0xhbmd1YWdlU2VydmVyL3VpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBjdXN0b21Qcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuL2N1c3RvbVByb3ZpZGVyc1wiKTtcclxubGV0IHVpO1xyXG52YXIgQ29uZmlndXJhdGlvblByaW9yaXR5O1xyXG4oZnVuY3Rpb24gKENvbmZpZ3VyYXRpb25Qcmlvcml0eSkge1xyXG4gICAgQ29uZmlndXJhdGlvblByaW9yaXR5W0NvbmZpZ3VyYXRpb25Qcmlvcml0eVtcIkluY2x1ZGVQYXRoXCJdID0gMV0gPSBcIkluY2x1ZGVQYXRoXCI7XHJcbiAgICBDb25maWd1cmF0aW9uUHJpb3JpdHlbQ29uZmlndXJhdGlvblByaW9yaXR5W1wiQ29tcGlsZUNvbW1hbmRzXCJdID0gMl0gPSBcIkNvbXBpbGVDb21tYW5kc1wiO1xyXG4gICAgQ29uZmlndXJhdGlvblByaW9yaXR5W0NvbmZpZ3VyYXRpb25Qcmlvcml0eVtcIkN1c3RvbVByb3ZpZGVyXCJdID0gM10gPSBcIkN1c3RvbVByb3ZpZGVyXCI7XHJcbn0pKENvbmZpZ3VyYXRpb25Qcmlvcml0eSB8fCAoQ29uZmlndXJhdGlvblByaW9yaXR5ID0ge30pKTtcclxuY2xhc3MgVUkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3RhdHVzQmFySXRlbSA9IHZzY29kZS53aW5kb3cuY3JlYXRlU3RhdHVzQmFySXRlbSh2c2NvZGUuU3RhdHVzQmFyQWxpZ25tZW50LlJpZ2h0LCAxMDAwKTtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TdGF0dXNCYXJJdGVtLnRvb2x0aXAgPSBcIkMvQysrIE5hdmlnYXRpb25cIjtcclxuICAgICAgICB0aGlzLm5hdmlnYXRpb25TdGF0dXNCYXJJdGVtLmNvbW1hbmQgPSBcIkNfQ3BwLk5hdmlnYXRlXCI7XHJcbiAgICAgICAgdGhpcy5TaG93TmF2aWdhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25maWdTdGF0dXNCYXJJdGVtID0gdnNjb2RlLndpbmRvdy5jcmVhdGVTdGF0dXNCYXJJdGVtKHZzY29kZS5TdGF0dXNCYXJBbGlnbm1lbnQuUmlnaHQsIDIpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnU3RhdHVzQmFySXRlbS5jb21tYW5kID0gXCJDX0NwcC5Db25maWd1cmF0aW9uU2VsZWN0XCI7XHJcbiAgICAgICAgdGhpcy5jb25maWdTdGF0dXNCYXJJdGVtLnRvb2x0aXAgPSBcIkMvQysrIENvbmZpZ3VyYXRpb25cIjtcclxuICAgICAgICB0aGlzLlNob3dDb25maWd1cmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmludGVsbGlTZW5zZVN0YXR1c0Jhckl0ZW0gPSB2c2NvZGUud2luZG93LmNyZWF0ZVN0YXR1c0Jhckl0ZW0odnNjb2RlLlN0YXR1c0JhckFsaWdubWVudC5SaWdodCwgMSk7XHJcbiAgICAgICAgdGhpcy5pbnRlbGxpU2Vuc2VTdGF0dXNCYXJJdGVtLnRleHQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuaW50ZWxsaVNlbnNlU3RhdHVzQmFySXRlbS50b29sdGlwID0gXCJVcGRhdGluZyBJbnRlbGxpU2Vuc2UuLi5cIjtcclxuICAgICAgICB0aGlzLmludGVsbGlTZW5zZVN0YXR1c0Jhckl0ZW0uY29sb3IgPSBcIlJlZFwiO1xyXG4gICAgICAgIHRoaXMuU2hvd0ZsYW1lSWNvbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5icm93c2VFbmdpbmVTdGF0dXNCYXJJdGVtID0gdnNjb2RlLndpbmRvdy5jcmVhdGVTdGF0dXNCYXJJdGVtKHZzY29kZS5TdGF0dXNCYXJBbGlnbm1lbnQuUmlnaHQsIDApO1xyXG4gICAgICAgIHRoaXMuYnJvd3NlRW5naW5lU3RhdHVzQmFySXRlbS50ZXh0ID0gXCJcIjtcclxuICAgICAgICB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0udG9vbHRpcCA9IFwiRGlzY292ZXJpbmcgZmlsZXMuLi5cIjtcclxuICAgICAgICB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0uY29sb3IgPSBuZXcgdnNjb2RlLlRoZW1lQ29sb3IoXCJzdGF0dXNCYXIuZm9yZWdyb3VuZFwiKTtcclxuICAgICAgICB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0uY29tbWFuZCA9IFwiQ19DcHAuU2hvd1BhcnNpbmdDb21tYW5kc1wiO1xyXG4gICAgICAgIHRoaXMuU2hvd0RCSWNvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzZXQgTmF2aWdhdGlvbkxvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3RhdHVzQmFySXRlbS50ZXh0ID0gbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgQWN0aXZlQ29uZmlnKGxhYmVsKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWdTdGF0dXNCYXJJdGVtLnRleHQgPSBsYWJlbDtcclxuICAgIH1cclxuICAgIHNldCBUYWdQYXJzZVN0YXR1cyhsYWJlbCkge1xyXG4gICAgICAgIHRoaXMuYnJvd3NlRW5naW5lU3RhdHVzQmFySXRlbS50b29sdGlwID0gbGFiZWw7XHJcbiAgICB9XHJcbiAgICBnZXQgSXNUYWdQYXJzaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0udGV4dCAhPT0gXCJcIjtcclxuICAgIH1cclxuICAgIHNldCBJc1RhZ1BhcnNpbmcodmFsKSB7XHJcbiAgICAgICAgdGhpcy5icm93c2VFbmdpbmVTdGF0dXNCYXJJdGVtLnRleHQgPSB2YWwgPyBcIiQoZGF0YWJhc2UpXCIgOiBcIlwiO1xyXG4gICAgICAgIHRoaXMuU2hvd0RCSWNvbiA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBJc1VwZGF0aW5nSW50ZWxsaVNlbnNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVsbGlTZW5zZVN0YXR1c0Jhckl0ZW0udGV4dCAhPT0gXCJcIjtcclxuICAgIH1cclxuICAgIHNldCBJc1VwZGF0aW5nSW50ZWxsaVNlbnNlKHZhbCkge1xyXG4gICAgICAgIHRoaXMuaW50ZWxsaVNlbnNlU3RhdHVzQmFySXRlbS50ZXh0ID0gdmFsID8gXCIkKGZsYW1lKVwiIDogXCJcIjtcclxuICAgICAgICB0aGlzLlNob3dGbGFtZUljb24gPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzZXQgU2hvd05hdmlnYXRpb24oc2hvdykge1xyXG4gICAgICAgIGlmIChzaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblN0YXR1c0Jhckl0ZW0uc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3RhdHVzQmFySXRlbS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IFNob3dEQkljb24oc2hvdykge1xyXG4gICAgICAgIGlmIChzaG93ICYmIHRoaXMuSXNUYWdQYXJzaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlRW5naW5lU3RhdHVzQmFySXRlbS5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0uaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBTaG93RmxhbWVJY29uKHNob3cpIHtcclxuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLklzVXBkYXRpbmdJbnRlbGxpU2Vuc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlbGxpU2Vuc2VTdGF0dXNCYXJJdGVtLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZWxsaVNlbnNlU3RhdHVzQmFySXRlbS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IFNob3dDb25maWd1cmF0aW9uKHNob3cpIHtcclxuICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1N0YXR1c0Jhckl0ZW0uc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWdTdGF0dXNCYXJJdGVtLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhY3RpdmVEb2N1bWVudENoYW5nZWQoKSB7XHJcbiAgICAgICAgbGV0IGFjdGl2ZUVkaXRvciA9IHZzY29kZS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvcjtcclxuICAgICAgICBsZXQgaXNDcHAgPSAoYWN0aXZlRWRpdG9yICYmIChhY3RpdmVFZGl0b3IuZG9jdW1lbnQubGFuZ3VhZ2VJZCA9PT0gXCJjcHBcIiB8fCBhY3RpdmVFZGl0b3IuZG9jdW1lbnQubGFuZ3VhZ2VJZCA9PT0gXCJjXCIpKTtcclxuICAgICAgICBsZXQgaXNTZXR0aW5nc0pzb24gPSAoYWN0aXZlRWRpdG9yICYmIChhY3RpdmVFZGl0b3IuZG9jdW1lbnQuZmlsZU5hbWUuZW5kc1dpdGgoXCJjX2NwcF9wcm9wZXJ0aWVzLmpzb25cIikgfHwgYWN0aXZlRWRpdG9yLmRvY3VtZW50LmZpbGVOYW1lLmVuZHNXaXRoKFwic2V0dGluZ3MuanNvblwiKSkpO1xyXG4gICAgICAgIHRoaXMuU2hvd0NvbmZpZ3VyYXRpb24gPSBpc0NwcCB8fCBpc1NldHRpbmdzSnNvbjtcclxuICAgICAgICB0aGlzLlNob3dEQkljb24gPSBpc0NwcCB8fCBpc1NldHRpbmdzSnNvbjtcclxuICAgICAgICB0aGlzLlNob3dGbGFtZUljb24gPSBpc0NwcCB8fCBpc1NldHRpbmdzSnNvbjtcclxuICAgICAgICB0aGlzLlNob3dOYXZpZ2F0aW9uID0gaXNDcHA7XHJcbiAgICB9XHJcbiAgICBiaW5kKGNsaWVudCkge1xyXG4gICAgICAgIGNsaWVudC5UYWdQYXJzaW5nQ2hhbmdlZCh2YWx1ZSA9PiB7IHRoaXMuSXNUYWdQYXJzaW5nID0gdmFsdWU7IH0pO1xyXG4gICAgICAgIGNsaWVudC5JbnRlbGxpU2Vuc2VQYXJzaW5nQ2hhbmdlZCh2YWx1ZSA9PiB7IHRoaXMuSXNVcGRhdGluZ0ludGVsbGlTZW5zZSA9IHZhbHVlOyB9KTtcclxuICAgICAgICBjbGllbnQuTmF2aWdhdGlvbkxvY2F0aW9uQ2hhbmdlZCh2YWx1ZSA9PiB7IHRoaXMuTmF2aWdhdGlvbkxvY2F0aW9uID0gdmFsdWU7IH0pO1xyXG4gICAgICAgIGNsaWVudC5UYWdQYXJzZXJTdGF0dXNDaGFuZ2VkKHZhbHVlID0+IHsgdGhpcy5UYWdQYXJzZVN0YXR1cyA9IHZhbHVlOyB9KTtcclxuICAgICAgICBjbGllbnQuQWN0aXZlQ29uZmlnQ2hhbmdlZCh2YWx1ZSA9PiB7IHRoaXMuQWN0aXZlQ29uZmlnID0gdmFsdWU7IH0pO1xyXG4gICAgfVxyXG4gICAgc2hvd05hdmlnYXRpb25PcHRpb25zKG5hdmlnYXRpb25MaXN0KSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnBsYWNlSG9sZGVyID0gXCJTZWxlY3Qgd2hlcmUgdG8gbmF2aWdhdGUgdG9cIjtcclxuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcclxuICAgICAgICBsZXQgbmF2bGlzdCA9IG5hdmlnYXRpb25MaXN0LnNwbGl0KFwiO1wiKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hdmxpc3QubGVuZ3RoIC0gMTsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBsYWJlbDogbmF2bGlzdFtpXSwgZGVzY3JpcHRpb246IFwiXCIsIGluZGV4OiBOdW1iZXIobmF2bGlzdFtpICsgMV0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2c2NvZGUud2luZG93LnNob3dRdWlja1BpY2soaXRlbXMsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKHNlbGVjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yLnJldmVhbFJhbmdlKG5ldyB2c2NvZGUuUmFuZ2Uoc2VsZWN0aW9uLmluZGV4LCAwLCBzZWxlY3Rpb24uaW5kZXgsIDApLCB2c2NvZGUuVGV4dEVkaXRvclJldmVhbFR5cGUuSW5DZW50ZXIpO1xyXG4gICAgICAgICAgICB2c2NvZGUud2luZG93LmFjdGl2ZVRleHRFZGl0b3Iuc2VsZWN0aW9uID0gbmV3IHZzY29kZS5TZWxlY3Rpb24obmV3IHZzY29kZS5Qb3NpdGlvbihzZWxlY3Rpb24uaW5kZXgsIDApLCBuZXcgdnNjb2RlLlBvc2l0aW9uKHNlbGVjdGlvbi5pbmRleCwgMCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2hvd0NvbmZpZ3VyYXRpb25zKGNvbmZpZ3VyYXRpb25OYW1lcykge1xyXG4gICAgICAgIGxldCBvcHRpb25zID0ge307XHJcbiAgICAgICAgb3B0aW9ucy5wbGFjZUhvbGRlciA9IFwiU2VsZWN0IGEgQ29uZmlndXJhdGlvbi4uLlwiO1xyXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmlndXJhdGlvbk5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBsYWJlbDogY29uZmlndXJhdGlvbk5hbWVzW2ldLCBkZXNjcmlwdGlvbjogXCJcIiwgaW5kZXg6IGkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZW1zLnB1c2goeyBsYWJlbDogXCJFZGl0IENvbmZpZ3VyYXRpb25zLi4uXCIsIGRlc2NyaXB0aW9uOiBcIlwiLCBpbmRleDogY29uZmlndXJhdGlvbk5hbWVzLmxlbmd0aCB9KTtcclxuICAgICAgICByZXR1cm4gdnNjb2RlLndpbmRvdy5zaG93UXVpY2tQaWNrKGl0ZW1zLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAudGhlbihzZWxlY3Rpb24gPT4gKHNlbGVjdGlvbikgPyBzZWxlY3Rpb24uaW5kZXggOiAtMSk7XHJcbiAgICB9XHJcbiAgICBzaG93Q29uZmlndXJhdGlvblByb3ZpZGVycyhjdXJyZW50UHJvdmlkZXIpIHtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMucGxhY2VIb2xkZXIgPSBcIlNlbGVjdCBhIENvbmZpZ3VyYXRpb24gUHJvdmlkZXIuLi5cIjtcclxuICAgICAgICBsZXQgcHJvdmlkZXJzID0gY3VzdG9tUHJvdmlkZXJzXzEuZ2V0Q3VzdG9tQ29uZmlnUHJvdmlkZXJzKCk7XHJcbiAgICAgICAgbGV0IGl0ZW1zID0gW107XHJcbiAgICAgICAgcHJvdmlkZXJzLmZvckVhY2gocHJvdmlkZXIgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBwcm92aWRlci5uYW1lO1xyXG4gICAgICAgICAgICBpZiAocHJvdmlkZXIuZXh0ZW5zaW9uSWQgPT09IGN1cnJlbnRQcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwgKz0gXCIgKGFjdGl2ZSlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHsgbGFiZWw6IGxhYmVsLCBkZXNjcmlwdGlvbjogXCJcIiwga2V5OiBwcm92aWRlci5leHRlbnNpb25JZCB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdGVtcy5wdXNoKHsgbGFiZWw6IFwiKG5vbmUpXCIsIGRlc2NyaXB0aW9uOiBcIkRpc2FibGUgdGhlIGFjdGl2ZSBjb25maWd1cmF0aW9uIHByb3ZpZGVyLCBpZiBhcHBsaWNhYmxlLlwiLCBrZXk6IFwiXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZS53aW5kb3cuc2hvd1F1aWNrUGljayhpdGVtcywgb3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4oc2VsZWN0aW9uID0+IChzZWxlY3Rpb24pID8gc2VsZWN0aW9uLmtleSA6IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICBzaG93Q29tcGlsZUNvbW1hbmRzKHBhdGhzKSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnBsYWNlSG9sZGVyID0gXCJTZWxlY3QgYSBjb21waWxlX2NvbW1hbmRzLmpzb24uLi5cIjtcclxuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBsYWJlbDogcGF0aHNbaV0sIGRlc2NyaXB0aW9uOiBcIlwiLCBpbmRleDogaSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZS53aW5kb3cuc2hvd1F1aWNrUGljayhpdGVtcywgb3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4oc2VsZWN0aW9uID0+IChzZWxlY3Rpb24pID8gc2VsZWN0aW9uLmluZGV4IDogLTEpO1xyXG4gICAgfVxyXG4gICAgc2hvd1dvcmtzcGFjZXMod29ya3NwYWNlTmFtZXMpIHtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMucGxhY2VIb2xkZXIgPSBcIlNlbGVjdCBhIFdvcmtzcGFjZS4uLlwiO1xyXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgICAgIHdvcmtzcGFjZU5hbWVzLmZvckVhY2gobmFtZSA9PiBpdGVtcy5wdXNoKHsgbGFiZWw6IG5hbWUubmFtZSwgZGVzY3JpcHRpb246IFwiXCIsIGtleTogbmFtZS5rZXkgfSkpO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGUud2luZG93LnNob3dRdWlja1BpY2soaXRlbXMsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKHNlbGVjdGlvbiA9PiAoc2VsZWN0aW9uKSA/IHNlbGVjdGlvbi5rZXkgOiBcIlwiKTtcclxuICAgIH1cclxuICAgIHNob3dQYXJzaW5nQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnBsYWNlSG9sZGVyID0gXCJTZWxlY3QgYSBwYXJzaW5nIGNvbW1hbmQuLi5cIjtcclxuICAgICAgICBsZXQgaXRlbXM7XHJcbiAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5icm93c2VFbmdpbmVTdGF0dXNCYXJJdGVtLnRvb2x0aXAgPT09IFwiUGFyc2luZyBwYXVzZWRcIikge1xyXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHsgbGFiZWw6IFwiUmVzdW1lIFBhcnNpbmdcIiwgZGVzY3JpcHRpb246IFwiXCIsIGluZGV4OiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbXMucHVzaCh7IGxhYmVsOiBcIlBhdXNlIFBhcnNpbmdcIiwgZGVzY3JpcHRpb246IFwiXCIsIGluZGV4OiAwIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdnNjb2RlLndpbmRvdy5zaG93UXVpY2tQaWNrKGl0ZW1zLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAudGhlbihzZWxlY3Rpb24gPT4gKHNlbGVjdGlvbikgPyBzZWxlY3Rpb24uaW5kZXggOiAtMSk7XHJcbiAgICB9XHJcbiAgICBzaG93Q29uZmlndXJlSW5jbHVkZVBhdGhNZXNzYWdlKHByb21wdCwgb25Ta2lwKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbmZpZ3VyYXRpb25Qcm9tcHQoQ29uZmlndXJhdGlvblByaW9yaXR5LkluY2x1ZGVQYXRoLCBwcm9tcHQsIG9uU2tpcCk7XHJcbiAgICAgICAgfSwgMTAwMDApO1xyXG4gICAgfVxyXG4gICAgc2hvd0NvbmZpZ3VyZUNvbXBpbGVDb21tYW5kc01lc3NhZ2UocHJvbXB0LCBvblNraXApIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zaG93Q29uZmlndXJhdGlvblByb21wdChDb25maWd1cmF0aW9uUHJpb3JpdHkuQ29tcGlsZUNvbW1hbmRzLCBwcm9tcHQsIG9uU2tpcCk7XHJcbiAgICAgICAgfSwgNTAwMCk7XHJcbiAgICB9XHJcbiAgICBzaG93Q29uZmlndXJlQ3VzdG9tUHJvdmlkZXJNZXNzYWdlKHByb21wdCwgb25Ta2lwKSB7XHJcbiAgICAgICAgdGhpcy5zaG93Q29uZmlndXJhdGlvblByb21wdChDb25maWd1cmF0aW9uUHJpb3JpdHkuQ3VzdG9tUHJvdmlkZXIsIHByb21wdCwgb25Ta2lwKTtcclxuICAgIH1cclxuICAgIHNob3dDb25maWd1cmF0aW9uUHJvbXB0KHByaW9yaXR5LCBwcm9tcHQsIG9uU2tpcCkge1xyXG4gICAgICAgIGxldCBzaG93UHJvbXB0ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgY29uZmlndXJlZCA9IHlpZWxkIHByb21wdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWQ6IGNvbmZpZ3VyZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvblVJUHJvbWlzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25VSVByb21pc2UgPSB0aGlzLmNvbmZpZ3VyYXRpb25VSVByb21pc2UudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByaW9yaXR5ID4gcmVzdWx0LnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3dQcm9tcHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bHQuY29uZmlndXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG93UHJvbXB0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvblNraXAoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiByZXN1bHQucHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uVUlQcm9taXNlID0gc2hvd1Byb21wdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWdTdGF0dXNCYXJJdGVtLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmJyb3dzZUVuZ2luZVN0YXR1c0Jhckl0ZW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuaW50ZWxsaVNlbnNlU3RhdHVzQmFySXRlbS5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU3RhdHVzQmFySXRlbS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5VSSA9IFVJO1xyXG5mdW5jdGlvbiBnZXRVSSgpIHtcclxuICAgIGlmICh1aSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdWkgPSBuZXcgVUkoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1aTtcclxufVxyXG5leHBvcnRzLmdldFVJID0gZ2V0VUk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LanguageServer/ui.ts\n");

/***/ }),

/***/ "./src/abTesting.ts":
/*!**************************!*\
  !*** ./src/abTesting.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nconst Telemetry = __webpack_require__(/*! ./telemetry */ \"./src/telemetry.ts\");\r\nconst persistentState_1 = __webpack_require__(/*! ./LanguageServer/persistentState */ \"./src/LanguageServer/persistentState.ts\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst userBucketMax = 100;\r\nconst userBucketString = \"CPP.UserBucket\";\r\nconst localConfigFile = \"cpptools.json\";\r\nclass ABTestSettings {\r\n    constructor() {\r\n        this.intelliSenseEngineDefault = new persistentState_1.PersistentState(\"ABTest.1\", 100);\r\n        this.recursiveIncludesDefault = new persistentState_1.PersistentState(\"ABTest.2\", 100);\r\n        this.gotoDefIntelliSenseDefault = new persistentState_1.PersistentState(\"ABTest.3\", 100);\r\n        this.settings = {\r\n            defaultIntelliSenseEngine: this.intelliSenseEngineDefault.Value,\r\n            recursiveIncludes: this.recursiveIncludesDefault.Value,\r\n            gotoDefIntelliSense: this.gotoDefIntelliSenseDefault.Value\r\n        };\r\n        this.bucket = new persistentState_1.PersistentState(userBucketString, -1);\r\n        if (this.bucket.Value === -1) {\r\n            this.bucket.Value = Math.floor(Math.random() * userBucketMax) + 1;\r\n        }\r\n        this.updateSettings();\r\n        this.downloadCpptoolsJsonPkgAsync();\r\n        setInterval(() => { this.downloadCpptoolsJsonPkgAsync(); }, 30 * 60 * 1000);\r\n    }\r\n    get UseDefaultIntelliSenseEngine() {\r\n        return util.isNumber(this.settings.defaultIntelliSenseEngine) ? this.settings.defaultIntelliSenseEngine >= this.bucket.Value : true;\r\n    }\r\n    get UseRecursiveIncludes() {\r\n        return util.isNumber(this.settings.recursiveIncludes) ? this.settings.recursiveIncludes >= this.bucket.Value : true;\r\n    }\r\n    get UseGoToDefIntelliSense() {\r\n        return util.isNumber(this.settings.gotoDefIntelliSense) ? this.settings.gotoDefIntelliSense >= this.bucket.Value : true;\r\n    }\r\n    updateSettings() {\r\n        const cpptoolsJsonFile = util.getExtensionFilePath(localConfigFile);\r\n        try {\r\n            const exists = fs.existsSync(cpptoolsJsonFile);\r\n            if (exists) {\r\n                const fileContent = fs.readFileSync(cpptoolsJsonFile).toString();\r\n                let newSettings = JSON.parse(fileContent);\r\n                this.intelliSenseEngineDefault.Value = util.isNumber(newSettings.defaultIntelliSenseEngine) ? newSettings.defaultIntelliSenseEngine : this.intelliSenseEngineDefault.DefaultValue;\r\n                this.recursiveIncludesDefault.Value = util.isNumber(newSettings.recursiveIncludes) ? newSettings.recursiveIncludes : this.recursiveIncludesDefault.DefaultValue;\r\n                this.gotoDefIntelliSenseDefault.Value = util.isNumber(newSettings.gotoDefIntelliSense) ? newSettings.gotoDefIntelliSense : this.gotoDefIntelliSenseDefault.DefaultValue;\r\n                this.settings = {\r\n                    defaultIntelliSenseEngine: this.intelliSenseEngineDefault.Value,\r\n                    recursiveIncludes: this.recursiveIncludesDefault.Value,\r\n                    gotoDefIntelliSense: this.gotoDefIntelliSenseDefault.Value\r\n                };\r\n            }\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    downloadCpptoolsJsonPkgAsync() {\r\n        let hasError = false;\r\n        let telemetryProperties = {};\r\n        const localConfigPath = util.getExtensionFilePath(localConfigFile);\r\n        return util.downloadFileToDestination(\"https://go.microsoft.com/fwlink/?linkid=2026205\", localConfigPath)\r\n            .catch((error) => {\r\n            hasError = true;\r\n        })\r\n            .then(() => {\r\n            this.updateSettings();\r\n            telemetryProperties['success'] = (!hasError).toString();\r\n            Telemetry.logDebuggerEvent(\"cpptoolsJsonDownload\", telemetryProperties);\r\n        });\r\n    }\r\n}\r\nexports.ABTestSettings = ABTestSettings;\r\nlet settings;\r\nfunction getABTestSettings() {\r\n    if (!settings) {\r\n        settings = new ABTestSettings();\r\n    }\r\n    return settings;\r\n}\r\nexports.getABTestSettings = getABTestSettings;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWJUZXN0aW5nLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9hYlRlc3RpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XHJcbmNvbnN0IFRlbGVtZXRyeSA9IHJlcXVpcmUoXCIuL3RlbGVtZXRyeVwiKTtcclxuY29uc3QgcGVyc2lzdGVudFN0YXRlXzEgPSByZXF1aXJlKFwiLi9MYW5ndWFnZVNlcnZlci9wZXJzaXN0ZW50U3RhdGVcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCB1c2VyQnVja2V0TWF4ID0gMTAwO1xyXG5jb25zdCB1c2VyQnVja2V0U3RyaW5nID0gXCJDUFAuVXNlckJ1Y2tldFwiO1xyXG5jb25zdCBsb2NhbENvbmZpZ0ZpbGUgPSBcImNwcHRvb2xzLmpzb25cIjtcclxuY2xhc3MgQUJUZXN0U2V0dGluZ3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlbGxpU2Vuc2VFbmdpbmVEZWZhdWx0ID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRTdGF0ZShcIkFCVGVzdC4xXCIsIDEwMCk7XHJcbiAgICAgICAgdGhpcy5yZWN1cnNpdmVJbmNsdWRlc0RlZmF1bHQgPSBuZXcgcGVyc2lzdGVudFN0YXRlXzEuUGVyc2lzdGVudFN0YXRlKFwiQUJUZXN0LjJcIiwgMTAwKTtcclxuICAgICAgICB0aGlzLmdvdG9EZWZJbnRlbGxpU2Vuc2VEZWZhdWx0ID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRTdGF0ZShcIkFCVGVzdC4zXCIsIDEwMCk7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgZGVmYXVsdEludGVsbGlTZW5zZUVuZ2luZTogdGhpcy5pbnRlbGxpU2Vuc2VFbmdpbmVEZWZhdWx0LlZhbHVlLFxyXG4gICAgICAgICAgICByZWN1cnNpdmVJbmNsdWRlczogdGhpcy5yZWN1cnNpdmVJbmNsdWRlc0RlZmF1bHQuVmFsdWUsXHJcbiAgICAgICAgICAgIGdvdG9EZWZJbnRlbGxpU2Vuc2U6IHRoaXMuZ290b0RlZkludGVsbGlTZW5zZURlZmF1bHQuVmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYnVja2V0ID0gbmV3IHBlcnNpc3RlbnRTdGF0ZV8xLlBlcnNpc3RlbnRTdGF0ZSh1c2VyQnVja2V0U3RyaW5nLCAtMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVja2V0LlZhbHVlID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldC5WYWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHVzZXJCdWNrZXRNYXgpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZXR0aW5ncygpO1xyXG4gICAgICAgIHRoaXMuZG93bmxvYWRDcHB0b29sc0pzb25Qa2dBc3luYygpO1xyXG4gICAgICAgIHNldEludGVydmFsKCgpID0+IHsgdGhpcy5kb3dubG9hZENwcHRvb2xzSnNvblBrZ0FzeW5jKCk7IH0sIDMwICogNjAgKiAxMDAwKTtcclxuICAgIH1cclxuICAgIGdldCBVc2VEZWZhdWx0SW50ZWxsaVNlbnNlRW5naW5lKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsLmlzTnVtYmVyKHRoaXMuc2V0dGluZ3MuZGVmYXVsdEludGVsbGlTZW5zZUVuZ2luZSkgPyB0aGlzLnNldHRpbmdzLmRlZmF1bHRJbnRlbGxpU2Vuc2VFbmdpbmUgPj0gdGhpcy5idWNrZXQuVmFsdWUgOiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IFVzZVJlY3Vyc2l2ZUluY2x1ZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsLmlzTnVtYmVyKHRoaXMuc2V0dGluZ3MucmVjdXJzaXZlSW5jbHVkZXMpID8gdGhpcy5zZXR0aW5ncy5yZWN1cnNpdmVJbmNsdWRlcyA+PSB0aGlzLmJ1Y2tldC5WYWx1ZSA6IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgVXNlR29Ub0RlZkludGVsbGlTZW5zZSgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbC5pc051bWJlcih0aGlzLnNldHRpbmdzLmdvdG9EZWZJbnRlbGxpU2Vuc2UpID8gdGhpcy5zZXR0aW5ncy5nb3RvRGVmSW50ZWxsaVNlbnNlID49IHRoaXMuYnVja2V0LlZhbHVlIDogdHJ1ZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNldHRpbmdzKCkge1xyXG4gICAgICAgIGNvbnN0IGNwcHRvb2xzSnNvbkZpbGUgPSB1dGlsLmdldEV4dGVuc2lvbkZpbGVQYXRoKGxvY2FsQ29uZmlnRmlsZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhjcHB0b29sc0pzb25GaWxlKTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoY3BwdG9vbHNKc29uRmlsZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdTZXR0aW5ncyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlbGxpU2Vuc2VFbmdpbmVEZWZhdWx0LlZhbHVlID0gdXRpbC5pc051bWJlcihuZXdTZXR0aW5ncy5kZWZhdWx0SW50ZWxsaVNlbnNlRW5naW5lKSA/IG5ld1NldHRpbmdzLmRlZmF1bHRJbnRlbGxpU2Vuc2VFbmdpbmUgOiB0aGlzLmludGVsbGlTZW5zZUVuZ2luZURlZmF1bHQuRGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVJbmNsdWRlc0RlZmF1bHQuVmFsdWUgPSB1dGlsLmlzTnVtYmVyKG5ld1NldHRpbmdzLnJlY3Vyc2l2ZUluY2x1ZGVzKSA/IG5ld1NldHRpbmdzLnJlY3Vyc2l2ZUluY2x1ZGVzIDogdGhpcy5yZWN1cnNpdmVJbmNsdWRlc0RlZmF1bHQuRGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb3RvRGVmSW50ZWxsaVNlbnNlRGVmYXVsdC5WYWx1ZSA9IHV0aWwuaXNOdW1iZXIobmV3U2V0dGluZ3MuZ290b0RlZkludGVsbGlTZW5zZSkgPyBuZXdTZXR0aW5ncy5nb3RvRGVmSW50ZWxsaVNlbnNlIDogdGhpcy5nb3RvRGVmSW50ZWxsaVNlbnNlRGVmYXVsdC5EZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlbGxpU2Vuc2VFbmdpbmU6IHRoaXMuaW50ZWxsaVNlbnNlRW5naW5lRGVmYXVsdC5WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVJbmNsdWRlczogdGhpcy5yZWN1cnNpdmVJbmNsdWRlc0RlZmF1bHQuVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ290b0RlZkludGVsbGlTZW5zZTogdGhpcy5nb3RvRGVmSW50ZWxsaVNlbnNlRGVmYXVsdC5WYWx1ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb3dubG9hZENwcHRvb2xzSnNvblBrZ0FzeW5jKCkge1xyXG4gICAgICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB0ZWxlbWV0cnlQcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgY29uc3QgbG9jYWxDb25maWdQYXRoID0gdXRpbC5nZXRFeHRlbnNpb25GaWxlUGF0aChsb2NhbENvbmZpZ0ZpbGUpO1xyXG4gICAgICAgIHJldHVybiB1dGlsLmRvd25sb2FkRmlsZVRvRGVzdGluYXRpb24oXCJodHRwczovL2dvLm1pY3Jvc29mdC5jb20vZndsaW5rLz9saW5raWQ9MjAyNjIwNVwiLCBsb2NhbENvbmZpZ1BhdGgpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICB0ZWxlbWV0cnlQcm9wZXJ0aWVzWydzdWNjZXNzJ10gPSAoIWhhc0Vycm9yKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBUZWxlbWV0cnkubG9nRGVidWdnZXJFdmVudChcImNwcHRvb2xzSnNvbkRvd25sb2FkXCIsIHRlbGVtZXRyeVByb3BlcnRpZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQUJUZXN0U2V0dGluZ3MgPSBBQlRlc3RTZXR0aW5ncztcclxubGV0IHNldHRpbmdzO1xyXG5mdW5jdGlvbiBnZXRBQlRlc3RTZXR0aW5ncygpIHtcclxuICAgIGlmICghc2V0dGluZ3MpIHtcclxuICAgICAgICBzZXR0aW5ncyA9IG5ldyBBQlRlc3RTZXR0aW5ncygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNldHRpbmdzO1xyXG59XHJcbmV4cG9ydHMuZ2V0QUJUZXN0U2V0dGluZ3MgPSBnZXRBQlRlc3RTZXR0aW5ncztcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/abTesting.ts\n");

/***/ }),

/***/ "./src/commands.ts":
/*!*************************!*\
  !*** ./src/commands.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst LanguageServer = __webpack_require__(/*! ./LanguageServer/extension */ \"./src/LanguageServer/extension.ts\");\r\nclass TemporaryCommandRegistrar {\r\n    constructor() {\r\n        this.isLanguageServerDisabled = false;\r\n        this.isActivationReady = false;\r\n        this.commandsToRegister = [\r\n            \"C_Cpp.ConfigurationEdit\",\r\n            \"C_Cpp.ConfigurationSelect\",\r\n            \"C_Cpp.ConfigurationProviderSelect\",\r\n            \"C_Cpp.SwitchHeaderSource\",\r\n            \"C_Cpp.Navigate\",\r\n            \"C_Cpp.GoToDeclaration\",\r\n            \"C_Cpp.PeekDeclaration\",\r\n            \"C_Cpp.ToggleErrorSquiggles\",\r\n            \"C_Cpp.ToggleIncludeFallback\",\r\n            \"C_Cpp.ToggleDimInactiveRegions\",\r\n            \"C_Cpp.ShowReleaseNotes\",\r\n            \"C_Cpp.ResetDatabase\",\r\n            \"C_Cpp.PauseParsing\",\r\n            \"C_Cpp.ResumeParsing\",\r\n            \"C_Cpp.ShowParsingCommands\",\r\n            \"C_Cpp.TakeSurvey\"\r\n        ];\r\n        this.tempCommands = [];\r\n        this.delayedCommandsToExecute = new Set();\r\n        this.commandsToRegister.forEach(command => {\r\n            this.registerTempCommand(command);\r\n        });\r\n    }\r\n    registerTempCommand(command) {\r\n        this.tempCommands.push(vscode.commands.registerCommand(command, () => {\r\n            if (this.isLanguageServerDisabled) {\r\n                vscode.window.showInformationMessage(\"The command is disabled because \\\"C_Cpp.intelliSenseEngine\\\" is set to \\\"Disabled\\\".\");\r\n                return;\r\n            }\r\n            this.delayedCommandsToExecute.add(command);\r\n            if (this.isActivationReady) {\r\n                LanguageServer.activate(true);\r\n            }\r\n        }));\r\n    }\r\n    disableLanguageServer() {\r\n        this.isLanguageServerDisabled = true;\r\n    }\r\n    activateLanguageServer() {\r\n        LanguageServer.activate(this.delayedCommandsToExecute.size > 0);\r\n        this.isActivationReady = true;\r\n    }\r\n    clearTempCommands() {\r\n        this.tempCommands.forEach((command) => {\r\n            command.dispose();\r\n        });\r\n        this.tempCommands = [];\r\n    }\r\n    executeDelayedCommands() {\r\n        this.delayedCommandsToExecute.forEach((command) => {\r\n            vscode.commands.executeCommand(command);\r\n        });\r\n        this.delayedCommandsToExecute.clear();\r\n    }\r\n}\r\nlet tempCommandRegistrar;\r\nfunction initializeTemporaryCommandRegistrar() {\r\n    tempCommandRegistrar = new TemporaryCommandRegistrar();\r\n}\r\nexports.initializeTemporaryCommandRegistrar = initializeTemporaryCommandRegistrar;\r\nfunction getTemporaryCommandRegistrarInstance() {\r\n    return tempCommandRegistrar;\r\n}\r\nexports.getTemporaryCommandRegistrarInstance = getTemporaryCommandRegistrarInstance;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbWFuZHMudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL2NvbW1hbmRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBMYW5ndWFnZVNlcnZlciA9IHJlcXVpcmUoXCIuL0xhbmd1YWdlU2VydmVyL2V4dGVuc2lvblwiKTtcclxuY2xhc3MgVGVtcG9yYXJ5Q29tbWFuZFJlZ2lzdHJhciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VTZXJ2ZXJEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmF0aW9uUmVhZHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzVG9SZWdpc3RlciA9IFtcclxuICAgICAgICAgICAgXCJDX0NwcC5Db25maWd1cmF0aW9uRWRpdFwiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLkNvbmZpZ3VyYXRpb25TZWxlY3RcIixcclxuICAgICAgICAgICAgXCJDX0NwcC5Db25maWd1cmF0aW9uUHJvdmlkZXJTZWxlY3RcIixcclxuICAgICAgICAgICAgXCJDX0NwcC5Td2l0Y2hIZWFkZXJTb3VyY2VcIixcclxuICAgICAgICAgICAgXCJDX0NwcC5OYXZpZ2F0ZVwiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLkdvVG9EZWNsYXJhdGlvblwiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLlBlZWtEZWNsYXJhdGlvblwiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLlRvZ2dsZUVycm9yU3F1aWdnbGVzXCIsXHJcbiAgICAgICAgICAgIFwiQ19DcHAuVG9nZ2xlSW5jbHVkZUZhbGxiYWNrXCIsXHJcbiAgICAgICAgICAgIFwiQ19DcHAuVG9nZ2xlRGltSW5hY3RpdmVSZWdpb25zXCIsXHJcbiAgICAgICAgICAgIFwiQ19DcHAuU2hvd1JlbGVhc2VOb3Rlc1wiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLlJlc2V0RGF0YWJhc2VcIixcclxuICAgICAgICAgICAgXCJDX0NwcC5QYXVzZVBhcnNpbmdcIixcclxuICAgICAgICAgICAgXCJDX0NwcC5SZXN1bWVQYXJzaW5nXCIsXHJcbiAgICAgICAgICAgIFwiQ19DcHAuU2hvd1BhcnNpbmdDb21tYW5kc1wiLFxyXG4gICAgICAgICAgICBcIkNfQ3BwLlRha2VTdXJ2ZXlcIlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy50ZW1wQ29tbWFuZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRDb21tYW5kc1RvRXhlY3V0ZSA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzVG9SZWdpc3Rlci5mb3JFYWNoKGNvbW1hbmQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVGVtcENvbW1hbmQoY29tbWFuZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlclRlbXBDb21tYW5kKGNvbW1hbmQpIHtcclxuICAgICAgICB0aGlzLnRlbXBDb21tYW5kcy5wdXNoKHZzY29kZS5jb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0xhbmd1YWdlU2VydmVyRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShcIlRoZSBjb21tYW5kIGlzIGRpc2FibGVkIGJlY2F1c2UgXFxcIkNfQ3BwLmludGVsbGlTZW5zZUVuZ2luZVxcXCIgaXMgc2V0IHRvIFxcXCJEaXNhYmxlZFxcXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZENvbW1hbmRzVG9FeGVjdXRlLmFkZChjb21tYW5kKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmF0aW9uUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIExhbmd1YWdlU2VydmVyLmFjdGl2YXRlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgZGlzYWJsZUxhbmd1YWdlU2VydmVyKCkge1xyXG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZVNlcnZlckRpc2FibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFjdGl2YXRlTGFuZ3VhZ2VTZXJ2ZXIoKSB7XHJcbiAgICAgICAgTGFuZ3VhZ2VTZXJ2ZXIuYWN0aXZhdGUodGhpcy5kZWxheWVkQ29tbWFuZHNUb0V4ZWN1dGUuc2l6ZSA+IDApO1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmF0aW9uUmVhZHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2xlYXJUZW1wQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wQ29tbWFuZHMuZm9yRWFjaCgoY29tbWFuZCkgPT4ge1xyXG4gICAgICAgICAgICBjb21tYW5kLmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnRlbXBDb21tYW5kcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZURlbGF5ZWRDb21tYW5kcygpIHtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRDb21tYW5kc1RvRXhlY3V0ZS5mb3JFYWNoKChjb21tYW5kKSA9PiB7XHJcbiAgICAgICAgICAgIHZzY29kZS5jb21tYW5kcy5leGVjdXRlQ29tbWFuZChjb21tYW5kKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlbGF5ZWRDb21tYW5kc1RvRXhlY3V0ZS5jbGVhcigpO1xyXG4gICAgfVxyXG59XHJcbmxldCB0ZW1wQ29tbWFuZFJlZ2lzdHJhcjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZVRlbXBvcmFyeUNvbW1hbmRSZWdpc3RyYXIoKSB7XHJcbiAgICB0ZW1wQ29tbWFuZFJlZ2lzdHJhciA9IG5ldyBUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFyKCk7XHJcbn1cclxuZXhwb3J0cy5pbml0aWFsaXplVGVtcG9yYXJ5Q29tbWFuZFJlZ2lzdHJhciA9IGluaXRpYWxpemVUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFyO1xyXG5mdW5jdGlvbiBnZXRUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFySW5zdGFuY2UoKSB7XHJcbiAgICByZXR1cm4gdGVtcENvbW1hbmRSZWdpc3RyYXI7XHJcbn1cclxuZXhwb3J0cy5nZXRUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFySW5zdGFuY2UgPSBnZXRUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFySW5zdGFuY2U7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/commands.ts\n");

/***/ }),

/***/ "./src/common.ts":
/*!***********************!*\
  !*** ./src/common.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst child_process = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst Telemetry = __webpack_require__(/*! ./telemetry */ \"./src/telemetry.ts\");\r\nconst HttpsProxyAgent = __webpack_require__(/*! https-proxy-agent */ \"./node_modules/https-proxy-agent/index.js\");\r\nconst url = __webpack_require__(/*! url */ \"url\");\r\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\r\nconst assert = __webpack_require__(/*! assert */ \"assert\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst extension_1 = __webpack_require__(/*! ./LanguageServer/extension */ \"./src/LanguageServer/extension.ts\");\r\nfunction setExtensionContext(context) {\r\n    exports.extensionContext = context;\r\n}\r\nexports.setExtensionContext = setExtensionContext;\r\nexports.packageJson = vscode.extensions.getExtension(\"ms-vscode.cpptools\").packageJSON;\r\nlet rawPackageJson = null;\r\nfunction getRawPackageJson() {\r\n    if (rawPackageJson === null) {\r\n        const fileContents = fs.readFileSync(getPackageJsonPath());\r\n        rawPackageJson = JSON.parse(fileContents.toString());\r\n    }\r\n    return rawPackageJson;\r\n}\r\nexports.getRawPackageJson = getRawPackageJson;\r\nfunction getRawTasksJson() {\r\n    const path = getTasksJsonPath();\r\n    if (!path) {\r\n        return undefined;\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        fs.exists(path, exists => {\r\n            if (!exists) {\r\n                return resolve({});\r\n            }\r\n            const fileContents = fs.readFileSync(path);\r\n            let rawTasks = {};\r\n            try {\r\n                rawTasks = JSON.parse(fileContents.toString());\r\n            }\r\n            catch (error) {\r\n            }\r\n            resolve(rawTasks);\r\n        });\r\n    });\r\n}\r\nexports.getRawTasksJson = getRawTasksJson;\r\nfunction ensureBuildTaskExists(taskName) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let rawTasksJson = yield getRawTasksJson();\r\n        if (!rawTasksJson.tasks) {\r\n            rawTasksJson.tasks = new Array();\r\n        }\r\n        let selectedTask = rawTasksJson.tasks.find(task => {\r\n            return task.label && task.label === task;\r\n        });\r\n        if (selectedTask) {\r\n            return;\r\n        }\r\n        const buildTasks = yield extension_1.getBuildTasks();\r\n        selectedTask = buildTasks.find(task => task.name === taskName);\r\n        console.assert(selectedTask);\r\n        let definition = selectedTask.definition;\r\n        if (definition && definition.compilerPath) {\r\n            delete definition.compilerPath;\r\n        }\r\n        rawTasksJson.version = \"2.0.0\";\r\n        if (!rawTasksJson.tasks.find(task => { return task.label === selectedTask.definition.label; })) {\r\n            rawTasksJson.tasks.push(selectedTask.definition);\r\n        }\r\n        yield writeFileText(getTasksJsonPath(), JSON.stringify(rawTasksJson, null, 2));\r\n    });\r\n}\r\nexports.ensureBuildTaskExists = ensureBuildTaskExists;\r\nfunction fileIsCOrCppSource(file) {\r\n    const fileExtLower = path.extname(file).toLowerCase();\r\n    return [\".C\", \".c\", \".cpp\", \".cc\", \".cxx\", \".mm\", \".ino\", \".inl\"].some(ext => fileExtLower === ext);\r\n}\r\nexports.fileIsCOrCppSource = fileIsCOrCppSource;\r\nfunction stringifyPackageJson(packageJson) {\r\n    return JSON.stringify(packageJson, null, 2);\r\n}\r\nexports.stringifyPackageJson = stringifyPackageJson;\r\nfunction getExtensionFilePath(extensionfile) {\r\n    return path.resolve(exports.extensionContext.extensionPath, extensionfile);\r\n}\r\nexports.getExtensionFilePath = getExtensionFilePath;\r\nfunction getPackageJsonPath() {\r\n    return getExtensionFilePath(\"package.json\");\r\n}\r\nexports.getPackageJsonPath = getPackageJsonPath;\r\nfunction getTasksJsonPath() {\r\n    const editor = vscode.window.activeTextEditor;\r\n    const folder = vscode.workspace.getWorkspaceFolder(editor.document.uri);\r\n    if (!folder) {\r\n        return undefined;\r\n    }\r\n    return path.join(folder.uri.fsPath, \".vscode\", \"tasks.json\");\r\n}\r\nexports.getTasksJsonPath = getTasksJsonPath;\r\nfunction getVcpkgPathDescriptorFile() {\r\n    if (process.platform === 'win32') {\r\n        return path.join(process.env.LOCALAPPDATA, \"vcpkg/vcpkg.path.txt\");\r\n    }\r\n    else {\r\n        return path.join(process.env.HOME, \".vcpkg/vcpkg.path.txt\");\r\n    }\r\n}\r\nexports.getVcpkgPathDescriptorFile = getVcpkgPathDescriptorFile;\r\nlet vcpkgRoot;\r\nfunction getVcpkgRoot() {\r\n    if (!vcpkgRoot && vcpkgRoot !== \"\") {\r\n        vcpkgRoot = \"\";\r\n        if (fs.existsSync(getVcpkgPathDescriptorFile())) {\r\n            let vcpkgRootTemp = fs.readFileSync(getVcpkgPathDescriptorFile()).toString();\r\n            vcpkgRootTemp = vcpkgRootTemp.trim();\r\n            if (fs.existsSync(vcpkgRootTemp)) {\r\n                vcpkgRoot = path.join(vcpkgRootTemp, \"/installed\").replace(/\\\\/g, \"/\");\r\n            }\r\n        }\r\n    }\r\n    return vcpkgRoot;\r\n}\r\nexports.getVcpkgRoot = getVcpkgRoot;\r\nfunction isHeader(document) {\r\n    let ext = path.extname(document.uri.fsPath);\r\n    return !ext || ext.startsWith(\".h\") || ext.startsWith(\".H\");\r\n}\r\nexports.isHeader = isHeader;\r\nfunction isExtensionReady() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const doesInstallLockFileExist = yield checkInstallLockFile();\r\n        return doesInstallLockFileExist;\r\n    });\r\n}\r\nexports.isExtensionReady = isExtensionReady;\r\nlet isExtensionNotReadyPromptDisplayed = false;\r\nexports.extensionNotReadyString = 'The C/C++ extension is still installing. See the output window for more information.';\r\nfunction displayExtensionNotReadyPrompt() {\r\n    if (!isExtensionNotReadyPromptDisplayed) {\r\n        isExtensionNotReadyPromptDisplayed = true;\r\n        logger_1.showOutputChannel();\r\n        logger_1.getOutputChannelLogger().showInformationMessage(exports.extensionNotReadyString).then(() => { isExtensionNotReadyPromptDisplayed = false; }, () => { isExtensionNotReadyPromptDisplayed = false; });\r\n    }\r\n}\r\nexports.displayExtensionNotReadyPrompt = displayExtensionNotReadyPrompt;\r\nconst progressInstallSuccess = 100;\r\nconst progressExecutableStarted = 150;\r\nconst progressExecutableSuccess = 200;\r\nconst progressParseRootSuccess = 300;\r\nconst progressIntelliSenseNoSquiggles = 1000;\r\nlet installProgressStr = \"CPP.\" + exports.packageJson.version + \".Progress\";\r\nlet intelliSenseProgressStr = \"CPP.\" + exports.packageJson.version + \".IntelliSenseProgress\";\r\nfunction getProgress() {\r\n    return exports.extensionContext.globalState.get(installProgressStr, -1);\r\n}\r\nexports.getProgress = getProgress;\r\nfunction getIntelliSenseProgress() {\r\n    return exports.extensionContext.globalState.get(intelliSenseProgressStr, -1);\r\n}\r\nexports.getIntelliSenseProgress = getIntelliSenseProgress;\r\nfunction setProgress(progress) {\r\n    if (getProgress() < progress) {\r\n        exports.extensionContext.globalState.update(installProgressStr, progress);\r\n        let telemetryProperties = {};\r\n        let progressName;\r\n        switch (progress) {\r\n            case 0:\r\n                progressName = \"install started\";\r\n                break;\r\n            case progressInstallSuccess:\r\n                progressName = \"install succeeded\";\r\n                break;\r\n            case progressExecutableStarted:\r\n                progressName = \"executable started\";\r\n                break;\r\n            case progressExecutableSuccess:\r\n                progressName = \"executable succeeded\";\r\n                break;\r\n            case progressParseRootSuccess:\r\n                progressName = \"parse root succeeded\";\r\n                break;\r\n        }\r\n        telemetryProperties['progress'] = progressName;\r\n        Telemetry.logDebuggerEvent(\"progress\", telemetryProperties);\r\n    }\r\n}\r\nexports.setProgress = setProgress;\r\nfunction setIntelliSenseProgress(progress) {\r\n    if (getIntelliSenseProgress() < progress) {\r\n        exports.extensionContext.globalState.update(intelliSenseProgressStr, progress);\r\n        let telemetryProperties = {};\r\n        let progressName;\r\n        switch (progress) {\r\n            case progressIntelliSenseNoSquiggles:\r\n                progressName = \"IntelliSense no squiggles\";\r\n                break;\r\n        }\r\n        telemetryProperties['progress'] = progressName;\r\n        Telemetry.logDebuggerEvent(\"progress\", telemetryProperties);\r\n    }\r\n}\r\nexports.setIntelliSenseProgress = setIntelliSenseProgress;\r\nfunction getProgressInstallSuccess() { return progressInstallSuccess; }\r\nexports.getProgressInstallSuccess = getProgressInstallSuccess;\r\nfunction getProgressExecutableStarted() { return progressExecutableStarted; }\r\nexports.getProgressExecutableStarted = getProgressExecutableStarted;\r\nfunction getProgressExecutableSuccess() { return progressExecutableSuccess; }\r\nexports.getProgressExecutableSuccess = getProgressExecutableSuccess;\r\nfunction getProgressParseRootSuccess() { return progressParseRootSuccess; }\r\nexports.getProgressParseRootSuccess = getProgressParseRootSuccess;\r\nfunction getProgressIntelliSenseNoSquiggles() { return progressIntelliSenseNoSquiggles; }\r\nexports.getProgressIntelliSenseNoSquiggles = getProgressIntelliSenseNoSquiggles;\r\nlet releaseNotesPanel = undefined;\r\nfunction showReleaseNotes() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (releaseNotesPanel) {\r\n            releaseNotesPanel.reveal();\r\n        }\r\n        else {\r\n            releaseNotesPanel = vscode.window.createWebviewPanel('releaseNotes', \"C/C++ Extension Release Notes\", vscode.ViewColumn.One);\r\n            releaseNotesPanel.webview.html = yield readFileText(getExtensionFilePath(\"ReleaseNotes.html\"));\r\n            releaseNotesPanel.onDidDispose(() => releaseNotesPanel = undefined, null, exports.extensionContext.subscriptions);\r\n        }\r\n    });\r\n}\r\nexports.showReleaseNotes = showReleaseNotes;\r\nfunction isUri(input) {\r\n    return input && input instanceof vscode.Uri;\r\n}\r\nexports.isUri = isUri;\r\nfunction isString(input) {\r\n    return typeof (input) === \"string\";\r\n}\r\nexports.isString = isString;\r\nfunction isNumber(input) {\r\n    return typeof (input) === \"number\";\r\n}\r\nexports.isNumber = isNumber;\r\nfunction isBoolean(input) {\r\n    return typeof (input) === \"boolean\";\r\n}\r\nexports.isBoolean = isBoolean;\r\nfunction isArray(input) {\r\n    return input instanceof Array;\r\n}\r\nexports.isArray = isArray;\r\nfunction isOptionalString(input) {\r\n    return input === undefined || isString(input);\r\n}\r\nexports.isOptionalString = isOptionalString;\r\nfunction isArrayOfString(input) {\r\n    return isArray(input) && input.every(item => isString(item));\r\n}\r\nexports.isArrayOfString = isArrayOfString;\r\nfunction isOptionalArrayOfString(input) {\r\n    return input === undefined || isArrayOfString(input);\r\n}\r\nexports.isOptionalArrayOfString = isOptionalArrayOfString;\r\nfunction resolveVariables(input, additionalEnvironment) {\r\n    if (!input) {\r\n        return \"\";\r\n    }\r\n    if (!additionalEnvironment) {\r\n        additionalEnvironment = {};\r\n    }\r\n    let regexp = () => /\\$\\{((env|config|workspaceFolder)(\\.|:))?(.*?)\\}/g;\r\n    let ret = input;\r\n    let cycleCache = new Set();\r\n    while (!cycleCache.has(ret)) {\r\n        cycleCache.add(ret);\r\n        ret = ret.replace(regexp(), (match, ignored1, varType, ignored2, name) => {\r\n            if (varType === undefined) {\r\n                varType = \"env\";\r\n            }\r\n            let newValue;\r\n            switch (varType) {\r\n                case \"env\": {\r\n                    let v = additionalEnvironment[name];\r\n                    if (isString(v)) {\r\n                        newValue = v;\r\n                    }\r\n                    else if (input === match && isArrayOfString(v)) {\r\n                        newValue = v.join(\";\");\r\n                    }\r\n                    if (!isString(newValue)) {\r\n                        newValue = process.env[name];\r\n                    }\r\n                    break;\r\n                }\r\n                case \"config\": {\r\n                    let config = vscode.workspace.getConfiguration();\r\n                    if (config) {\r\n                        newValue = config.get(name);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"workspaceFolder\": {\r\n                    if (name && vscode.workspace && vscode.workspace.workspaceFolders) {\r\n                        let folder = vscode.workspace.workspaceFolders.find(folder => folder.name.toLocaleLowerCase() === name.toLocaleLowerCase());\r\n                        if (folder) {\r\n                            newValue = folder.uri.fsPath;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    assert.fail(\"unknown varType matched\");\r\n                }\r\n            }\r\n            return (isString(newValue)) ? newValue : match;\r\n        });\r\n    }\r\n    regexp = () => /^\\~/g;\r\n    ret = ret.replace(regexp(), (match, name) => {\r\n        let newValue = (process.platform === 'win32') ? process.env.USERPROFILE : process.env.HOME;\r\n        return (newValue) ? newValue : match;\r\n    });\r\n    return ret;\r\n}\r\nexports.resolveVariables = resolveVariables;\r\nfunction asFolder(uri) {\r\n    let result = uri.toString();\r\n    if (result.charAt(result.length - 1) !== '/') {\r\n        result += '/';\r\n    }\r\n    return result;\r\n}\r\nexports.asFolder = asFolder;\r\nfunction getOpenCommand() {\r\n    if (os.platform() === 'win32') {\r\n        return 'explorer';\r\n    }\r\n    else if (os.platform() === 'darwin') {\r\n        return '/usr/bin/open';\r\n    }\r\n    else {\r\n        return '/usr/bin/xdg-open';\r\n    }\r\n}\r\nexports.getOpenCommand = getOpenCommand;\r\nfunction getDebugAdaptersPath(file) {\r\n    return path.resolve(getExtensionFilePath(\"debugAdapters\"), file);\r\n}\r\nexports.getDebugAdaptersPath = getDebugAdaptersPath;\r\nfunction getHttpsProxyAgent() {\r\n    let proxy = vscode.workspace.getConfiguration().get('http.proxy');\r\n    if (!proxy) {\r\n        proxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;\r\n        if (!proxy) {\r\n            return null;\r\n        }\r\n    }\r\n    let proxyUrl = url.parse(proxy);\r\n    if (proxyUrl.protocol !== \"https:\" && proxyUrl.protocol !== \"http:\") {\r\n        return null;\r\n    }\r\n    let strictProxy = vscode.workspace.getConfiguration().get(\"http.proxyStrictSSL\", true);\r\n    let proxyOptions = {\r\n        host: proxyUrl.hostname,\r\n        port: parseInt(proxyUrl.port, 10),\r\n        auth: proxyUrl.auth,\r\n        rejectUnauthorized: strictProxy\r\n    };\r\n    return new HttpsProxyAgent(proxyOptions);\r\n}\r\nexports.getHttpsProxyAgent = getHttpsProxyAgent;\r\nfunction touchFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.writeFile(file, \"\", (err) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nfunction touchInstallLockFile() {\r\n    return touchFile(getInstallLockPath());\r\n}\r\nexports.touchInstallLockFile = touchInstallLockFile;\r\nfunction touchExtensionFolder() {\r\n    return new Promise((resolve, reject) => {\r\n        fs.utimes(path.resolve(exports.extensionContext.extensionPath, \"..\"), new Date(Date.now()), new Date(Date.now()), (err) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            resolve();\r\n        });\r\n    });\r\n}\r\nexports.touchExtensionFolder = touchExtensionFolder;\r\nfunction checkFileExists(filePath) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.stat(filePath, (err, stats) => {\r\n            if (stats && stats.isFile()) {\r\n                resolve(true);\r\n            }\r\n            else {\r\n                resolve(false);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.checkFileExists = checkFileExists;\r\nfunction checkDirectoryExists(dirPath) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.stat(dirPath, (err, stats) => {\r\n            if (stats && stats.isDirectory()) {\r\n                resolve(true);\r\n            }\r\n            else {\r\n                resolve(false);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.checkDirectoryExists = checkDirectoryExists;\r\nfunction checkFileExistsSync(filePath) {\r\n    try {\r\n        return fs.statSync(filePath).isFile();\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nexports.checkFileExistsSync = checkFileExistsSync;\r\nfunction checkDirectoryExistsSync(dirPath) {\r\n    try {\r\n        return fs.statSync(dirPath).isDirectory();\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nexports.checkDirectoryExistsSync = checkDirectoryExistsSync;\r\nfunction readDir(dirPath) {\r\n    return new Promise((resolve) => {\r\n        fs.readdir(dirPath, (err, list) => {\r\n            resolve(list);\r\n        });\r\n    });\r\n}\r\nexports.readDir = readDir;\r\nfunction checkInstallLockFile() {\r\n    return checkFileExists(getInstallLockPath());\r\n}\r\nexports.checkInstallLockFile = checkInstallLockFile;\r\nfunction readFileText(filePath, encoding = \"utf8\") {\r\n    return new Promise((resolve, reject) => {\r\n        fs.readFile(filePath, encoding, (err, data) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve(data);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.readFileText = readFileText;\r\nfunction writeFileText(filePath, content, encoding = \"utf8\") {\r\n    return new Promise((resolve, reject) => {\r\n        fs.writeFile(filePath, content, { encoding }, (err) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.writeFileText = writeFileText;\r\nfunction deleteFile(filePath) {\r\n    return new Promise((resolve, reject) => {\r\n        if (fs.existsSync(filePath)) {\r\n            fs.unlink(filePath, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            resolve();\r\n        }\r\n    });\r\n}\r\nexports.deleteFile = deleteFile;\r\nfunction getInstallLockPath() {\r\n    return getExtensionFilePath(\"install.lock\");\r\n}\r\nexports.getInstallLockPath = getInstallLockPath;\r\nfunction getReadmeMessage() {\r\n    const readmePath = getExtensionFilePath(\"README.md\");\r\n    const readmeMessage = `Please refer to ${readmePath} for troubleshooting information. Issues can be created at https://github.com/Microsoft/vscode-cpptools/issues`;\r\n    return readmeMessage;\r\n}\r\nexports.getReadmeMessage = getReadmeMessage;\r\nfunction logToFile(message) {\r\n    const logFolder = getExtensionFilePath(\"extension.log\");\r\n    fs.writeFileSync(logFolder, `${message}${os.EOL}`, { flag: 'a' });\r\n}\r\nexports.logToFile = logToFile;\r\nfunction execChildProcess(process, workingDirectory, channel) {\r\n    return new Promise((resolve, reject) => {\r\n        child_process.exec(process, { cwd: workingDirectory, maxBuffer: 500 * 1024 }, (error, stdout, stderr) => {\r\n            if (channel) {\r\n                let message = \"\";\r\n                let err = false;\r\n                if (stdout && stdout.length > 0) {\r\n                    message += stdout;\r\n                }\r\n                if (stderr && stderr.length > 0) {\r\n                    message += stderr;\r\n                    err = true;\r\n                }\r\n                if (error) {\r\n                    message += error.message;\r\n                    err = true;\r\n                }\r\n                if (err) {\r\n                    channel.append(message);\r\n                    channel.show();\r\n                }\r\n            }\r\n            if (error) {\r\n                reject(error);\r\n                return;\r\n            }\r\n            if (stderr && stderr.length > 0) {\r\n                reject(new Error(stderr));\r\n                return;\r\n            }\r\n            resolve(stdout);\r\n        });\r\n    });\r\n}\r\nexports.execChildProcess = execChildProcess;\r\nfunction spawnChildProcess(process, args, workingDirectory, dataCallback, errorCallback) {\r\n    return new Promise(function (resolve, reject) {\r\n        const child = child_process.spawn(process, args, { cwd: workingDirectory });\r\n        child.stdout.on('data', (data) => {\r\n            dataCallback(`${data}`);\r\n        });\r\n        child.stderr.on('data', (data) => {\r\n            errorCallback(`${data}`);\r\n        });\r\n        child.on('exit', (code) => {\r\n            if (code !== 0) {\r\n                reject(new Error(`${process} exited with error code ${code}`));\r\n            }\r\n            else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.spawnChildProcess = spawnChildProcess;\r\nfunction allowExecution(file) {\r\n    return new Promise((resolve, reject) => {\r\n        if (process.platform !== 'win32') {\r\n            checkFileExists(file).then((exists) => {\r\n                if (exists) {\r\n                    fs.chmod(file, '755', (err) => {\r\n                        if (err) {\r\n                            reject(err);\r\n                            return;\r\n                        }\r\n                        resolve();\r\n                    });\r\n                }\r\n                else {\r\n                    logger_1.getOutputChannelLogger().appendLine(\"\");\r\n                    logger_1.getOutputChannelLogger().appendLine(`Warning: Expected file ${file} is missing.`);\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            resolve();\r\n        }\r\n    });\r\n}\r\nexports.allowExecution = allowExecution;\r\nfunction removePotentialPII(str) {\r\n    let words = str.split(\" \");\r\n    let result = \"\";\r\n    for (let word of words) {\r\n        if (word.indexOf(\".\") === -1 && word.indexOf(\"/\") === -1 && word.indexOf(\"\\\\\") === -1 && word.indexOf(\":\") === -1) {\r\n            result += word + \" \";\r\n        }\r\n        else {\r\n            result += \"? \";\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.removePotentialPII = removePotentialPII;\r\nfunction checkDistro(platformInfo) {\r\n    if (platformInfo.platform !== 'win32' && platformInfo.platform !== 'linux' && platformInfo.platform !== 'darwin') {\r\n        logger_1.getOutputChannelLogger().appendLine(`Warning: Debugging has not been tested for this platform. ${getReadmeMessage()}`);\r\n    }\r\n}\r\nexports.checkDistro = checkDistro;\r\nfunction unlinkPromise(fileName) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        return new Promise((resolve, reject) => {\r\n            fs.unlink(fileName, err => {\r\n                if (err) {\r\n                    return reject(err);\r\n                }\r\n                return resolve();\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.unlinkPromise = unlinkPromise;\r\nfunction renamePromise(oldName, newName) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        return new Promise((resolve, reject) => {\r\n            fs.rename(oldName, newName, err => {\r\n                if (err) {\r\n                    return reject(err);\r\n                }\r\n                return resolve();\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.renamePromise = renamePromise;\r\nfunction promptForReloadWindowDueToSettingsChange() {\r\n    promptReloadWindow(\"Reload the workspace for the settings change to take effect.\");\r\n}\r\nexports.promptForReloadWindowDueToSettingsChange = promptForReloadWindowDueToSettingsChange;\r\nfunction promptReloadWindow(message) {\r\n    let reload = \"Reload\";\r\n    vscode.window.showInformationMessage(message, reload).then((value) => {\r\n        if (value === reload) {\r\n            vscode.commands.executeCommand(\"workbench.action.reloadWindow\");\r\n        }\r\n    });\r\n}\r\nexports.promptReloadWindow = promptReloadWindow;\r\nfunction downloadFileToDestination(urlStr, destinationPath, headers) {\r\n    return new Promise((resolve, reject) => {\r\n        let parsedUrl = url.parse(urlStr);\r\n        let request = https.request({\r\n            host: parsedUrl.host,\r\n            path: parsedUrl.path,\r\n            agent: getHttpsProxyAgent(),\r\n            rejectUnauthorized: vscode.workspace.getConfiguration().get('http.proxyStrictSSL', true),\r\n            headers: headers\r\n        }, (response) => {\r\n            if (response.statusCode === 301 || response.statusCode === 302) {\r\n                let redirectUrl;\r\n                if (typeof response.headers.location === 'string') {\r\n                    redirectUrl = response.headers.location;\r\n                }\r\n                else {\r\n                    redirectUrl = response.headers.location[0];\r\n                }\r\n                return resolve(downloadFileToDestination(redirectUrl, destinationPath, headers));\r\n            }\r\n            if (response.statusCode !== 200) {\r\n                return reject();\r\n            }\r\n            let createdFile = fs.createWriteStream(destinationPath);\r\n            createdFile.on('finish', () => { resolve(); });\r\n            response.on('error', (error) => { reject(error); });\r\n            response.pipe(createdFile);\r\n        });\r\n        request.on('error', (error) => { reject(error); });\r\n        request.end();\r\n    });\r\n}\r\nexports.downloadFileToDestination = downloadFileToDestination;\r\nfunction downloadFileToStr(urlStr, headers) {\r\n    return new Promise((resolve, reject) => {\r\n        let parsedUrl = url.parse(urlStr);\r\n        let request = https.request({\r\n            host: parsedUrl.host,\r\n            path: parsedUrl.path,\r\n            agent: getHttpsProxyAgent(),\r\n            rejectUnauthorized: vscode.workspace.getConfiguration().get('http.proxyStrictSSL', true),\r\n            headers: headers\r\n        }, (response) => {\r\n            if (response.statusCode === 301 || response.statusCode === 302) {\r\n                let redirectUrl;\r\n                if (typeof response.headers.location === 'string') {\r\n                    redirectUrl = response.headers.location;\r\n                }\r\n                else {\r\n                    redirectUrl = response.headers.location[0];\r\n                }\r\n                return resolve(downloadFileToStr(redirectUrl, headers));\r\n            }\r\n            if (response.statusCode !== 200) {\r\n                return reject();\r\n            }\r\n            let downloadedData = '';\r\n            response.on('data', (data) => { downloadedData += data; });\r\n            response.on('error', (error) => { reject(error); });\r\n            response.on('end', () => { resolve(downloadedData); });\r\n        });\r\n        request.on('error', (error) => { reject(error); });\r\n        request.end();\r\n    });\r\n}\r\nexports.downloadFileToStr = downloadFileToStr;\r\nfunction extractCompilerPathAndArgs(inputCompilerPath) {\r\n    let compilerPath = inputCompilerPath;\r\n    let additionalArgs;\r\n    let isWindows = os.platform() === 'win32';\r\n    if (compilerPath) {\r\n        compilerPath = compilerPath.trim();\r\n        if (compilerPath.startsWith(\"\\\"\")) {\r\n            let endQuote = compilerPath.substr(1).search(\"\\\"\") + 1;\r\n            if (endQuote !== -1) {\r\n                additionalArgs = compilerPath.substr(endQuote + 1).split(\" \");\r\n                additionalArgs = additionalArgs.filter((arg) => { return arg.trim().length !== 0; });\r\n                compilerPath = compilerPath.substr(1, endQuote - 1);\r\n            }\r\n        }\r\n        else {\r\n            let spaceStart = compilerPath.lastIndexOf(\" \");\r\n            if (spaceStart !== -1 && (!isWindows || !compilerPath.endsWith(\"cl.exe\")) && !checkFileExistsSync(compilerPath)) {\r\n                let potentialCompilerPath = compilerPath.substr(0, spaceStart);\r\n                while ((!isWindows || !potentialCompilerPath.endsWith(\"cl.exe\")) && !checkFileExistsSync(potentialCompilerPath)) {\r\n                    spaceStart = potentialCompilerPath.lastIndexOf(\" \");\r\n                    if (spaceStart === -1) {\r\n                        potentialCompilerPath = compilerPath;\r\n                        break;\r\n                    }\r\n                    potentialCompilerPath = potentialCompilerPath.substr(0, spaceStart);\r\n                }\r\n                if (compilerPath !== potentialCompilerPath) {\r\n                    additionalArgs = compilerPath.substr(spaceStart + 1).split(\" \");\r\n                    additionalArgs = additionalArgs.filter((arg) => { return arg.trim().length !== 0; });\r\n                    compilerPath = potentialCompilerPath;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { compilerPath, additionalArgs };\r\n}\r\nexports.extractCompilerPathAndArgs = extractCompilerPathAndArgs;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9jb21tb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxuY29uc3QgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jb25zdCBUZWxlbWV0cnkgPSByZXF1aXJlKFwiLi90ZWxlbWV0cnlcIik7XHJcbmNvbnN0IEh0dHBzUHJveHlBZ2VudCA9IHJlcXVpcmUoXCJodHRwcy1wcm94eS1hZ2VudFwiKTtcclxuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcclxuY29uc3QgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xyXG5jb25zdCBleHRlbnNpb25fMSA9IHJlcXVpcmUoXCIuL0xhbmd1YWdlU2VydmVyL2V4dGVuc2lvblwiKTtcclxuZnVuY3Rpb24gc2V0RXh0ZW5zaW9uQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICBleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQgPSBjb250ZXh0O1xyXG59XHJcbmV4cG9ydHMuc2V0RXh0ZW5zaW9uQ29udGV4dCA9IHNldEV4dGVuc2lvbkNvbnRleHQ7XHJcbmV4cG9ydHMucGFja2FnZUpzb24gPSB2c2NvZGUuZXh0ZW5zaW9ucy5nZXRFeHRlbnNpb24oXCJtcy12c2NvZGUuY3BwdG9vbHNcIikucGFja2FnZUpTT047XHJcbmxldCByYXdQYWNrYWdlSnNvbiA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldFJhd1BhY2thZ2VKc29uKCkge1xyXG4gICAgaWYgKHJhd1BhY2thZ2VKc29uID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGdldFBhY2thZ2VKc29uUGF0aCgpKTtcclxuICAgICAgICByYXdQYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnRzLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhd1BhY2thZ2VKc29uO1xyXG59XHJcbmV4cG9ydHMuZ2V0UmF3UGFja2FnZUpzb24gPSBnZXRSYXdQYWNrYWdlSnNvbjtcclxuZnVuY3Rpb24gZ2V0UmF3VGFza3NKc29uKCkge1xyXG4gICAgY29uc3QgcGF0aCA9IGdldFRhc2tzSnNvblBhdGgoKTtcclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGZzLmV4aXN0cyhwYXRoLCBleGlzdHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcclxuICAgICAgICAgICAgbGV0IHJhd1Rhc2tzID0ge307XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByYXdUYXNrcyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnRzLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUocmF3VGFza3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5nZXRSYXdUYXNrc0pzb24gPSBnZXRSYXdUYXNrc0pzb247XHJcbmZ1bmN0aW9uIGVuc3VyZUJ1aWxkVGFza0V4aXN0cyh0YXNrTmFtZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgcmF3VGFza3NKc29uID0geWllbGQgZ2V0UmF3VGFza3NKc29uKCk7XHJcbiAgICAgICAgaWYgKCFyYXdUYXNrc0pzb24udGFza3MpIHtcclxuICAgICAgICAgICAgcmF3VGFza3NKc29uLnRhc2tzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZWxlY3RlZFRhc2sgPSByYXdUYXNrc0pzb24udGFza3MuZmluZCh0YXNrID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhc2subGFiZWwgJiYgdGFzay5sYWJlbCA9PT0gdGFzaztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRUYXNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVpbGRUYXNrcyA9IHlpZWxkIGV4dGVuc2lvbl8xLmdldEJ1aWxkVGFza3MoKTtcclxuICAgICAgICBzZWxlY3RlZFRhc2sgPSBidWlsZFRhc2tzLmZpbmQodGFzayA9PiB0YXNrLm5hbWUgPT09IHRhc2tOYW1lKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChzZWxlY3RlZFRhc2spO1xyXG4gICAgICAgIGxldCBkZWZpbml0aW9uID0gc2VsZWN0ZWRUYXNrLmRlZmluaXRpb247XHJcbiAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5jb21waWxlclBhdGgpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGRlZmluaXRpb24uY29tcGlsZXJQYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByYXdUYXNrc0pzb24udmVyc2lvbiA9IFwiMi4wLjBcIjtcclxuICAgICAgICBpZiAoIXJhd1Rhc2tzSnNvbi50YXNrcy5maW5kKHRhc2sgPT4geyByZXR1cm4gdGFzay5sYWJlbCA9PT0gc2VsZWN0ZWRUYXNrLmRlZmluaXRpb24ubGFiZWw7IH0pKSB7XHJcbiAgICAgICAgICAgIHJhd1Rhc2tzSnNvbi50YXNrcy5wdXNoKHNlbGVjdGVkVGFzay5kZWZpbml0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgd3JpdGVGaWxlVGV4dChnZXRUYXNrc0pzb25QYXRoKCksIEpTT04uc3RyaW5naWZ5KHJhd1Rhc2tzSnNvbiwgbnVsbCwgMikpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5lbnN1cmVCdWlsZFRhc2tFeGlzdHMgPSBlbnN1cmVCdWlsZFRhc2tFeGlzdHM7XHJcbmZ1bmN0aW9uIGZpbGVJc0NPckNwcFNvdXJjZShmaWxlKSB7XHJcbiAgICBjb25zdCBmaWxlRXh0TG93ZXIgPSBwYXRoLmV4dG5hbWUoZmlsZSkudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiBbXCIuQ1wiLCBcIi5jXCIsIFwiLmNwcFwiLCBcIi5jY1wiLCBcIi5jeHhcIiwgXCIubW1cIiwgXCIuaW5vXCIsIFwiLmlubFwiXS5zb21lKGV4dCA9PiBmaWxlRXh0TG93ZXIgPT09IGV4dCk7XHJcbn1cclxuZXhwb3J0cy5maWxlSXNDT3JDcHBTb3VyY2UgPSBmaWxlSXNDT3JDcHBTb3VyY2U7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVBhY2thZ2VKc29uKHBhY2thZ2VKc29uKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5naWZ5UGFja2FnZUpzb24gPSBzdHJpbmdpZnlQYWNrYWdlSnNvbjtcclxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRmlsZVBhdGgoZXh0ZW5zaW9uZmlsZSkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQuZXh0ZW5zaW9uUGF0aCwgZXh0ZW5zaW9uZmlsZSk7XHJcbn1cclxuZXhwb3J0cy5nZXRFeHRlbnNpb25GaWxlUGF0aCA9IGdldEV4dGVuc2lvbkZpbGVQYXRoO1xyXG5mdW5jdGlvbiBnZXRQYWNrYWdlSnNvblBhdGgoKSB7XHJcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRmlsZVBhdGgoXCJwYWNrYWdlLmpzb25cIik7XHJcbn1cclxuZXhwb3J0cy5nZXRQYWNrYWdlSnNvblBhdGggPSBnZXRQYWNrYWdlSnNvblBhdGg7XHJcbmZ1bmN0aW9uIGdldFRhc2tzSnNvblBhdGgoKSB7XHJcbiAgICBjb25zdCBlZGl0b3IgPSB2c2NvZGUud2luZG93LmFjdGl2ZVRleHRFZGl0b3I7XHJcbiAgICBjb25zdCBmb2xkZXIgPSB2c2NvZGUud29ya3NwYWNlLmdldFdvcmtzcGFjZUZvbGRlcihlZGl0b3IuZG9jdW1lbnQudXJpKTtcclxuICAgIGlmICghZm9sZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLmpvaW4oZm9sZGVyLnVyaS5mc1BhdGgsIFwiLnZzY29kZVwiLCBcInRhc2tzLmpzb25cIik7XHJcbn1cclxuZXhwb3J0cy5nZXRUYXNrc0pzb25QYXRoID0gZ2V0VGFza3NKc29uUGF0aDtcclxuZnVuY3Rpb24gZ2V0VmNwa2dQYXRoRGVzY3JpcHRvckZpbGUoKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4ocHJvY2Vzcy5lbnYuTE9DQUxBUFBEQVRBLCBcInZjcGtnL3ZjcGtnLnBhdGgudHh0XCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbihwcm9jZXNzLmVudi5IT01FLCBcIi52Y3BrZy92Y3BrZy5wYXRoLnR4dFwiKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldFZjcGtnUGF0aERlc2NyaXB0b3JGaWxlID0gZ2V0VmNwa2dQYXRoRGVzY3JpcHRvckZpbGU7XHJcbmxldCB2Y3BrZ1Jvb3Q7XHJcbmZ1bmN0aW9uIGdldFZjcGtnUm9vdCgpIHtcclxuICAgIGlmICghdmNwa2dSb290ICYmIHZjcGtnUm9vdCAhPT0gXCJcIikge1xyXG4gICAgICAgIHZjcGtnUm9vdCA9IFwiXCI7XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZ2V0VmNwa2dQYXRoRGVzY3JpcHRvckZpbGUoKSkpIHtcclxuICAgICAgICAgICAgbGV0IHZjcGtnUm9vdFRlbXAgPSBmcy5yZWFkRmlsZVN5bmMoZ2V0VmNwa2dQYXRoRGVzY3JpcHRvckZpbGUoKSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmNwa2dSb290VGVtcCA9IHZjcGtnUm9vdFRlbXAudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyh2Y3BrZ1Jvb3RUZW1wKSkge1xyXG4gICAgICAgICAgICAgICAgdmNwa2dSb290ID0gcGF0aC5qb2luKHZjcGtnUm9vdFRlbXAsIFwiL2luc3RhbGxlZFwiKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2Y3BrZ1Jvb3Q7XHJcbn1cclxuZXhwb3J0cy5nZXRWY3BrZ1Jvb3QgPSBnZXRWY3BrZ1Jvb3Q7XHJcbmZ1bmN0aW9uIGlzSGVhZGVyKGRvY3VtZW50KSB7XHJcbiAgICBsZXQgZXh0ID0gcGF0aC5leHRuYW1lKGRvY3VtZW50LnVyaS5mc1BhdGgpO1xyXG4gICAgcmV0dXJuICFleHQgfHwgZXh0LnN0YXJ0c1dpdGgoXCIuaFwiKSB8fCBleHQuc3RhcnRzV2l0aChcIi5IXCIpO1xyXG59XHJcbmV4cG9ydHMuaXNIZWFkZXIgPSBpc0hlYWRlcjtcclxuZnVuY3Rpb24gaXNFeHRlbnNpb25SZWFkeSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgZG9lc0luc3RhbGxMb2NrRmlsZUV4aXN0ID0geWllbGQgY2hlY2tJbnN0YWxsTG9ja0ZpbGUoKTtcclxuICAgICAgICByZXR1cm4gZG9lc0luc3RhbGxMb2NrRmlsZUV4aXN0O1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5pc0V4dGVuc2lvblJlYWR5ID0gaXNFeHRlbnNpb25SZWFkeTtcclxubGV0IGlzRXh0ZW5zaW9uTm90UmVhZHlQcm9tcHREaXNwbGF5ZWQgPSBmYWxzZTtcclxuZXhwb3J0cy5leHRlbnNpb25Ob3RSZWFkeVN0cmluZyA9ICdUaGUgQy9DKysgZXh0ZW5zaW9uIGlzIHN0aWxsIGluc3RhbGxpbmcuIFNlZSB0aGUgb3V0cHV0IHdpbmRvdyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xyXG5mdW5jdGlvbiBkaXNwbGF5RXh0ZW5zaW9uTm90UmVhZHlQcm9tcHQoKSB7XHJcbiAgICBpZiAoIWlzRXh0ZW5zaW9uTm90UmVhZHlQcm9tcHREaXNwbGF5ZWQpIHtcclxuICAgICAgICBpc0V4dGVuc2lvbk5vdFJlYWR5UHJvbXB0RGlzcGxheWVkID0gdHJ1ZTtcclxuICAgICAgICBsb2dnZXJfMS5zaG93T3V0cHV0Q2hhbm5lbCgpO1xyXG4gICAgICAgIGxvZ2dlcl8xLmdldE91dHB1dENoYW5uZWxMb2dnZXIoKS5zaG93SW5mb3JtYXRpb25NZXNzYWdlKGV4cG9ydHMuZXh0ZW5zaW9uTm90UmVhZHlTdHJpbmcpLnRoZW4oKCkgPT4geyBpc0V4dGVuc2lvbk5vdFJlYWR5UHJvbXB0RGlzcGxheWVkID0gZmFsc2U7IH0sICgpID0+IHsgaXNFeHRlbnNpb25Ob3RSZWFkeVByb21wdERpc3BsYXllZCA9IGZhbHNlOyB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRpc3BsYXlFeHRlbnNpb25Ob3RSZWFkeVByb21wdCA9IGRpc3BsYXlFeHRlbnNpb25Ob3RSZWFkeVByb21wdDtcclxuY29uc3QgcHJvZ3Jlc3NJbnN0YWxsU3VjY2VzcyA9IDEwMDtcclxuY29uc3QgcHJvZ3Jlc3NFeGVjdXRhYmxlU3RhcnRlZCA9IDE1MDtcclxuY29uc3QgcHJvZ3Jlc3NFeGVjdXRhYmxlU3VjY2VzcyA9IDIwMDtcclxuY29uc3QgcHJvZ3Jlc3NQYXJzZVJvb3RTdWNjZXNzID0gMzAwO1xyXG5jb25zdCBwcm9ncmVzc0ludGVsbGlTZW5zZU5vU3F1aWdnbGVzID0gMTAwMDtcclxubGV0IGluc3RhbGxQcm9ncmVzc1N0ciA9IFwiQ1BQLlwiICsgZXhwb3J0cy5wYWNrYWdlSnNvbi52ZXJzaW9uICsgXCIuUHJvZ3Jlc3NcIjtcclxubGV0IGludGVsbGlTZW5zZVByb2dyZXNzU3RyID0gXCJDUFAuXCIgKyBleHBvcnRzLnBhY2thZ2VKc29uLnZlcnNpb24gKyBcIi5JbnRlbGxpU2Vuc2VQcm9ncmVzc1wiO1xyXG5mdW5jdGlvbiBnZXRQcm9ncmVzcygpIHtcclxuICAgIHJldHVybiBleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQuZ2xvYmFsU3RhdGUuZ2V0KGluc3RhbGxQcm9ncmVzc1N0ciwgLTEpO1xyXG59XHJcbmV4cG9ydHMuZ2V0UHJvZ3Jlc3MgPSBnZXRQcm9ncmVzcztcclxuZnVuY3Rpb24gZ2V0SW50ZWxsaVNlbnNlUHJvZ3Jlc3MoKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbnNpb25Db250ZXh0Lmdsb2JhbFN0YXRlLmdldChpbnRlbGxpU2Vuc2VQcm9ncmVzc1N0ciwgLTEpO1xyXG59XHJcbmV4cG9ydHMuZ2V0SW50ZWxsaVNlbnNlUHJvZ3Jlc3MgPSBnZXRJbnRlbGxpU2Vuc2VQcm9ncmVzcztcclxuZnVuY3Rpb24gc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcclxuICAgIGlmIChnZXRQcm9ncmVzcygpIDwgcHJvZ3Jlc3MpIHtcclxuICAgICAgICBleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQuZ2xvYmFsU3RhdGUudXBkYXRlKGluc3RhbGxQcm9ncmVzc1N0ciwgcHJvZ3Jlc3MpO1xyXG4gICAgICAgIGxldCB0ZWxlbWV0cnlQcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgbGV0IHByb2dyZXNzTmFtZTtcclxuICAgICAgICBzd2l0Y2ggKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzTmFtZSA9IFwiaW5zdGFsbCBzdGFydGVkXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm9ncmVzc0luc3RhbGxTdWNjZXNzOlxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOYW1lID0gXCJpbnN0YWxsIHN1Y2NlZWRlZFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvZ3Jlc3NFeGVjdXRhYmxlU3RhcnRlZDpcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzTmFtZSA9IFwiZXhlY3V0YWJsZSBzdGFydGVkXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwcm9ncmVzc0V4ZWN1dGFibGVTdWNjZXNzOlxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOYW1lID0gXCJleGVjdXRhYmxlIHN1Y2NlZWRlZFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvZ3Jlc3NQYXJzZVJvb3RTdWNjZXNzOlxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NOYW1lID0gXCJwYXJzZSByb290IHN1Y2NlZWRlZFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbGVtZXRyeVByb3BlcnRpZXNbJ3Byb2dyZXNzJ10gPSBwcm9ncmVzc05hbWU7XHJcbiAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJwcm9ncmVzc1wiLCB0ZWxlbWV0cnlQcm9wZXJ0aWVzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNldFByb2dyZXNzID0gc2V0UHJvZ3Jlc3M7XHJcbmZ1bmN0aW9uIHNldEludGVsbGlTZW5zZVByb2dyZXNzKHByb2dyZXNzKSB7XHJcbiAgICBpZiAoZ2V0SW50ZWxsaVNlbnNlUHJvZ3Jlc3MoKSA8IHByb2dyZXNzKSB7XHJcbiAgICAgICAgZXhwb3J0cy5leHRlbnNpb25Db250ZXh0Lmdsb2JhbFN0YXRlLnVwZGF0ZShpbnRlbGxpU2Vuc2VQcm9ncmVzc1N0ciwgcHJvZ3Jlc3MpO1xyXG4gICAgICAgIGxldCB0ZWxlbWV0cnlQcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgbGV0IHByb2dyZXNzTmFtZTtcclxuICAgICAgICBzd2l0Y2ggKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvZ3Jlc3NJbnRlbGxpU2Vuc2VOb1NxdWlnZ2xlczpcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzTmFtZSA9IFwiSW50ZWxsaVNlbnNlIG5vIHNxdWlnZ2xlc1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbGVtZXRyeVByb3BlcnRpZXNbJ3Byb2dyZXNzJ10gPSBwcm9ncmVzc05hbWU7XHJcbiAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJwcm9ncmVzc1wiLCB0ZWxlbWV0cnlQcm9wZXJ0aWVzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNldEludGVsbGlTZW5zZVByb2dyZXNzID0gc2V0SW50ZWxsaVNlbnNlUHJvZ3Jlc3M7XHJcbmZ1bmN0aW9uIGdldFByb2dyZXNzSW5zdGFsbFN1Y2Nlc3MoKSB7IHJldHVybiBwcm9ncmVzc0luc3RhbGxTdWNjZXNzOyB9XHJcbmV4cG9ydHMuZ2V0UHJvZ3Jlc3NJbnN0YWxsU3VjY2VzcyA9IGdldFByb2dyZXNzSW5zdGFsbFN1Y2Nlc3M7XHJcbmZ1bmN0aW9uIGdldFByb2dyZXNzRXhlY3V0YWJsZVN0YXJ0ZWQoKSB7IHJldHVybiBwcm9ncmVzc0V4ZWN1dGFibGVTdGFydGVkOyB9XHJcbmV4cG9ydHMuZ2V0UHJvZ3Jlc3NFeGVjdXRhYmxlU3RhcnRlZCA9IGdldFByb2dyZXNzRXhlY3V0YWJsZVN0YXJ0ZWQ7XHJcbmZ1bmN0aW9uIGdldFByb2dyZXNzRXhlY3V0YWJsZVN1Y2Nlc3MoKSB7IHJldHVybiBwcm9ncmVzc0V4ZWN1dGFibGVTdWNjZXNzOyB9XHJcbmV4cG9ydHMuZ2V0UHJvZ3Jlc3NFeGVjdXRhYmxlU3VjY2VzcyA9IGdldFByb2dyZXNzRXhlY3V0YWJsZVN1Y2Nlc3M7XHJcbmZ1bmN0aW9uIGdldFByb2dyZXNzUGFyc2VSb290U3VjY2VzcygpIHsgcmV0dXJuIHByb2dyZXNzUGFyc2VSb290U3VjY2VzczsgfVxyXG5leHBvcnRzLmdldFByb2dyZXNzUGFyc2VSb290U3VjY2VzcyA9IGdldFByb2dyZXNzUGFyc2VSb290U3VjY2VzcztcclxuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NJbnRlbGxpU2Vuc2VOb1NxdWlnZ2xlcygpIHsgcmV0dXJuIHByb2dyZXNzSW50ZWxsaVNlbnNlTm9TcXVpZ2dsZXM7IH1cclxuZXhwb3J0cy5nZXRQcm9ncmVzc0ludGVsbGlTZW5zZU5vU3F1aWdnbGVzID0gZ2V0UHJvZ3Jlc3NJbnRlbGxpU2Vuc2VOb1NxdWlnZ2xlcztcclxubGV0IHJlbGVhc2VOb3Rlc1BhbmVsID0gdW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBzaG93UmVsZWFzZU5vdGVzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAocmVsZWFzZU5vdGVzUGFuZWwpIHtcclxuICAgICAgICAgICAgcmVsZWFzZU5vdGVzUGFuZWwucmV2ZWFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWxlYXNlTm90ZXNQYW5lbCA9IHZzY29kZS53aW5kb3cuY3JlYXRlV2Vidmlld1BhbmVsKCdyZWxlYXNlTm90ZXMnLCBcIkMvQysrIEV4dGVuc2lvbiBSZWxlYXNlIE5vdGVzXCIsIHZzY29kZS5WaWV3Q29sdW1uLk9uZSk7XHJcbiAgICAgICAgICAgIHJlbGVhc2VOb3Rlc1BhbmVsLndlYnZpZXcuaHRtbCA9IHlpZWxkIHJlYWRGaWxlVGV4dChnZXRFeHRlbnNpb25GaWxlUGF0aChcIlJlbGVhc2VOb3Rlcy5odG1sXCIpKTtcclxuICAgICAgICAgICAgcmVsZWFzZU5vdGVzUGFuZWwub25EaWREaXNwb3NlKCgpID0+IHJlbGVhc2VOb3Rlc1BhbmVsID0gdW5kZWZpbmVkLCBudWxsLCBleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQuc3Vic2NyaXB0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5zaG93UmVsZWFzZU5vdGVzID0gc2hvd1JlbGVhc2VOb3RlcztcclxuZnVuY3Rpb24gaXNVcmkoaW5wdXQpIHtcclxuICAgIHJldHVybiBpbnB1dCAmJiBpbnB1dCBpbnN0YW5jZW9mIHZzY29kZS5Vcmk7XHJcbn1cclxuZXhwb3J0cy5pc1VyaSA9IGlzVXJpO1xyXG5mdW5jdGlvbiBpc1N0cmluZyhpbnB1dCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiAoaW5wdXQpID09PSBcInN0cmluZ1wiO1xyXG59XHJcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcclxuZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcclxuICAgIHJldHVybiB0eXBlb2YgKGlucHV0KSA9PT0gXCJudW1iZXJcIjtcclxufVxyXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XHJcbmZ1bmN0aW9uIGlzQm9vbGVhbihpbnB1dCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiAoaW5wdXQpID09PSBcImJvb2xlYW5cIjtcclxufVxyXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcclxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXk7XHJcbn1cclxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcclxuZnVuY3Rpb24gaXNPcHRpb25hbFN0cmluZyhpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0ID09PSB1bmRlZmluZWQgfHwgaXNTdHJpbmcoaW5wdXQpO1xyXG59XHJcbmV4cG9ydHMuaXNPcHRpb25hbFN0cmluZyA9IGlzT3B0aW9uYWxTdHJpbmc7XHJcbmZ1bmN0aW9uIGlzQXJyYXlPZlN0cmluZyhpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGl0ZW0gPT4gaXNTdHJpbmcoaXRlbSkpO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheU9mU3RyaW5nID0gaXNBcnJheU9mU3RyaW5nO1xyXG5mdW5jdGlvbiBpc09wdGlvbmFsQXJyYXlPZlN0cmluZyhpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0ID09PSB1bmRlZmluZWQgfHwgaXNBcnJheU9mU3RyaW5nKGlucHV0KTtcclxufVxyXG5leHBvcnRzLmlzT3B0aW9uYWxBcnJheU9mU3RyaW5nID0gaXNPcHRpb25hbEFycmF5T2ZTdHJpbmc7XHJcbmZ1bmN0aW9uIHJlc29sdmVWYXJpYWJsZXMoaW5wdXQsIGFkZGl0aW9uYWxFbnZpcm9ubWVudCkge1xyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhZGRpdGlvbmFsRW52aXJvbm1lbnQpIHtcclxuICAgICAgICBhZGRpdGlvbmFsRW52aXJvbm1lbnQgPSB7fTtcclxuICAgIH1cclxuICAgIGxldCByZWdleHAgPSAoKSA9PiAvXFwkXFx7KChlbnZ8Y29uZmlnfHdvcmtzcGFjZUZvbGRlcikoXFwufDopKT8oLio/KVxcfS9nO1xyXG4gICAgbGV0IHJldCA9IGlucHV0O1xyXG4gICAgbGV0IGN5Y2xlQ2FjaGUgPSBuZXcgU2V0KCk7XHJcbiAgICB3aGlsZSAoIWN5Y2xlQ2FjaGUuaGFzKHJldCkpIHtcclxuICAgICAgICBjeWNsZUNhY2hlLmFkZChyZXQpO1xyXG4gICAgICAgIHJldCA9IHJldC5yZXBsYWNlKHJlZ2V4cCgpLCAobWF0Y2gsIGlnbm9yZWQxLCB2YXJUeXBlLCBpZ25vcmVkMiwgbmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFyVHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXJUeXBlID0gXCJlbnZcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodmFyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVudlwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHYgPSBhZGRpdGlvbmFsRW52aXJvbm1lbnRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQgPT09IG1hdGNoICYmIGlzQXJyYXlPZlN0cmluZyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHYuam9pbihcIjtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gcHJvY2Vzcy5lbnZbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbmZpZ1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjb25maWcuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3b3Jrc3BhY2VGb2xkZXJcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHZzY29kZS53b3Jrc3BhY2UgJiYgdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZXIgPSB2c2NvZGUud29ya3NwYWNlLndvcmtzcGFjZUZvbGRlcnMuZmluZChmb2xkZXIgPT4gZm9sZGVyLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBmb2xkZXIudXJpLmZzUGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcInVua25vd24gdmFyVHlwZSBtYXRjaGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpbmcobmV3VmFsdWUpKSA/IG5ld1ZhbHVlIDogbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZWdleHAgPSAoKSA9PiAvXlxcfi9nO1xyXG4gICAgcmV0ID0gcmV0LnJlcGxhY2UocmVnZXhwKCksIChtYXRjaCwgbmFtZSkgPT4ge1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSA/IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFIDogcHJvY2Vzcy5lbnYuSE9NRTtcclxuICAgICAgICByZXR1cm4gKG5ld1ZhbHVlKSA/IG5ld1ZhbHVlIDogbWF0Y2g7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZlVmFyaWFibGVzID0gcmVzb2x2ZVZhcmlhYmxlcztcclxuZnVuY3Rpb24gYXNGb2xkZXIodXJpKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gdXJpLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgIT09ICcvJykge1xyXG4gICAgICAgIHJlc3VsdCArPSAnLyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuYXNGb2xkZXIgPSBhc0ZvbGRlcjtcclxuZnVuY3Rpb24gZ2V0T3BlbkNvbW1hbmQoKSB7XHJcbiAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICAgIHJldHVybiAnZXhwbG9yZXInO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ2RhcndpbicpIHtcclxuICAgICAgICByZXR1cm4gJy91c3IvYmluL29wZW4nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcvdXNyL2Jpbi94ZGctb3Blbic7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRPcGVuQ29tbWFuZCA9IGdldE9wZW5Db21tYW5kO1xyXG5mdW5jdGlvbiBnZXREZWJ1Z0FkYXB0ZXJzUGF0aChmaWxlKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGdldEV4dGVuc2lvbkZpbGVQYXRoKFwiZGVidWdBZGFwdGVyc1wiKSwgZmlsZSk7XHJcbn1cclxuZXhwb3J0cy5nZXREZWJ1Z0FkYXB0ZXJzUGF0aCA9IGdldERlYnVnQWRhcHRlcnNQYXRoO1xyXG5mdW5jdGlvbiBnZXRIdHRwc1Byb3h5QWdlbnQoKSB7XHJcbiAgICBsZXQgcHJveHkgPSB2c2NvZGUud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24oKS5nZXQoJ2h0dHAucHJveHknKTtcclxuICAgIGlmICghcHJveHkpIHtcclxuICAgICAgICBwcm94eSA9IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcclxuICAgICAgICBpZiAoIXByb3h5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBwcm94eVVybCA9IHVybC5wYXJzZShwcm94eSk7XHJcbiAgICBpZiAocHJveHlVcmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgJiYgcHJveHlVcmwucHJvdG9jb2wgIT09IFwiaHR0cDpcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0cmljdFByb3h5ID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCkuZ2V0KFwiaHR0cC5wcm94eVN0cmljdFNTTFwiLCB0cnVlKTtcclxuICAgIGxldCBwcm94eU9wdGlvbnMgPSB7XHJcbiAgICAgICAgaG9zdDogcHJveHlVcmwuaG9zdG5hbWUsXHJcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocHJveHlVcmwucG9ydCwgMTApLFxyXG4gICAgICAgIGF1dGg6IHByb3h5VXJsLmF1dGgsXHJcbiAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBzdHJpY3RQcm94eVxyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgSHR0cHNQcm94eUFnZW50KHByb3h5T3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5nZXRIdHRwc1Byb3h5QWdlbnQgPSBnZXRIdHRwc1Byb3h5QWdlbnQ7XHJcbmZ1bmN0aW9uIHRvdWNoRmlsZShmaWxlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGZzLndyaXRlRmlsZShmaWxlLCBcIlwiLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRvdWNoSW5zdGFsbExvY2tGaWxlKCkge1xyXG4gICAgcmV0dXJuIHRvdWNoRmlsZShnZXRJbnN0YWxsTG9ja1BhdGgoKSk7XHJcbn1cclxuZXhwb3J0cy50b3VjaEluc3RhbGxMb2NrRmlsZSA9IHRvdWNoSW5zdGFsbExvY2tGaWxlO1xyXG5mdW5jdGlvbiB0b3VjaEV4dGVuc2lvbkZvbGRlcigpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgZnMudXRpbWVzKHBhdGgucmVzb2x2ZShleHBvcnRzLmV4dGVuc2lvbkNvbnRleHQuZXh0ZW5zaW9uUGF0aCwgXCIuLlwiKSwgbmV3IERhdGUoRGF0ZS5ub3coKSksIG5ldyBEYXRlKERhdGUubm93KCkpLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudG91Y2hFeHRlbnNpb25Gb2xkZXIgPSB0b3VjaEV4dGVuc2lvbkZvbGRlcjtcclxuZnVuY3Rpb24gY2hlY2tGaWxlRXhpc3RzKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGZzLnN0YXQoZmlsZVBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmNoZWNrRmlsZUV4aXN0cyA9IGNoZWNrRmlsZUV4aXN0cztcclxuZnVuY3Rpb24gY2hlY2tEaXJlY3RvcnlFeGlzdHMoZGlyUGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBmcy5zdGF0KGRpclBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY2hlY2tEaXJlY3RvcnlFeGlzdHMgPSBjaGVja0RpcmVjdG9yeUV4aXN0cztcclxuZnVuY3Rpb24gY2hlY2tGaWxlRXhpc3RzU3luYyhmaWxlUGF0aCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZnMuc3RhdFN5bmMoZmlsZVBhdGgpLmlzRmlsZSgpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmNoZWNrRmlsZUV4aXN0c1N5bmMgPSBjaGVja0ZpbGVFeGlzdHNTeW5jO1xyXG5mdW5jdGlvbiBjaGVja0RpcmVjdG9yeUV4aXN0c1N5bmMoZGlyUGF0aCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZnMuc3RhdFN5bmMoZGlyUGF0aCkuaXNEaXJlY3RvcnkoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5jaGVja0RpcmVjdG9yeUV4aXN0c1N5bmMgPSBjaGVja0RpcmVjdG9yeUV4aXN0c1N5bmM7XHJcbmZ1bmN0aW9uIHJlYWREaXIoZGlyUGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgZnMucmVhZGRpcihkaXJQYXRoLCAoZXJyLCBsaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobGlzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnJlYWREaXIgPSByZWFkRGlyO1xyXG5mdW5jdGlvbiBjaGVja0luc3RhbGxMb2NrRmlsZSgpIHtcclxuICAgIHJldHVybiBjaGVja0ZpbGVFeGlzdHMoZ2V0SW5zdGFsbExvY2tQYXRoKCkpO1xyXG59XHJcbmV4cG9ydHMuY2hlY2tJbnN0YWxsTG9ja0ZpbGUgPSBjaGVja0luc3RhbGxMb2NrRmlsZTtcclxuZnVuY3Rpb24gcmVhZEZpbGVUZXh0KGZpbGVQYXRoLCBlbmNvZGluZyA9IFwidXRmOFwiKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCBlbmNvZGluZywgKGVyciwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucmVhZEZpbGVUZXh0ID0gcmVhZEZpbGVUZXh0O1xyXG5mdW5jdGlvbiB3cml0ZUZpbGVUZXh0KGZpbGVQYXRoLCBjb250ZW50LCBlbmNvZGluZyA9IFwidXRmOFwiKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGZzLndyaXRlRmlsZShmaWxlUGF0aCwgY29udGVudCwgeyBlbmNvZGluZyB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLndyaXRlRmlsZVRleHQgPSB3cml0ZUZpbGVUZXh0O1xyXG5mdW5jdGlvbiBkZWxldGVGaWxlKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICBmcy51bmxpbmsoZmlsZVBhdGgsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kZWxldGVGaWxlID0gZGVsZXRlRmlsZTtcclxuZnVuY3Rpb24gZ2V0SW5zdGFsbExvY2tQYXRoKCkge1xyXG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpbGVQYXRoKFwiaW5zdGFsbC5sb2NrXCIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0SW5zdGFsbExvY2tQYXRoID0gZ2V0SW5zdGFsbExvY2tQYXRoO1xyXG5mdW5jdGlvbiBnZXRSZWFkbWVNZXNzYWdlKCkge1xyXG4gICAgY29uc3QgcmVhZG1lUGF0aCA9IGdldEV4dGVuc2lvbkZpbGVQYXRoKFwiUkVBRE1FLm1kXCIpO1xyXG4gICAgY29uc3QgcmVhZG1lTWVzc2FnZSA9IGBQbGVhc2UgcmVmZXIgdG8gJHtyZWFkbWVQYXRofSBmb3IgdHJvdWJsZXNob290aW5nIGluZm9ybWF0aW9uLiBJc3N1ZXMgY2FuIGJlIGNyZWF0ZWQgYXQgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC92c2NvZGUtY3BwdG9vbHMvaXNzdWVzYDtcclxuICAgIHJldHVybiByZWFkbWVNZXNzYWdlO1xyXG59XHJcbmV4cG9ydHMuZ2V0UmVhZG1lTWVzc2FnZSA9IGdldFJlYWRtZU1lc3NhZ2U7XHJcbmZ1bmN0aW9uIGxvZ1RvRmlsZShtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBsb2dGb2xkZXIgPSBnZXRFeHRlbnNpb25GaWxlUGF0aChcImV4dGVuc2lvbi5sb2dcIik7XHJcbiAgICBmcy53cml0ZUZpbGVTeW5jKGxvZ0ZvbGRlciwgYCR7bWVzc2FnZX0ke29zLkVPTH1gLCB7IGZsYWc6ICdhJyB9KTtcclxufVxyXG5leHBvcnRzLmxvZ1RvRmlsZSA9IGxvZ1RvRmlsZTtcclxuZnVuY3Rpb24gZXhlY0NoaWxkUHJvY2Vzcyhwcm9jZXNzLCB3b3JraW5nRGlyZWN0b3J5LCBjaGFubmVsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlYyhwcm9jZXNzLCB7IGN3ZDogd29ya2luZ0RpcmVjdG9yeSwgbWF4QnVmZmVyOiA1MDAgKiAxMDI0IH0sIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBlcnIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGRvdXQgJiYgc3Rkb3V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IHN0ZG91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGRlcnIgJiYgc3RkZXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IHN0ZGVycjtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5hcHBlbmQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGRlcnIgJiYgc3RkZXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3Ioc3RkZXJyKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZShzdGRvdXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5leGVjQ2hpbGRQcm9jZXNzID0gZXhlY0NoaWxkUHJvY2VzcztcclxuZnVuY3Rpb24gc3Bhd25DaGlsZFByb2Nlc3MocHJvY2VzcywgYXJncywgd29ya2luZ0RpcmVjdG9yeSwgZGF0YUNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRfcHJvY2Vzcy5zcGF3bihwcm9jZXNzLCBhcmdzLCB7IGN3ZDogd29ya2luZ0RpcmVjdG9yeSB9KTtcclxuICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhQ2FsbGJhY2soYCR7ZGF0YX1gKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGAke2RhdGF9YCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hpbGQub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgJHtwcm9jZXNzfSBleGl0ZWQgd2l0aCBlcnJvciBjb2RlICR7Y29kZX1gKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuc3Bhd25DaGlsZFByb2Nlc3MgPSBzcGF3bkNoaWxkUHJvY2VzcztcclxuZnVuY3Rpb24gYWxsb3dFeGVjdXRpb24oZmlsZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xyXG4gICAgICAgICAgICBjaGVja0ZpbGVFeGlzdHMoZmlsZSkudGhlbigoZXhpc3RzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnMuY2htb2QoZmlsZSwgJzc1NScsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZ2V0T3V0cHV0Q2hhbm5lbExvZ2dlcigpLmFwcGVuZExpbmUoXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZ2V0T3V0cHV0Q2hhbm5lbExvZ2dlcigpLmFwcGVuZExpbmUoYFdhcm5pbmc6IEV4cGVjdGVkIGZpbGUgJHtmaWxlfSBpcyBtaXNzaW5nLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5hbGxvd0V4ZWN1dGlvbiA9IGFsbG93RXhlY3V0aW9uO1xyXG5mdW5jdGlvbiByZW1vdmVQb3RlbnRpYWxQSUkoc3RyKSB7XHJcbiAgICBsZXQgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xyXG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICBmb3IgKGxldCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgICAgaWYgKHdvcmQuaW5kZXhPZihcIi5cIikgPT09IC0xICYmIHdvcmQuaW5kZXhPZihcIi9cIikgPT09IC0xICYmIHdvcmQuaW5kZXhPZihcIlxcXFxcIikgPT09IC0xICYmIHdvcmQuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB3b3JkICsgXCIgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCI/IFwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVQb3RlbnRpYWxQSUkgPSByZW1vdmVQb3RlbnRpYWxQSUk7XHJcbmZ1bmN0aW9uIGNoZWNrRGlzdHJvKHBsYXRmb3JtSW5mbykge1xyXG4gICAgaWYgKHBsYXRmb3JtSW5mby5wbGF0Zm9ybSAhPT0gJ3dpbjMyJyAmJiBwbGF0Zm9ybUluZm8ucGxhdGZvcm0gIT09ICdsaW51eCcgJiYgcGxhdGZvcm1JbmZvLnBsYXRmb3JtICE9PSAnZGFyd2luJykge1xyXG4gICAgICAgIGxvZ2dlcl8xLmdldE91dHB1dENoYW5uZWxMb2dnZXIoKS5hcHBlbmRMaW5lKGBXYXJuaW5nOiBEZWJ1Z2dpbmcgaGFzIG5vdCBiZWVuIHRlc3RlZCBmb3IgdGhpcyBwbGF0Zm9ybS4gJHtnZXRSZWFkbWVNZXNzYWdlKCl9YCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jaGVja0Rpc3RybyA9IGNoZWNrRGlzdHJvO1xyXG5mdW5jdGlvbiB1bmxpbmtQcm9taXNlKGZpbGVOYW1lKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGZzLnVubGluayhmaWxlTmFtZSwgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5saW5rUHJvbWlzZSA9IHVubGlua1Byb21pc2U7XHJcbmZ1bmN0aW9uIHJlbmFtZVByb21pc2Uob2xkTmFtZSwgbmV3TmFtZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBmcy5yZW5hbWUob2xkTmFtZSwgbmV3TmFtZSwgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucmVuYW1lUHJvbWlzZSA9IHJlbmFtZVByb21pc2U7XHJcbmZ1bmN0aW9uIHByb21wdEZvclJlbG9hZFdpbmRvd0R1ZVRvU2V0dGluZ3NDaGFuZ2UoKSB7XHJcbiAgICBwcm9tcHRSZWxvYWRXaW5kb3coXCJSZWxvYWQgdGhlIHdvcmtzcGFjZSBmb3IgdGhlIHNldHRpbmdzIGNoYW5nZSB0byB0YWtlIGVmZmVjdC5cIik7XHJcbn1cclxuZXhwb3J0cy5wcm9tcHRGb3JSZWxvYWRXaW5kb3dEdWVUb1NldHRpbmdzQ2hhbmdlID0gcHJvbXB0Rm9yUmVsb2FkV2luZG93RHVlVG9TZXR0aW5nc0NoYW5nZTtcclxuZnVuY3Rpb24gcHJvbXB0UmVsb2FkV2luZG93KG1lc3NhZ2UpIHtcclxuICAgIGxldCByZWxvYWQgPSBcIlJlbG9hZFwiO1xyXG4gICAgdnNjb2RlLndpbmRvdy5zaG93SW5mb3JtYXRpb25NZXNzYWdlKG1lc3NhZ2UsIHJlbG9hZCkudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHJlbG9hZCkge1xyXG4gICAgICAgICAgICB2c2NvZGUuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmQoXCJ3b3JrYmVuY2guYWN0aW9uLnJlbG9hZFdpbmRvd1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnByb21wdFJlbG9hZFdpbmRvdyA9IHByb21wdFJlbG9hZFdpbmRvdztcclxuZnVuY3Rpb24gZG93bmxvYWRGaWxlVG9EZXN0aW5hdGlvbih1cmxTdHIsIGRlc3RpbmF0aW9uUGF0aCwgaGVhZGVycykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHVybFN0cik7XHJcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgaG9zdDogcGFyc2VkVXJsLmhvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6IHBhcnNlZFVybC5wYXRoLFxyXG4gICAgICAgICAgICBhZ2VudDogZ2V0SHR0cHNQcm94eUFnZW50KCksXHJcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCkuZ2V0KCdodHRwLnByb3h5U3RyaWN0U1NMJywgdHJ1ZSksXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICB9LCAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWRpcmVjdFVybDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkb3dubG9hZEZpbGVUb0Rlc3RpbmF0aW9uKHJlZGlyZWN0VXJsLCBkZXN0aW5hdGlvblBhdGgsIGhlYWRlcnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNyZWF0ZWRGaWxlID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdGluYXRpb25QYXRoKTtcclxuICAgICAgICAgICAgY3JlYXRlZEZpbGUub24oJ2ZpbmlzaCcsICgpID0+IHsgcmVzb2x2ZSgpOyB9KTtcclxuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7IHJlamVjdChlcnJvcik7IH0pO1xyXG4gICAgICAgICAgICByZXNwb25zZS5waXBlKGNyZWF0ZWRGaWxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIChlcnJvcikgPT4geyByZWplY3QoZXJyb3IpOyB9KTtcclxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kb3dubG9hZEZpbGVUb0Rlc3RpbmF0aW9uID0gZG93bmxvYWRGaWxlVG9EZXN0aW5hdGlvbjtcclxuZnVuY3Rpb24gZG93bmxvYWRGaWxlVG9TdHIodXJsU3RyLCBoZWFkZXJzKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBwYXJzZWRVcmwgPSB1cmwucGFyc2UodXJsU3RyKTtcclxuICAgICAgICBsZXQgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICBob3N0OiBwYXJzZWRVcmwuaG9zdCxcclxuICAgICAgICAgICAgcGF0aDogcGFyc2VkVXJsLnBhdGgsXHJcbiAgICAgICAgICAgIGFnZW50OiBnZXRIdHRwc1Byb3h5QWdlbnQoKSxcclxuICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB2c2NvZGUud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24oKS5nZXQoJ2h0dHAucHJveHlTdHJpY3RTU0wnLCB0cnVlKSxcclxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xyXG4gICAgICAgIH0sIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlZGlyZWN0VXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvblswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRvd25sb2FkRmlsZVRvU3RyKHJlZGlyZWN0VXJsLCBoZWFkZXJzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkb3dubG9hZGVkRGF0YSA9ICcnO1xyXG4gICAgICAgICAgICByZXNwb25zZS5vbignZGF0YScsIChkYXRhKSA9PiB7IGRvd25sb2FkZWREYXRhICs9IGRhdGE7IH0pO1xyXG4gICAgICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCAoZXJyb3IpID0+IHsgcmVqZWN0KGVycm9yKTsgfSk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7IHJlc29sdmUoZG93bmxvYWRlZERhdGEpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIChlcnJvcikgPT4geyByZWplY3QoZXJyb3IpOyB9KTtcclxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kb3dubG9hZEZpbGVUb1N0ciA9IGRvd25sb2FkRmlsZVRvU3RyO1xyXG5mdW5jdGlvbiBleHRyYWN0Q29tcGlsZXJQYXRoQW5kQXJncyhpbnB1dENvbXBpbGVyUGF0aCkge1xyXG4gICAgbGV0IGNvbXBpbGVyUGF0aCA9IGlucHV0Q29tcGlsZXJQYXRoO1xyXG4gICAgbGV0IGFkZGl0aW9uYWxBcmdzO1xyXG4gICAgbGV0IGlzV2luZG93cyA9IG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMic7XHJcbiAgICBpZiAoY29tcGlsZXJQYXRoKSB7XHJcbiAgICAgICAgY29tcGlsZXJQYXRoID0gY29tcGlsZXJQYXRoLnRyaW0oKTtcclxuICAgICAgICBpZiAoY29tcGlsZXJQYXRoLnN0YXJ0c1dpdGgoXCJcXFwiXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCBlbmRRdW90ZSA9IGNvbXBpbGVyUGF0aC5zdWJzdHIoMSkuc2VhcmNoKFwiXFxcIlwiKSArIDE7XHJcbiAgICAgICAgICAgIGlmIChlbmRRdW90ZSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxBcmdzID0gY29tcGlsZXJQYXRoLnN1YnN0cihlbmRRdW90ZSArIDEpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxBcmdzID0gYWRkaXRpb25hbEFyZ3MuZmlsdGVyKChhcmcpID0+IHsgcmV0dXJuIGFyZy50cmltKCkubGVuZ3RoICE9PSAwOyB9KTtcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVyUGF0aCA9IGNvbXBpbGVyUGF0aC5zdWJzdHIoMSwgZW5kUXVvdGUgLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBjb21waWxlclBhdGgubGFzdEluZGV4T2YoXCIgXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3BhY2VTdGFydCAhPT0gLTEgJiYgKCFpc1dpbmRvd3MgfHwgIWNvbXBpbGVyUGF0aC5lbmRzV2l0aChcImNsLmV4ZVwiKSkgJiYgIWNoZWNrRmlsZUV4aXN0c1N5bmMoY29tcGlsZXJQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvdGVudGlhbENvbXBpbGVyUGF0aCA9IGNvbXBpbGVyUGF0aC5zdWJzdHIoMCwgc3BhY2VTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKCFpc1dpbmRvd3MgfHwgIXBvdGVudGlhbENvbXBpbGVyUGF0aC5lbmRzV2l0aChcImNsLmV4ZVwiKSkgJiYgIWNoZWNrRmlsZUV4aXN0c1N5bmMocG90ZW50aWFsQ29tcGlsZXJQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlU3RhcnQgPSBwb3RlbnRpYWxDb21waWxlclBhdGgubGFzdEluZGV4T2YoXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZVN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxDb21waWxlclBhdGggPSBjb21waWxlclBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxDb21waWxlclBhdGggPSBwb3RlbnRpYWxDb21waWxlclBhdGguc3Vic3RyKDAsIHNwYWNlU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBpbGVyUGF0aCAhPT0gcG90ZW50aWFsQ29tcGlsZXJQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3MgPSBjb21waWxlclBhdGguc3Vic3RyKHNwYWNlU3RhcnQgKyAxKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEFyZ3MgPSBhZGRpdGlvbmFsQXJncy5maWx0ZXIoKGFyZykgPT4geyByZXR1cm4gYXJnLnRyaW0oKS5sZW5ndGggIT09IDA7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVyUGF0aCA9IHBvdGVudGlhbENvbXBpbGVyUGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbXBpbGVyUGF0aCwgYWRkaXRpb25hbEFyZ3MgfTtcclxufVxyXG5leHBvcnRzLmV4dHJhY3RDb21waWxlclBhdGhBbmRBcmdzID0gZXh0cmFjdENvbXBpbGVyUGF0aEFuZEFyZ3M7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/common.ts\n");

/***/ }),

/***/ "./src/cppTools.ts":
/*!*************************!*\
  !*** ./src/cppTools.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_cpptools_1 = __webpack_require__(/*! vscode-cpptools */ \"./node_modules/vscode-cpptools/out/api.js\");\r\nconst customProviders_1 = __webpack_require__(/*! ./LanguageServer/customProviders */ \"./src/LanguageServer/customProviders.ts\");\r\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\r\nconst LanguageServer = __webpack_require__(/*! ./LanguageServer/extension */ \"./src/LanguageServer/extension.ts\");\r\nconst test = __webpack_require__(/*! ./testHook */ \"./src/testHook.ts\");\r\nclass CppTools {\r\n    constructor(version) {\r\n        this.providers = [];\r\n        this.failedRegistrations = [];\r\n        this.timers = new Map();\r\n        if (version > vscode_cpptools_1.Version.latest) {\r\n            console.warn(`version ${version} is not supported by this version of cpptools`);\r\n            console.warn(`  using ${vscode_cpptools_1.Version.latest} instead`);\r\n            version = vscode_cpptools_1.Version.latest;\r\n        }\r\n        this.version = version;\r\n    }\r\n    addNotifyReadyTimer(provider) {\r\n        if (this.version >= vscode_cpptools_1.Version.v2) {\r\n            const timeout = 30;\r\n            let timer = setTimeout(() => {\r\n                console.warn(`registered provider ${provider.extensionId} did not call 'notifyReady' within ${timeout} seconds`);\r\n            }, timeout * 1000);\r\n            this.timers.set(provider.extensionId, timer);\r\n        }\r\n    }\r\n    removeNotifyReadyTimer(provider) {\r\n        if (this.version >= vscode_cpptools_1.Version.v2) {\r\n            let timer = this.timers.get(provider.extensionId);\r\n            if (timer) {\r\n                this.timers.delete(provider.extensionId);\r\n                clearTimeout(timer);\r\n            }\r\n        }\r\n    }\r\n    getVersion() {\r\n        return this.version;\r\n    }\r\n    registerCustomConfigurationProvider(provider) {\r\n        let providers = customProviders_1.getCustomConfigProviders();\r\n        if (providers.add(provider, this.version)) {\r\n            let added = providers.get(provider);\r\n            logger_1.getOutputChannel().appendLine(`Custom configuration provider '${added.name}' registered`);\r\n            this.providers.push(added);\r\n            LanguageServer.getClients().forEach(client => client.onRegisterCustomConfigurationProvider(added));\r\n            this.addNotifyReadyTimer(added);\r\n        }\r\n        else {\r\n            this.failedRegistrations.push(provider);\r\n        }\r\n    }\r\n    notifyReady(provider) {\r\n        let providers = customProviders_1.getCustomConfigProviders();\r\n        let p = providers.get(provider);\r\n        if (p) {\r\n            this.removeNotifyReadyTimer(p);\r\n            p.isReady = true;\r\n            LanguageServer.getClients().forEach(client => {\r\n                client.updateCustomConfigurations(p);\r\n                client.updateCustomBrowseConfiguration(p);\r\n            });\r\n        }\r\n        else if (this.failedRegistrations.find(p => p === provider)) {\r\n            console.warn(\"provider not successfully registered, 'notifyReady' ignored\");\r\n        }\r\n        else {\r\n            console.warn(\"provider should be registered before signaling it's ready to provide configurations\");\r\n        }\r\n    }\r\n    didChangeCustomConfiguration(provider) {\r\n        let providers = customProviders_1.getCustomConfigProviders();\r\n        let p = providers.get(provider);\r\n        if (p) {\r\n            if (!p.isReady) {\r\n                console.warn(\"didChangeCustomConfiguration was invoked before notifyReady\");\r\n            }\r\n            LanguageServer.getClients().forEach(client => client.updateCustomConfigurations(p));\r\n        }\r\n        else if (this.failedRegistrations.find(p => p === provider)) {\r\n            console.warn(\"provider not successfully registered, 'didChangeCustomConfiguration' ignored\");\r\n        }\r\n        else {\r\n            console.warn(\"provider should be registered before sending config change messages\");\r\n        }\r\n    }\r\n    didChangeCustomBrowseConfiguration(provider) {\r\n        let providers = customProviders_1.getCustomConfigProviders();\r\n        let p = providers.get(provider);\r\n        if (p) {\r\n            LanguageServer.getClients().forEach(client => client.updateCustomBrowseConfiguration(p));\r\n        }\r\n        else if (this.failedRegistrations.find(p => p === provider)) {\r\n            console.warn(\"provider not successfully registered, 'didChangeCustomBrowseConfiguration' ignored\");\r\n        }\r\n        else {\r\n            console.warn(\"provider should be registered before sending config change messages\");\r\n        }\r\n    }\r\n    dispose() {\r\n        this.providers.forEach(provider => {\r\n            customProviders_1.getCustomConfigProviders().remove(provider);\r\n            provider.dispose();\r\n        });\r\n        this.providers = [];\r\n    }\r\n    getTestHook() {\r\n        return test.getTestHook();\r\n    }\r\n}\r\nexports.CppTools = CppTools;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3BwVG9vbHMudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL2NwcFRvb2xzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGVfY3BwdG9vbHNfMSA9IHJlcXVpcmUoXCJ2c2NvZGUtY3BwdG9vbHNcIik7XHJcbmNvbnN0IGN1c3RvbVByb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vTGFuZ3VhZ2VTZXJ2ZXIvY3VzdG9tUHJvdmlkZXJzXCIpO1xyXG5jb25zdCBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuY29uc3QgTGFuZ3VhZ2VTZXJ2ZXIgPSByZXF1aXJlKFwiLi9MYW5ndWFnZVNlcnZlci9leHRlbnNpb25cIik7XHJcbmNvbnN0IHRlc3QgPSByZXF1aXJlKFwiLi90ZXN0SG9va1wiKTtcclxuY2xhc3MgQ3BwVG9vbHMge1xyXG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5mYWlsZWRSZWdpc3RyYXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKHZlcnNpb24gPiB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLmxhdGVzdCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZlcnNpb24gJHt2ZXJzaW9ufSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiBjcHB0b29sc2ApO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCAgdXNpbmcgJHt2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLmxhdGVzdH0gaW5zdGVhZGApO1xyXG4gICAgICAgICAgICB2ZXJzaW9uID0gdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi5sYXRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB9XHJcbiAgICBhZGROb3RpZnlSZWFkeVRpbWVyKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA+PSB2c2NvZGVfY3BwdG9vbHNfMS5WZXJzaW9uLnYyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSAzMDtcclxuICAgICAgICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHJlZ2lzdGVyZWQgcHJvdmlkZXIgJHtwcm92aWRlci5leHRlbnNpb25JZH0gZGlkIG5vdCBjYWxsICdub3RpZnlSZWFkeScgd2l0aGluICR7dGltZW91dH0gc2Vjb25kc2ApO1xyXG4gICAgICAgICAgICB9LCB0aW1lb3V0ICogMTAwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJzLnNldChwcm92aWRlci5leHRlbnNpb25JZCwgdGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZU5vdGlmeVJlYWR5VGltZXIocHJvdmlkZXIpIHtcclxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IHZzY29kZV9jcHB0b29sc18xLlZlcnNpb24udjIpIHtcclxuICAgICAgICAgICAgbGV0IHRpbWVyID0gdGhpcy50aW1lcnMuZ2V0KHByb3ZpZGVyLmV4dGVuc2lvbklkKTtcclxuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVycy5kZWxldGUocHJvdmlkZXIuZXh0ZW5zaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFZlcnNpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVycyA9IGN1c3RvbVByb3ZpZGVyc18xLmdldEN1c3RvbUNvbmZpZ1Byb3ZpZGVycygpO1xyXG4gICAgICAgIGlmIChwcm92aWRlcnMuYWRkKHByb3ZpZGVyLCB0aGlzLnZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgIGxldCBhZGRlZCA9IHByb3ZpZGVycy5nZXQocHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBsb2dnZXJfMS5nZXRPdXRwdXRDaGFubmVsKCkuYXBwZW5kTGluZShgQ3VzdG9tIGNvbmZpZ3VyYXRpb24gcHJvdmlkZXIgJyR7YWRkZWQubmFtZX0nIHJlZ2lzdGVyZWRgKTtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaChhZGRlZCk7XHJcbiAgICAgICAgICAgIExhbmd1YWdlU2VydmVyLmdldENsaWVudHMoKS5mb3JFYWNoKGNsaWVudCA9PiBjbGllbnQub25SZWdpc3RlckN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcihhZGRlZCkpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE5vdGlmeVJlYWR5VGltZXIoYWRkZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5mYWlsZWRSZWdpc3RyYXRpb25zLnB1c2gocHJvdmlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5vdGlmeVJlYWR5KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVycyA9IGN1c3RvbVByb3ZpZGVyc18xLmdldEN1c3RvbUNvbmZpZ1Byb3ZpZGVycygpO1xyXG4gICAgICAgIGxldCBwID0gcHJvdmlkZXJzLmdldChwcm92aWRlcik7XHJcbiAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb3RpZnlSZWFkeVRpbWVyKHApO1xyXG4gICAgICAgICAgICBwLmlzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBMYW5ndWFnZVNlcnZlci5nZXRDbGllbnRzKCkuZm9yRWFjaChjbGllbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LnVwZGF0ZUN1c3RvbUNvbmZpZ3VyYXRpb25zKHApO1xyXG4gICAgICAgICAgICAgICAgY2xpZW50LnVwZGF0ZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24ocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxlZFJlZ2lzdHJhdGlvbnMuZmluZChwID0+IHAgPT09IHByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwcm92aWRlciBub3Qgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsICdub3RpZnlSZWFkeScgaWdub3JlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInByb3ZpZGVyIHNob3VsZCBiZSByZWdpc3RlcmVkIGJlZm9yZSBzaWduYWxpbmcgaXQncyByZWFkeSB0byBwcm92aWRlIGNvbmZpZ3VyYXRpb25zXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpZENoYW5nZUN1c3RvbUNvbmZpZ3VyYXRpb24ocHJvdmlkZXIpIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXJzID0gY3VzdG9tUHJvdmlkZXJzXzEuZ2V0Q3VzdG9tQ29uZmlnUHJvdmlkZXJzKCk7XHJcbiAgICAgICAgbGV0IHAgPSBwcm92aWRlcnMuZ2V0KHByb3ZpZGVyKTtcclxuICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICBpZiAoIXAuaXNSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZGlkQ2hhbmdlQ3VzdG9tQ29uZmlndXJhdGlvbiB3YXMgaW52b2tlZCBiZWZvcmUgbm90aWZ5UmVhZHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTGFuZ3VhZ2VTZXJ2ZXIuZ2V0Q2xpZW50cygpLmZvckVhY2goY2xpZW50ID0+IGNsaWVudC51cGRhdGVDdXN0b21Db25maWd1cmF0aW9ucyhwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmFpbGVkUmVnaXN0cmF0aW9ucy5maW5kKHAgPT4gcCA9PT0gcHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInByb3ZpZGVyIG5vdCBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCwgJ2RpZENoYW5nZUN1c3RvbUNvbmZpZ3VyYXRpb24nIGlnbm9yZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwcm92aWRlciBzaG91bGQgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgc2VuZGluZyBjb25maWcgY2hhbmdlIG1lc3NhZ2VzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpZENoYW5nZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24ocHJvdmlkZXIpIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXJzID0gY3VzdG9tUHJvdmlkZXJzXzEuZ2V0Q3VzdG9tQ29uZmlnUHJvdmlkZXJzKCk7XHJcbiAgICAgICAgbGV0IHAgPSBwcm92aWRlcnMuZ2V0KHByb3ZpZGVyKTtcclxuICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICBMYW5ndWFnZVNlcnZlci5nZXRDbGllbnRzKCkuZm9yRWFjaChjbGllbnQgPT4gY2xpZW50LnVwZGF0ZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24ocCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxlZFJlZ2lzdHJhdGlvbnMuZmluZChwID0+IHAgPT09IHByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwcm92aWRlciBub3Qgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsICdkaWRDaGFuZ2VDdXN0b21Ccm93c2VDb25maWd1cmF0aW9uJyBpZ25vcmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwicHJvdmlkZXIgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgYmVmb3JlIHNlbmRpbmcgY29uZmlnIGNoYW5nZSBtZXNzYWdlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLmZvckVhY2gocHJvdmlkZXIgPT4ge1xyXG4gICAgICAgICAgICBjdXN0b21Qcm92aWRlcnNfMS5nZXRDdXN0b21Db25maWdQcm92aWRlcnMoKS5yZW1vdmUocHJvdmlkZXIpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIGdldFRlc3RIb29rKCkge1xyXG4gICAgICAgIHJldHVybiB0ZXN0LmdldFRlc3RIb29rKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DcHBUb29scyA9IENwcFRvb2xzO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/cppTools.ts\n");

/***/ }),

/***/ "./src/cppTools1.ts":
/*!**************************!*\
  !*** ./src/cppTools1.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_cpptools_1 = __webpack_require__(/*! vscode-cpptools */ \"./node_modules/vscode-cpptools/out/api.js\");\r\nconst cppTools_1 = __webpack_require__(/*! ./cppTools */ \"./src/cppTools.ts\");\r\nclass CppTools1 {\r\n    get BackupApi() {\r\n        if (!this.backupApi) {\r\n            this.backupApi = new cppTools_1.CppTools(vscode_cpptools_1.Version.v0);\r\n        }\r\n        return this.backupApi;\r\n    }\r\n    getApi(version) {\r\n        switch (version) {\r\n            case vscode_cpptools_1.Version.v0:\r\n                return this.BackupApi;\r\n            default:\r\n                return new cppTools_1.CppTools(version);\r\n        }\r\n    }\r\n    getTestApi(version) {\r\n        return this.getApi(version);\r\n    }\r\n    getVersion() {\r\n        return this.BackupApi.getVersion();\r\n    }\r\n    registerCustomConfigurationProvider(provider) {\r\n        this.BackupApi.registerCustomConfigurationProvider(provider);\r\n    }\r\n    notifyReady(provider) {\r\n        this.BackupApi.notifyReady(provider);\r\n    }\r\n    didChangeCustomConfiguration(provider) {\r\n        this.BackupApi.didChangeCustomConfiguration(provider);\r\n    }\r\n    didChangeCustomBrowseConfiguration(provider) {\r\n        this.BackupApi.didChangeCustomBrowseConfiguration(provider);\r\n    }\r\n    dispose() {\r\n    }\r\n    getTestHook() {\r\n        return this.BackupApi.getTestHook();\r\n    }\r\n}\r\nexports.CppTools1 = CppTools1;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3BwVG9vbHMxLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9jcHBUb29sczEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZV9jcHB0b29sc18xID0gcmVxdWlyZShcInZzY29kZS1jcHB0b29sc1wiKTtcclxuY29uc3QgY3BwVG9vbHNfMSA9IHJlcXVpcmUoXCIuL2NwcFRvb2xzXCIpO1xyXG5jbGFzcyBDcHBUb29sczEge1xyXG4gICAgZ2V0IEJhY2t1cEFwaSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYmFja3VwQXBpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja3VwQXBpID0gbmV3IGNwcFRvb2xzXzEuQ3BwVG9vbHModnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmJhY2t1cEFwaTtcclxuICAgIH1cclxuICAgIGdldEFwaSh2ZXJzaW9uKSB7XHJcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgdnNjb2RlX2NwcHRvb2xzXzEuVmVyc2lvbi52MDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkJhY2t1cEFwaTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY3BwVG9vbHNfMS5DcHBUb29scyh2ZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUZXN0QXBpKHZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkodmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBnZXRWZXJzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkJhY2t1cEFwaS5nZXRWZXJzaW9uKCk7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckN1c3RvbUNvbmZpZ3VyYXRpb25Qcm92aWRlcihwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuQmFja3VwQXBpLnJlZ2lzdGVyQ3VzdG9tQ29uZmlndXJhdGlvblByb3ZpZGVyKHByb3ZpZGVyKTtcclxuICAgIH1cclxuICAgIG5vdGlmeVJlYWR5KHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5CYWNrdXBBcGkubm90aWZ5UmVhZHkocHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgZGlkQ2hhbmdlQ3VzdG9tQ29uZmlndXJhdGlvbihwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuQmFja3VwQXBpLmRpZENoYW5nZUN1c3RvbUNvbmZpZ3VyYXRpb24ocHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgZGlkQ2hhbmdlQ3VzdG9tQnJvd3NlQ29uZmlndXJhdGlvbihwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuQmFja3VwQXBpLmRpZENoYW5nZUN1c3RvbUJyb3dzZUNvbmZpZ3VyYXRpb24ocHJvdmlkZXIpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgIH1cclxuICAgIGdldFRlc3RIb29rKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkJhY2t1cEFwaS5nZXRUZXN0SG9vaygpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ3BwVG9vbHMxID0gQ3BwVG9vbHMxO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/cppTools1.ts\n");

/***/ }),

/***/ "./src/githubAPI.ts":
/*!**************************!*\
  !*** ./src/githubAPI.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst packageVersion_1 = __webpack_require__(/*! ./packageVersion */ \"./src/packageVersion.ts\");\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nconst platform_1 = __webpack_require__(/*! ./platform */ \"./src/platform.ts\");\r\nconst testingInsidersVsixInstall = false;\r\nfunction getVsixDownloadUrl(build, vsixName) {\r\n    const downloadUrl = build.assets.find(asset => {\r\n        return asset.name === vsixName;\r\n    }).browser_download_url;\r\n    if (!downloadUrl) {\r\n        throw new Error('Failed to find VSIX: ' + vsixName + ' in build: ' + build.name);\r\n    }\r\n    return downloadUrl;\r\n}\r\nfunction isAsset(input) {\r\n    return input && input.name && typeof (input.name) === \"string\" &&\r\n        input.browser_download_url && typeof (input.browser_download_url) === \"string\";\r\n}\r\nfunction isBuild(input) {\r\n    return input && input.name && typeof (input.name) === \"string\" && isArrayOfAssets(input.assets) && input.assets.length >= 4;\r\n}\r\nfunction isArrayOfAssets(input) {\r\n    return input instanceof Array && input.every(item => isAsset(item));\r\n}\r\nfunction isArrayOfBuilds(input) {\r\n    if (!input || !(input instanceof Array) || input.length === 0) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < 5 && i < input.length; i++) {\r\n        if (!isBuild(input[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction vsixNameForPlatform(info) {\r\n    const vsixName = function (platformInfo) {\r\n        switch (platformInfo.platform) {\r\n            case 'win32': return 'cpptools-win32.vsix';\r\n            case 'darwin': return 'cpptools-osx.vsix';\r\n            default: {\r\n                switch (platformInfo.architecture) {\r\n                    case 'x86_64': return 'cpptools-linux.vsix';\r\n                    case 'x86':\r\n                    case 'i386':\r\n                    case 'i686': return 'cpptools-linux32.vsix';\r\n                }\r\n            }\r\n        }\r\n    }(info);\r\n    if (!vsixName) {\r\n        throw new Error('Failed to match VSIX name for: ' + info.platform + ':' + info.architecture);\r\n    }\r\n    return vsixName;\r\n}\r\nfunction getTargetBuildInfo(updateChannel) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        return getReleaseJson()\r\n            .then(builds => {\r\n            if (!builds || builds.length === 0) {\r\n                return undefined;\r\n            }\r\n            const userVersion = new packageVersion_1.PackageVersion(util.packageJson.version);\r\n            const latestVersion = new packageVersion_1.PackageVersion(builds[0].name);\r\n            if (!testingInsidersVsixInstall && (userVersion.isGreaterThan(latestVersion) || (userVersion.suffix && userVersion.suffix !== 'insiders'))) {\r\n                return undefined;\r\n            }\r\n            return getTargetBuild(builds, userVersion, updateChannel);\r\n        })\r\n            .then((build) => __awaiter(this, void 0, void 0, function* () {\r\n            if (!build) {\r\n                return Promise.resolve(undefined);\r\n            }\r\n            try {\r\n                const platformInfo = yield platform_1.PlatformInformation.GetPlatformInformation();\r\n                const vsixName = vsixNameForPlatform(platformInfo);\r\n                const downloadUrl = getVsixDownloadUrl(build, vsixName);\r\n                return { downloadUrl: downloadUrl, name: build.name };\r\n            }\r\n            catch (error) {\r\n                return Promise.reject(error);\r\n            }\r\n        }));\r\n    });\r\n}\r\nexports.getTargetBuildInfo = getTargetBuildInfo;\r\nfunction getTargetBuild(builds, userVersion, updateChannel) {\r\n    let needsUpdate;\r\n    let useBuild;\r\n    if (updateChannel === 'Insiders') {\r\n        needsUpdate = (installed, target) => { return testingInsidersVsixInstall || target.isGreaterThan(installed); };\r\n        useBuild = (build) => { return true; };\r\n    }\r\n    else if (updateChannel === 'Default') {\r\n        needsUpdate = function (installed, target) { return installed.isGreaterThan(target); };\r\n        useBuild = (build) => { return build.name.indexOf('-') === -1; };\r\n    }\r\n    else {\r\n        throw new Error('Incorrect updateChannel setting provided');\r\n    }\r\n    const targetBuild = builds.find((build) => useBuild(build));\r\n    if (!targetBuild) {\r\n        throw new Error('Failed to determine installation candidate');\r\n    }\r\n    const targetVersion = new packageVersion_1.PackageVersion(targetBuild.name);\r\n    if (needsUpdate(userVersion, targetVersion)) {\r\n        return targetBuild;\r\n    }\r\n    return undefined;\r\n}\r\nfunction isRate(input) {\r\n    return input && util.isNumber(input.remaining);\r\n}\r\nfunction isRateLimit(input) {\r\n    return input && isRate(input.rate);\r\n}\r\nfunction getRateLimit() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const header = { 'User-Agent': 'vscode-cpptools' };\r\n        const data = yield util.downloadFileToStr('https://api.github.com/rate_limit', header)\r\n            .catch((error) => {\r\n            if (error && error.code && error.code !== \"ENOENT\") {\r\n                throw new Error('Failed to download rate limit JSON');\r\n            }\r\n        });\r\n        if (!data) {\r\n            return Promise.resolve(null);\r\n        }\r\n        let rateLimit;\r\n        try {\r\n            rateLimit = JSON.parse(data);\r\n        }\r\n        catch (error) {\r\n            throw new Error('Failed to parse rate limit JSON');\r\n        }\r\n        if (isRateLimit(rateLimit)) {\r\n            return Promise.resolve(rateLimit);\r\n        }\r\n        else {\r\n            throw new Error('Rate limit JSON is not of type RateLimit');\r\n        }\r\n    });\r\n}\r\nfunction rateLimitExceeded() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const rateLimit = yield getRateLimit();\r\n        return rateLimit && rateLimit.rate.remaining <= 0;\r\n    });\r\n}\r\nfunction getReleaseJson() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (yield rateLimitExceeded()) {\r\n            throw new Error('Failed to stay within GitHub API rate limit');\r\n        }\r\n        const releaseUrl = 'https://api.github.com/repos/Microsoft/vscode-cpptools/releases';\r\n        const header = { 'User-Agent': 'vscode-cpptools' };\r\n        const data = yield util.downloadFileToStr(releaseUrl, header)\r\n            .catch((error) => {\r\n            if (error && error.code && error.code !== \"ENOENT\") {\r\n                throw new Error('Failed to download release JSON');\r\n            }\r\n        });\r\n        if (!data) {\r\n            return Promise.resolve(null);\r\n        }\r\n        let releaseJson;\r\n        try {\r\n            releaseJson = JSON.parse(data);\r\n        }\r\n        catch (error) {\r\n            throw new Error('Failed to parse release JSON');\r\n        }\r\n        if (isArrayOfBuilds(releaseJson)) {\r\n            return releaseJson;\r\n        }\r\n        else {\r\n            throw new Error('Release JSON is not of type Build[]');\r\n        }\r\n    });\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2l0aHViQVBJLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9naXRodWJBUEkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHBhY2thZ2VWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9wYWNrYWdlVmVyc2lvblwiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcclxuY29uc3QgcGxhdGZvcm1fMSA9IHJlcXVpcmUoXCIuL3BsYXRmb3JtXCIpO1xyXG5jb25zdCB0ZXN0aW5nSW5zaWRlcnNWc2l4SW5zdGFsbCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBnZXRWc2l4RG93bmxvYWRVcmwoYnVpbGQsIHZzaXhOYW1lKSB7XHJcbiAgICBjb25zdCBkb3dubG9hZFVybCA9IGJ1aWxkLmFzc2V0cy5maW5kKGFzc2V0ID0+IHtcclxuICAgICAgICByZXR1cm4gYXNzZXQubmFtZSA9PT0gdnNpeE5hbWU7XHJcbiAgICB9KS5icm93c2VyX2Rvd25sb2FkX3VybDtcclxuICAgIGlmICghZG93bmxvYWRVcmwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIFZTSVg6ICcgKyB2c2l4TmFtZSArICcgaW4gYnVpbGQ6ICcgKyBidWlsZC5uYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb3dubG9hZFVybDtcclxufVxyXG5mdW5jdGlvbiBpc0Fzc2V0KGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgJiYgaW5wdXQubmFtZSAmJiB0eXBlb2YgKGlucHV0Lm5hbWUpID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgaW5wdXQuYnJvd3Nlcl9kb3dubG9hZF91cmwgJiYgdHlwZW9mIChpbnB1dC5icm93c2VyX2Rvd25sb2FkX3VybCkgPT09IFwic3RyaW5nXCI7XHJcbn1cclxuZnVuY3Rpb24gaXNCdWlsZChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0ICYmIGlucHV0Lm5hbWUgJiYgdHlwZW9mIChpbnB1dC5uYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBpc0FycmF5T2ZBc3NldHMoaW5wdXQuYXNzZXRzKSAmJiBpbnB1dC5hc3NldHMubGVuZ3RoID49IDQ7XHJcbn1cclxuZnVuY3Rpb24gaXNBcnJheU9mQXNzZXRzKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSAmJiBpbnB1dC5ldmVyeShpdGVtID0+IGlzQXNzZXQoaXRlbSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXJyYXlPZkJ1aWxkcyhpbnB1dCkge1xyXG4gICAgaWYgKCFpbnB1dCB8fCAhKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIWlzQnVpbGQoaW5wdXRbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB2c2l4TmFtZUZvclBsYXRmb3JtKGluZm8pIHtcclxuICAgIGNvbnN0IHZzaXhOYW1lID0gZnVuY3Rpb24gKHBsYXRmb3JtSW5mbykge1xyXG4gICAgICAgIHN3aXRjaCAocGxhdGZvcm1JbmZvLnBsYXRmb3JtKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3dpbjMyJzogcmV0dXJuICdjcHB0b29scy13aW4zMi52c2l4JztcclxuICAgICAgICAgICAgY2FzZSAnZGFyd2luJzogcmV0dXJuICdjcHB0b29scy1vc3gudnNpeCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGxhdGZvcm1JbmZvLmFyY2hpdGVjdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3g4Nl82NCc6IHJldHVybiAnY3BwdG9vbHMtbGludXgudnNpeCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneDg2JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpMzg2JzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpNjg2JzogcmV0dXJuICdjcHB0b29scy1saW51eDMyLnZzaXgnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfShpbmZvKTtcclxuICAgIGlmICghdnNpeE5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBtYXRjaCBWU0lYIG5hbWUgZm9yOiAnICsgaW5mby5wbGF0Zm9ybSArICc6JyArIGluZm8uYXJjaGl0ZWN0dXJlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2c2l4TmFtZTtcclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRCdWlsZEluZm8odXBkYXRlQ2hhbm5lbCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UmVsZWFzZUpzb24oKVxyXG4gICAgICAgICAgICAudGhlbihidWlsZHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWJ1aWxkcyB8fCBidWlsZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJWZXJzaW9uID0gbmV3IHBhY2thZ2VWZXJzaW9uXzEuUGFja2FnZVZlcnNpb24odXRpbC5wYWNrYWdlSnNvbi52ZXJzaW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IG5ldyBwYWNrYWdlVmVyc2lvbl8xLlBhY2thZ2VWZXJzaW9uKGJ1aWxkc1swXS5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKCF0ZXN0aW5nSW5zaWRlcnNWc2l4SW5zdGFsbCAmJiAodXNlclZlcnNpb24uaXNHcmVhdGVyVGhhbihsYXRlc3RWZXJzaW9uKSB8fCAodXNlclZlcnNpb24uc3VmZml4ICYmIHVzZXJWZXJzaW9uLnN1ZmZpeCAhPT0gJ2luc2lkZXJzJykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRUYXJnZXRCdWlsZChidWlsZHMsIHVzZXJWZXJzaW9uLCB1cGRhdGVDaGFubmVsKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoYnVpbGQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCFidWlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybUluZm8gPSB5aWVsZCBwbGF0Zm9ybV8xLlBsYXRmb3JtSW5mb3JtYXRpb24uR2V0UGxhdGZvcm1JbmZvcm1hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdnNpeE5hbWUgPSB2c2l4TmFtZUZvclBsYXRmb3JtKHBsYXRmb3JtSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFVybCA9IGdldFZzaXhEb3dubG9hZFVybChidWlsZCwgdnNpeE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG93bmxvYWRVcmw6IGRvd25sb2FkVXJsLCBuYW1lOiBidWlsZC5uYW1lIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5nZXRUYXJnZXRCdWlsZEluZm8gPSBnZXRUYXJnZXRCdWlsZEluZm87XHJcbmZ1bmN0aW9uIGdldFRhcmdldEJ1aWxkKGJ1aWxkcywgdXNlclZlcnNpb24sIHVwZGF0ZUNoYW5uZWwpIHtcclxuICAgIGxldCBuZWVkc1VwZGF0ZTtcclxuICAgIGxldCB1c2VCdWlsZDtcclxuICAgIGlmICh1cGRhdGVDaGFubmVsID09PSAnSW5zaWRlcnMnKSB7XHJcbiAgICAgICAgbmVlZHNVcGRhdGUgPSAoaW5zdGFsbGVkLCB0YXJnZXQpID0+IHsgcmV0dXJuIHRlc3RpbmdJbnNpZGVyc1ZzaXhJbnN0YWxsIHx8IHRhcmdldC5pc0dyZWF0ZXJUaGFuKGluc3RhbGxlZCk7IH07XHJcbiAgICAgICAgdXNlQnVpbGQgPSAoYnVpbGQpID0+IHsgcmV0dXJuIHRydWU7IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1cGRhdGVDaGFubmVsID09PSAnRGVmYXVsdCcpIHtcclxuICAgICAgICBuZWVkc1VwZGF0ZSA9IGZ1bmN0aW9uIChpbnN0YWxsZWQsIHRhcmdldCkgeyByZXR1cm4gaW5zdGFsbGVkLmlzR3JlYXRlclRoYW4odGFyZ2V0KTsgfTtcclxuICAgICAgICB1c2VCdWlsZCA9IChidWlsZCkgPT4geyByZXR1cm4gYnVpbGQubmFtZS5pbmRleE9mKCctJykgPT09IC0xOyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgdXBkYXRlQ2hhbm5lbCBzZXR0aW5nIHByb3ZpZGVkJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRCdWlsZCA9IGJ1aWxkcy5maW5kKChidWlsZCkgPT4gdXNlQnVpbGQoYnVpbGQpKTtcclxuICAgIGlmICghdGFyZ2V0QnVpbGQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZXRlcm1pbmUgaW5zdGFsbGF0aW9uIGNhbmRpZGF0ZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0VmVyc2lvbiA9IG5ldyBwYWNrYWdlVmVyc2lvbl8xLlBhY2thZ2VWZXJzaW9uKHRhcmdldEJ1aWxkLm5hbWUpO1xyXG4gICAgaWYgKG5lZWRzVXBkYXRlKHVzZXJWZXJzaW9uLCB0YXJnZXRWZXJzaW9uKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRCdWlsZDtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNSYXRlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgJiYgdXRpbC5pc051bWJlcihpbnB1dC5yZW1haW5pbmcpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmF0ZUxpbWl0KGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgJiYgaXNSYXRlKGlucHV0LnJhdGUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhdGVMaW1pdCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0geyAnVXNlci1BZ2VudCc6ICd2c2NvZGUtY3BwdG9vbHMnIH07XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHV0aWwuZG93bmxvYWRGaWxlVG9TdHIoJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmF0ZV9saW1pdCcsIGhlYWRlcilcclxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCByYXRlIGxpbWl0IEpTT04nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmF0ZUxpbWl0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJhdGVMaW1pdCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSByYXRlIGxpbWl0IEpTT04nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmF0ZUxpbWl0KHJhdGVMaW1pdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyYXRlTGltaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRlIGxpbWl0IEpTT04gaXMgbm90IG9mIHR5cGUgUmF0ZUxpbWl0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmF0ZUxpbWl0RXhjZWVkZWQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJhdGVMaW1pdCA9IHlpZWxkIGdldFJhdGVMaW1pdCgpO1xyXG4gICAgICAgIHJldHVybiByYXRlTGltaXQgJiYgcmF0ZUxpbWl0LnJhdGUucmVtYWluaW5nIDw9IDA7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRSZWxlYXNlSnNvbigpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKHlpZWxkIHJhdGVMaW1pdEV4Y2VlZGVkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3RheSB3aXRoaW4gR2l0SHViIEFQSSByYXRlIGxpbWl0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlbGVhc2VVcmwgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9NaWNyb3NvZnQvdnNjb2RlLWNwcHRvb2xzL3JlbGVhc2VzJztcclxuICAgICAgICBjb25zdCBoZWFkZXIgPSB7ICdVc2VyLUFnZW50JzogJ3ZzY29kZS1jcHB0b29scycgfTtcclxuICAgICAgICBjb25zdCBkYXRhID0geWllbGQgdXRpbC5kb3dubG9hZEZpbGVUb1N0cihyZWxlYXNlVXJsLCBoZWFkZXIpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgJiYgZXJyb3IuY29kZSAhPT0gXCJFTk9FTlRcIikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgcmVsZWFzZSBKU09OJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlbGVhc2VKc29uO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlbGVhc2VKc29uID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHJlbGVhc2UgSlNPTicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheU9mQnVpbGRzKHJlbGVhc2VKc29uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZUpzb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbGVhc2UgSlNPTiBpcyBub3Qgb2YgdHlwZSBCdWlsZFtdJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/githubAPI.ts\n");

/***/ }),

/***/ "./src/installationInformation.ts":
/*!****************************************!*\
  !*** ./src/installationInformation.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nclass InstallationInformation {\r\n    constructor() {\r\n        this.hasError = false;\r\n        this.telemetryProperties = {};\r\n    }\r\n}\r\nexports.InstallationInformation = InstallationInformation;\r\nlet installBlob;\r\nfunction getInstallationInformation() {\r\n    if (!installBlob) {\r\n        installBlob = new InstallationInformation();\r\n    }\r\n    return installBlob;\r\n}\r\nexports.getInstallationInformation = getInstallationInformation;\r\nfunction setInstallationStage(stage) {\r\n    getInstallationInformation().stage = stage;\r\n}\r\nexports.setInstallationStage = setInstallationStage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5zdGFsbGF0aW9uSW5mb3JtYXRpb24udHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL2luc3RhbGxhdGlvbkluZm9ybWF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgSW5zdGFsbGF0aW9uSW5mb3JtYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGVsZW1ldHJ5UHJvcGVydGllcyA9IHt9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSW5zdGFsbGF0aW9uSW5mb3JtYXRpb24gPSBJbnN0YWxsYXRpb25JbmZvcm1hdGlvbjtcclxubGV0IGluc3RhbGxCbG9iO1xyXG5mdW5jdGlvbiBnZXRJbnN0YWxsYXRpb25JbmZvcm1hdGlvbigpIHtcclxuICAgIGlmICghaW5zdGFsbEJsb2IpIHtcclxuICAgICAgICBpbnN0YWxsQmxvYiA9IG5ldyBJbnN0YWxsYXRpb25JbmZvcm1hdGlvbigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3RhbGxCbG9iO1xyXG59XHJcbmV4cG9ydHMuZ2V0SW5zdGFsbGF0aW9uSW5mb3JtYXRpb24gPSBnZXRJbnN0YWxsYXRpb25JbmZvcm1hdGlvbjtcclxuZnVuY3Rpb24gc2V0SW5zdGFsbGF0aW9uU3RhZ2Uoc3RhZ2UpIHtcclxuICAgIGdldEluc3RhbGxhdGlvbkluZm9ybWF0aW9uKCkuc3RhZ2UgPSBzdGFnZTtcclxufVxyXG5leHBvcnRzLnNldEluc3RhbGxhdGlvblN0YWdlID0gc2V0SW5zdGFsbGF0aW9uU3RhZ2U7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/installationInformation.ts\n");

/***/ }),

/***/ "./src/linuxDistribution.ts":
/*!**********************************!*\
  !*** ./src/linuxDistribution.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nclass LinuxDistribution {\r\n    constructor(name, version) {\r\n        this.name = name;\r\n        this.version = version;\r\n    }\r\n    static GetDistroInformation() {\r\n        let linuxDistro;\r\n        linuxDistro = LinuxDistribution.getDistroInformationFromFile('/etc/os-release')\r\n            .catch(() => {\r\n            return LinuxDistribution.getDistroInformationFromFile('/usr/lib/os-release');\r\n        }).catch(() => {\r\n            return Promise.resolve(new LinuxDistribution('unknown', 'unknown'));\r\n        });\r\n        return linuxDistro;\r\n    }\r\n    static getDistroInformationFromFile(path) {\r\n        return new Promise((resolve, reject) => {\r\n            fs.readFile(path, 'utf8', (error, data) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                resolve(LinuxDistribution.getDistroInformation(data));\r\n            });\r\n        });\r\n    }\r\n    static getDistroInformation(data) {\r\n        const idKey = 'ID';\r\n        const versionKey = 'VERSION_ID';\r\n        let distroName = 'unknown';\r\n        let distroVersion = 'unknown';\r\n        let keyValues = data.split(os.EOL);\r\n        for (let i = 0; i < keyValues.length; i++) {\r\n            let keyValue = keyValues[i].split('=');\r\n            if (keyValue.length === 2) {\r\n                if (keyValue[0] === idKey) {\r\n                    distroName = keyValue[1];\r\n                }\r\n                else if (keyValue[0] === versionKey) {\r\n                    distroVersion = keyValue[1];\r\n                }\r\n            }\r\n        }\r\n        return new LinuxDistribution(distroName, distroVersion);\r\n    }\r\n}\r\nexports.LinuxDistribution = LinuxDistribution;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGludXhEaXN0cmlidXRpb24udHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL2xpbnV4RGlzdHJpYnV0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jbGFzcyBMaW51eERpc3RyaWJ1dGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIEdldERpc3Ryb0luZm9ybWF0aW9uKCkge1xyXG4gICAgICAgIGxldCBsaW51eERpc3RybztcclxuICAgICAgICBsaW51eERpc3RybyA9IExpbnV4RGlzdHJpYnV0aW9uLmdldERpc3Ryb0luZm9ybWF0aW9uRnJvbUZpbGUoJy9ldGMvb3MtcmVsZWFzZScpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaW51eERpc3RyaWJ1dGlvbi5nZXREaXN0cm9JbmZvcm1hdGlvbkZyb21GaWxlKCcvdXNyL2xpYi9vcy1yZWxlYXNlJyk7XHJcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBMaW51eERpc3RyaWJ1dGlvbigndW5rbm93bicsICd1bmtub3duJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBsaW51eERpc3RybztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXREaXN0cm9JbmZvcm1hdGlvbkZyb21GaWxlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBmcy5yZWFkRmlsZShwYXRoLCAndXRmOCcsIChlcnJvciwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKExpbnV4RGlzdHJpYnV0aW9uLmdldERpc3Ryb0luZm9ybWF0aW9uKGRhdGEpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0RGlzdHJvSW5mb3JtYXRpb24oZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGlkS2V5ID0gJ0lEJztcclxuICAgICAgICBjb25zdCB2ZXJzaW9uS2V5ID0gJ1ZFUlNJT05fSUQnO1xyXG4gICAgICAgIGxldCBkaXN0cm9OYW1lID0gJ3Vua25vd24nO1xyXG4gICAgICAgIGxldCBkaXN0cm9WZXJzaW9uID0gJ3Vua25vd24nO1xyXG4gICAgICAgIGxldCBrZXlWYWx1ZXMgPSBkYXRhLnNwbGl0KG9zLkVPTCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGtleVZhbHVlID0ga2V5VmFsdWVzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZVswXSA9PT0gaWRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0cm9OYW1lID0ga2V5VmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXlWYWx1ZVswXSA9PT0gdmVyc2lvbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Ryb1ZlcnNpb24gPSBrZXlWYWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbnV4RGlzdHJpYnV0aW9uKGRpc3Ryb05hbWUsIGRpc3Ryb1ZlcnNpb24pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTGludXhEaXN0cmlidXRpb24gPSBMaW51eERpc3RyaWJ1dGlvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/linuxDistribution.ts\n");

/***/ }),

/***/ "./src/logger.ts":
/*!***********************!*\
  !*** ./src/logger.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nlet Subscriber;\r\nfunction subscribeToAllLoggers(subscriber) {\r\n    Subscriber = subscriber;\r\n}\r\nexports.subscribeToAllLoggers = subscribeToAllLoggers;\r\nclass Logger {\r\n    constructor(writer) {\r\n        this.writer = writer;\r\n    }\r\n    append(message) {\r\n        this.writer(message);\r\n        if (Subscriber) {\r\n            Subscriber(message);\r\n        }\r\n    }\r\n    appendLine(message) {\r\n        this.writer(message + os.EOL);\r\n        if (Subscriber) {\r\n            Subscriber(message + os.EOL);\r\n        }\r\n    }\r\n    showInformationMessage(message, items) {\r\n        this.appendLine(message);\r\n        return vscode.window.showInformationMessage(message, ...items);\r\n    }\r\n    showWarningMessage(message, items) {\r\n        this.appendLine(message);\r\n        return vscode.window.showWarningMessage(message, ...items);\r\n    }\r\n    showErrorMessage(message, items) {\r\n        this.appendLine(message);\r\n        return vscode.window.showErrorMessage(message, ...items);\r\n    }\r\n}\r\nexports.Logger = Logger;\r\nlet outputChannel;\r\nfunction getOutputChannel() {\r\n    if (outputChannel === undefined) {\r\n        outputChannel = vscode.window.createOutputChannel(\"C/C++\");\r\n    }\r\n    return outputChannel;\r\n}\r\nexports.getOutputChannel = getOutputChannel;\r\nfunction showOutputChannel() {\r\n    getOutputChannel().show();\r\n}\r\nexports.showOutputChannel = showOutputChannel;\r\nlet outputChannelLogger;\r\nfunction getOutputChannelLogger() {\r\n    if (!outputChannelLogger) {\r\n        outputChannelLogger = new Logger(message => getOutputChannel().append(message));\r\n    }\r\n    return outputChannelLogger;\r\n}\r\nexports.getOutputChannelLogger = getOutputChannelLogger;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9nZ2VyLnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy9sb2dnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5sZXQgU3Vic2NyaWJlcjtcclxuZnVuY3Rpb24gc3Vic2NyaWJlVG9BbGxMb2dnZXJzKHN1YnNjcmliZXIpIHtcclxuICAgIFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xyXG59XHJcbmV4cG9ydHMuc3Vic2NyaWJlVG9BbGxMb2dnZXJzID0gc3Vic2NyaWJlVG9BbGxMb2dnZXJzO1xyXG5jbGFzcyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVyKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXIgPSB3cml0ZXI7XHJcbiAgICB9XHJcbiAgICBhcHBlbmQobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMud3JpdGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmIChTdWJzY3JpYmVyKSB7XHJcbiAgICAgICAgICAgIFN1YnNjcmliZXIobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXBwZW5kTGluZShtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXIobWVzc2FnZSArIG9zLkVPTCk7XHJcbiAgICAgICAgaWYgKFN1YnNjcmliZXIpIHtcclxuICAgICAgICAgICAgU3Vic2NyaWJlcihtZXNzYWdlICsgb3MuRU9MKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG93SW5mb3JtYXRpb25NZXNzYWdlKG1lc3NhZ2UsIGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRMaW5lKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGUud2luZG93LnNob3dJbmZvcm1hdGlvbk1lc3NhZ2UobWVzc2FnZSwgLi4uaXRlbXMpO1xyXG4gICAgfVxyXG4gICAgc2hvd1dhcm5pbmdNZXNzYWdlKG1lc3NhZ2UsIGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRMaW5lKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGUud2luZG93LnNob3dXYXJuaW5nTWVzc2FnZShtZXNzYWdlLCAuLi5pdGVtcyk7XHJcbiAgICB9XHJcbiAgICBzaG93RXJyb3JNZXNzYWdlKG1lc3NhZ2UsIGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRMaW5lKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UobWVzc2FnZSwgLi4uaXRlbXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xyXG5sZXQgb3V0cHV0Q2hhbm5lbDtcclxuZnVuY3Rpb24gZ2V0T3V0cHV0Q2hhbm5lbCgpIHtcclxuICAgIGlmIChvdXRwdXRDaGFubmVsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvdXRwdXRDaGFubmVsID0gdnNjb2RlLndpbmRvdy5jcmVhdGVPdXRwdXRDaGFubmVsKFwiQy9DKytcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0Q2hhbm5lbDtcclxufVxyXG5leHBvcnRzLmdldE91dHB1dENoYW5uZWwgPSBnZXRPdXRwdXRDaGFubmVsO1xyXG5mdW5jdGlvbiBzaG93T3V0cHV0Q2hhbm5lbCgpIHtcclxuICAgIGdldE91dHB1dENoYW5uZWwoKS5zaG93KCk7XHJcbn1cclxuZXhwb3J0cy5zaG93T3V0cHV0Q2hhbm5lbCA9IHNob3dPdXRwdXRDaGFubmVsO1xyXG5sZXQgb3V0cHV0Q2hhbm5lbExvZ2dlcjtcclxuZnVuY3Rpb24gZ2V0T3V0cHV0Q2hhbm5lbExvZ2dlcigpIHtcclxuICAgIGlmICghb3V0cHV0Q2hhbm5lbExvZ2dlcikge1xyXG4gICAgICAgIG91dHB1dENoYW5uZWxMb2dnZXIgPSBuZXcgTG9nZ2VyKG1lc3NhZ2UgPT4gZ2V0T3V0cHV0Q2hhbm5lbCgpLmFwcGVuZChtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0Q2hhbm5lbExvZ2dlcjtcclxufVxyXG5leHBvcnRzLmdldE91dHB1dENoYW5uZWxMb2dnZXIgPSBnZXRPdXRwdXRDaGFubmVsTG9nZ2VyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/logger.ts\n");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cpptoolsJsonUtils = __webpack_require__(/*! ./abTesting */ \"./src/abTesting.ts\");\r\nconst DebuggerExtension = __webpack_require__(/*! ./Debugger/extension */ \"./src/Debugger/extension.ts\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst LanguageServer = __webpack_require__(/*! ./LanguageServer/extension */ \"./src/LanguageServer/extension.ts\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst Telemetry = __webpack_require__(/*! ./telemetry */ \"./src/telemetry.ts\");\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst commands_1 = __webpack_require__(/*! ./commands */ \"./src/commands.ts\");\r\nconst platform_1 = __webpack_require__(/*! ./platform */ \"./src/platform.ts\");\r\nconst packageManager_1 = __webpack_require__(/*! ./packageManager */ \"./src/packageManager.ts\");\r\nconst persistentState_1 = __webpack_require__(/*! ./LanguageServer/persistentState */ \"./src/LanguageServer/persistentState.ts\");\r\nconst installationInformation_1 = __webpack_require__(/*! ./installationInformation */ \"./src/installationInformation.ts\");\r\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\r\nconst cppTools1_1 = __webpack_require__(/*! ./cppTools1 */ \"./src/cppTools1.ts\");\r\nconst releaseNotesVersion = 3;\r\nconst cppTools = new cppTools1_1.CppTools1();\r\nlet languageServiceDisabled = false;\r\nlet reloadMessageShown = false;\r\nlet disposables = [];\r\nfunction activate(context) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        commands_1.initializeTemporaryCommandRegistrar();\r\n        util.setExtensionContext(context);\r\n        Telemetry.activate();\r\n        util.setProgress(0);\r\n        DebuggerExtension.initialize(context);\r\n        yield processRuntimeDependencies();\r\n        return cppTools;\r\n    });\r\n}\r\nexports.activate = activate;\r\nfunction deactivate() {\r\n    DebuggerExtension.dispose();\r\n    Telemetry.deactivate();\r\n    disposables.forEach(d => d.dispose());\r\n    if (languageServiceDisabled) {\r\n        return;\r\n    }\r\n    return LanguageServer.deactivate();\r\n}\r\nexports.deactivate = deactivate;\r\nfunction processRuntimeDependencies() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const installLockExists = yield util.checkInstallLockFile();\r\n        if (installLockExists) {\r\n            if (util.packageJson.activationEvents && util.packageJson.activationEvents.length === 1) {\r\n                try {\r\n                    yield offlineInstallation();\r\n                }\r\n                catch (error) {\r\n                    logger_1.getOutputChannelLogger().showErrorMessage('The installation of the C/C++ extension failed. Please see the output window for more information.');\r\n                    logger_1.showOutputChannel();\r\n                    sendTelemetry(yield platform_1.PlatformInformation.GetPlatformInformation());\r\n                }\r\n            }\r\n            else {\r\n                yield finalizeExtensionActivation();\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                yield onlineInstallation();\r\n            }\r\n            catch (error) {\r\n                handleError(error);\r\n                sendTelemetry(yield platform_1.PlatformInformation.GetPlatformInformation());\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction offlineInstallation() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        installationInformation_1.setInstallationStage('getPlatformInfo');\r\n        const info = yield platform_1.PlatformInformation.GetPlatformInformation();\r\n        installationInformation_1.setInstallationStage('makeBinariesExecutable');\r\n        yield makeBinariesExecutable();\r\n        installationInformation_1.setInstallationStage('makeOfflineBinariesExecutable');\r\n        yield makeOfflineBinariesExecutable(info);\r\n        installationInformation_1.setInstallationStage('removeUnnecessaryFile');\r\n        yield removeUnnecessaryFile();\r\n        installationInformation_1.setInstallationStage('rewriteManifest');\r\n        yield rewriteManifest();\r\n        installationInformation_1.setInstallationStage('postInstall');\r\n        yield postInstall(info);\r\n    });\r\n}\r\nfunction onlineInstallation() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        installationInformation_1.setInstallationStage('getPlatformInfo');\r\n        const info = yield platform_1.PlatformInformation.GetPlatformInformation();\r\n        yield downloadAndInstallPackages(info);\r\n        installationInformation_1.setInstallationStage('makeBinariesExecutable');\r\n        yield makeBinariesExecutable();\r\n        installationInformation_1.setInstallationStage('removeUnnecessaryFile');\r\n        yield removeUnnecessaryFile();\r\n        installationInformation_1.setInstallationStage('rewriteManifest');\r\n        yield rewriteManifest();\r\n        installationInformation_1.setInstallationStage('touchInstallLockFile');\r\n        yield touchInstallLockFile();\r\n        installationInformation_1.setInstallationStage('postInstall');\r\n        yield postInstall(info);\r\n    });\r\n}\r\nfunction downloadAndInstallPackages(info) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let outputChannelLogger = logger_1.getOutputChannelLogger();\r\n        outputChannelLogger.appendLine(\"Updating C/C++ dependencies...\");\r\n        let packageManager = new packageManager_1.PackageManager(info, outputChannelLogger);\r\n        return vscode.window.withProgress({\r\n            location: vscode.ProgressLocation.Notification,\r\n            title: \"C/C++ Extension\",\r\n            cancellable: false\r\n        }, (progress, token) => __awaiter(this, void 0, void 0, function* () {\r\n            outputChannelLogger.appendLine('');\r\n            installationInformation_1.setInstallationStage('downloadPackages');\r\n            yield packageManager.DownloadPackages(progress);\r\n            outputChannelLogger.appendLine('');\r\n            installationInformation_1.setInstallationStage('installPackages');\r\n            yield packageManager.InstallPackages(progress);\r\n        }));\r\n    });\r\n}\r\nfunction makeBinariesExecutable() {\r\n    return util.allowExecution(util.getDebugAdaptersPath(\"OpenDebugAD7\"));\r\n}\r\nfunction makeOfflineBinariesExecutable(info) {\r\n    let promises = [];\r\n    let packages = util.packageJson[\"runtimeDependencies\"];\r\n    packages.forEach(p => {\r\n        if (p.binaries && p.binaries.length > 0 &&\r\n            p.platforms.findIndex(plat => plat === info.platform) !== -1 &&\r\n            (p.architectures === undefined || p.architectures.findIndex(arch => arch === info.architecture) !== -1)) {\r\n            p.binaries.forEach(binary => promises.push(util.allowExecution(util.getExtensionFilePath(binary))));\r\n        }\r\n    });\r\n    return Promise.all(promises).then(() => { });\r\n}\r\nfunction removeUnnecessaryFile() {\r\n    if (os.platform() !== 'win32') {\r\n        let sourcePath = util.getDebugAdaptersPath(\"bin/OpenDebugAD7.exe.config\");\r\n        if (fs.existsSync(sourcePath)) {\r\n            fs.rename(sourcePath, util.getDebugAdaptersPath(\"bin/OpenDebugAD7.exe.config.unused\"), (err) => {\r\n                if (err) {\r\n                    logger_1.getOutputChannelLogger().appendLine(`ERROR: fs.rename failed with \"${err.message}\". Delete ${sourcePath} manually to enable debugging.`);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return Promise.resolve();\r\n}\r\nfunction touchInstallLockFile() {\r\n    return util.touchInstallLockFile();\r\n}\r\nfunction handleError(error) {\r\n    let installationInformation = installationInformation_1.getInstallationInformation();\r\n    installationInformation.hasError = true;\r\n    installationInformation.telemetryProperties['stage'] = installationInformation.stage;\r\n    let errorMessage;\r\n    if (error instanceof packageManager_1.PackageManagerError) {\r\n        let packageError = error;\r\n        installationInformation.telemetryProperties['error.methodName'] = packageError.methodName;\r\n        installationInformation.telemetryProperties['error.message'] = packageError.message;\r\n        if (packageError.innerError) {\r\n            errorMessage = packageError.innerError.toString();\r\n            installationInformation.telemetryProperties['error.innerError'] = util.removePotentialPII(errorMessage);\r\n        }\r\n        else {\r\n            errorMessage = packageError.message;\r\n        }\r\n        if (packageError.pkg) {\r\n            installationInformation.telemetryProperties['error.packageName'] = packageError.pkg.description;\r\n            installationInformation.telemetryProperties['error.packageUrl'] = packageError.pkg.url;\r\n        }\r\n        if (packageError.errorCode) {\r\n            installationInformation.telemetryProperties['error.errorCode'] = util.removePotentialPII(packageError.errorCode);\r\n        }\r\n    }\r\n    else {\r\n        errorMessage = error.toString();\r\n        installationInformation.telemetryProperties['error.toString'] = util.removePotentialPII(errorMessage);\r\n    }\r\n    let outputChannelLogger = logger_1.getOutputChannelLogger();\r\n    if (installationInformation.stage === 'downloadPackages') {\r\n        outputChannelLogger.appendLine(\"\");\r\n    }\r\n    outputChannelLogger.appendLine(`Failed at stage: ${installationInformation.stage}`);\r\n    outputChannelLogger.appendLine(errorMessage);\r\n    outputChannelLogger.appendLine(\"\");\r\n    outputChannelLogger.appendLine(`If you work in an offline environment or repeatedly see this error, try downloading a version of the extension with all the dependencies pre-included from https://github.com/Microsoft/vscode-cpptools/releases, then use the \"Install from VSIX\" command in VS Code to install it.`);\r\n    logger_1.showOutputChannel();\r\n}\r\nfunction sendTelemetry(info) {\r\n    let installBlob = installationInformation_1.getInstallationInformation();\r\n    const success = !installBlob.hasError;\r\n    installBlob.telemetryProperties['success'] = success.toString();\r\n    if (info.distribution) {\r\n        installBlob.telemetryProperties['linuxDistroName'] = info.distribution.name;\r\n        installBlob.telemetryProperties['linuxDistroVersion'] = info.distribution.version;\r\n    }\r\n    if (success) {\r\n        util.setProgress(util.getProgressInstallSuccess());\r\n        let versionShown = new persistentState_1.PersistentState(\"CPP.ReleaseNotesVersion\", -1);\r\n        if (versionShown.Value < releaseNotesVersion) {\r\n            util.showReleaseNotes();\r\n            versionShown.Value = releaseNotesVersion;\r\n        }\r\n    }\r\n    installBlob.telemetryProperties['osArchitecture'] = info.architecture;\r\n    Telemetry.logDebuggerEvent(\"acquisition\", installBlob.telemetryProperties);\r\n    return success;\r\n}\r\nfunction postInstall(info) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let outputChannelLogger = logger_1.getOutputChannelLogger();\r\n        outputChannelLogger.appendLine(\"\");\r\n        outputChannelLogger.appendLine(\"Finished installing dependencies\");\r\n        outputChannelLogger.appendLine(\"\");\r\n        const installSuccess = sendTelemetry(info);\r\n        if (!installSuccess) {\r\n            return Promise.reject(\"\");\r\n        }\r\n        else {\r\n            util.checkDistro(info);\r\n            return finalizeExtensionActivation();\r\n        }\r\n    });\r\n}\r\nfunction finalizeExtensionActivation() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (vscode.workspace.getConfiguration(\"C_Cpp\", null).get(\"intelliSenseEngine\") === \"Disabled\") {\r\n            languageServiceDisabled = true;\r\n            commands_1.getTemporaryCommandRegistrarInstance().disableLanguageServer();\r\n            disposables.push(vscode.workspace.onDidChangeConfiguration(() => {\r\n                if (!reloadMessageShown && vscode.workspace.getConfiguration(\"C_Cpp\", null).get(\"intelliSenseEngine\") !== \"Disabled\") {\r\n                    reloadMessageShown = true;\r\n                    util.promptForReloadWindowDueToSettingsChange();\r\n                }\r\n            }));\r\n            return;\r\n        }\r\n        disposables.push(vscode.workspace.onDidChangeConfiguration(() => {\r\n            if (!reloadMessageShown && vscode.workspace.getConfiguration(\"C_Cpp\", null).get(\"intelliSenseEngine\") === \"Disabled\") {\r\n                reloadMessageShown = true;\r\n                util.promptForReloadWindowDueToSettingsChange();\r\n            }\r\n        }));\r\n        commands_1.getTemporaryCommandRegistrarInstance().activateLanguageServer();\r\n        let packageJsonPath = util.getExtensionFilePath(\"package.json\");\r\n        if (!packageJsonPath.includes(\".vscode-insiders\") && !packageJsonPath.includes(\".vscode-exploration\")) {\r\n            let abTestSettings = cpptoolsJsonUtils.getABTestSettings();\r\n            let packageJson = util.getRawPackageJson();\r\n            let prevIntelliSenseEngineDefault = packageJson.contributes.configuration.properties[\"C_Cpp.intelliSenseEngine\"].default;\r\n            if (abTestSettings.UseDefaultIntelliSenseEngine) {\r\n                packageJson.contributes.configuration.properties[\"C_Cpp.intelliSenseEngine\"].default = \"Default\";\r\n            }\r\n            else {\r\n                packageJson.contributes.configuration.properties[\"C_Cpp.intelliSenseEngine\"].default = \"Tag Parser\";\r\n            }\r\n            if (prevIntelliSenseEngineDefault !== packageJson.contributes.configuration.properties[\"C_Cpp.intelliSenseEngine\"].default) {\r\n                return util.writeFileText(util.getPackageJsonPath(), util.stringifyPackageJson(packageJson));\r\n            }\r\n        }\r\n        else {\r\n            let packageJson = util.getRawPackageJson();\r\n            if (packageJson.contributes.configuration.properties['C_Cpp.updateChannel'].default === 'Default') {\r\n                packageJson.contributes.configuration.properties['C_Cpp.updateChannel'].default = 'Insiders';\r\n                return util.writeFileText(util.getPackageJsonPath(), util.stringifyPackageJson(packageJson));\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction rewriteManifest() {\r\n    let packageJson = util.getRawPackageJson();\r\n    packageJson.activationEvents = [\r\n        \"onLanguage:cpp\",\r\n        \"onLanguage:c\",\r\n        \"onCommand:extension.pickNativeProcess\",\r\n        \"onCommand:extension.pickRemoteNativeProcess\",\r\n        \"onCommand:C_Cpp.BuildAndDebugActiveFile\",\r\n        \"onCommand:C_Cpp.ConfigurationEdit\",\r\n        \"onCommand:C_Cpp.ConfigurationSelect\",\r\n        \"onCommand:C_Cpp.ConfigurationProviderSelect\",\r\n        \"onCommand:C_Cpp.SwitchHeaderSource\",\r\n        \"onCommand:C_Cpp.Navigate\",\r\n        \"onCommand:C_Cpp.GoToDeclaration\",\r\n        \"onCommand:C_Cpp.PeekDeclaration\",\r\n        \"onCommand:C_Cpp.ToggleErrorSquiggles\",\r\n        \"onCommand:C_Cpp.ToggleIncludeFallback\",\r\n        \"onCommand:C_Cpp.ToggleDimInactiveRegions\",\r\n        \"onCommand:C_Cpp.ShowReleaseNotes\",\r\n        \"onCommand:C_Cpp.ResetDatabase\",\r\n        \"onCommand:C_Cpp.PauseParsing\",\r\n        \"onCommand:C_Cpp.ResumeParsing\",\r\n        \"onCommand:C_Cpp.ShowParsingCommands\",\r\n        \"onCommand:C_Cpp.TakeSurvey\",\r\n        \"onDebug\",\r\n        \"workspaceContains:/.vscode/c_cpp_properties.json\"\r\n    ];\r\n    return util.writeFileText(util.getPackageJsonPath(), util.stringifyPackageJson(packageJson));\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi50cy5qcyIsInNvdXJjZXMiOlsiLi4vLi9zcmMvbWFpbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY3BwdG9vbHNKc29uVXRpbHMgPSByZXF1aXJlKFwiLi9hYlRlc3RpbmdcIik7XHJcbmNvbnN0IERlYnVnZ2VyRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4vRGVidWdnZXIvZXh0ZW5zaW9uXCIpO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuY29uc3QgTGFuZ3VhZ2VTZXJ2ZXIgPSByZXF1aXJlKFwiLi9MYW5ndWFnZVNlcnZlci9leHRlbnNpb25cIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jb25zdCBUZWxlbWV0cnkgPSByZXF1aXJlKFwiLi90ZWxlbWV0cnlcIik7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kc1wiKTtcclxuY29uc3QgcGxhdGZvcm1fMSA9IHJlcXVpcmUoXCIuL3BsYXRmb3JtXCIpO1xyXG5jb25zdCBwYWNrYWdlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vcGFja2FnZU1hbmFnZXJcIik7XHJcbmNvbnN0IHBlcnNpc3RlbnRTdGF0ZV8xID0gcmVxdWlyZShcIi4vTGFuZ3VhZ2VTZXJ2ZXIvcGVyc2lzdGVudFN0YXRlXCIpO1xyXG5jb25zdCBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xID0gcmVxdWlyZShcIi4vaW5zdGFsbGF0aW9uSW5mb3JtYXRpb25cIik7XHJcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG5jb25zdCBjcHBUb29sczFfMSA9IHJlcXVpcmUoXCIuL2NwcFRvb2xzMVwiKTtcclxuY29uc3QgcmVsZWFzZU5vdGVzVmVyc2lvbiA9IDM7XHJcbmNvbnN0IGNwcFRvb2xzID0gbmV3IGNwcFRvb2xzMV8xLkNwcFRvb2xzMSgpO1xyXG5sZXQgbGFuZ3VhZ2VTZXJ2aWNlRGlzYWJsZWQgPSBmYWxzZTtcclxubGV0IHJlbG9hZE1lc3NhZ2VTaG93biA9IGZhbHNlO1xyXG5sZXQgZGlzcG9zYWJsZXMgPSBbXTtcclxuZnVuY3Rpb24gYWN0aXZhdGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb21tYW5kc18xLmluaXRpYWxpemVUZW1wb3JhcnlDb21tYW5kUmVnaXN0cmFyKCk7XHJcbiAgICAgICAgdXRpbC5zZXRFeHRlbnNpb25Db250ZXh0KGNvbnRleHQpO1xyXG4gICAgICAgIFRlbGVtZXRyeS5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIHV0aWwuc2V0UHJvZ3Jlc3MoMCk7XHJcbiAgICAgICAgRGVidWdnZXJFeHRlbnNpb24uaW5pdGlhbGl6ZShjb250ZXh0KTtcclxuICAgICAgICB5aWVsZCBwcm9jZXNzUnVudGltZURlcGVuZGVuY2llcygpO1xyXG4gICAgICAgIHJldHVybiBjcHBUb29scztcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuYWN0aXZhdGUgPSBhY3RpdmF0ZTtcclxuZnVuY3Rpb24gZGVhY3RpdmF0ZSgpIHtcclxuICAgIERlYnVnZ2VyRXh0ZW5zaW9uLmRpc3Bvc2UoKTtcclxuICAgIFRlbGVtZXRyeS5kZWFjdGl2YXRlKCk7XHJcbiAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKGQgPT4gZC5kaXNwb3NlKCkpO1xyXG4gICAgaWYgKGxhbmd1YWdlU2VydmljZURpc2FibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExhbmd1YWdlU2VydmVyLmRlYWN0aXZhdGUoKTtcclxufVxyXG5leHBvcnRzLmRlYWN0aXZhdGUgPSBkZWFjdGl2YXRlO1xyXG5mdW5jdGlvbiBwcm9jZXNzUnVudGltZURlcGVuZGVuY2llcygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFsbExvY2tFeGlzdHMgPSB5aWVsZCB1dGlsLmNoZWNrSW5zdGFsbExvY2tGaWxlKCk7XHJcbiAgICAgICAgaWYgKGluc3RhbGxMb2NrRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLnBhY2thZ2VKc29uLmFjdGl2YXRpb25FdmVudHMgJiYgdXRpbC5wYWNrYWdlSnNvbi5hY3RpdmF0aW9uRXZlbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBvZmZsaW5lSW5zdGFsbGF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5nZXRPdXRwdXRDaGFubmVsTG9nZ2VyKCkuc2hvd0Vycm9yTWVzc2FnZSgnVGhlIGluc3RhbGxhdGlvbiBvZiB0aGUgQy9DKysgZXh0ZW5zaW9uIGZhaWxlZC4gUGxlYXNlIHNlZSB0aGUgb3V0cHV0IHdpbmRvdyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5zaG93T3V0cHV0Q2hhbm5lbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRUZWxlbWV0cnkoeWllbGQgcGxhdGZvcm1fMS5QbGF0Zm9ybUluZm9ybWF0aW9uLkdldFBsYXRmb3JtSW5mb3JtYXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBmaW5hbGl6ZUV4dGVuc2lvbkFjdGl2YXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIG9ubGluZUluc3RhbGxhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgc2VuZFRlbGVtZXRyeSh5aWVsZCBwbGF0Zm9ybV8xLlBsYXRmb3JtSW5mb3JtYXRpb24uR2V0UGxhdGZvcm1JbmZvcm1hdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG9mZmxpbmVJbnN0YWxsYXRpb24oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuc2V0SW5zdGFsbGF0aW9uU3RhZ2UoJ2dldFBsYXRmb3JtSW5mbycpO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB5aWVsZCBwbGF0Zm9ybV8xLlBsYXRmb3JtSW5mb3JtYXRpb24uR2V0UGxhdGZvcm1JbmZvcm1hdGlvbigpO1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuc2V0SW5zdGFsbGF0aW9uU3RhZ2UoJ21ha2VCaW5hcmllc0V4ZWN1dGFibGUnKTtcclxuICAgICAgICB5aWVsZCBtYWtlQmluYXJpZXNFeGVjdXRhYmxlKCk7XHJcbiAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb25fMS5zZXRJbnN0YWxsYXRpb25TdGFnZSgnbWFrZU9mZmxpbmVCaW5hcmllc0V4ZWN1dGFibGUnKTtcclxuICAgICAgICB5aWVsZCBtYWtlT2ZmbGluZUJpbmFyaWVzRXhlY3V0YWJsZShpbmZvKTtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdyZW1vdmVVbm5lY2Vzc2FyeUZpbGUnKTtcclxuICAgICAgICB5aWVsZCByZW1vdmVVbm5lY2Vzc2FyeUZpbGUoKTtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdyZXdyaXRlTWFuaWZlc3QnKTtcclxuICAgICAgICB5aWVsZCByZXdyaXRlTWFuaWZlc3QoKTtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdwb3N0SW5zdGFsbCcpO1xyXG4gICAgICAgIHlpZWxkIHBvc3RJbnN0YWxsKGluZm8pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gb25saW5lSW5zdGFsbGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdnZXRQbGF0Zm9ybUluZm8nKTtcclxuICAgICAgICBjb25zdCBpbmZvID0geWllbGQgcGxhdGZvcm1fMS5QbGF0Zm9ybUluZm9ybWF0aW9uLkdldFBsYXRmb3JtSW5mb3JtYXRpb24oKTtcclxuICAgICAgICB5aWVsZCBkb3dubG9hZEFuZEluc3RhbGxQYWNrYWdlcyhpbmZvKTtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdtYWtlQmluYXJpZXNFeGVjdXRhYmxlJyk7XHJcbiAgICAgICAgeWllbGQgbWFrZUJpbmFyaWVzRXhlY3V0YWJsZSgpO1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuc2V0SW5zdGFsbGF0aW9uU3RhZ2UoJ3JlbW92ZVVubmVjZXNzYXJ5RmlsZScpO1xyXG4gICAgICAgIHlpZWxkIHJlbW92ZVVubmVjZXNzYXJ5RmlsZSgpO1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuc2V0SW5zdGFsbGF0aW9uU3RhZ2UoJ3Jld3JpdGVNYW5pZmVzdCcpO1xyXG4gICAgICAgIHlpZWxkIHJld3JpdGVNYW5pZmVzdCgpO1xyXG4gICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuc2V0SW5zdGFsbGF0aW9uU3RhZ2UoJ3RvdWNoSW5zdGFsbExvY2tGaWxlJyk7XHJcbiAgICAgICAgeWllbGQgdG91Y2hJbnN0YWxsTG9ja0ZpbGUoKTtcclxuICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLnNldEluc3RhbGxhdGlvblN0YWdlKCdwb3N0SW5zdGFsbCcpO1xyXG4gICAgICAgIHlpZWxkIHBvc3RJbnN0YWxsKGluZm8pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZG93bmxvYWRBbmRJbnN0YWxsUGFja2FnZXMoaW5mbykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgb3V0cHV0Q2hhbm5lbExvZ2dlciA9IGxvZ2dlcl8xLmdldE91dHB1dENoYW5uZWxMb2dnZXIoKTtcclxuICAgICAgICBvdXRwdXRDaGFubmVsTG9nZ2VyLmFwcGVuZExpbmUoXCJVcGRhdGluZyBDL0MrKyBkZXBlbmRlbmNpZXMuLi5cIik7XHJcbiAgICAgICAgbGV0IHBhY2thZ2VNYW5hZ2VyID0gbmV3IHBhY2thZ2VNYW5hZ2VyXzEuUGFja2FnZU1hbmFnZXIoaW5mbywgb3V0cHV0Q2hhbm5lbExvZ2dlcik7XHJcbiAgICAgICAgcmV0dXJuIHZzY29kZS53aW5kb3cud2l0aFByb2dyZXNzKHtcclxuICAgICAgICAgICAgbG9jYXRpb246IHZzY29kZS5Qcm9ncmVzc0xvY2F0aW9uLk5vdGlmaWNhdGlvbixcclxuICAgICAgICAgICAgdGl0bGU6IFwiQy9DKysgRXh0ZW5zaW9uXCIsXHJcbiAgICAgICAgICAgIGNhbmNlbGxhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0sIChwcm9ncmVzcywgdG9rZW4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbExvZ2dlci5hcHBlbmRMaW5lKCcnKTtcclxuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb25fMS5zZXRJbnN0YWxsYXRpb25TdGFnZSgnZG93bmxvYWRQYWNrYWdlcycpO1xyXG4gICAgICAgICAgICB5aWVsZCBwYWNrYWdlTWFuYWdlci5Eb3dubG9hZFBhY2thZ2VzKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbExvZ2dlci5hcHBlbmRMaW5lKCcnKTtcclxuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb25fMS5zZXRJbnN0YWxsYXRpb25TdGFnZSgnaW5zdGFsbFBhY2thZ2VzJyk7XHJcbiAgICAgICAgICAgIHlpZWxkIHBhY2thZ2VNYW5hZ2VyLkluc3RhbGxQYWNrYWdlcyhwcm9ncmVzcyk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbWFrZUJpbmFyaWVzRXhlY3V0YWJsZSgpIHtcclxuICAgIHJldHVybiB1dGlsLmFsbG93RXhlY3V0aW9uKHV0aWwuZ2V0RGVidWdBZGFwdGVyc1BhdGgoXCJPcGVuRGVidWdBRDdcIikpO1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VPZmZsaW5lQmluYXJpZXNFeGVjdXRhYmxlKGluZm8pIHtcclxuICAgIGxldCBwcm9taXNlcyA9IFtdO1xyXG4gICAgbGV0IHBhY2thZ2VzID0gdXRpbC5wYWNrYWdlSnNvbltcInJ1bnRpbWVEZXBlbmRlbmNpZXNcIl07XHJcbiAgICBwYWNrYWdlcy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgIGlmIChwLmJpbmFyaWVzICYmIHAuYmluYXJpZXMubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICBwLnBsYXRmb3Jtcy5maW5kSW5kZXgocGxhdCA9PiBwbGF0ID09PSBpbmZvLnBsYXRmb3JtKSAhPT0gLTEgJiZcclxuICAgICAgICAgICAgKHAuYXJjaGl0ZWN0dXJlcyA9PT0gdW5kZWZpbmVkIHx8IHAuYXJjaGl0ZWN0dXJlcy5maW5kSW5kZXgoYXJjaCA9PiBhcmNoID09PSBpbmZvLmFyY2hpdGVjdHVyZSkgIT09IC0xKSkge1xyXG4gICAgICAgICAgICBwLmJpbmFyaWVzLmZvckVhY2goYmluYXJ5ID0+IHByb21pc2VzLnB1c2godXRpbC5hbGxvd0V4ZWN1dGlvbih1dGlsLmdldEV4dGVuc2lvbkZpbGVQYXRoKGJpbmFyeSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4geyB9KTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVVbm5lY2Vzc2FyeUZpbGUoKSB7XHJcbiAgICBpZiAob3MucGxhdGZvcm0oKSAhPT0gJ3dpbjMyJykge1xyXG4gICAgICAgIGxldCBzb3VyY2VQYXRoID0gdXRpbC5nZXREZWJ1Z0FkYXB0ZXJzUGF0aChcImJpbi9PcGVuRGVidWdBRDcuZXhlLmNvbmZpZ1wiKTtcclxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2VQYXRoKSkge1xyXG4gICAgICAgICAgICBmcy5yZW5hbWUoc291cmNlUGF0aCwgdXRpbC5nZXREZWJ1Z0FkYXB0ZXJzUGF0aChcImJpbi9PcGVuRGVidWdBRDcuZXhlLmNvbmZpZy51bnVzZWRcIiksIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5nZXRPdXRwdXRDaGFubmVsTG9nZ2VyKCkuYXBwZW5kTGluZShgRVJST1I6IGZzLnJlbmFtZSBmYWlsZWQgd2l0aCBcIiR7ZXJyLm1lc3NhZ2V9XCIuIERlbGV0ZSAke3NvdXJjZVBhdGh9IG1hbnVhbGx5IHRvIGVuYWJsZSBkZWJ1Z2dpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufVxyXG5mdW5jdGlvbiB0b3VjaEluc3RhbGxMb2NrRmlsZSgpIHtcclxuICAgIHJldHVybiB1dGlsLnRvdWNoSW5zdGFsbExvY2tGaWxlKCk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcclxuICAgIGxldCBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbiA9IGluc3RhbGxhdGlvbkluZm9ybWF0aW9uXzEuZ2V0SW5zdGFsbGF0aW9uSW5mb3JtYXRpb24oKTtcclxuICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uLmhhc0Vycm9yID0gdHJ1ZTtcclxuICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uLnRlbGVtZXRyeVByb3BlcnRpZXNbJ3N0YWdlJ10gPSBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbi5zdGFnZTtcclxuICAgIGxldCBlcnJvck1lc3NhZ2U7XHJcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBwYWNrYWdlTWFuYWdlcl8xLlBhY2thZ2VNYW5hZ2VyRXJyb3IpIHtcclxuICAgICAgICBsZXQgcGFja2FnZUVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb24udGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IubWV0aG9kTmFtZSddID0gcGFja2FnZUVycm9yLm1ldGhvZE5hbWU7XHJcbiAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb24udGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IubWVzc2FnZSddID0gcGFja2FnZUVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKHBhY2thZ2VFcnJvci5pbm5lckVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHBhY2thZ2VFcnJvci5pbm5lckVycm9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uLnRlbGVtZXRyeVByb3BlcnRpZXNbJ2Vycm9yLmlubmVyRXJyb3InXSA9IHV0aWwucmVtb3ZlUG90ZW50aWFsUElJKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBwYWNrYWdlRXJyb3IubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhY2thZ2VFcnJvci5wa2cpIHtcclxuICAgICAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb24udGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IucGFja2FnZU5hbWUnXSA9IHBhY2thZ2VFcnJvci5wa2cuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbkluZm9ybWF0aW9uLnRlbGVtZXRyeVByb3BlcnRpZXNbJ2Vycm9yLnBhY2thZ2VVcmwnXSA9IHBhY2thZ2VFcnJvci5wa2cudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFja2FnZUVycm9yLmVycm9yQ29kZSkge1xyXG4gICAgICAgICAgICBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbi50ZWxlbWV0cnlQcm9wZXJ0aWVzWydlcnJvci5lcnJvckNvZGUnXSA9IHV0aWwucmVtb3ZlUG90ZW50aWFsUElJKHBhY2thZ2VFcnJvci5lcnJvckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaW5zdGFsbGF0aW9uSW5mb3JtYXRpb24udGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IudG9TdHJpbmcnXSA9IHV0aWwucmVtb3ZlUG90ZW50aWFsUElJKGVycm9yTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgb3V0cHV0Q2hhbm5lbExvZ2dlciA9IGxvZ2dlcl8xLmdldE91dHB1dENoYW5uZWxMb2dnZXIoKTtcclxuICAgIGlmIChpbnN0YWxsYXRpb25JbmZvcm1hdGlvbi5zdGFnZSA9PT0gJ2Rvd25sb2FkUGFja2FnZXMnKSB7XHJcbiAgICAgICAgb3V0cHV0Q2hhbm5lbExvZ2dlci5hcHBlbmRMaW5lKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgb3V0cHV0Q2hhbm5lbExvZ2dlci5hcHBlbmRMaW5lKGBGYWlsZWQgYXQgc3RhZ2U6ICR7aW5zdGFsbGF0aW9uSW5mb3JtYXRpb24uc3RhZ2V9YCk7XHJcbiAgICBvdXRwdXRDaGFubmVsTG9nZ2VyLmFwcGVuZExpbmUoZXJyb3JNZXNzYWdlKTtcclxuICAgIG91dHB1dENoYW5uZWxMb2dnZXIuYXBwZW5kTGluZShcIlwiKTtcclxuICAgIG91dHB1dENoYW5uZWxMb2dnZXIuYXBwZW5kTGluZShgSWYgeW91IHdvcmsgaW4gYW4gb2ZmbGluZSBlbnZpcm9ubWVudCBvciByZXBlYXRlZGx5IHNlZSB0aGlzIGVycm9yLCB0cnkgZG93bmxvYWRpbmcgYSB2ZXJzaW9uIG9mIHRoZSBleHRlbnNpb24gd2l0aCBhbGwgdGhlIGRlcGVuZGVuY2llcyBwcmUtaW5jbHVkZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3ZzY29kZS1jcHB0b29scy9yZWxlYXNlcywgdGhlbiB1c2UgdGhlIFwiSW5zdGFsbCBmcm9tIFZTSVhcIiBjb21tYW5kIGluIFZTIENvZGUgdG8gaW5zdGFsbCBpdC5gKTtcclxuICAgIGxvZ2dlcl8xLnNob3dPdXRwdXRDaGFubmVsKCk7XHJcbn1cclxuZnVuY3Rpb24gc2VuZFRlbGVtZXRyeShpbmZvKSB7XHJcbiAgICBsZXQgaW5zdGFsbEJsb2IgPSBpbnN0YWxsYXRpb25JbmZvcm1hdGlvbl8xLmdldEluc3RhbGxhdGlvbkluZm9ybWF0aW9uKCk7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gIWluc3RhbGxCbG9iLmhhc0Vycm9yO1xyXG4gICAgaW5zdGFsbEJsb2IudGVsZW1ldHJ5UHJvcGVydGllc1snc3VjY2VzcyddID0gc3VjY2Vzcy50b1N0cmluZygpO1xyXG4gICAgaWYgKGluZm8uZGlzdHJpYnV0aW9uKSB7XHJcbiAgICAgICAgaW5zdGFsbEJsb2IudGVsZW1ldHJ5UHJvcGVydGllc1snbGludXhEaXN0cm9OYW1lJ10gPSBpbmZvLmRpc3RyaWJ1dGlvbi5uYW1lO1xyXG4gICAgICAgIGluc3RhbGxCbG9iLnRlbGVtZXRyeVByb3BlcnRpZXNbJ2xpbnV4RGlzdHJvVmVyc2lvbiddID0gaW5mby5kaXN0cmlidXRpb24udmVyc2lvbjtcclxuICAgIH1cclxuICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgdXRpbC5zZXRQcm9ncmVzcyh1dGlsLmdldFByb2dyZXNzSW5zdGFsbFN1Y2Nlc3MoKSk7XHJcbiAgICAgICAgbGV0IHZlcnNpb25TaG93biA9IG5ldyBwZXJzaXN0ZW50U3RhdGVfMS5QZXJzaXN0ZW50U3RhdGUoXCJDUFAuUmVsZWFzZU5vdGVzVmVyc2lvblwiLCAtMSk7XHJcbiAgICAgICAgaWYgKHZlcnNpb25TaG93bi5WYWx1ZSA8IHJlbGVhc2VOb3Rlc1ZlcnNpb24pIHtcclxuICAgICAgICAgICAgdXRpbC5zaG93UmVsZWFzZU5vdGVzKCk7XHJcbiAgICAgICAgICAgIHZlcnNpb25TaG93bi5WYWx1ZSA9IHJlbGVhc2VOb3Rlc1ZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5zdGFsbEJsb2IudGVsZW1ldHJ5UHJvcGVydGllc1snb3NBcmNoaXRlY3R1cmUnXSA9IGluZm8uYXJjaGl0ZWN0dXJlO1xyXG4gICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJhY3F1aXNpdGlvblwiLCBpbnN0YWxsQmxvYi50ZWxlbWV0cnlQcm9wZXJ0aWVzKTtcclxuICAgIHJldHVybiBzdWNjZXNzO1xyXG59XHJcbmZ1bmN0aW9uIHBvc3RJbnN0YWxsKGluZm8pIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgbGV0IG91dHB1dENoYW5uZWxMb2dnZXIgPSBsb2dnZXJfMS5nZXRPdXRwdXRDaGFubmVsTG9nZ2VyKCk7XHJcbiAgICAgICAgb3V0cHV0Q2hhbm5lbExvZ2dlci5hcHBlbmRMaW5lKFwiXCIpO1xyXG4gICAgICAgIG91dHB1dENoYW5uZWxMb2dnZXIuYXBwZW5kTGluZShcIkZpbmlzaGVkIGluc3RhbGxpbmcgZGVwZW5kZW5jaWVzXCIpO1xyXG4gICAgICAgIG91dHB1dENoYW5uZWxMb2dnZXIuYXBwZW5kTGluZShcIlwiKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsU3VjY2VzcyA9IHNlbmRUZWxlbWV0cnkoaW5mbyk7XHJcbiAgICAgICAgaWYgKCFpbnN0YWxsU3VjY2Vzcykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1dGlsLmNoZWNrRGlzdHJvKGluZm8pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVFeHRlbnNpb25BY3RpdmF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmluYWxpemVFeHRlbnNpb25BY3RpdmF0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAodnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKFwiQ19DcHBcIiwgbnVsbCkuZ2V0KFwiaW50ZWxsaVNlbnNlRW5naW5lXCIpID09PSBcIkRpc2FibGVkXCIpIHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VTZXJ2aWNlRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb21tYW5kc18xLmdldFRlbXBvcmFyeUNvbW1hbmRSZWdpc3RyYXJJbnN0YW5jZSgpLmRpc2FibGVMYW5ndWFnZVNlcnZlcigpO1xyXG4gICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHZzY29kZS53b3Jrc3BhY2Uub25EaWRDaGFuZ2VDb25maWd1cmF0aW9uKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVsb2FkTWVzc2FnZVNob3duICYmIHZzY29kZS53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbihcIkNfQ3BwXCIsIG51bGwpLmdldChcImludGVsbGlTZW5zZUVuZ2luZVwiKSAhPT0gXCJEaXNhYmxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkTWVzc2FnZVNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsLnByb21wdEZvclJlbG9hZFdpbmRvd0R1ZVRvU2V0dGluZ3NDaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpc3Bvc2FibGVzLnB1c2godnNjb2RlLndvcmtzcGFjZS5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXJlbG9hZE1lc3NhZ2VTaG93biAmJiB2c2NvZGUud29ya3NwYWNlLmdldENvbmZpZ3VyYXRpb24oXCJDX0NwcFwiLCBudWxsKS5nZXQoXCJpbnRlbGxpU2Vuc2VFbmdpbmVcIikgPT09IFwiRGlzYWJsZWRcIikge1xyXG4gICAgICAgICAgICAgICAgcmVsb2FkTWVzc2FnZVNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHV0aWwucHJvbXB0Rm9yUmVsb2FkV2luZG93RHVlVG9TZXR0aW5nc0NoYW5nZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNvbW1hbmRzXzEuZ2V0VGVtcG9yYXJ5Q29tbWFuZFJlZ2lzdHJhckluc3RhbmNlKCkuYWN0aXZhdGVMYW5ndWFnZVNlcnZlcigpO1xyXG4gICAgICAgIGxldCBwYWNrYWdlSnNvblBhdGggPSB1dGlsLmdldEV4dGVuc2lvbkZpbGVQYXRoKFwicGFja2FnZS5qc29uXCIpO1xyXG4gICAgICAgIGlmICghcGFja2FnZUpzb25QYXRoLmluY2x1ZGVzKFwiLnZzY29kZS1pbnNpZGVyc1wiKSAmJiAhcGFja2FnZUpzb25QYXRoLmluY2x1ZGVzKFwiLnZzY29kZS1leHBsb3JhdGlvblwiKSkge1xyXG4gICAgICAgICAgICBsZXQgYWJUZXN0U2V0dGluZ3MgPSBjcHB0b29sc0pzb25VdGlscy5nZXRBQlRlc3RTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBsZXQgcGFja2FnZUpzb24gPSB1dGlsLmdldFJhd1BhY2thZ2VKc29uKCk7XHJcbiAgICAgICAgICAgIGxldCBwcmV2SW50ZWxsaVNlbnNlRW5naW5lRGVmYXVsdCA9IHBhY2thZ2VKc29uLmNvbnRyaWJ1dGVzLmNvbmZpZ3VyYXRpb24ucHJvcGVydGllc1tcIkNfQ3BwLmludGVsbGlTZW5zZUVuZ2luZVwiXS5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoYWJUZXN0U2V0dGluZ3MuVXNlRGVmYXVsdEludGVsbGlTZW5zZUVuZ2luZSkge1xyXG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24uY29udHJpYnV0ZXMuY29uZmlndXJhdGlvbi5wcm9wZXJ0aWVzW1wiQ19DcHAuaW50ZWxsaVNlbnNlRW5naW5lXCJdLmRlZmF1bHQgPSBcIkRlZmF1bHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhY2thZ2VKc29uLmNvbnRyaWJ1dGVzLmNvbmZpZ3VyYXRpb24ucHJvcGVydGllc1tcIkNfQ3BwLmludGVsbGlTZW5zZUVuZ2luZVwiXS5kZWZhdWx0ID0gXCJUYWcgUGFyc2VyXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZJbnRlbGxpU2Vuc2VFbmdpbmVEZWZhdWx0ICE9PSBwYWNrYWdlSnNvbi5jb250cmlidXRlcy5jb25maWd1cmF0aW9uLnByb3BlcnRpZXNbXCJDX0NwcC5pbnRlbGxpU2Vuc2VFbmdpbmVcIl0uZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwud3JpdGVGaWxlVGV4dCh1dGlsLmdldFBhY2thZ2VKc29uUGF0aCgpLCB1dGlsLnN0cmluZ2lmeVBhY2thZ2VKc29uKHBhY2thZ2VKc29uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBwYWNrYWdlSnNvbiA9IHV0aWwuZ2V0UmF3UGFja2FnZUpzb24oKTtcclxuICAgICAgICAgICAgaWYgKHBhY2thZ2VKc29uLmNvbnRyaWJ1dGVzLmNvbmZpZ3VyYXRpb24ucHJvcGVydGllc1snQ19DcHAudXBkYXRlQ2hhbm5lbCddLmRlZmF1bHQgPT09ICdEZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24uY29udHJpYnV0ZXMuY29uZmlndXJhdGlvbi5wcm9wZXJ0aWVzWydDX0NwcC51cGRhdGVDaGFubmVsJ10uZGVmYXVsdCA9ICdJbnNpZGVycyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC53cml0ZUZpbGVUZXh0KHV0aWwuZ2V0UGFja2FnZUpzb25QYXRoKCksIHV0aWwuc3RyaW5naWZ5UGFja2FnZUpzb24ocGFja2FnZUpzb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJld3JpdGVNYW5pZmVzdCgpIHtcclxuICAgIGxldCBwYWNrYWdlSnNvbiA9IHV0aWwuZ2V0UmF3UGFja2FnZUpzb24oKTtcclxuICAgIHBhY2thZ2VKc29uLmFjdGl2YXRpb25FdmVudHMgPSBbXHJcbiAgICAgICAgXCJvbkxhbmd1YWdlOmNwcFwiLFxyXG4gICAgICAgIFwib25MYW5ndWFnZTpjXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6ZXh0ZW5zaW9uLnBpY2tOYXRpdmVQcm9jZXNzXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6ZXh0ZW5zaW9uLnBpY2tSZW1vdGVOYXRpdmVQcm9jZXNzXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6Q19DcHAuQnVpbGRBbmREZWJ1Z0FjdGl2ZUZpbGVcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5Db25maWd1cmF0aW9uRWRpdFwiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLkNvbmZpZ3VyYXRpb25TZWxlY3RcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5Db25maWd1cmF0aW9uUHJvdmlkZXJTZWxlY3RcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5Td2l0Y2hIZWFkZXJTb3VyY2VcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5OYXZpZ2F0ZVwiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLkdvVG9EZWNsYXJhdGlvblwiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLlBlZWtEZWNsYXJhdGlvblwiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLlRvZ2dsZUVycm9yU3F1aWdnbGVzXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6Q19DcHAuVG9nZ2xlSW5jbHVkZUZhbGxiYWNrXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6Q19DcHAuVG9nZ2xlRGltSW5hY3RpdmVSZWdpb25zXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6Q19DcHAuU2hvd1JlbGVhc2VOb3Rlc1wiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLlJlc2V0RGF0YWJhc2VcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5QYXVzZVBhcnNpbmdcIixcclxuICAgICAgICBcIm9uQ29tbWFuZDpDX0NwcC5SZXN1bWVQYXJzaW5nXCIsXHJcbiAgICAgICAgXCJvbkNvbW1hbmQ6Q19DcHAuU2hvd1BhcnNpbmdDb21tYW5kc1wiLFxyXG4gICAgICAgIFwib25Db21tYW5kOkNfQ3BwLlRha2VTdXJ2ZXlcIixcclxuICAgICAgICBcIm9uRGVidWdcIixcclxuICAgICAgICBcIndvcmtzcGFjZUNvbnRhaW5zOi8udnNjb2RlL2NfY3BwX3Byb3BlcnRpZXMuanNvblwiXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIHV0aWwud3JpdGVGaWxlVGV4dCh1dGlsLmdldFBhY2thZ2VKc29uUGF0aCgpLCB1dGlsLnN0cmluZ2lmeVBhY2thZ2VKc29uKHBhY2thZ2VKc29uKSk7XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.ts\n");

/***/ }),

/***/ "./src/packageManager.ts":
/*!*******************************!*\
  !*** ./src/packageManager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nconst url = __webpack_require__(/*! url */ \"url\");\r\nconst tmp = __webpack_require__(/*! tmp */ \"./node_modules/tmp/lib/tmp.js\");\r\nconst yauzl = __webpack_require__(/*! yauzl */ \"./node_modules/yauzl/index.js\");\r\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\");\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nconst Telemetry = __webpack_require__(/*! ./telemetry */ \"./src/telemetry.ts\");\r\nclass PackageManagerError extends Error {\r\n    constructor(message, methodName, pkg = null, innerError = null, errorCode = '') {\r\n        super(message);\r\n        this.message = message;\r\n        this.methodName = methodName;\r\n        this.pkg = pkg;\r\n        this.innerError = innerError;\r\n        this.errorCode = errorCode;\r\n    }\r\n}\r\nexports.PackageManagerError = PackageManagerError;\r\nclass PackageManagerWebResponseError extends PackageManagerError {\r\n    constructor(socket, message, methodName, pkg = null, innerError = null, errorCode = '') {\r\n        super(message, methodName, pkg, innerError, errorCode);\r\n        this.socket = socket;\r\n        this.message = message;\r\n        this.methodName = methodName;\r\n        this.pkg = pkg;\r\n        this.innerError = innerError;\r\n        this.errorCode = errorCode;\r\n    }\r\n}\r\nexports.PackageManagerWebResponseError = PackageManagerWebResponseError;\r\nclass PackageManager {\r\n    constructor(platformInfo, outputChannel) {\r\n        this.platformInfo = platformInfo;\r\n        this.outputChannel = outputChannel;\r\n        tmp.setGracefulCleanup();\r\n    }\r\n    DownloadPackages(progress) {\r\n        return this.GetPackages()\r\n            .then((packages) => {\r\n            let count = 1;\r\n            return this.BuildPromiseChain(packages, (pkg) => {\r\n                const p = this.DownloadPackage(pkg, `${count}/${packages.length}`, progress);\r\n                count += 1;\r\n                return p;\r\n            });\r\n        });\r\n    }\r\n    InstallPackages(progress) {\r\n        return this.GetPackages()\r\n            .then((packages) => {\r\n            let count = 1;\r\n            return this.BuildPromiseChain(packages, (pkg) => {\r\n                const p = this.InstallPackage(pkg, `${count}/${packages.length}`, progress);\r\n                count += 1;\r\n                return p;\r\n            });\r\n        });\r\n    }\r\n    BuildPromiseChain(items, promiseBuilder) {\r\n        let promiseChain = Promise.resolve(null);\r\n        for (let item of items) {\r\n            promiseChain = promiseChain.then(() => {\r\n                return promiseBuilder(item);\r\n            });\r\n        }\r\n        return promiseChain;\r\n    }\r\n    GetPackageList() {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.allPackages) {\r\n                if (util.packageJson.runtimeDependencies) {\r\n                    this.allPackages = util.packageJson.runtimeDependencies;\r\n                    for (let pkg of this.allPackages) {\r\n                        if (pkg.binaries) {\r\n                            pkg.binaries = pkg.binaries.map((value) => {\r\n                                return util.getExtensionFilePath(value);\r\n                            });\r\n                        }\r\n                    }\r\n                    resolve(this.allPackages);\r\n                }\r\n                else {\r\n                    reject(new PackageManagerError('Package manifest does not exist', 'GetPackageList'));\r\n                }\r\n            }\r\n            else {\r\n                resolve(this.allPackages);\r\n            }\r\n        });\r\n    }\r\n    GetPackages() {\r\n        return this.GetPackageList()\r\n            .then((list) => {\r\n            return list.filter((value, index, array) => {\r\n                return (!value.architectures || value.architectures.indexOf(this.platformInfo.architecture) !== -1) &&\r\n                    (!value.platforms || value.platforms.indexOf(this.platformInfo.platform) !== -1);\r\n            });\r\n        });\r\n    }\r\n    DownloadPackage(pkg, progressCount, progress) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.AppendChannel(`Downloading package '${pkg.description}' `);\r\n            progress.report({ message: `Downloading ${progressCount}: ${pkg.description}` });\r\n            const tmpResult = yield this.CreateTempFile(pkg);\r\n            yield this.DownloadPackageWithRetries(pkg, tmpResult, progress);\r\n        });\r\n    }\r\n    CreateTempFile(pkg) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((resolve, reject) => {\r\n                tmp.file({ prefix: \"package-\" }, (err, path, fd, cleanupCallback) => {\r\n                    if (err) {\r\n                        return reject(new PackageManagerError('Error from temp.file', 'DownloadPackage', pkg, err));\r\n                    }\r\n                    return resolve({ name: path, fd: fd, removeCallback: cleanupCallback });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    DownloadPackageWithRetries(pkg, tmpResult, progress) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            pkg.tmpFile = tmpResult;\r\n            let success = false;\r\n            let lastError = null;\r\n            let retryCount = 0;\r\n            const MAX_RETRIES = 5;\r\n            do {\r\n                try {\r\n                    yield this.DownloadFile(pkg.url, pkg, retryCount, progress);\r\n                    success = true;\r\n                }\r\n                catch (error) {\r\n                    retryCount += 1;\r\n                    lastError = error;\r\n                    if (retryCount > MAX_RETRIES) {\r\n                        this.AppendChannel(` Failed to download ` + pkg.url);\r\n                        throw error;\r\n                    }\r\n                    else {\r\n                        this.AppendChannel(` Failed. Retrying...`);\r\n                        continue;\r\n                    }\r\n                }\r\n            } while (!success && retryCount < MAX_RETRIES);\r\n            this.AppendLineChannel(\" Done!\");\r\n            if (retryCount !== 0) {\r\n                let telemetryProperties = {};\r\n                telemetryProperties[\"success\"] = success ? `OnRetry${retryCount}` : 'false';\r\n                if (lastError instanceof PackageManagerError) {\r\n                    let packageError = lastError;\r\n                    telemetryProperties['error.methodName'] = packageError.methodName;\r\n                    telemetryProperties['error.message'] = packageError.message;\r\n                    if (packageError.pkg) {\r\n                        telemetryProperties['error.packageName'] = packageError.pkg.description;\r\n                        telemetryProperties['error.packageUrl'] = packageError.pkg.url;\r\n                    }\r\n                    if (packageError.errorCode) {\r\n                        telemetryProperties['error.errorCode'] = packageError.errorCode;\r\n                    }\r\n                }\r\n                Telemetry.logDebuggerEvent(\"acquisition\", telemetryProperties);\r\n            }\r\n        });\r\n    }\r\n    DownloadFile(urlString, pkg, delay, progress) {\r\n        let parsedUrl = url.parse(urlString);\r\n        let proxyStrictSSL = vscode.workspace.getConfiguration().get(\"http.proxyStrictSSL\", true);\r\n        let options = {\r\n            host: parsedUrl.host,\r\n            path: parsedUrl.path,\r\n            agent: util.getHttpsProxyAgent(),\r\n            rejectUnauthorized: proxyStrictSSL\r\n        };\r\n        return new Promise((resolve, reject) => {\r\n            let secondsDelay = Math.pow(2, delay);\r\n            if (secondsDelay === 1) {\r\n                secondsDelay = 0;\r\n            }\r\n            if (secondsDelay > 4) {\r\n                this.AppendChannel(`Waiting ${secondsDelay} seconds...`);\r\n            }\r\n            setTimeout(() => {\r\n                if (!pkg.tmpFile || pkg.tmpFile.fd === 0) {\r\n                    return reject(new PackageManagerError('Temporary Package file unavailable', 'DownloadFile', pkg));\r\n                }\r\n                let handleHttpResponse = (response) => {\r\n                    if (response.statusCode === 301 || response.statusCode === 302) {\r\n                        let redirectUrl;\r\n                        if (typeof response.headers.location === \"string\") {\r\n                            redirectUrl = response.headers.location;\r\n                        }\r\n                        else {\r\n                            redirectUrl = response.headers.location[0];\r\n                        }\r\n                        return resolve(this.DownloadFile(redirectUrl, pkg, 0, progress));\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        let errorMessage = `failed (error code '${response.statusCode}')`;\r\n                        return reject(new PackageManagerWebResponseError(response.socket, 'HTTP/HTTPS Response Error', 'DownloadFile', pkg, errorMessage, response.statusCode.toString()));\r\n                    }\r\n                    else {\r\n                        let contentLength = response.headers['content-length'];\r\n                        if (typeof response.headers['content-length'] === \"string\") {\r\n                            contentLength = response.headers['content-length'];\r\n                        }\r\n                        else {\r\n                            contentLength = response.headers['content-length'][0];\r\n                        }\r\n                        let packageSize = parseInt(contentLength, 10);\r\n                        let downloadPercentage = 0;\r\n                        let dots = 0;\r\n                        let tmpFile = fs.createWriteStream(null, { fd: pkg.tmpFile.fd });\r\n                        this.AppendChannel(`(${Math.ceil(packageSize / 1024)} KB) `);\r\n                        response.on('data', (data) => {\r\n                            let newDots = Math.ceil(downloadPercentage / 5);\r\n                            if (newDots > dots) {\r\n                                this.AppendChannel(\".\".repeat(newDots - dots));\r\n                                dots = newDots;\r\n                            }\r\n                        });\r\n                        response.on('end', () => {\r\n                            return resolve();\r\n                        });\r\n                        response.on('error', (error) => {\r\n                            return reject(new PackageManagerWebResponseError(response.socket, 'HTTP/HTTPS Response error', 'DownloadFile', pkg, error.stack, error.name));\r\n                        });\r\n                        response.pipe(tmpFile, { end: false });\r\n                    }\r\n                };\r\n                let request = https.request(options, handleHttpResponse);\r\n                request.on('error', (error) => {\r\n                    return reject(new PackageManagerError('HTTP/HTTPS Request error' + (urlString.includes(\"fwlink\") ? \": fwlink\" : \"\"), 'DownloadFile', pkg, error.stack, error.message));\r\n                });\r\n                request.end();\r\n            }, secondsDelay * 1000);\r\n        });\r\n    }\r\n    InstallPackage(pkg, progressCount, progress) {\r\n        this.AppendLineChannel(`Installing package '${pkg.description}'`);\r\n        progress.report({ message: `Installing ${progressCount}: ${pkg.description}` });\r\n        return new Promise((resolve, reject) => {\r\n            if (!pkg.tmpFile || pkg.tmpFile.fd === 0) {\r\n                return reject(new PackageManagerError('Downloaded file unavailable', 'InstallPackage', pkg));\r\n            }\r\n            yauzl.fromFd(pkg.tmpFile.fd, { lazyEntries: true }, (err, zipfile) => {\r\n                if (err) {\r\n                    return reject(new PackageManagerError('Zip file error', 'InstallPackage', pkg, err));\r\n                }\r\n                zipfile.on('end', () => {\r\n                    return resolve();\r\n                });\r\n                zipfile.on('error', err => {\r\n                    return reject(new PackageManagerError('Zip File Error', 'InstallPackage', pkg, err, err.code));\r\n                });\r\n                zipfile.readEntry();\r\n                zipfile.on('entry', (entry) => {\r\n                    let absoluteEntryPath = util.getExtensionFilePath(entry.fileName);\r\n                    if (entry.fileName.endsWith(\"/\")) {\r\n                        mkdirp.mkdirp(absoluteEntryPath, { mode: 0o775 }, (err) => {\r\n                            if (err) {\r\n                                return reject(new PackageManagerError('Error creating directory', 'InstallPackage', pkg, err, err.code));\r\n                            }\r\n                            zipfile.readEntry();\r\n                        });\r\n                    }\r\n                    else {\r\n                        util.checkFileExists(absoluteEntryPath).then((exists) => {\r\n                            if (!exists) {\r\n                                zipfile.openReadStream(entry, (err, readStream) => {\r\n                                    if (err) {\r\n                                        return reject(new PackageManagerError('Error reading zip stream', 'InstallPackage', pkg, err));\r\n                                    }\r\n                                    readStream.on('error', (err) => {\r\n                                        return reject(new PackageManagerError('Error in readStream', 'InstallPackage', pkg, err));\r\n                                    });\r\n                                    mkdirp.mkdirp(path.dirname(absoluteEntryPath), { mode: 0o775 }, (err) => __awaiter(this, void 0, void 0, function* () {\r\n                                        if (err) {\r\n                                            return reject(new PackageManagerError('Error creating directory', 'InstallPackage', pkg, err, err.code));\r\n                                        }\r\n                                        let absoluteEntryTempFile = absoluteEntryPath + \".tmp\";\r\n                                        if (fs.existsSync(absoluteEntryTempFile)) {\r\n                                            try {\r\n                                                yield util.unlinkPromise(absoluteEntryTempFile);\r\n                                            }\r\n                                            catch (err) {\r\n                                                return reject(new PackageManagerError(`Error unlinking file ${absoluteEntryTempFile}`, 'InstallPackage', pkg, err));\r\n                                            }\r\n                                        }\r\n                                        let fileMode = (pkg.binaries && pkg.binaries.indexOf(absoluteEntryPath) !== -1) ? 0o755 : 0o664;\r\n                                        let writeStream = fs.createWriteStream(absoluteEntryTempFile, { mode: fileMode });\r\n                                        writeStream.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                                            try {\r\n                                                yield util.renamePromise(absoluteEntryTempFile, absoluteEntryPath);\r\n                                            }\r\n                                            catch (err) {\r\n                                                return reject(new PackageManagerError(`Error renaming file ${absoluteEntryTempFile}`, 'InstallPackage', pkg, err));\r\n                                            }\r\n                                            zipfile.readEntry();\r\n                                        }));\r\n                                        writeStream.on('error', (err) => {\r\n                                            return reject(new PackageManagerError('Error in writeStream', 'InstallPackage', pkg, err));\r\n                                        });\r\n                                        readStream.pipe(writeStream);\r\n                                    }));\r\n                                });\r\n                            }\r\n                            else {\r\n                                if (path.extname(absoluteEntryPath) !== \".txt\") {\r\n                                    this.AppendLineChannel(`Warning: File '${absoluteEntryPath}' already exists and was not updated.`);\r\n                                }\r\n                                zipfile.readEntry();\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }).then(() => {\r\n            pkg.tmpFile.removeCallback();\r\n        });\r\n    }\r\n    AppendChannel(text) {\r\n        if (this.outputChannel) {\r\n            this.outputChannel.append(text);\r\n        }\r\n    }\r\n    AppendLineChannel(text) {\r\n        if (this.outputChannel) {\r\n            this.outputChannel.appendLine(text);\r\n        }\r\n    }\r\n}\r\nexports.PackageManager = PackageManager;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFja2FnZU1hbmFnZXIudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL3BhY2thZ2VNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IHZzY29kZSA9IHJlcXVpcmUoXCJ2c2NvZGVcIik7XHJcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbmNvbnN0IHRtcCA9IHJlcXVpcmUoXCJ0bXBcIik7XHJcbmNvbnN0IHlhdXpsID0gcmVxdWlyZShcInlhdXpsXCIpO1xyXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKFwibWtkaXJwXCIpO1xyXG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xyXG5jb25zdCBUZWxlbWV0cnkgPSByZXF1aXJlKFwiLi90ZWxlbWV0cnlcIik7XHJcbmNsYXNzIFBhY2thZ2VNYW5hZ2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBtZXRob2ROYW1lLCBwa2cgPSBudWxsLCBpbm5lckVycm9yID0gbnVsbCwgZXJyb3JDb2RlID0gJycpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgdGhpcy5wa2cgPSBwa2c7XHJcbiAgICAgICAgdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcclxuICAgICAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBhY2thZ2VNYW5hZ2VyRXJyb3IgPSBQYWNrYWdlTWFuYWdlckVycm9yO1xyXG5jbGFzcyBQYWNrYWdlTWFuYWdlcldlYlJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBQYWNrYWdlTWFuYWdlckVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvY2tldCwgbWVzc2FnZSwgbWV0aG9kTmFtZSwgcGtnID0gbnVsbCwgaW5uZXJFcnJvciA9IG51bGwsIGVycm9yQ29kZSA9ICcnKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgbWV0aG9kTmFtZSwgcGtnLCBpbm5lckVycm9yLCBlcnJvckNvZGUpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcclxuICAgICAgICB0aGlzLnBrZyA9IHBrZztcclxuICAgICAgICB0aGlzLmlubmVyRXJyb3IgPSBpbm5lckVycm9yO1xyXG4gICAgICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGFja2FnZU1hbmFnZXJXZWJSZXNwb25zZUVycm9yID0gUGFja2FnZU1hbmFnZXJXZWJSZXNwb25zZUVycm9yO1xyXG5jbGFzcyBQYWNrYWdlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybUluZm8sIG91dHB1dENoYW5uZWwpIHtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtSW5mbyA9IHBsYXRmb3JtSW5mbztcclxuICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwgPSBvdXRwdXRDaGFubmVsO1xyXG4gICAgICAgIHRtcC5zZXRHcmFjZWZ1bENsZWFudXAoKTtcclxuICAgIH1cclxuICAgIERvd25sb2FkUGFja2FnZXMocHJvZ3Jlc3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5HZXRQYWNrYWdlcygpXHJcbiAgICAgICAgICAgIC50aGVuKChwYWNrYWdlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CdWlsZFByb21pc2VDaGFpbihwYWNrYWdlcywgKHBrZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuRG93bmxvYWRQYWNrYWdlKHBrZywgYCR7Y291bnR9LyR7cGFja2FnZXMubGVuZ3RofWAsIHByb2dyZXNzKTtcclxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBJbnN0YWxsUGFja2FnZXMocHJvZ3Jlc3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5HZXRQYWNrYWdlcygpXHJcbiAgICAgICAgICAgIC50aGVuKChwYWNrYWdlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CdWlsZFByb21pc2VDaGFpbihwYWNrYWdlcywgKHBrZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuSW5zdGFsbFBhY2thZ2UocGtnLCBgJHtjb3VudH0vJHtwYWNrYWdlcy5sZW5ndGh9YCwgcHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEJ1aWxkUHJvbWlzZUNoYWluKGl0ZW1zLCBwcm9taXNlQnVpbGRlcikge1xyXG4gICAgICAgIGxldCBwcm9taXNlQ2hhaW4gPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAgICAgICBwcm9taXNlQ2hhaW4gPSBwcm9taXNlQ2hhaW4udGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZUJ1aWxkZXIoaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluO1xyXG4gICAgfVxyXG4gICAgR2V0UGFja2FnZUxpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbFBhY2thZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5wYWNrYWdlSnNvbi5ydW50aW1lRGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxQYWNrYWdlcyA9IHV0aWwucGFja2FnZUpzb24ucnVudGltZURlcGVuZGVuY2llcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwa2cgb2YgdGhpcy5hbGxQYWNrYWdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGtnLmJpbmFyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa2cuYmluYXJpZXMgPSBwa2cuYmluYXJpZXMubWFwKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldEV4dGVuc2lvbkZpbGVQYXRoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5hbGxQYWNrYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFBhY2thZ2VNYW5hZ2VyRXJyb3IoJ1BhY2thZ2UgbWFuaWZlc3QgZG9lcyBub3QgZXhpc3QnLCAnR2V0UGFja2FnZUxpc3QnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuYWxsUGFja2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBHZXRQYWNrYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5HZXRQYWNrYWdlTGlzdCgpXHJcbiAgICAgICAgICAgIC50aGVuKChsaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmZpbHRlcigodmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICghdmFsdWUuYXJjaGl0ZWN0dXJlcyB8fCB2YWx1ZS5hcmNoaXRlY3R1cmVzLmluZGV4T2YodGhpcy5wbGF0Zm9ybUluZm8uYXJjaGl0ZWN0dXJlKSAhPT0gLTEpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCF2YWx1ZS5wbGF0Zm9ybXMgfHwgdmFsdWUucGxhdGZvcm1zLmluZGV4T2YodGhpcy5wbGF0Zm9ybUluZm8ucGxhdGZvcm0pICE9PSAtMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRG93bmxvYWRQYWNrYWdlKHBrZywgcHJvZ3Jlc3NDb3VudCwgcHJvZ3Jlc3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLkFwcGVuZENoYW5uZWwoYERvd25sb2FkaW5nIHBhY2thZ2UgJyR7cGtnLmRlc2NyaXB0aW9ufScgYCk7XHJcbiAgICAgICAgICAgIHByb2dyZXNzLnJlcG9ydCh7IG1lc3NhZ2U6IGBEb3dubG9hZGluZyAke3Byb2dyZXNzQ291bnR9OiAke3BrZy5kZXNjcmlwdGlvbn1gIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0bXBSZXN1bHQgPSB5aWVsZCB0aGlzLkNyZWF0ZVRlbXBGaWxlKHBrZyk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuRG93bmxvYWRQYWNrYWdlV2l0aFJldHJpZXMocGtnLCB0bXBSZXN1bHQsIHByb2dyZXNzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIENyZWF0ZVRlbXBGaWxlKHBrZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0bXAuZmlsZSh7IHByZWZpeDogXCJwYWNrYWdlLVwiIH0sIChlcnIsIHBhdGgsIGZkLCBjbGVhbnVwQ2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFBhY2thZ2VNYW5hZ2VyRXJyb3IoJ0Vycm9yIGZyb20gdGVtcC5maWxlJywgJ0Rvd25sb2FkUGFja2FnZScsIHBrZywgZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbmFtZTogcGF0aCwgZmQ6IGZkLCByZW1vdmVDYWxsYmFjazogY2xlYW51cENhbGxiYWNrIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRG93bmxvYWRQYWNrYWdlV2l0aFJldHJpZXMocGtnLCB0bXBSZXN1bHQsIHByb2dyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcGtnLnRtcEZpbGUgPSB0bXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IE1BWF9SRVRSSUVTID0gNTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLkRvd25sb2FkRmlsZShwa2cudXJsLCBwa2csIHJldHJ5Q291bnQsIHByb2dyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+IE1BWF9SRVRSSUVTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQXBwZW5kQ2hhbm5lbChgIEZhaWxlZCB0byBkb3dubG9hZCBgICsgcGtnLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BcHBlbmRDaGFubmVsKGAgRmFpbGVkLiBSZXRyeWluZy4uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKCFzdWNjZXNzICYmIHJldHJ5Q291bnQgPCBNQVhfUkVUUklFUyk7XHJcbiAgICAgICAgICAgIHRoaXMuQXBwZW5kTGluZUNoYW5uZWwoXCIgRG9uZSFcIik7XHJcbiAgICAgICAgICAgIGlmIChyZXRyeUNvdW50ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVsZW1ldHJ5UHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5UHJvcGVydGllc1tcInN1Y2Nlc3NcIl0gPSBzdWNjZXNzID8gYE9uUmV0cnkke3JldHJ5Q291bnR9YCA6ICdmYWxzZSc7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yIGluc3RhbmNlb2YgUGFja2FnZU1hbmFnZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWNrYWdlRXJyb3IgPSBsYXN0RXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IubWV0aG9kTmFtZSddID0gcGFja2FnZUVycm9yLm1ldGhvZE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IubWVzc2FnZSddID0gcGFja2FnZUVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhY2thZ2VFcnJvci5wa2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5UHJvcGVydGllc1snZXJyb3IucGFja2FnZU5hbWUnXSA9IHBhY2thZ2VFcnJvci5wa2cuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVByb3BlcnRpZXNbJ2Vycm9yLnBhY2thZ2VVcmwnXSA9IHBhY2thZ2VFcnJvci5wa2cudXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFja2FnZUVycm9yLmVycm9yQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlQcm9wZXJ0aWVzWydlcnJvci5lcnJvckNvZGUnXSA9IHBhY2thZ2VFcnJvci5lcnJvckNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVGVsZW1ldHJ5LmxvZ0RlYnVnZ2VyRXZlbnQoXCJhY3F1aXNpdGlvblwiLCB0ZWxlbWV0cnlQcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRG93bmxvYWRGaWxlKHVybFN0cmluZywgcGtnLCBkZWxheSwgcHJvZ3Jlc3MpIHtcclxuICAgICAgICBsZXQgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHVybFN0cmluZyk7XHJcbiAgICAgICAgbGV0IHByb3h5U3RyaWN0U1NMID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCkuZ2V0KFwiaHR0cC5wcm94eVN0cmljdFNTTFwiLCB0cnVlKTtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaG9zdDogcGFyc2VkVXJsLmhvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6IHBhcnNlZFVybC5wYXRoLFxyXG4gICAgICAgICAgICBhZ2VudDogdXRpbC5nZXRIdHRwc1Byb3h5QWdlbnQoKSxcclxuICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBwcm94eVN0cmljdFNTTFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlY29uZHNEZWxheSA9IE1hdGgucG93KDIsIGRlbGF5KTtcclxuICAgICAgICAgICAgaWYgKHNlY29uZHNEZWxheSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kc0RlbGF5ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2Vjb25kc0RlbGF5ID4gNCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5BcHBlbmRDaGFubmVsKGBXYWl0aW5nICR7c2Vjb25kc0RlbGF5fSBzZWNvbmRzLi4uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBrZy50bXBGaWxlIHx8IHBrZy50bXBGaWxlLmZkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJFcnJvcignVGVtcG9yYXJ5IFBhY2thZ2UgZmlsZSB1bmF2YWlsYWJsZScsICdEb3dubG9hZEZpbGUnLCBwa2cpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGVIdHRwUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVkaXJlY3RVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVcmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVcmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuRG93bmxvYWRGaWxlKHJlZGlyZWN0VXJsLCBwa2csIDAsIHByb2dyZXNzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYGZhaWxlZCAoZXJyb3IgY29kZSAnJHtyZXNwb25zZS5zdGF0dXNDb2RlfScpYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJXZWJSZXNwb25zZUVycm9yKHJlc3BvbnNlLnNvY2tldCwgJ0hUVFAvSFRUUFMgUmVzcG9uc2UgRXJyb3InLCAnRG93bmxvYWRGaWxlJywgcGtnLCBlcnJvck1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhY2thZ2VTaXplID0gcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG93bmxvYWRQZXJjZW50YWdlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvdHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1wRmlsZSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG51bGwsIHsgZmQ6IHBrZy50bXBGaWxlLmZkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFwcGVuZENoYW5uZWwoYCgke01hdGguY2VpbChwYWNrYWdlU2l6ZSAvIDEwMjQpfSBLQikgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdEb3RzID0gTWF0aC5jZWlsKGRvd25sb2FkUGVyY2VudGFnZSAvIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RvdHMgPiBkb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BcHBlbmRDaGFubmVsKFwiLlwiLnJlcGVhdChuZXdEb3RzIC0gZG90cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMgPSBuZXdEb3RzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFBhY2thZ2VNYW5hZ2VyV2ViUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zb2NrZXQsICdIVFRQL0hUVFBTIFJlc3BvbnNlIGVycm9yJywgJ0Rvd25sb2FkRmlsZScsIHBrZywgZXJyb3Iuc3RhY2ssIGVycm9yLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBpcGUodG1wRmlsZSwgeyBlbmQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucywgaGFuZGxlSHR0cFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJFcnJvcignSFRUUC9IVFRQUyBSZXF1ZXN0IGVycm9yJyArICh1cmxTdHJpbmcuaW5jbHVkZXMoXCJmd2xpbmtcIikgPyBcIjogZndsaW5rXCIgOiBcIlwiKSwgJ0Rvd25sb2FkRmlsZScsIHBrZywgZXJyb3Iuc3RhY2ssIGVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcclxuICAgICAgICAgICAgfSwgc2Vjb25kc0RlbGF5ICogMTAwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBJbnN0YWxsUGFja2FnZShwa2csIHByb2dyZXNzQ291bnQsIHByb2dyZXNzKSB7XHJcbiAgICAgICAgdGhpcy5BcHBlbmRMaW5lQ2hhbm5lbChgSW5zdGFsbGluZyBwYWNrYWdlICcke3BrZy5kZXNjcmlwdGlvbn0nYCk7XHJcbiAgICAgICAgcHJvZ3Jlc3MucmVwb3J0KHsgbWVzc2FnZTogYEluc3RhbGxpbmcgJHtwcm9ncmVzc0NvdW50fTogJHtwa2cuZGVzY3JpcHRpb259YCB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXBrZy50bXBGaWxlIHx8IHBrZy50bXBGaWxlLmZkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQYWNrYWdlTWFuYWdlckVycm9yKCdEb3dubG9hZGVkIGZpbGUgdW5hdmFpbGFibGUnLCAnSW5zdGFsbFBhY2thZ2UnLCBwa2cpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5YXV6bC5mcm9tRmQocGtnLnRtcEZpbGUuZmQsIHsgbGF6eUVudHJpZXM6IHRydWUgfSwgKGVyciwgemlwZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFBhY2thZ2VNYW5hZ2VyRXJyb3IoJ1ppcCBmaWxlIGVycm9yJywgJ0luc3RhbGxQYWNrYWdlJywgcGtnLCBlcnIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHppcGZpbGUub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB6aXBmaWxlLm9uKCdlcnJvcicsIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJFcnJvcignWmlwIEZpbGUgRXJyb3InLCAnSW5zdGFsbFBhY2thZ2UnLCBwa2csIGVyciwgZXJyLmNvZGUpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcclxuICAgICAgICAgICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFic29sdXRlRW50cnlQYXRoID0gdXRpbC5nZXRFeHRlbnNpb25GaWxlUGF0aChlbnRyeS5maWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLmVuZHNXaXRoKFwiL1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBta2RpcnAubWtkaXJwKGFic29sdXRlRW50cnlQYXRoLCB7IG1vZGU6IDBvNzc1IH0sIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQYWNrYWdlTWFuYWdlckVycm9yKCdFcnJvciBjcmVhdGluZyBkaXJlY3RvcnknLCAnSW5zdGFsbFBhY2thZ2UnLCBwa2csIGVyciwgZXJyLmNvZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jaGVja0ZpbGVFeGlzdHMoYWJzb2x1dGVFbnRyeVBhdGgpLnRoZW4oKGV4aXN0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6aXBmaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFBhY2thZ2VNYW5hZ2VyRXJyb3IoJ0Vycm9yIHJlYWRpbmcgemlwIHN0cmVhbScsICdJbnN0YWxsUGFja2FnZScsIHBrZywgZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQYWNrYWdlTWFuYWdlckVycm9yKCdFcnJvciBpbiByZWFkU3RyZWFtJywgJ0luc3RhbGxQYWNrYWdlJywgcGtnLCBlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1rZGlycC5ta2RpcnAocGF0aC5kaXJuYW1lKGFic29sdXRlRW50cnlQYXRoKSwgeyBtb2RlOiAwbzc3NSB9LCAoZXJyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJFcnJvcignRXJyb3IgY3JlYXRpbmcgZGlyZWN0b3J5JywgJ0luc3RhbGxQYWNrYWdlJywgcGtnLCBlcnIsIGVyci5jb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWJzb2x1dGVFbnRyeVRlbXBGaWxlID0gYWJzb2x1dGVFbnRyeVBhdGggKyBcIi50bXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGFic29sdXRlRW50cnlUZW1wRmlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB1dGlsLnVubGlua1Byb21pc2UoYWJzb2x1dGVFbnRyeVRlbXBGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQYWNrYWdlTWFuYWdlckVycm9yKGBFcnJvciB1bmxpbmtpbmcgZmlsZSAke2Fic29sdXRlRW50cnlUZW1wRmlsZX1gLCAnSW5zdGFsbFBhY2thZ2UnLCBwa2csIGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTW9kZSA9IChwa2cuYmluYXJpZXMgJiYgcGtnLmJpbmFyaWVzLmluZGV4T2YoYWJzb2x1dGVFbnRyeVBhdGgpICE9PSAtMSkgPyAwbzc1NSA6IDBvNjY0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oYWJzb2x1dGVFbnRyeVRlbXBGaWxlLCB7IG1vZGU6IGZpbGVNb2RlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVTdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHV0aWwucmVuYW1lUHJvbWlzZShhYnNvbHV0ZUVudHJ5VGVtcEZpbGUsIGFic29sdXRlRW50cnlQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBQYWNrYWdlTWFuYWdlckVycm9yKGBFcnJvciByZW5hbWluZyBmaWxlICR7YWJzb2x1dGVFbnRyeVRlbXBGaWxlfWAsICdJbnN0YWxsUGFja2FnZScsIHBrZywgZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUGFja2FnZU1hbmFnZXJFcnJvcignRXJyb3IgaW4gd3JpdGVTdHJlYW0nLCAnSW5zdGFsbFBhY2thZ2UnLCBwa2csIGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5leHRuYW1lKGFic29sdXRlRW50cnlQYXRoKSAhPT0gXCIudHh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BcHBlbmRMaW5lQ2hhbm5lbChgV2FybmluZzogRmlsZSAnJHthYnNvbHV0ZUVudHJ5UGF0aH0nIGFscmVhZHkgZXhpc3RzIGFuZCB3YXMgbm90IHVwZGF0ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcGZpbGUucmVhZEVudHJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcGtnLnRtcEZpbGUucmVtb3ZlQ2FsbGJhY2soKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEFwcGVuZENoYW5uZWwodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLm91dHB1dENoYW5uZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsLmFwcGVuZCh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBBcHBlbmRMaW5lQ2hhbm5lbCh0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0Q2hhbm5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuYXBwZW5kTGluZSh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QYWNrYWdlTWFuYWdlciA9IFBhY2thZ2VNYW5hZ2VyO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/packageManager.ts\n");

/***/ }),

/***/ "./src/packageVersion.ts":
/*!*******************************!*\
  !*** ./src/packageVersion.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass PackageVersion {\r\n    constructor(version) {\r\n        const tokens = version.split(new RegExp('[-\\\\.]', 'g'));\r\n        if (tokens.length < 3) {\r\n            throw new Error('Failed to parse version string: ' + version);\r\n        }\r\n        this.major = parseInt(tokens[0]);\r\n        this.minor = parseInt(tokens[1]);\r\n        this.patch = parseInt(tokens[2]);\r\n        if (tokens.length > 3) {\r\n            const firstDigitOffset = tokens[3].search(new RegExp(/(\\d)/));\r\n            if (firstDigitOffset !== -1) {\r\n                this.suffix = tokens[3].substring(0, firstDigitOffset);\r\n                this.suffixVersion = parseInt(tokens[3].substring(firstDigitOffset));\r\n            }\r\n            else {\r\n                this.suffix = tokens[3];\r\n                this.suffixVersion = 1;\r\n            }\r\n        }\r\n        else {\r\n            this.suffix = undefined;\r\n            this.suffixVersion = 0;\r\n        }\r\n        if (this.major === undefined || this.minor === undefined || this.patch === undefined) {\r\n            throw new Error('Failed to parse version string: ' + version);\r\n        }\r\n    }\r\n    isGreaterThan(other, suffixStr = 'insiders') {\r\n        if ((this.suffix && !this.suffix.startsWith(suffixStr)) || (other.suffix && !other.suffix.startsWith(suffixStr))) {\r\n            return false;\r\n        }\r\n        let diff = this.major - other.major;\r\n        if (diff) {\r\n            return diff > 0;\r\n        }\r\n        else if (diff = this.minor - other.minor) {\r\n            return diff > 0;\r\n        }\r\n        else if (diff = this.patch - other.patch) {\r\n            return diff > 0;\r\n        }\r\n        else if (this.suffix) {\r\n            return (other.suffix && this.suffixVersion > other.suffixVersion);\r\n        }\r\n        else {\r\n            return other.suffix ? true : false;\r\n        }\r\n    }\r\n}\r\nexports.PackageVersion = PackageVersion;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFja2FnZVZlcnNpb24udHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL3BhY2thZ2VWZXJzaW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBQYWNrYWdlVmVyc2lvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XHJcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdmVyc2lvbi5zcGxpdChuZXcgUmVnRXhwKCdbLVxcXFwuXScsICdnJykpO1xyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSB2ZXJzaW9uIHN0cmluZzogJyArIHZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1ham9yID0gcGFyc2VJbnQodG9rZW5zWzBdKTtcclxuICAgICAgICB0aGlzLm1pbm9yID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICB0aGlzLnBhdGNoID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3REaWdpdE9mZnNldCA9IHRva2Vuc1szXS5zZWFyY2gobmV3IFJlZ0V4cCgvKFxcZCkvKSk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERpZ2l0T2Zmc2V0ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWZmaXggPSB0b2tlbnNbM10uc3Vic3RyaW5nKDAsIGZpcnN0RGlnaXRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWZmaXhWZXJzaW9uID0gcGFyc2VJbnQodG9rZW5zWzNdLnN1YnN0cmluZyhmaXJzdERpZ2l0T2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHRva2Vuc1szXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3VmZml4VmVyc2lvbiA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VmZml4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnN1ZmZpeFZlcnNpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYWpvciA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubWlub3IgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnBhdGNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgdmVyc2lvbiBzdHJpbmc6ICcgKyB2ZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0dyZWF0ZXJUaGFuKG90aGVyLCBzdWZmaXhTdHIgPSAnaW5zaWRlcnMnKSB7XHJcbiAgICAgICAgaWYgKCh0aGlzLnN1ZmZpeCAmJiAhdGhpcy5zdWZmaXguc3RhcnRzV2l0aChzdWZmaXhTdHIpKSB8fCAob3RoZXIuc3VmZml4ICYmICFvdGhlci5zdWZmaXguc3RhcnRzV2l0aChzdWZmaXhTdHIpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkaWZmID0gdGhpcy5tYWpvciAtIG90aGVyLm1ham9yO1xyXG4gICAgICAgIGlmIChkaWZmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlmZiA9IHRoaXMubWlub3IgLSBvdGhlci5taW5vcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZiA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpZmYgPSB0aGlzLnBhdGNoIC0gb3RoZXIucGF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmYgPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1ZmZpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLnN1ZmZpeCAmJiB0aGlzLnN1ZmZpeFZlcnNpb24gPiBvdGhlci5zdWZmaXhWZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5zdWZmaXggPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGFja2FnZVZlcnNpb24gPSBQYWNrYWdlVmVyc2lvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/packageVersion.ts\n");

/***/ }),

/***/ "./src/platform.ts":
/*!*************************!*\
  !*** ./src/platform.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nconst linuxDistribution_1 = __webpack_require__(/*! ./linuxDistribution */ \"./src/linuxDistribution.ts\");\r\nclass PlatformInformation {\r\n    constructor(platform, architecture, distribution) {\r\n        this.platform = platform;\r\n        this.architecture = architecture;\r\n        this.distribution = distribution;\r\n    }\r\n    static GetPlatformInformation() {\r\n        let platform = os.platform();\r\n        let architecturePromise;\r\n        let distributionPromise = Promise.resolve(null);\r\n        switch (platform) {\r\n            case \"win32\":\r\n                architecturePromise = PlatformInformation.GetWindowsArchitecture();\r\n                break;\r\n            case \"linux\":\r\n                architecturePromise = PlatformInformation.GetUnixArchitecture();\r\n                distributionPromise = linuxDistribution_1.LinuxDistribution.GetDistroInformation();\r\n                break;\r\n            case \"darwin\":\r\n                architecturePromise = PlatformInformation.GetUnixArchitecture();\r\n                break;\r\n        }\r\n        return Promise.all([architecturePromise, distributionPromise])\r\n            .then(([arch, distro]) => {\r\n            return new PlatformInformation(platform, arch, distro);\r\n        });\r\n    }\r\n    static GetUnknownArchitecture() { return \"Unknown\"; }\r\n    static GetWindowsArchitecture() {\r\n        return util.execChildProcess('wmic os get osarchitecture', util.extensionContext.extensionPath)\r\n            .then((architecture) => {\r\n            if (architecture) {\r\n                let archArray = architecture.split(os.EOL);\r\n                if (archArray.length >= 2) {\r\n                    let arch = archArray[1].trim();\r\n                    if (arch.indexOf('64') >= 0) {\r\n                        return \"x86_64\";\r\n                    }\r\n                    else if (arch.indexOf('32') >= 0) {\r\n                        return \"x86\";\r\n                    }\r\n                }\r\n            }\r\n            return PlatformInformation.GetUnknownArchitecture();\r\n        }).catch((error) => {\r\n            return PlatformInformation.GetUnknownArchitecture();\r\n        });\r\n    }\r\n    static GetUnixArchitecture() {\r\n        return util.execChildProcess('uname -m', util.packageJson.extensionFolderPath)\r\n            .then((architecture) => {\r\n            if (architecture) {\r\n                return architecture.trim();\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n}\r\nexports.PlatformInformation = PlatformInformation;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGxhdGZvcm0udHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL3BsYXRmb3JtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XHJcbmNvbnN0IGxpbnV4RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9saW51eERpc3RyaWJ1dGlvblwiKTtcclxuY2xhc3MgUGxhdGZvcm1JbmZvcm1hdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSwgYXJjaGl0ZWN0dXJlLCBkaXN0cmlidXRpb24pIHtcclxuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbiAgICAgICAgdGhpcy5hcmNoaXRlY3R1cmUgPSBhcmNoaXRlY3R1cmU7XHJcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb24gPSBkaXN0cmlidXRpb247XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgR2V0UGxhdGZvcm1JbmZvcm1hdGlvbigpIHtcclxuICAgICAgICBsZXQgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xyXG4gICAgICAgIGxldCBhcmNoaXRlY3R1cmVQcm9taXNlO1xyXG4gICAgICAgIGxldCBkaXN0cmlidXRpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIHN3aXRjaCAocGxhdGZvcm0pIHtcclxuICAgICAgICAgICAgY2FzZSBcIndpbjMyXCI6XHJcbiAgICAgICAgICAgICAgICBhcmNoaXRlY3R1cmVQcm9taXNlID0gUGxhdGZvcm1JbmZvcm1hdGlvbi5HZXRXaW5kb3dzQXJjaGl0ZWN0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImxpbnV4XCI6XHJcbiAgICAgICAgICAgICAgICBhcmNoaXRlY3R1cmVQcm9taXNlID0gUGxhdGZvcm1JbmZvcm1hdGlvbi5HZXRVbml4QXJjaGl0ZWN0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25Qcm9taXNlID0gbGludXhEaXN0cmlidXRpb25fMS5MaW51eERpc3RyaWJ1dGlvbi5HZXREaXN0cm9JbmZvcm1hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXJ3aW5cIjpcclxuICAgICAgICAgICAgICAgIGFyY2hpdGVjdHVyZVByb21pc2UgPSBQbGF0Zm9ybUluZm9ybWF0aW9uLkdldFVuaXhBcmNoaXRlY3R1cmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2FyY2hpdGVjdHVyZVByb21pc2UsIGRpc3RyaWJ1dGlvblByb21pc2VdKVxyXG4gICAgICAgICAgICAudGhlbigoW2FyY2gsIGRpc3Ryb10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGF0Zm9ybUluZm9ybWF0aW9uKHBsYXRmb3JtLCBhcmNoLCBkaXN0cm8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIEdldFVua25vd25BcmNoaXRlY3R1cmUoKSB7IHJldHVybiBcIlVua25vd25cIjsgfVxyXG4gICAgc3RhdGljIEdldFdpbmRvd3NBcmNoaXRlY3R1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuZXhlY0NoaWxkUHJvY2Vzcygnd21pYyBvcyBnZXQgb3NhcmNoaXRlY3R1cmUnLCB1dGlsLmV4dGVuc2lvbkNvbnRleHQuZXh0ZW5zaW9uUGF0aClcclxuICAgICAgICAgICAgLnRoZW4oKGFyY2hpdGVjdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXJjaGl0ZWN0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXJjaEFycmF5ID0gYXJjaGl0ZWN0dXJlLnNwbGl0KG9zLkVPTCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJjaEFycmF5Lmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyY2ggPSBhcmNoQXJyYXlbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmNoLmluZGV4T2YoJzY0JykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ4ODZfNjRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJjaC5pbmRleE9mKCczMicpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwieDg2XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybUluZm9ybWF0aW9uLkdldFVua25vd25BcmNoaXRlY3R1cmUoKTtcclxuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtSW5mb3JtYXRpb24uR2V0VW5rbm93bkFyY2hpdGVjdHVyZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIEdldFVuaXhBcmNoaXRlY3R1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWwuZXhlY0NoaWxkUHJvY2VzcygndW5hbWUgLW0nLCB1dGlsLnBhY2thZ2VKc29uLmV4dGVuc2lvbkZvbGRlclBhdGgpXHJcbiAgICAgICAgICAgIC50aGVuKChhcmNoaXRlY3R1cmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGFyY2hpdGVjdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyY2hpdGVjdHVyZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QbGF0Zm9ybUluZm9ybWF0aW9uID0gUGxhdGZvcm1JbmZvcm1hdGlvbjtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/platform.ts\n");

/***/ }),

/***/ "./src/telemetry.ts":
/*!**************************!*\
  !*** ./src/telemetry.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_extension_telemetry_1 = __webpack_require__(/*! vscode-extension-telemetry */ \"./node_modules/vscode-extension-telemetry/lib/telemetryReporter.js\");\r\nconst util = __webpack_require__(/*! ./common */ \"./src/common.ts\");\r\nlet telemetryReporter;\r\nfunction activate() {\r\n    try {\r\n        telemetryReporter = createReporter();\r\n    }\r\n    catch (e) {\r\n    }\r\n}\r\nexports.activate = activate;\r\nfunction deactivate() {\r\n    if (telemetryReporter) {\r\n        telemetryReporter.dispose();\r\n    }\r\n}\r\nexports.deactivate = deactivate;\r\nfunction logDebuggerEvent(eventName, properties) {\r\n    const eventNamePrefix = \"cppdbg/VS/Diagnostics/Debugger/\";\r\n    if (telemetryReporter) {\r\n        telemetryReporter.sendTelemetryEvent(eventNamePrefix + eventName, properties);\r\n    }\r\n}\r\nexports.logDebuggerEvent = logDebuggerEvent;\r\nfunction logLanguageServerEvent(eventName, properties, metrics) {\r\n    const eventNamePrefix = \"C_Cpp/LanguageServer/\";\r\n    if (telemetryReporter) {\r\n        telemetryReporter.sendTelemetryEvent(eventNamePrefix + eventName, properties, metrics);\r\n    }\r\n}\r\nexports.logLanguageServerEvent = logLanguageServerEvent;\r\nfunction createReporter() {\r\n    let packageInfo = getPackageInfo();\r\n    if (packageInfo && packageInfo.aiKey) {\r\n        return new vscode_extension_telemetry_1.default(packageInfo.name, packageInfo.version, packageInfo.aiKey);\r\n    }\r\n    return null;\r\n}\r\nfunction getPackageInfo() {\r\n    return {\r\n        name: util.packageJson.publisher + \".\" + util.packageJson.name,\r\n        version: util.packageJson.version,\r\n        aiKey: util.packageJson.contributes.debuggers[0].aiKey\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdGVsZW1ldHJ5LnRzLmpzIiwic291cmNlcyI6WyIuLi8uL3NyYy90ZWxlbWV0cnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZzY29kZV9leHRlbnNpb25fdGVsZW1ldHJ5XzEgPSByZXF1aXJlKFwidnNjb2RlLWV4dGVuc2lvbi10ZWxlbWV0cnlcIik7XHJcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XHJcbmxldCB0ZWxlbWV0cnlSZXBvcnRlcjtcclxuZnVuY3Rpb24gYWN0aXZhdGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRlbGVtZXRyeVJlcG9ydGVyID0gY3JlYXRlUmVwb3J0ZXIoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hY3RpdmF0ZSA9IGFjdGl2YXRlO1xyXG5mdW5jdGlvbiBkZWFjdGl2YXRlKCkge1xyXG4gICAgaWYgKHRlbGVtZXRyeVJlcG9ydGVyKSB7XHJcbiAgICAgICAgdGVsZW1ldHJ5UmVwb3J0ZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVhY3RpdmF0ZSA9IGRlYWN0aXZhdGU7XHJcbmZ1bmN0aW9uIGxvZ0RlYnVnZ2VyRXZlbnQoZXZlbnROYW1lLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICBjb25zdCBldmVudE5hbWVQcmVmaXggPSBcImNwcGRiZy9WUy9EaWFnbm9zdGljcy9EZWJ1Z2dlci9cIjtcclxuICAgIGlmICh0ZWxlbWV0cnlSZXBvcnRlcikge1xyXG4gICAgICAgIHRlbGVtZXRyeVJlcG9ydGVyLnNlbmRUZWxlbWV0cnlFdmVudChldmVudE5hbWVQcmVmaXggKyBldmVudE5hbWUsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubG9nRGVidWdnZXJFdmVudCA9IGxvZ0RlYnVnZ2VyRXZlbnQ7XHJcbmZ1bmN0aW9uIGxvZ0xhbmd1YWdlU2VydmVyRXZlbnQoZXZlbnROYW1lLCBwcm9wZXJ0aWVzLCBtZXRyaWNzKSB7XHJcbiAgICBjb25zdCBldmVudE5hbWVQcmVmaXggPSBcIkNfQ3BwL0xhbmd1YWdlU2VydmVyL1wiO1xyXG4gICAgaWYgKHRlbGVtZXRyeVJlcG9ydGVyKSB7XHJcbiAgICAgICAgdGVsZW1ldHJ5UmVwb3J0ZXIuc2VuZFRlbGVtZXRyeUV2ZW50KGV2ZW50TmFtZVByZWZpeCArIGV2ZW50TmFtZSwgcHJvcGVydGllcywgbWV0cmljcyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5sb2dMYW5ndWFnZVNlcnZlckV2ZW50ID0gbG9nTGFuZ3VhZ2VTZXJ2ZXJFdmVudDtcclxuZnVuY3Rpb24gY3JlYXRlUmVwb3J0ZXIoKSB7XHJcbiAgICBsZXQgcGFja2FnZUluZm8gPSBnZXRQYWNrYWdlSW5mbygpO1xyXG4gICAgaWYgKHBhY2thZ2VJbmZvICYmIHBhY2thZ2VJbmZvLmFpS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2c2NvZGVfZXh0ZW5zaW9uX3RlbGVtZXRyeV8xLmRlZmF1bHQocGFja2FnZUluZm8ubmFtZSwgcGFja2FnZUluZm8udmVyc2lvbiwgcGFja2FnZUluZm8uYWlLZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFja2FnZUluZm8oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHV0aWwucGFja2FnZUpzb24ucHVibGlzaGVyICsgXCIuXCIgKyB1dGlsLnBhY2thZ2VKc29uLm5hbWUsXHJcbiAgICAgICAgdmVyc2lvbjogdXRpbC5wYWNrYWdlSnNvbi52ZXJzaW9uLFxyXG4gICAgICAgIGFpS2V5OiB1dGlsLnBhY2thZ2VKc29uLmNvbnRyaWJ1dGVzLmRlYnVnZ2Vyc1swXS5haUtleVxyXG4gICAgfTtcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/telemetry.ts\n");

/***/ }),

/***/ "./src/testHook.ts":
/*!*************************!*\
  !*** ./src/testHook.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = __webpack_require__(/*! vscode */ \"vscode\");\r\nclass TestHook {\r\n    constructor() {\r\n        this.statusChangedEvent = new vscode.EventEmitter();\r\n    }\r\n    get StatusChanged() {\r\n        return this.statusChangedEvent.event;\r\n    }\r\n    get valid() {\r\n        return !!this.statusChangedEvent;\r\n    }\r\n    updateStatus(status) {\r\n        this.statusChangedEvent.fire(status);\r\n    }\r\n    dispose() {\r\n        this.statusChangedEvent.dispose();\r\n        this.statusChangedEvent = null;\r\n    }\r\n}\r\nexports.TestHook = TestHook;\r\nlet testHook;\r\nfunction getTestHook() {\r\n    if (!testHook || !testHook.valid) {\r\n        testHook = new TestHook();\r\n    }\r\n    return testHook;\r\n}\r\nexports.getTestHook = getTestHook;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdGVzdEhvb2sudHMuanMiLCJzb3VyY2VzIjpbIi4uLy4vc3JjL3Rlc3RIb29rLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2c2NvZGUgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xyXG5jbGFzcyBUZXN0SG9vayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZWRFdmVudCA9IG5ldyB2c2NvZGUuRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgU3RhdHVzQ2hhbmdlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNDaGFuZ2VkRXZlbnQuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zdGF0dXNDaGFuZ2VkRXZlbnQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VkRXZlbnQuZmlyZShzdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZWRFdmVudC5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VkRXZlbnQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVGVzdEhvb2sgPSBUZXN0SG9vaztcclxubGV0IHRlc3RIb29rO1xyXG5mdW5jdGlvbiBnZXRUZXN0SG9vaygpIHtcclxuICAgIGlmICghdGVzdEhvb2sgfHwgIXRlc3RIb29rLnZhbGlkKSB7XHJcbiAgICAgICAgdGVzdEhvb2sgPSBuZXcgVGVzdEhvb2soKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXN0SG9vaztcclxufVxyXG5leHBvcnRzLmdldFRlc3RIb29rID0gZ2V0VGVzdEhvb2s7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/testHook.ts\n");

/***/ }),

/***/ "_http_client":
/*!*******************************!*\
  !*** external "_http_client" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("_http_client");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("console");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("vscode");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });