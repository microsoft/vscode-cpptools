[
  "error desconocido",
  "la última línea del archivo termina sin una nueva línea",
  "la última línea del archivo termina con una barra diagonal inversa",
  "el archivo #include %sq se incluye a sí mismo",
  "memoria insuficiente",
  null,
  "comentario no cerrado al final del archivo",
  "token no reconocido",
  "falta la comilla de cierre",
  "no se permite un comentario anidado",
  "no se esperaba '#' aquí",
  "directiva de preprocesamiento no reconocida",
  "el análisis se reanuda aquí tras un error de sintaxis previo",
  "se esperaba un nombre de archivo",
  "texto adicional tras el final esperado de la directiva de preprocesamiento",
  null,
  null,
  "se esperaba ']'",
  "se esperaba ')'",
  "texto adicional tras el final esperado del número",
  "el identificador %sq no está definido",
  "Los calificadores de tipo carecen de sentido en esta declaración",
  "número hexadecimal no válido",
  "la constante de tipo entero es demasiado grande",
  "dígito octal no válido",
  "una cadena entrecomillada debe contener al menos un carácter",
  "hay demasiados caracteres en la constante de caracteres",
  "el valor del carácter está fuera del intervalo",
  "la expresión debe tener un valor constante",
  "se esperaba una expresión",
  "la constante flotante está fuera del intervalo",
  "la expresión debe tener un tipo entero",
  "la expresión debe tener un tipo aritmético",
  "se esperaba un número de línea",
  "número de línea no válido",
  "directiva #error: %s",
  "falta #if para esta directiva",
  "falta #endif para esta directiva",
  "la directiva no se permite; ya ha aparecido #else",
  "división por cero",
  "se esperaba un identificador",
  "la expresión debe tener un tipo aritmético o de puntero",
  "los tipos de operando no son compatibles (%t1 y %t2)",
  null,
  "la expresión debe tener un tipo de puntero",
  "no se puede usar #undef en este nombre predefinido",
  "%no se ha predefinido; se ha omitido el intento de nueva definición",
  "nueva definición de la macro %nod no compatible",
  null,
  "nombre de parámetro de macro duplicado",
  "'##' no puede aparecer en primer lugar en una definición de macro",
  "'##' no puede aparecer en último lugar en una definición de macro",
  "se esperaba un nombre de parámetro de macro",
  "se esperaba ':'",
  "no hay suficientes argumentos en la llamada de %n",
  "hay demasiados argumentos en la llamada de %n",
  "un operando de sizeof no puede ser una función",
  "este operador no está permitido en una expresión constante",
  "este operador no está permitido en una expresión de preprocesamiento",
  "no se permite una llamada a función en una expresión constante",
  "este operador no está permitido en una expresión constante integral",
  "el resultado de la operación con enteros está fuera del intervalo",
  "el recuento de desplazamientos es negativo",
  "el recuento de desplazamientos es demasiado grande",
  "la declaración no declara nada",
  "se esperaba ';'",
  "el valor de enumeración está fuera del intervalo de 'int'",
  "se esperaba '}'",
  "la conversión de enteros dio como resultado un cambio de signo",
  "la conversión de enteros dio como resultado una truncación",
  "no se permite un tipo incompleto",
  "un operando de sizeof no puede ser un campo de bits",
  null,
  null,
  null,
  "el operando de \"*\" debe ser un puntero, pero tiene el tipo %t",
  "el argumento para la macro está vacío",
  "esta declaración no tiene ningún especificador de tipo o clase de almacenamiento",
  "una declaración de parámetros no puede tener un inicializador",
  "se esperaba un especificador de tipo",
  "no se puede especificar aquí una clase de almacenamiento",
  "no se puede especificar más de una clase de almacenamiento",
  "la clase de almacenamiento no aparece en primer lugar",
  "calificador de tipo especificado más de una vez",
  "combinación no válida de especificadores de tipo",
  "clase de almacenamiento no válida para un parámetro",
  "clase de almacenamiento no válida para una función",
  "no se puede usar aquí un especificador de tipo",
  "no se permite una matriz de funciones",
  "no se permite una matriz de tipos void",
  "no se permite una función que devuelva otra función",
  "no se permite una función que devuelva una matriz",
  "los parámetros de la lista de identificadores solo se pueden usar en una definición de función",
  "el tipo de función no puede proceder de un typedef",
  "el tamaño de una matriz debe ser mayor que cero",
  "la matriz es demasiado grande",
  "una unidad de traducción debe contener al menos una declaración",
  "una función no puede devolver un valor de este tipo",
  "una matriz no puede tener elementos de este tipo",
  "una declaración aquí debe declarar un parámetro",
  "nombre de parámetro duplicado",
  "%sq ya se ha declarado en el ámbito actual",
  "la declaración adelantada de un tipo de enumeración no es estándar",
  "la clase es demasiado grande",
  "struct o union demasiado grande",
  "tamaño no válido para el campo de bits",
  "tipo no válido para un campo de bits",
  "el campo de bits de longitud cero no debe tener nombre",
  "campo de bits con signo de longitud 1",
  "la expresión incluida delante del paréntesis de la llamada aparente debe tener un tipo de puntero a función",
  "se esperaba una definición o un nombre de etiqueta",
  "no se puede tener acceso a la instrucción",
  "se esperaba 'while'",
  null,
  "se hizo referencia a %n, pero no se definió",
  "una instrucción continue solo se puede usar en un bucle",
  "una instrucción break solo se puede usar en un bucle o modificador",
  "%n distinto de void debe devolver un valor",
  "una función void no puede devolver un valor",
  "no se permite convertir en el tipo %t",
  "el tipo de valor devuelto no coincide con el tipo de función",
  "una etiqueta de caso solo se puede usar en un modificador",
  "una etiqueta predeterminada solo se puede usar en un modificador",
  null,
  "ya ha aparecido una etiqueta predeterminada en este modificador",
  "se esperaba '('",
  "la expresión debe ser un valor L",
  "se esperaba una instrucción",
  "no se puede tener acceso al bucle",
  "una función de ámbito de bloque solo puede tener una clase de almacenamiento extern",
  "se esperaba '{'",
  "la expresión debe tener un tipo de puntero a clase, pero tiene el tipo %t",
  "la expresión debe tener un tipo de puntero a struct o union, pero tiene el tipo %t",
  "se esperaba un nombre de miembro",
  "se esperaba un nombre de campo",
  "%n no tiene ningún miembro %sq",
  "%n no tiene ningún campo %sq",
  "la expresión debe ser un valor L modificable",
  "no se permite la aceptación de la dirección de una variable de registro",
  "no se permite la aceptación de la dirección de un campo de bits",
  "hay demasiados argumentos en la llamada a función",
  "no se permiten parámetros de prototipos sin nombre si aparece un cuerpo",
  "la expresión debe tener un tipo de puntero a objeto, pero tiene el tipo %t",
  "el programa es demasiado grande o complicado para compilarlo",
  "no se puede usar un valor de tipo %t1 para inicializar una entidad de tipo %t2",
  "%n no se puede inicializar",
  "hay demasiados valores de inicializador",
  "la declaración no es compatible con %nfd",
  "%n ya se ha inicializado",
  "una declaración de ámbito global no puede tener esta clase de almacenamiento",
  "un nombre de tipo no se puede declarar de nuevo como parámetro",
  "un nombre typedef no se puede declarar de nuevo como parámetro",
  "conversión de un entero distinto de cero en puntero",
  "la expresión debe tener un tipo de clase, pero tiene el tipo %t",
  "la expresión debe tener un tipo struct o union, pero tiene el tipo %t",
  "operador de asignaciones anticuado",
  "inicializador anticuado",
  "la expresión debe ser de tipo constante integral",
  "la expresión debe ser un designador de función o valor L",
  "la declaración no es compatible con %nod anterior",
  "el nombre externo entra en conflicto con el nombre externo de %nd",
  "#pragma no reconocida",
  null,
  "no se pudo abrir el archivo temporal %sq: %s2",
  "el nombre del directorio de archivos temporales es demasiado largo (%sq)",
  "no hay suficientes argumentos en la llamada a función",
  "constante flotante no válida",
  "un argumento de tipo %t1 no es compatible con un parámetro de tipo %t2",
  "no se permite aquí un tipo de función",
  "se esperaba una declaración",
  "el puntero señala fuera del objeto subyacente",
  "conversión de tipo no válida",
  "conflicto de vinculación externa o interna con la declaración anterior %p",
  "el valor de punto flotante no incluye el tipo entero requerido",
  "la expresión no tiene efecto",
  "el subíndice está fuera del intervalo",
  null,
  "se declaró %n, pero nunca se le hizo referencia",
  "no tiene ningún efecto aplicar '&' a una matriz",
  "el operando derecho de '%%' es cero",
  "el argumento no es compatible con un parámetro formal",
  "el argumento no es compatible con la conversión de la cadena de formato correspondiente",
  "no se pudo abrir el archivo de código fuente %sq (no hay directorios en la lista de búsqueda)",
  "la conversión debe ser de tipo integral",
  "la conversión debe ser de tipo aritmético o de puntero",
  "inicialización dinámica en código inaccesible",
  "comparación sin sentido de un entero sin signo con cero",
  "puede que se pretendiera usar '=' en lugar de '=='",
  "tipo enumerado mezclado con otro tipo",
  "error al escribir en el archivo %s",
  "archivo de lenguaje intermedio no válido",
  "el calificador de tipo carece de sentido en el tipo de conversión",
  "secuencia de escape de caracteres no reconocida",
  "se usó cero para el identificador de preprocesamiento %sq no definido",
  "se esperaba una cadena asm",
  "una función asm debe tener prototipos",
  "una función asm no puede tener puntos suspensivos",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "error al eliminar el archivo %sq: %s2",
  "el valor integral no incluye el tipo de punto flotante requerido",
  "el valor de punto flotante no incluye el tipo de punto flotante requerido",
  "el resultado de la operación de punto flotante está fuera del intervalo",
  "la función %sq se declaró implícitamente",
  "la cadena de formato requiere más argumentos",
  "la cadena de formato termina antes que este argumento",
  "conversión de cadena de formato no válida",
  "recursividad de macros",
  "la coma final no es estándar",
  "un campo de bits no puede contener todos los valores del tipo enumerado",
  "tipo no estándar para un campo de bits",
  "la declaración no es visible fuera de la función",
  "typedef anticuado de 'void' omitido",
  "el operando izquierdo no es un struct o union que contenga este campo",
  "el puntero no señala a un struct o union que contenga este campo",
  "la variable %sq se declaró con un tipo jamás completado",
  "la expresión de control es constante",
  "la expresión de selector es constante",
  "especificador no válido en un parámetro",
  "especificador no válido fuera de una declaración de clase",
  "especificador duplicado en la declaración",
  "no se permite que una unión tenga una clase base",
  "no se permiten múltiples especificadores de Access Control",
  "falta una definición de clase o struct",
  "el nombre completo no es miembro de la clase %t ni de sus clases base",
  "una referencia de miembro no estático debe ser relativa a un objeto específico",
  "un miembro de datos no estático no se puede definir fuera de su clase",
  "%n ya se ha definido",
  "no se permite un puntero a referencia",
  "no se permite una referencia a la referencia",
  "no se permite una referencia a void",
  "no se permite una matriz de referencia",
  "la referencia %n requiere un inicializador",
  "se esperaba ','",
  "no se permite un nombre de tipo",
  "no se permite una definición de tipo",
  "nueva declaración del nombre de tipo %nod no válida",
  "const %n requiere un inicializador",
  "'this' solo se puede usar en una función miembro no estática",
  "no se conoce el valor constante",
  "falta un tipo explícito (se presupone 'int')",
  "Access Control no especificado (%sq de forma predeterminada)",
  "no es un nombre de clase o struct",
  "nombre de clase base duplicado",
  "clase base no válida",
  "no se puede obtener acceso a %nd",
  "%no ambiguo",
  "lista de parámetros de estilo anterior (anacronismo)",
  "una declaración no puede aparecer detrás de una instrucción ejecutable en bloque",
  "no se permite la conversión en la clase base inaccesible %t",
  null,
  null,
  null,
  null,
  "llamada de macro terminada incorrectamente",
  null,
  "un nombre seguido de '::' debe ser un nombre de clase o espacio de nombres",
  "Declaración \"friend\" no válida",
  "un constructor o destructor no puede devolver un valor",
  "declaración de destructor no válida",
  "declaración de un miembro con el mismo nombre que su clase",
  "no se permite un calificador de ámbito global ('::' inicial)",
  "el ámbito global no tiene %sq",
  "no se permite un nombre completo",
  "no se permite una referencia NULL",
  "la inicialización con '{...}' no está permitida para un objeto de tipo %t",
  "la clase base %t es ambigua",
  "la clase derivada %t1 contiene más de una instancia de la clase %t2",
  "un puntero a la clase base %t2 no se puede convertir en un puntero a la clase derivada %t1; la clase base es virtual",
  "ninguna instancia del constructor %no coincide con la lista de argumentos",
  "el constructor de copia para la clase %t es ambiguo",
  "no existe ningún constructor predeterminado para la clase %t",
  "%sq es un miembro de datos no estático o una clase base de la clase %t",
  "no se permite una clase base no virtual indirecta",
  "miembro union no válido; la clase %t tiene una función miembro no permitida",
  null,
  "uso no válido de una matriz con valor distinto de L",
  "se esperaba un operador",
  "no se permite un miembro heredado",
  "no se puede determinar a qué instancia de %n se refiere",
  "un puntero a una función enlazada solo se puede usar para llamar a la función",
  "el nombre typedef ya se ha declarado (con el mismo tipo)",
  "%n ya se ha definido",
  null,
  "ninguna instancia de %n coincide con la lista de argumentos",
  "no se permite una definición de tipo en la declaración de tipos de valor devuelto de la función",
  "el argumento predeterminado no aparece al final de la lista de parámetros",
  "nueva definición del argumento predeterminado",
  "más de una instancia de %n coincide con la lista de argumentos:",
  "más de una instancia del constructor %no coincide con la lista de argumentos:",
  "un argumento predeterminado de tipo %t1 no es compatible con el parámetro de tipo %t2",
  "no se pueden sobrecargar las funciones que se distinguen solamente por el tipo de valor devuelto",
  "no existe ninguna conversión adecuada definida por el usuario de %t1 a %t2",
  null,
  "solo las funciones miembro no estáticas pueden ser virtuales",
  "El objeto tiene calificadores de tipo que no son compatibles con la función miembro",
  "el programa es demasiado grande para compilarlo (demasiadas funciones virtuales)",
  "el tipo de valor devuelto no es idéntico ni covariante con el tipo de valor devuelto %t de la función virtual invalidada %no",
  "la invalidación de %n virtual es ambigua",
  "el especificador puro ('= 0') solo se permite en las funciones virtuales",
  "especificador puro con formato incorrecto (solo se permite '= 0')",
  "no se permite un inicializador del miembro de datos",
  "no se permite un objeto de tipo de clase abstracta %t:",
  "no se permite una función que devuelva la clase abstracta %t:",
  "Declaración \"friend\" duplicada",
  "especificador inline permitido solamente en declaraciones de función",
  "no se permite 'inline'",
  "clase de almacenamiento no válida para una función insertada",
  "clase de almacenamiento no válida para un miembro de clase",
  "el miembro de clase local %n requiere una definición",
  "no se puede obtener acceso a %nfd",
  null,
  "la clase %t no tiene ningún constructor de copia para copiar un objeto const",
  "no se permite definir una función miembro declarada implícitamente",
  "la clase %t no tiene ningún constructor de copia adecuado",
  "no se permite la especificación de vinculación",
  "especificación de vinculación externa desconocida",
  "la especificación de vinculación no es compatible con %nod anterior",
  "más de una instancia de la función %no sobrecargada tiene una vinculación 'C'",
  "la clase %t tiene más de un constructor predeterminado",
  "valor copiado en memoria temporal, se usa la referencia a la memoria temporal",
  "'operator%s' debe ser una función miembro",
  "el operador no puede ser una función miembro estática",
  "no se permiten argumentos en una conversión definida por el usuario",
  "hay demasiados parámetros para esta función operator",
  "no hay suficientes parámetros para esta función operator",
  "un operador que no sea de miembro requiere un parámetro con un tipo de clase",
  "no se permite el argumento predeterminado",
  "se aplica más de una conversión definida por el usuario de %t1 a %t2:",
  "ningún operador %sq coincide con estos operandos",
  "más de un operador %sq coincide con estos operandos:",
  "el primer parámetro de la función de asignación debe ser de tipo 'size_t'",
  "la función de asignación requiere el tipo de valor devuelto 'void *'",
  "la función de desasignación requiere el tipo de valor devuelto 'void'",
  "el primer parámetro de la función de desasignación debe ser de tipo 'void *'",
  null,
  "el tipo debe ser un tipo de objeto",
  "la clase base %t ya se ha inicializado",
  "se requiere el nombre de la clase base; se presupone %t (anacronismo)",
  "%n ya se ha inicializado",
  "falta el nombre de la clase base o de miembro",
  "asignación a 'this' (anacronismo)",
  "se usó la palabra clave 'overload' (anacronismo)",
  "unión anónima no válida; no se permite un miembro no público",
  "unión anónima no válida; no se permite una función miembro",
  "una unión anónima en el ámbito global o de espacio de nombres se debe declarar como static",
  "%nf no proporciona ningún inicializador para:",
  "el constructor generado implícitamente para la clase %t no se puede inicializar:",
  "%n no define ningún constructor para inicializar los siguientes elementos:",
  "%n tiene un miembro de constante o referencia no inicializado",
  "%n tiene un campo const no inicializado",
  "la clase %t no tiene ningún operador de asignaciones para copiar un objeto const",
  "la clase %t no tiene ningún operador de asignaciones adecuado",
  "operador de asignaciones ambiguo para la clase %t",
  null,
  "la declaración requiere un nombre typedef",
  null,
  "no se permite 'virtual'",
  "no se permite 'static'",
  "conversión de un puntero a una función enlazada en un puntero a función normal (anacronismo)",
  "la expresión debe tener un tipo de puntero a miembro",
  "';' adicional omitido",
  "el inicializador in-class para un miembro no estático no es estándar",
  null,
  "ninguna instancia de %no sobrecargado coincide con la lista de argumentos",
  null,
  "ninguna instancia de %n coincide con el tipo requerido",
  "se ha usado la expresión delete array size (anacronismo)",
  null,
  "no se permite una conversión a la clase abstracta %t:",
  "no se puede llamar a la función 'main' ni tomar su dirección",
  "no se puede especificar un inicializador new para una matriz",
  "la función miembro %no no se puede declarar de nuevo fuera de su clase",
  "no se permite un puntero a un tipo %t de clase incompleta",
  "no se permite una referencia a una variable local de una función de inclusión",
  "se usó una función de un solo argumento para %sq postfijo (anacronismo)",
  null,
  "el operador de asignaciones generado implícitamente no se puede copiar:",
  "la conversión en tipo de matriz no es estándar (tratada como conversión en %t)",
  "%n tiene un operador new%s() pero no un operador delete%s() predeterminado",
  "%n tiene un operador delete%s() predeterminado pero no un operador new%s()",
  "el destructor para la clase base %nod no es virtual",
  null,
  "nueva declaración del miembro %npd no válida",
  "la función 'main' no se puede declarar como inline",
  "una función miembro con el mismo nombre que su clase debe ser un constructor",
  "uso de %n anidada (anacronismo)",
  "un destructor no puede tener parámetros",
  "el constructor de copia para la clase %t no puede tener un parámetro de tipo %t",
  "%n devuelve el tipo %t incompleto",
  "no se puede obtener acceso a %nd protegido a través de un objeto o puntero %t",
  "no se permite un parámetro",
  "no se permite aquí una declaración 'asm'",
  "no existe ninguna función de conversión de %t1 a %t2 adecuada",
  "eliminación de un puntero a una clase incompleta",
  "no existe ningún constructor adecuado para convertir de %t1 a %t2",
  "se aplica más de un constructor para convertir de %t1 a %t2:",
  "se aplica más de una función de conversión de %t1 a %t2:",
  "se aplica más de una función de conversión de %t a un tipo integrado:",
  "const %n",
  "referencia %n",
  "%npTd",
  "operador integrado %sq",
  "%nod, ambiguo por herencia",
  "no se puede tomar la dirección de un constructor o destructor",
  null,
  "elemento temporal usado para el valor inicial de referencia a un elemento que no es const (anacronismo)",
  "no se permite un nombre completo en la declaración de miembro",
  "tipo enumerado mezclado con otro tipo (anacronismo)",
  "el tamaño de una matriz en 'new' debe ser un valor no negativo",
  "devolviendo una referencia a la memoria temporal local",
  null,
  "no se permite una declaración 'enum'",
  "calificadores colocados en la referencia de enlace de tipo %t1 al inicializador de tipo %t2",
  "una referencia de tipo %t1 (no calificado constante) no se puede inicializar con un valor de tipo %t2",
  "no se puede eliminar un puntero a una función",
  "la función de conversión debe ser una función miembro no estática",
  "no se permite aquí una declaración de plantilla",
  "se esperaba '<'",
  "se esperaba '>'",
  "falta la declaración de parámetros de plantilla",
  "falta la lista de argumentos para %nf",
  "no hay suficientes argumentos para %nf",
  "hay demasiados argumentos para %nf",
  null,
  "%n1 no se usa al declarar los tipos de parámetros de %n2",
  "dos tipos anidados tienen el mismo nombre: %no1 y %nod2 (compatibilidad cfront)",
  "%no1 global se declaró después de %nod2 anidado (compatibilidad cfront)",
  null,
  "más de una instancia de %n coincide con el tipo requerido",
  "el tipo 'long long' no es estándar",
  "la omisión de %sq no es estándar",
  "no se puede especificar un tipo de valor devuelto en una función de conversión",
  "se detectó durante:",
  "Creación de una instancia de %nt %p",
  "generación implícita de %nt %p",
  "Recursividad excesiva en la creación de una instancia de %n",
  "%sq no es una función o miembro de datos estático",
  "un argumento de tipo %t1 no es compatible con un parámetro de plantilla de tipo %t2",
  "no se permite una inicialización que requiera un tipo temporal o una conversión",
  "la declaración de %sq oculta un parámetro de función",
  "un valor inicial de referencia a un elemento que no es const debe ser un valor L",
  "definición implícita de %nt %p",
  "no se permite 'template'",
  "%t no es una plantilla de clase",
  null,
  "'main' no es un nombre válido para una plantilla de función",
  "referencia no válida a %n (no coinciden el elemento de unión y no unión)",
  "un argumento de plantilla no puede hacer referencia a un tipo local",
  "el tipo de etiqueta de %s no es compatible con la declaración de %nfd",
  "el ámbito global no tiene ninguna etiqueta denominada %sq",
  "%n no tiene ningún miembro de etiqueta denominado %sq",
  "función miembro typedef (permitida para la compatibilidad cfront)",
  "%n solo se puede usar en una declaración de puntero a miembro",
  null,
  "un argumento de plantilla no puede hacer referencia a una entidad no externa",
  "un nombre seguido de '::~' debe ser un nombre de clase o de tipo",
  null,
  "el tipo usado como nombre de destructor no coincide con el tipo %t",
  "después de llamar a %n, declaró de nuevo 'inline'",
  null,
  "clase de almacenamiento no válida para una declaración de plantilla",
  "%nd es un tipo inaccesible (permitido para la compatibilidad cfront)",
  null,
  "Declaración de creación de una instancia explícita no válida",
  "%nf no es una entidad de la que se puedan crear instancias",
  "no se pueden crear instancias explícitamente de %n generado por el compilador",
  "no se pueden crear instancias explícitamente de %n inline",
  null,
  "no se pueden crear instancias de %n; no se proporcionó ninguna definición de plantilla",
  "no se pueden crear instancias de %n; se ha especializado de forma explícita",
  null,
  null,
  "ninguna instancia de %n coincide con el tipo especificado",
  "la declaración de una lista de parámetros void con typedef no es estándar",
  "se usó %n1 global en lugar de %n2 (compatibilidad cfront)",
  "el parámetro de plantilla %sq no se puede declarar de nuevo en este ámbito",
  "la declaración de %sq oculta un parámetro de plantilla",
  "la lista de argumentos de plantilla debe coincidir con la lista de parámetros",
  null,
  "el parámetro adicional de 'operator%s' postfijo debe ser de tipo 'int'",
  "un nombre de operador se debe declarar como función",
  "no se permite un nombre de operador",
  "%n no se puede especializar en el ámbito actual",
  "forma no estándar para tomar la dirección de una función miembro",
  "no hay suficientes parámetros de plantilla; no coincide con la declaración anterior (se declaró %p)",
  "hay demasiados parámetros de plantilla; no coincide con la declaración anterior (se declaró %p)",
  "no se permite una plantilla de función para el operador delete(void *)",
  "la plantilla de clase y el parámetro de plantilla no pueden tener el mismo nombre",
  null,
  "un argumento de plantilla no puede hacer referencia a un tipo sin nombre",
  "esta operación en un tipo enumerado requiere una función operator aplicable definida por el usuario",
  "no se permite un calificador de tipo en un tipo de referencia",
  "no se puede asignar un valor de tipo %t1 a una entidad de tipo %t2",
  "comparación sin sentido de un entero sin signo con una constante negativa",
  "no se puede convertir en la clase %t incompleta",
  "el objeto const requiere un inicializador",
  "el objeto tiene un miembro de constante o referencia no inicializado",
  "directiva de preprocesamiento no estándar",
  "%n no puede tener una lista de argumentos de plantilla",
  "se esperaba la inicialización con '{...}' para el objeto agregado",
  "los tipos de clase de selección de puntero a miembro no son compatibles (%t1 y %t2)",
  "Declaración \"friend\" sin sentido",
  "se usó '.' en lugar de '::' para formar un nombre completo",
  "se llamó a una función no constante para un objeto const (anacronismo)",
  "una instrucción dependiente no puede ser una declaración",
  "un parámetro no puede tener el tipo void",
  "Creación de una instancia de %na %p",
  "procesamiento de la lista de argumentos de plantilla para %na %p",
  "este operador no está permitido en una expresión de argumento de plantilla",
  "el bloque try requiere al menos un controlador",
  "el controlador requiere una declaración de excepción",
  "el controlador predeterminado enmascara el controlador",
  "controlador posiblemente enmascarado por el controlador anterior del tipo %t",
  "uso de un tipo local para especificar una excepción",
  "tipo redundante en la especificación de la excepción",
  "la especificación de la excepción no es compatible con la de %nd%s anterior",
  "se especificó anteriormente: no se producirán excepciones",
  "se omitió anteriormente: %t",
  "se especificó anteriormente pero se omitió aquí: %t",
  "la compatibilidad con el control de excepciones está deshabilitada",
  "permitir todas las excepciones es incompatible con la especificación anterior de %nd",
  "No se pudo crear el archivo de solicitud de creación de una instancia %sq",
  "no se permite una operación no aritmética en un argumento de plantilla sin tipo",
  "uso de un tipo local para declarar una variable no local",
  "uso de un tipo local para declarar una función",
  "la transferencia de control omite la inicialización de:",
  "%nd",
  "transferencia de control a un controlador de excepciones",
  "%n se ha usado antes de establecerse su valor",
  "%n se estableció pero nunca se usó",
  "%n no se puede definir en el ámbito actual",
  "no se permite la especificación de excepción",
  "conflicto de vinculación externa o interna para %nfd",
  "no se llamará a %nf para conversiones implícitas o explícitas",
  "el tipo de etiqueta de %s no es compatible con un parámetro de plantilla de tipo %t",
  "no se permite una plantilla de función para el operador new(size_t)",
  null,
  "no se permite un puntero a miembro de tipo %t",
  "no se permiten puntos suspensivos en la lista de parámetros de función del operador",
  "%no se reserva para uso futuro como palabra clave",
  "definición de macro no válida: %s",
  "anulación de definición de macro no válida: %s",
  null,
  null,
  "se debe especificar el nombre del archivo IL si la entrada es ",
  null,
  null,
  null,
  null,
  "error en el argumento de la opción de depuración",
  "opción no válida: %s",
  "back-end requiere el nombre del archivo IL",
  "no se pudo abrir el archivo IL %s",
  "número no válido: %s",
  "id. de CPU host no válido",
  "Modo de creación de una instancia no válido: %s",
  null,
  "límite de error no válido: %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "las tablas de funciones virtuales solo se pueden suprimir al compilar C++",
  "la opción de anacronismo solo se puede usar al compilar C++",
  "La opción del modo de creación de una instancia solo se puede usar al compilar C++",
  "El modo de creación de una instancia automática solo se puede usar al compilar C++",
  "el modo de inclusión implícita de plantillas solo se puede usar al compilar C++",
  "la opción de control de excepciones solo se puede usar al compilar C++",
  "el modo strict no es compatible con el modo K&R",
  "el modo strict no es compatible con el modo cfront",
  "falta el nombre del archivo de código fuente",
  "no se pueden especificar los archivos de salida al compilar varios archivos de entrada",
  "hay demasiados argumentos en la línea de comandos",
  "se especificó un archivo de salida, pero no se requiere ninguno",
  "para mostrar IL se requiere el nombre del archivo IL",
  "un parámetro de plantilla no puede tener el tipo void",
  "Creación de una instancia de %n recursiva excesiva debido al modo instantiate-all",
  "el modo strict no es compatible con la aparición de anacronismos",
  "una expresión throw no puede tener el tipo void",
  "El modo de creación de una instancia local no es compatible con la creación de una instancia automática",
  "no se permite un parámetro de tipo de clase abstracta %t:",
  "no se permite una matriz de clase abstracta %t:",
  "el parámetro de plantilla de punto flotante no es estándar",
  "esta pragma debe preceder directamente a una declaración",
  "esta pragma debe preceder directamente a una instrucción",
  "esta pragma debe preceder directamente a una declaración o instrucción",
  "este tipo de pragma no se puede usar aquí",
  null,
  "la función virtual sobrecargada %no1 solo se invalida parcialmente en %n2",
  "la definición específica de la función de plantilla inline debe preceder a su primer uso",
  "etiqueta de error no válida en la opción de control de diagnóstico: %s",
  "número de error no válido en la opción de control de diagnóstico: %s",
  null,
  null,
  "Conversión de una función puntero a miembro en un puntero a función",
  "struct o union no declara ningún miembro con nombre",
  "campo sin nombre no estándar",
  "miembro sin nombre no estándar",
  null,
  null,
  null,
  "%sq no es un nombre de tipo",
  "no se puede abrir el archivo de entrada de encabezado precompilado %sq: %s2",
  "el archivo de encabezado precompilado %sq no es válido o no se generó con esta versión del compilador",
  "el archivo de encabezado precompilado %sq no se generó en este directorio",
  "los archivos de encabezado usados para generar el archivo de encabezado precompilado %sq han cambiado",
  "las opciones de la línea de comandos no coinciden con las utilizadas cuando se creó el archivo de encabezado precompilado %sq",
  "la secuencia inicial de directivas de preprocesamiento no es compatible con las del archivo de encabezado precompilado %sq",
  "no se puede obtener la memoria asignada",
  "'%s': usando el archivo de encabezado precompilado '%s'",
  "'%s': creando el archivo de encabezado precompilado '%s'",
  "conflicto de uso de memoria con el archivo de encabezado precompilado %sq",
  "tamaño de memoria para archivos PCH no válido: %s ",
  "las opciones de los archivos PCH deben aparecer en primer lugar en la línea de comandos",
  "no hay memoria suficiente para asignar a los archivos PCH",
  "no se pueden usar archivos de encabezado precompilados al compilar varios archivos de entrada",
  "no hay suficiente memoria asignada previamente para la generación de un archivo de encabezado precompilado (se requieren %s bytes)",
  "una entidad muy grande en el programa impide la generación del archivo de encabezado precompilado",
  "%sq no es un directorio válido",
  "no se puede compilar un nombre de archivo temporal",
  "no se permite 'restrict'",
  "'restrict' no puede calificar un puntero o referencia al tipo de función",
  null,
  "no se puede especificar aquí un modificador de convención de llamada",
  "modificadores de convención de llamada en conflicto",
  "el modo strict no es compatible con el modo Microsoft",
  "el modo cfront no es compatible con el modo Microsoft",
  "se omite la convención de llamada especificada aquí",
  "una convención de llamada no puede ir seguida de un declarador anidado",
  "se omite la convención de llamada para este tipo",
  null,
  "los modificadores de declaración no son compatibles con la declaración anterior",
  "el modificador %sq no se permite en esta declaración",
  "transferencia de control a un bloque try",
  "la especificación inline no es compatible con %nod anterior",
  "no se encontró la llave de cierre de la definición de plantilla",
  "la opción de palabra clave wchar_t solo se puede usar al compilar C++",
  "valor de alineación del empaquetado no válido",
  "se esperaba una constante de tipo entero",
  "llamada de función virtual pura",
  "cadena del identificador del archivo de código fuente no válida",
  "Una plantilla de clase no se puede definir en una declaración \"friend\"",
  "no se permite 'asm'",
  "'asm' se debe usar con una definición de función",
  "la función 'asm' no es estándar",
  "el uso de puntos suspensivos con parámetros no explícitos no es estándar",
  "'&...' no es estándar",
  "uso no válido de '&...'",
  null,
  "elemento temporal usado para el valor inicial de referencia a const volatile (anacronismo)",
  "una referencia de tipo %t1 no se puede inicializar con un valor de tipo %t2",
  "un valor inicial de referencia a const volatile debe ser un valor L",
  "la opción de compatibilidad con SVR4 C solo se puede usar al compilar ANSI C",
  "declaración using fuera de ámbito de %nd",
  "el modo strict no es compatible con el modo SVR4 C",
  "La llamada de %nd no se puede insertar",
  "%n no se puede insertar",
  "directorio de archivos PCH no válido: %s",
  "se esperaba __except o __finally",
  "una instrucción __leave solo se puede usar en __try",
  "Se detectó durante la creación de una instancia de %nt %p",
  "se detectó durante la generación implícita de %nt %p",
  "Se detectó durante la creación de una instancia de %na %p",
  "se detectó durante el procesamiento de la lista de argumentos de plantilla para %na %p",
  "se detectó durante la definición implícita de %nt %p",
  "%sq no se encontró en la pila de alineación de paquetes",
  "pila de alineación de paquetes vacía",
  "la opción RTTI solo se puede usar al compilar C++",
  "no se puede obtener acceso a %nfd, que se requiere para la copia eliminada",
  "no se puede llamar a %nf, que se requiere para la copia eliminada, porque un parámetro de referencia no se puede enlazar a un valor R",
  "<typeinfo> se debe incluir antes de usar typeid",
  "%s no puede desechar const u otros calificadores de tipo",
  "el tipo incluido en dynamic_cast debe ser un puntero o referencia a un tipo de clase completa o void *",
  "el operando de un dynamic_cast de puntero debe ser un puntero a un tipo de clase completa",
  "el operando de un dynamic_cast de referencia debe ser un valor L de un tipo de clase completa",
  "el operando de un dynamic_cast en tiempo de ejecución debe tener un tipo de clase polimórfica",
  "la opción bool solo se puede usar al compilar C++",
  null,
  "no se permite aquí un tipo de matriz",
  "se esperaba '='",
  null,
  "%sq, que se declara en la condición, no se puede declarar de nuevo en este ámbito",
  "no se permiten argumentos de plantilla predeterminados para las plantillas de función",
  "se esperaba ',' o '>'",
  "se esperaba una lista de parámetros de plantilla",
  "el incremento de un valor booleano está desusado",
  "no se permite un tipo bool",
  "el desplazamiento de la clase base %no1 dentro de la clase %no2 es demasiado grande",
  "la expresión debe tener el tipo bool (o poder convertirse en dicho tipo)",
  "las opciones new y delete de una matriz solo se pueden usar al compilar C++",
  "%n no es un nombre de variable",
  "no se permite aquí el modificador __based",
  "__based no precede a un operador de puntero; se ha omitido __based",
  "la variable del modificador __based debe tener un tipo de puntero",
  "el tipo incluido en const_cast debe ser un puntero, una referencia o un puntero a miembro para un tipo de objeto",
  "const_cast solo puede ajustar los calificadores de tipo; no puede cambiar el tipo subyacente",
  "no se permite un tipo mutable",
  "no se permite que una nueva declaración de %n modifique su acceso",
  null,
  "el uso del token '<:' alternativo no parece ser intencionado",
  "el uso del token '%%:' alternativo no parece ser intencionado",
  "no se permite una definición de espacio de nombres",
  "debe ser un nombre de espacio de nombres",
  "no se permite una definición de alias de espacio de nombres",
  "se requiere el nombre completo del espacio de nombres",
  "no se permite un nombre de espacio de nombres",
  "combinación no válida de atributos de DLL",
  "%n no es una plantilla de clase",
  "una matriz con un tipo de elemento incompleto no es estándar",
  "un operador de asignación no se puede declarar en un espacio de nombres",
  "un operador de desasignación no se puede declarar en un espacio de nombres",
  "%np1 entra en conflicto con la declaración using de %np2",
  "la declaración using de %np1 entra en conflicto con %npd2",
  "la opción de espacios de nombres solo se puede usar al compilar C++",
  "se omitió la declaración using; hace referencia al espacio de nombres actual",
  "se requiere un nombre completo de clase",
  "los tipos de argumento son: (%s)",
  "los tipos de operando son: %s",
  null,
  "%n no tiene ningún miembro %sq real",
  null,
  "se han especificado atributos de memoria no compatibles",
  "atributo de memoria omitido",
  "un atributo de memoria no puede ir seguido de un declarador anidado",
  "atributo de memoria especificado más de una vez",
  "convención de llamada especificada más de una vez",
  "no se permite un calificador de tipo",
  "%npd1 se usó antes de declarar su plantilla",
  "no se pueden sobrecargar las funciones miembro static y no static con los mismos tipos de parámetro",
  "no hay ninguna declaración anterior de %np",
  "no se permite un id. de plantilla",
  "no se permite un nombre completo de clase",
  "%n no se puede declarar de nuevo en el ámbito actual",
  "no se permite un nombre completo en la declaración de miembro de espacio de nombres",
  "%n no es un nombre de tipo",
  "La creación de una instancia explícita no se permite en el ámbito actual",
  "no se pueden crear instancias de %n explícitamente en el ámbito actual",
  "se crearon instancias de %n explícitamente más de una vez",
  "typename solo se puede usar en una plantilla",
  "la opción special_subscript_cost solo se puede usar al compilar C++",
  "la opción typename solo se puede usar al compilar C++",
  "la opción typename implícita solo se puede usar al compilar C++",
  "carácter no estándar al inicio de una definición de macro como un objeto",
  "la especificación de la excepción para %n1 virtual no es compatible con la de %n2 invalidado",
  "conversión de puntero en entero más pequeño",
  "la especificación de la excepción para %n1 virtual declarada implícitamente no es compatible con la de %n2 invalidado",
  "%no1, que se llama implícitamente desde %np2, es ambiguo",
  "la opción 'explicit' solo se puede usar al compilar C++",
  "no se permite 'explicit'",
  "la declaración entra en conflicto con %sq (nombre de clase reservado)",
  "solo se permite '()' como inicializador de la matriz %n",
  "no se permite 'virtual' en una declaración de plantilla de función",
  "unión anónima no válida; no se permite una plantilla de miembro de clase",
  "la profundidad de anidamiento de plantilla no coincide con la declaración anterior de %n",
  "esta declaración no puede tener varias cláusulas 'template <...>'",
  "la opción para controlar el ámbito para la inicialización solo se puede usar al compilar C++",
  "%sq, que se declara en la inicialización del bucle For, no se puede declarar de nuevo en este ámbito",
  "la referencia se hace a %nd1; bajo las reglas anteriores de ámbito para la inicialización habría sido %nd2",
  "la opción para controlar las advertencias sobre diferencias para la inicialización solo se puede usar al compilar C++",
  "aquí se requiere la definición de %n virtual",
  "comentario vacío interpretado como operador '##' de pegado de token",
  "No se permite una clase de almacenamiento en una declaración \"friend\"",
  "la lista de parámetros de plantilla para %no no se permite en esta declaración",
  "%n no es una plantilla de miembro de clase válida",
  "no es una declaración de plantilla de función o clase de miembro válida",
  "una declaración de plantilla que contiene una lista de parámetros de plantilla no puede ir seguida de una declaración de especialización explícita",
  "la especialización explícita de %n1 debe preceder al primer uso de %n2",
  "la especialización explícita no se permite en el ámbito actual",
  "no se permite la especialización parcial de %n",
  "%nf no es una entidad que se pueda especializar de forma explícita",
  "la especialización explícita de %n debe preceder a su primer uso",
  "el parámetro de plantilla %sq no se puede usar en un especificador de tipo elaborado",
  "la especialización de %n requiere la sintaxis 'template<>'",
  null,
  null,
  "la opción 'old_specializations' solo se puede usar al compilar C++",
  "la especialización de %n sin la sintaxis 'template<>' no es estándar",
  "esta declaración no puede tener una vinculación 'C' externa",
  "%sq no es un nombre de plantilla de clase o función en el ámbito actual",
  "la especificación de un argumento predeterminado al declarar de nuevo una plantilla de función sin referencia no es estándar",
  "no se permite especificar un argumento predeterminado al declarar de nuevo una plantilla de función a la que ya se ha hecho referencia",
  "un puntero a miembro de la clase base %t2 no se puede convertir en un puntero a miembro de la clase derivada %t1; la clase base es virtual",
  "la especificación de la excepción no es compatible con la de %nd%s",
  "permitir todas las excepciones es incompatible con la especificación de %nd",
  "final inesperado de la expresión de argumentos predeterminada",
  "no se permite la inicialización predeterminada de la referencia",
  "%n sin inicializar tiene un miembro de constante",
  "la clase base %t no inicializada tiene un miembro de constante",
  "const %n requiere un inicializador; la clase %t no tiene ningún constructor predeterminado proporcionado por el usuario",
  "const requiere un inicializador; la clase %t no tiene ningún constructor predeterminado proporcionado por el usuario",
  "la opción 'implicit_extern_c_type_conversion' solo se puede usar al compilar C++",
  "el modo strict no es compatible con las reglas de conservación long",
  "el calificador de tipo del tipo de valor devuelto carece de sentido",
  "en una definición de función, no se permite un calificador de tipo en un tipo de valor devuelto 'void'",
  "no se permite una declaración de miembro de datos estático en esta clase",
  "La creación de una instancia de plantilla dio como resultado una declaración de función no válida",
  "no se permite '...'",
  "la opción 'extern_inline' solo se puede usar al compilar C++",
  "se hizo referencia a %n inline externo, pero no se definió",
  "nombre de destructor no válido para el tipo %t",
  null,
  "la referencia al destructor es ambigua; se podría usar tanto %n1 como %n2",
  "nunca se definió %n inline virtual",
  "nunca se hizo referencia a %n",
  "solamente se puede especificar un miembro de una unión en una lista de inicializadores del constructor",
  "la compatibilidad con 'new[]' y 'delete[]' está deshabilitada",
  "se usó 'double' para 'long double' en el código de C generado",
  "%n no tiene ningún operador delete%s correspondiente (al que llamar si se produce una excepción durante la inicialización de un objeto asignado)",
  "la compatibilidad con placement delete está deshabilitada",
  "no hay visible ningún operador delete adecuado",
  "no se permite un puntero o una referencia a un tipo incompleto",
  "especialización parcial no válida; %n ya se ha especializado por completo",
  "especificaciones de excepción no compatibles",
  "devolviendo una referencia a una variable local",
  "la omisión de un tipo explícito no es estándar (se presupone 'int')",
  "más de una especialización parcial coincide con la lista de argumentos de plantilla de %n",
  "%nod",
  "no se permite una lista de argumentos de plantilla en una declaración de plantilla principal",
  "las especializaciones parciales no pueden tener argumentos de plantilla predeterminados",
  "%n1 no se usa en (o no se puede deducir de) la lista de argumentos de plantilla de %n2",
  null,
  "la lista de argumentos de plantilla de la especialización parcial incluye un argumento sin tipo cuyo tipo depende de un parámetro de plantilla",
  "esta especialización parcial se habría usado para crear instancias de %n",
  "Esta especialización parcial habría hecho que la creación de una instancia de %n resultara ambigua",
  "la expresión debe tener un tipo integral o de enumeración",
  "la expresión debe tener un tipo aritmético o de enumeración",
  "la expresión debe tener un tipo aritmético, de enumeración o de puntero",
  "el tipo de la conversión debe ser integral o de enumeración",
  "el tipo de la conversión debe ser aritmético, de enumeración o de puntero",
  "la expresión debe ser un puntero a un tipo de objeto completo",
  null,
  "un argumento sin tipo de especialización parcial debe ser el nombre de una constante o un parámetro sin tipo",
  "el tipo de valor devuelto no es idéntico al tipo de valor devuelto %t de la función virtual invalidada %no",
  "la opción 'guiding_decls' solo se puede usar al compilar C++",
  "una especialización parcial de una plantilla de clase se debe declarar en el espacio de nombres del que es miembro",
  "%n es una función virtual pura",
  "%n virtual pura no tiene ningún elemento que la invalide",
  "se han omitido los atributos __declspec",
  "carácter no válido en la línea de entrada",
  "la función devuelve el tipo incompleto %t",
  "el efecto de esta directiva '#pragma pack' es local para %n",
  "%s no es una plantilla",
  "Una declaración \"friend\" no puede declarar una especialización parcial",
  "se ha omitido la especificación de la excepción",
  "la declaración de 'size_t' no coincide con el tipo %t esperado",
  "es necesario dejar espacio entre los delimitadores '>' adyacentes de las listas de argumentos de plantilla anidados ('>>' es el operador de desplazamiento a la derecha)",
  "no se pudo establecer la configuración regional %sq para permitir el procesamiento de caracteres multibyte",
  "secuencia de caracteres multibyte no válida",
  "La creación de una instancia de plantilla dio como resultado el tipo de función inesperado de %t1 (el significado de un nombre puede haber cambiado desde la declaración de la plantilla; el tipo de la plantilla es %t2)",
  "declaración de guía ambigua; más de una plantilla de función %no coincide con el tipo %t",
  "no se permite una operación no integral en un argumento de plantilla sin tipo",
  "la opción 'embedded_c++' solo se puede usar al compilar C++",
  "C++ incrustado no admite plantillas",
  "C++ incrustado no admite el control de excepciones",
  "C++ incrustado no admite espacios de nombres",
  "C++ incrustado no admite información de tipo en tiempo de ejecución",
  "C++ incrustado no admite la nueva sintaxis de conversión",
  "C++ incrustado no admite las declaraciones using",
  "C++ incrustado no admite 'mutable'",
  "C++ incrustado no admite la herencia múltiple o virtual",
  "número de versión de Microsoft no válido: %s",
  "la representación de puntero a miembro %sq ya se ha establecido para %n",
  "%t1 no se puede usar para designar un constructor para %t2",
  "sufijo no válido en una constante integral",
  "un operando de __uuidof debe tener un tipo de clase o enumeración para el que se haya especificado __declspec(uuid('...'))",
  "cadena de GUID no válida en __declspec(uuid('...'))",
  "la opción 'vla' solo se puede usar al compilar C",
  "no se permite una matriz de longitud variable con un límite no especificado",
  "en esta declaración no se permite una lista de argumentos de plantilla explícita",
  "una entidad con vinculación no puede tener un tipo que requiera una matriz de longitud variable",
  "una matriz de longitud variable no puede tener una duración de almacenamiento estática",
  "%n no es una plantilla",
  "dimensión de matriz de longitud variable (se declaró %p)",
  "se esperaba un argumento de plantilla",
  null,
  "un operador que no sea de miembro requiere un parámetro con un tipo de clase o enumeración",
  "la opción 'enum_overloading' solo se puede usar al compilar C++",
  null,
  "el calificador del nombre de destructor %t1 no coincide con el tipo %t2",
  "se ha omitido el calificador de tipo",
  "La opción \"nonstd_qualifier_deduction\" solo se puede usar al compilar C++",
  "no se puede definir una función declarada como 'dllimport'",
  "especificación incorrecta de la propiedad; la forma correcta es __declspec(property(get=nombre1,put=nombre2))",
  "la propiedad ya se ha especificado",
  "__declspec(property) no se permite en esta declaración",
  "el miembro se declara con __declspec(property), pero no se especificó ninguna función 'get'",
  "falta la función 'get' %sq de __declspec(property)",
  "el miembro se declara con __declspec(property), pero no se especificó ninguna función 'put'",
  "falta la función 'put' %sq de __declspec(property)",
  "referencia ambigua a un miembro de clase; se usa %nd1 antes que %nd2",
  null,
  null,
  null,
  "un puntero a miembro de la clase derivada %t1 no se puede convertir en un puntero a miembro de la clase base %t2; la clase base es virtual",
  "Directorio no válido para los archivos de creación de una instancia: %s",
  "La opción \"one_instantiation_per_object\" solo se puede usar al compilar C++",
  null,
  null,
  "No se puede especificar un nombre de archivo de información de creación de una instancia al compilar varios archivos de entrada",
  "La opción \"one_instantiation_per_object\" no se puede usar al compilar varios archivos de entrada",
  "más de una opción de la línea de comandos coincide con la abreviatura '--%s':",
  "--%s",
  "Se omiten los calificadores de tipo en los tipos de función",
  null,
  "la opción late/early tiebreaker solo se puede usar al compilar C++",
  "uso incorrecto de va_start",
  "uso incorrecto de va_arg",
  "uso incorrecto de va_end",
  "La opción de creaciones de instancias pendientes solo se puede usar al compilar C++",
  "directorio no válido para los archivos #import: %s",
  "un directorio de importación solo se puede especificar en el modo Microsoft",
  "no se permite un miembro con un tipo de referencia en una unión",
  "'typedef' no se puede especificar aquí",
  "la nueva declaración de %n modifica su acceso",
  "se requiere un nombre completo de clase o espacio de nombres",
  "el tipo de valor devuelto 'int' se omitió en la declaración de la función 'main'",
  "la representación de puntero a miembro %sq es demasiado restrictiva para %n",
  "Falta una instrucción \"return\" al final de %n distinto de void",
  "se ha omitido la declaración using duplicada de %no",
  "los campos de bits de enumeraciones son siempre sin signo, pero la enumeración %t incluye un enumerador negativo",
  "la opción 'class_name_injection' solo se puede usar al compilar C++",
  "la opción 'arg_dep_lookup' solo se puede usar al compilar C++",
  "la opción 'friend_injection' solo se puede usar al compilar C++",
  "el nombre que sigue a 'template' debe ser una plantilla",
  null,
  "Declaración \"friend\" de clase local no estándar; no hay ninguna declaración anterior en el ámbito de inclusión",
  "la especificación de un argumento predeterminado en esta declaración no es estándar",
  "la opción 'nonstd_using_decl' solo se puede usar al compilar C++",
  "el tipo de valor devuelto de la función 'main' debe ser 'int'",
  "un parámetro de plantilla sin tipo no puede tener un tipo de clase",
  "no se puede especificar un argumento de plantilla predeterminado en la declaración de un miembro de una plantilla de clase fuera de su clase",
  "No se permite una instrucción \"return\" en un controlador de un bloque try de función de un constructor",
  "los designadores comunes y extendidos no se pueden combinar en una designación de inicializador",
  "el segundo subíndice no debe ser más pequeño que el primero",
  null,
  "La opción \"extended_designators\" solo se puede usar al compilar C",
  "el tamaño declarado para el campo de bits es mayor que el tamaño del tipo de campo de bits; se trunca a %s bits",
  "el tipo usado como nombre de constructor no coincide con el tipo %t",
  "uso de un tipo sin vinculación para declarar una variable con vinculación",
  "uso de un tipo sin vinculación para declarar una función",
  "no se puede especificar un tipo de valor devuelto en un constructor",
  "no se puede especificar un tipo de valor devuelto en un destructor",
  "nombre de carácter universal formado incorrectamente",
  "el nombre de carácter universal especifica un carácter no válido",
  "un nombre de carácter universal no puede designar un carácter en el juego de caracteres básico",
  "este carácter universal no está permitido en un identificador",
  "el identificador __VA_ARGS__ solo puede aparecer en las listas de reemplazos de las macros variádicas",
  "Se ha omitido el calificador en esta declaración \"friend\"",
  "los designadores de intervalo de matriz no se pueden aplicar a los inicializadores dinámicos",
  "aquí no puede aparecer un nombre de propiedad",
  "se omite el uso de 'inline' como calificador de función",
  "la opción 'compound_literals' solo se puede usar al compilar C",
  "no se permite un tipo de matriz de longitud variable",
  "no se permite un literal compuesto en una expresión constante integral",
  "no se permite un literal compuesto de tipo %t",
  "No se puede incluir una declaración \"friend\" de plantilla en una clase local",
  "operación '?' ambigua: el segundo operando de tipo %t1 se puede convertir en el tercer tipo de operando %t2 y viceversa",
  "llamada de un objeto de un tipo de clase sin ninguna función de conversión u operator() adecuados para el tipo de puntero a función",
  "función suplente de conversión %np",
  "existe más de una forma de llamar a un objeto de tipo %t para la lista de argumentos:",
  "el nombre typedef ya se ha declarado (con un tipo similar)",
  "no se puede asignar una vinculación interna a los operadores new y delete",
  "la clase de almacenamiento 'mutable' no está permitida para las uniones anónimas",
  "archivo de encabezado precompilado no válido",
  "el tipo de clase abstracta %t no está permitido como tipo catch:",
  "no se puede usar un tipo de función calificada para declarar una función que no sea miembro o una función miembro estática",
  "no se puede usar un tipo de función calificada para declarar un parámetro",
  "no se puede crear un puntero o referencia a un tipo de función calificada",
  "las llaves adicionales no son estándar",
  "definición de macro no válida: %s",
  "la resta de los tipos de puntero %t1 y %t2 no es estándar",
  "no se permite una lista de parámetros de plantilla vacía en una declaración de parámetros template de plantilla",
  "se esperaba 'class'",
  "al declarar un parámetro de plantilla no se debe usar la palabra clave \"struct\"",
  "%no1 oculta a %np2; ¿se pretende invalidar la función virtual?",
  "No se permite un nombre completo para una declaración \"friend\" que es una definición de función",
  "%n1 no es compatible con %n2",
  "no se puede especificar aquí una clase de almacenamiento",
  "un miembro de clase designado por una declaración using debe estar visible en una clase base directa",
  null,
  "el modo Sun no es compatible con el modo cfront",
  "el modo strict no es compatible con el modo Sun",
  "el modo Sun solo se permite al compilar C++",
  "un parámetro template de plantilla no puede tener el mismo nombre que uno de sus parámetros de plantilla",
  "Creación de una instancia recursiva del argumento predeterminado",
  null,
  "%n no es una entidad que se pueda definir",
  "el nombre del destructor debe estar completo",
  "'typename' no puede producir un nombre de clase friend",
  "una declaración using no puede asignar nombre a un constructor o destructor",
  "una declaración de plantilla friend calificada debe hacer referencia a una plantilla específica declarada anteriormente",
  "especificador no válido en la declaración de plantilla de clase",
  "el argumento no es compatible con un parámetro formal",
  "la opción 'dep_name' solo se puede usar al compilar C++",
  "bucle en la secuencia de funciones 'operator->' que empieza en la clase %t1",
  "%n no tiene ninguna clase de miembro %sq",
  "el ámbito global no tiene ninguna clase denominada %sq",
  "Creación de una instancia recursiva del argumento de plantilla predeterminado",
  "las declaraciones using y de acceso no pueden aparecer en las uniones",
  "%no no es un miembro de clase",
  "no se permite una declaración de constantes miembro no estándar",
  "la opción 'ignore_std' solo se puede usar al compilar C++",
  "la opción 'parse_templates' solo se puede usar al compilar C++",
  "la opción 'dep_name' no se puede usar con 'no_parse_templates'",
  "los modos de lenguaje especificados no son compatibles",
  "nueva declaración de la clase anidada no válida",
  "no se permite un tipo que contenga una matriz de tamaño desconocido",
  "no se puede definir una variable con una duración de almacenamiento estática dentro de una función insertada",
  "no se puede hacer referencia a una entidad con vinculación interna dentro de una función insertada con vinculación externa",
  "el tipo de argumento %t no coincide con esta macro de función genérica",
  "matriz de longitud variable %nod",
  "Una declaración \"friend\" no puede agregar argumentos predeterminados a una declaración anterior",
  "%n no se puede declarar en este ámbito",
  "el identificador %sq reservado solo se puede usar dentro de una función",
  "un identificador no puede empezar por este carácter universal",
  "se esperaba un literal de cadena",
  "pragma STDC no reconocida",
  "se esperaba 'ON', 'OFF' o 'DEFAULT'",
  "una pragma STDC solo puede aparecer entre declaraciones en el ámbito global o delante de cualquier instrucción o declaración en un ámbito de bloque",
  "uso incorrecto de va_copy",
  "%s solo se puede usar con tipos de punto flotante",
  "no se permite un tipo complejo",
  "tipo de designador no válido",
  "el valor de punto flotante no se puede representar con exactitud",
  "el resultado de la operación de punto flotante compleja está fuera del intervalo",
  "la conversión entre real e imaginario devuelve cero",
  "no se puede especificar un inicializador para un miembro de matriz flexible",
  "imaginary *= imaginary establece el operando en la parte izquierda en cero",
  "el modo estándar requiere que una declaración subsiguiente asigne un tipo a %n (se presupone 'int')",
  "se requiere una definición para %n inline",
  "conversión de integer en puntero más pequeño",
  "debe incluirse un tipo de punto flotante en el especificador de un tipo _Complex o _Imaginary",
  "no se pueden declarar tipos en las uniones anónimas",
  "devolviendo un puntero a una variable local",
  "devolviendo un puntero a la memoria temporal local",
  "la opción 'export' solo se puede usar al compilar C++",
  "la opción 'export' no se puede usar con 'no_dep_name'",
  "la opción 'export' no se puede usar con 'implicit_include'",
  "la declaración de %n no es compatible con una declaración en otra unidad de traducción",
  "la otra declaración es %p",
  "se detectó durante la compilación de la unidad de traducción secundaria %sq",
  "compilación de la unidad de traducción secundaria %sq",
  "una declaración de campo no puede tener un tipo que requiera una matriz de longitud variable",
  "la declaración de %n tenía otro significado durante la compilación de %sq",
  "se esperaba 'template'",
  "\"export\" no se puede usar en una creación de una instancia explícita",
  "'export' no se puede usar en esta declaración",
  "un miembro de un espacio de nombres sin nombre no se puede declarar como 'export'",
  "una plantilla no se puede declarar como 'export' después de haberla definido",
  "una declaración no puede tener una etiqueta",
  "la compatibilidad con las plantillas exportadas está deshabilitada",
  null,
  "%n ya se ha definido durante la compilación de %sq",
  "%n ya se ha definido en otra unidad de traducción",
  "una variable local no estática no se puede usar en una especificación de __based",
  "la opción para enumerar las dependencias de archivos Make no se puede especificar al compilar más de una unidad de traducción",
  null,
  "la opción para generar un resultado preprocesado no se puede especificar al compilar más de una unidad de traducción",
  "no se puede declarar un campo con el mismo nombre que su clase en una clase con un constructor declarado por el usuario",
  "'implicit_include' no se puede usar al compilar más de una unidad de traducción",
  "el archivo de plantilla %sq exportado está dañado",
  "no se pueden crear instancias de %n; se ha especializado de forma explícita en la unidad de traducción que contiene la definición exportada",
  "el tipo de objeto es: %s",
  "El objeto tiene calificadores de tipo que no son compatibles con la %n miembro",
  "Ninguna instancia de %n coincide con el objeto y la lista de argumentos (el objeto tiene calificadores de tipo que impiden la coincidencia)",
  "un atributo especifica un modo no compatible con %t",
  "no hay ningún tipo con el ancho especificado",
  "el valor de alineación especificado por el atributo no es válido",
  "atributo no válido para %t",
  null,
  null,
  "el atributo %sq no toma argumentos",
  null,
  "se esperaba un nombre de atributo",
  "atributo desconocido %sq",
  "aquí no pueden aparecer atributos",
  "argumento no válido para el atributo %sq",
  null,
  "en 'goto *expr', expr debe tener el tipo 'void *'",
  "'goto *expr' no es estándar",
  "la aceptación de la dirección de una etiqueta no es estándar",
  "el nombre de archivo se especificó más de una vez: %s",
  "directiva #warning: %s",
  null,
  "el atributo 'transparent_union' solo se aplica a las uniones y %t no es una unión",
  "al atributo 'transparent_union' se omite en los tipos incompletos",
  "%t no puede ser transparente porque %n no tiene el mismo tamaño que el primer campo",
  "%t1 no puede ser transparente porque tiene un campo de tipo %t2 que no tiene el mismo tamaño que el primer campo",
  null,
  "el atributo %sq no se aplica a la variables locales",
  "no se permiten atributos en una definición de función",
  null,
  "la segunda constante de un intervalo case debe ser mayor que la primera",
  "no se permite un nombre asm en una definición de función",
  "un nombre asm se omite en un typedef",
  "nombre de registro desconocido '%s'",
  null,
  "modificador de restricción asm '%s' desconocido",
  "letra de restricción asm '%s' desconocida",
  "el operando asm no tiene ninguna letra de restricción",
  "un operando de salida asm debe tener el modificador '=' o '+'",
  "un operando de entrada asm no puede tener los modificadores '=' o '+'",
  null,
  null,
  "el registro '%s' se ha usado más de una vez",
  "el registro '%s' se ha usado y destruido",
  "el registro '%s' se destruyó más de una vez",
  "el registro '%s' tiene un propósito fijo y no se puede usar en una instrucción asm",
  "el registro '%s' tiene un propósito fijo y no se puede destruir en una instrucción asm",
  "una lista de destrucciones vacía se debe omitir por completo",
  "se esperaba un operando asm",
  "se esperaba un registro para destruir",
  "el atributo 'format' requiere un parámetro de puntos suspensivos",
  "el primer argumento de sustitución no es el primer argumento de variable",
  "el índice de argumentos de formato es superior al número de parámetros",
  "un argumento de formato no tiene un tipo de cadena",
  "la palabra clave 'template' que se usa para anular la ambigüedad sintáctica solo se puede usar en una plantilla",
  "para usar la pragma db_opt se debe especificar una opción de depuración en la línea de comandos",
  null,
  "el atributo %sq no se aplica al tipo %t que no es de función",
  "aritmética en puntero a tipo de función o void",
  "la clase de almacenamiento debe ser auto o register",
  "%t1 se habría promovido a %t2 al pasar a través del parámetro de puntos suspensivos; use el segundo tipo en su lugar",
  "%sq no es un miembro de clase base",
  "__super no puede aparecer después de '::'",
  "__super solo se puede usar en un ámbito de clase",
  "__super debe estar seguido de '::'",
  "[los contextos de creación de una instancia de %d no se muestran]",
  "el nombre alterado es demasiado largo",
  "declaración con el alias de la entidad %sq no definida",
  "la declaración no coincide con su alias %n",
  "la entidad declarada como alias no puede tener una definición",
  "el tipo de campo de matriz de longitud variable se tratará como tipo de campo de matriz de longitud cero",
  "se ha omitido la conversión no estándar en valor L",
  "nombre de marca no reconocido: %s",
  "no se puede calificar un tipo de valor devuelto void",
  "el especificador auto se omite aquí (no válido en C/C++ estándar)",
  "se ha omitido una reducción de la alineación sin el atributo 'packed'",
  "una plantilla de miembro correspondiente a %no se ha declarado como plantilla de otro tipo en una unidad de traducción distinta",
  "los inicializadores en exceso se omiten",
  "va_start solo puede aparecer en una función con un parámetro de puntos suspensivos",
  "la opción 'short_enums' solo es válida en los modos GNU C y GNU C++",
  "archivo de información de exportación %sq1 no válido en el número de línea %s2",
  "las expresiones de instrucción solo se permiten en el ámbito de bloque",
  "desde unidad de traducción ",
  "un nombre asm se omite en una variable automática que no es del registro",
  null,
  "pragma UPC no reconocida",
  "el tamaño de bloque compartido no coincide con el especificado anteriormente",
  "se presupone que la expresión entre corchetes es una especificación del tamaño de bloque y no una dimensión de matriz",
  "el tamaño de bloque de una matriz compartida debe ser mayor que cero",
  "no se permiten múltiples tamaños de bloque",
  "una conversión estricta o flexible requiere un tipo compartido",
  "THREADS no se permite en este contexto",
  "el tamaño de bloque especificado supera el valor máximo de %s",
  "no se permite una función que devuelva un tipo compartido",
  null,
  "una dimensión de una matriz de un tipo compartido debe ser un múltiplo de THREADS cuando el número de subprocesos no es constante",
  "no se permite un tipo compartido dentro de un struct o union",
  "los parámetros no pueden tener tipos compartidos",
  "una dimensión THREADS dinámica requiere un tamaño de bloque definitivo",
  "las variables compartidas deben ser static o extern",
  "el argumento de upc_blocksizeof es un puntero a un tipo compartido (no el tipo compartido en sí)",
  "expresión de afinidad omitida en upc_forall anidado",
  "no se permite la creación de una rama dentro o fuera de un bucle upc_forall",
  "la expresión de afinidad debe tener un tipo compartido o señalarlo",
  "la afinidad tiene un tipo compartido (no un puntero a compartido)",
  "los tipos void* compartidos solo se pueden comparar para comprobar si son iguales",
  "el modo UPC no es compatible con los modos C++ y K&R",
  "se ha omitido el carácter nulo (cero) en la línea de entrada",
  "carácter nulo (cero) en la constante de caracteres o cadena",
  "carácter nulo (cero) en el nombre de encabezado",
  "la declaración en el inicializador for oculta una declaración en el ámbito adyacente",
  "la declaración oculta es %p",
  "la declaración de prototipos de %nfd se omite después de esta nueva declaración sin prototipos",
  null,
  "%npd debe tener una vinculación C externa",
  "la declaración de variable oculta la declaración en el inicializador for",
  "el typedef %sq no se puede usar en un especificador de tipo elaborado",
  "se ha omitido una llamada de constante cero",
  "el parámetro %sq no se puede declarar de nuevo en una cláusula catch de un bloque try de función",
  "la especialización explícita inicial de %n se debe declarar en el espacio de nombres que contiene la plantilla",
  "se ha omitido la destrucción de 'cc'",
  "'template' debe estar seguido de un identificador",
  "MYTHREAD no se permite en este contexto",
  "un calificador de diseño no puede calificar un puntero a un tipo compartido",
  "un calificador de diseño no puede calificar una matriz incompleta",
  "la declaración de %sq oculta un parámetro de controlador",
  "se ha omitido la conversión no estándar en tipo de matriz",
  "esta pragma no se puede usar en un operador _Pragma (se debe usar una directiva #pragma)",
  "el campo usa el relleno posterior de una clase base",
  "los compiladores de GNU C++ pueden usar espacio de campo de bits",
  "%nd se declaró como deprecated",
  "no se permite un nombre asm en una declaración de miembro no estático",
  "se ha omitido el tipo de función de formato %sq no reconocido",
  "la clase base %no1 usa el espacio de cola de la clase base %no2",
  "el atributo 'init_priority' solo se puede usar para las definiciones de miembros de datos estáticos y variables de ámbito de espacio de nombres de los tipos de clase",
  "la prioridad de inicialización solicitada está reservada para uso interno",
  "%nd oculta este campo union/struct anónimo",
  "número de error no válido",
  "etiqueta de error no válida",
  "se esperaba un número o etiqueta de error",
  "el tamaño de la clase se ve afectado por el espacio de cola",
  "solo se puede hacer referencia a las etiquetas en las definiciones de función",
  "no se permite la transferencia de control a una expresión de instrucción",
  null,
  "esta instrucción no está permitida en una expresión de instrucción",
  "no se puede definir una clase que no se pueda copiar de forma trivial dentro de una expresión de instrucción",
  null,
  "no se permite una variable estática local inicializada dinámicamente en una expresión de instrucción",
  "no se permite una matriz de longitud variable en una expresión de instrucción",
  "no se permite una expresión de instrucción en un argumento predeterminado",
  "conversión no estándar entre un puntero a función y un puntero a datos",
  "los tipos de interfaz no pueden tener clases base virtuales",
  "los tipos de interfaz no pueden especificar 'private' o 'protected'",
  "los tipos de interfaz solo pueden derivarse de otros tipos de interfaz",
  "%t es un tipo de interfaz",
  "los tipos de interfaz no pueden tener miembros typedef",
  "los tipos de interfaz no pueden tener constructores o destructores declarados por el usuario",
  "los tipos de interfaz no pueden tener operadores de miembro declarados por el usuario",
  "no se pueden declarar tipos de interfaz en las funciones",
  null,
  "los tipos de interfaz no pueden tener miembros de datos",
  "Los tipos de interfaz no pueden contener declaraciones \"friend\"",
  null,
  "los tipos de interfaz no pueden ser tipos de clases anidadas",
  "los tipos de interfaz no pueden tener plantillas de miembros",
  "los tipos de interfaz no pueden tener funciones miembro static",
  "esta pragma no se puede usar en un operador __pragma (se debe usar una directiva #pragma)",
  "el calificador debe ser la clase base de %t",
  "la declaración debe corresponder a una función miembro virtual pura en la clase base indicada",
  "desbordamiento con enteros en el cálculo interno debido al tamaño o la complejidad de %t",
  "desbordamiento con enteros en el cálculo interno",
  "__w64 solo se puede especificar en tipos de puntero, int y long",
  "Conversión posiblemente de restricción cuando se compila en un entorno donde los tipos de puntero, int o long tienen un ancho de 64 bits",
  "el valor actual de pragma pack es %s",
  "se omiten los argumentos de pragma pack(show)",
  null,
  null,
  "se ha omitido __declspec(align(...)) anterior",
  "se esperaba un valor de argumento para el parámetro del atributo %sq",
  "valor de argumento no válido para el parámetro del atributo %sq",
  "se esperaba un valor booleano para el parámetro del atributo %sq",
  "un argumento posicional no puede seguir a un argumento con nombre en un atributo",
  "el atributo %sq1 no tiene ningún parámetro denominado %sq2",
  "se esperaba una lista de argumentos para el atributo %sq",
  "se esperaba ',' o ']'",
  "ya se ha asignado un valor al argumento de atributo %sq",
  "no se puede asignar un valor al atributo %sq",
  "una expresión throw no puede tener un puntero a tipo incompleto",
  "el operador alignment-of se aplicó a un tipo incompleto",
  "%sq solo se puede usar como atributo independiente",
  "el atributo %sq no se puede usar aquí",
  null,
  "no se permiten aquí atributos",
  "valor de argumento no válido para el parámetro del atributo %sq",
  "hay demasiados argumentos de atributo",
  "no se permite la conversión desde una clase base %t inaccesible",
  "la opción 'export' requiere signaturas de plantilla definidas",
  "no se pueden concatenar literales de cadena con distintos tipos de caracteres",
  "el error de diseño de GNU no se ha emulado porque coloca %no1 de base virtual fuera de los límites del objeto %no2",
  "la base virtual %no1 se colocó fuera de los límites del objeto %no2",
  "nombre completo no estándar en la declaración de miembro de espacio de nombres",
  "se ha omitido la reducción en la alineación",
  "se ha omitido el calificador const",
  null,
  "calificadores asm de GNU no válidos",
  "un tipo de clase que no se puede copiar de forma trivial se ha pasado a través de los puntos suspensivos",
  "va_arg no puede capturar un tipo de clase que no se pueda copiar de forma trivial",
  "el sufijo 'u' o 'U' debe aparecer delante del sufijo 'l' o 'L' en un literal de punto fijo",
  "la opción 'fixed_point' solo se puede usar al compilar C",
  "un operando entero puede causar un desbordamiento de punto fijo",
  "la constante de punto fijo está fuera del intervalo",
  "el valor de punto fijo no se puede representar con exactitud",
  "la constante es demasiado grande para long long; se proporciona un tipo unsigned long long (no estándar)",
  "un calificador de diseño no puede calificar un puntero a un tipo void compartido",
  "THREADS duplicados en el tipo de matriz multidimensional",
  "una directiva using segura solo puede aparecer en un ámbito de espacio de nombres",
  "%nf declara una función que no es de plantilla; agregue <> para hacer referencia a una instancia de plantilla",
  "la operación puede causar un desbordamiento de punto fijo",
  "la expresión debe tener un tipo integral, de enumeración o de punto fijo",
  "la expresión debe tener un tipo integral o de punto fijo",
  "una función declarada con 'noreturn' devuelve resultados",
  "el nombre asm se ha omitido porque entra en conflicto con una declaración anterior",
  "un typedef de miembro de clase no se puede declarar de nuevo",
  "se toma la dirección de un elemento temporal",
  "se omiten los atributos de una declaración de clase que no sea también una definición",
  "valor de punto fijo convertido implícitamente en tipo de punto flotante",
  "los tipos de punto flotante no tienen clasificación",
  "un parámetro de plantilla no puede tener un tipo de punto fijo",
  "no se permiten constantes hexadecimales de punto flotante",
  "la opción 'named_address_spaces' solo se puede usar al compilar C",
  "el valor de punto flotante no incluye el tipo de punto fijo requerido",
  "el valor no se puede convertir en un valor de punto fijo con exactitud",
  "la conversión de punto fijo dio como resultado un cambio de signo",
  "el valor entero no incluye el tipo de punto fijo requerido",
  "el resultado de la operación de punto fijo está fuera del intervalo",
  "múltiples espacios de dirección con nombre",
  "una variable con duración de almacenamiento automática no se puede almacenar en un espacio de dirección con nombre",
  "el tipo no se puede calificar con un espacio de dirección con nombre",
  "el tipo de función no se puede calificar con un espacio de dirección con nombre",
  "el tipo de campo no se puede calificar con un espacio de dirección con nombre",
  "el valor de punto fijo no incluye el tipo de punto flotante requerido",
  "el valor de punto fijo no incluye el tipo entero requerido",
  "el valor no incluye el tipo de punto fijo requerido",
  "la opción 'named_registers' solo se puede usar al compilar C",
  "no se permite aquí una clase de almacenamiento con nombre en el registro",
  "%nd se declaró de nuevo con una clase de almacenamiento con nombre en el registro no compatible",
  "no se puede especificar una clase de almacenamiento con nombre en el registro para una variable con alias",
  "el especificador de almacenamiento de registro con nombre ya está en uso",
  "la opción 'embedded_c' no se puede combinar con las opciones para controlar las funcionalidades individuales de C incrustado",
  "directorio EDG_BASE no válido: %s",
  null,
  "entrada de macro predefinida no válida en la línea %s: %s2",
  "nombre de modo de macro %sq no válido",
  "nueva definición de la macro predefinida %sq no compatible",
  "falta una clase de almacenamiento con nombre en el registro en la nueva declaración de %nd",
  "el registro con nombre es demasiado pequeño para el tipo de la variable",
  "no se pueden declarar matrices con una clase de almacenamiento con nombre en el registro",
  "const_cast en un tipo de enumeración no es estándar",
  "la opción 'embedded_c' solo se puede usar al compilar C",
  "no se permite aquí un calificador de espacio de dirección con nombre",
  "un inicializador vacío no es válido para una matriz con un límite no especificado",
  "la función devuelve el tipo de clase incompleta %t",
  "%n ya se ha inicializado; el inicializador out-of-class se omitirá",
  "la declaración oculta %nd",
  "no se puede asignar un parámetro en un espacio de dirección con nombre",
  "sufijo no válido en una constante de punto fijo o punto flotante",
  "no se puede asignar una variable de registro en un espacio de dirección con nombre",
  "se esperaba 'SAT' o 'DEFAULT'",
  "%n no tiene ningún operador de miembro delete%s correspondiente (al que llamar si se produce una excepción durante la inicialización de un objeto asignado)",
  "una variable de subproceso local no se puede declarar con 'dllimport' o 'dllexport'",
  "un tipo de valor devuelto de función no se puede calificar con un espacio de dirección con nombre",
  "no se puede especificar un inicializador para un miembro de matriz flexible cuyos elementos tienen un destructor no trivial",
  "no se puede especificar un inicializador para un miembro de matriz flexible indirecto",
  "número de versión de GNU no válido: %s",
  "los atributos de variable que aparecen después de un inicializador entre paréntesis se omiten",
  "el resultado de esta conversión no se puede usar como valor L",
  "negación de un valor de punto fijo sin signo",
  null,
  null,
  "los nombres de registro solo se pueden usar para las variables de registro",
  "las variables de registro con nombre no pueden tener el tipo void",
  null,
  "los parámetros no pueden tener especificadores de ámbito de vínculo",
  "múltiples especificadores de ámbito de vínculo",
  "los especificadores de ámbito de vínculo solo pueden aparecer en funciones y variables con vinculación externa",
  "una nueva declaración no puede debilitar un ámbito de vínculo",
  "especificador de ámbito de vínculo no permitido en esta declaración",
  "nombre completo no estándar en la declaración de ámbito global",
  "conversión implícita de un tipo entero de 64 bits en un tipo entero más pequeño (posible problema de portabilidad)",
  "conversión explícita de un tipo entero de 64 bits en un tipo entero más pequeño (posible problema de portabilidad)",
  "conversión de un puntero en un tipo entero del mismo tamaño (posible problema de portabilidad)",
  null,
  "no se permite un especificador friend en una definición de clase; se omite el especificador friend",
  "solo las variables static y extern pueden usar almacenamiento local de subprocesos",
  "múltiples especificadores de almacenamiento local de subprocesos",
  "no se definió %n virtual (y no se puede definir en ninguna otra parte porque es miembro de un espacio de nombres sin nombre)",
  "carácter de retorno de carro en la línea de código fuente fuera del comentario o el literal de carácter o cadena",
  "la expresión debe tener un tipo de punto fijo",
  "se ha omitido un uso no válido del especificador de acceso",
  "puntero convertido en bool",
  "puntero a miembro convertido en bool",
  "se ha omitido el especificador de almacenamiento",
  "dllexport y dllimport se omiten en las plantillas de clase",
  "la especificación dllexport/dllimport de la clase base es distinta de la correspondiente a la clase derivada",
  "la nueva declaración no puede agregar dllexport/dllimport a %nod",
  "conflicto de dllexport y dllimport con %nod; se presupone dllexport",
  "no se puede definir la entidad dllimport",
  "dllexport o dllimport requiere una vinculación externa",
  "un miembro de una clase declarada con dllexport/dllimport no puede declararse propiamente con tal especificador",
  "se ha usado un campo de tipo de clase sin interfaz DLL en una clase con una interfaz DLL",
  "la declaración de miembro entre paréntesis no es estándar",
  "se ha omitido el espacio en blanco entre la barra diagonal inversa y la nueva línea en la inserción de líneas",
  "conflicto de dllexport y dllimport con %nod; se ha colocado dllimport/dllexport",
  "miembro no válido para una clase de miembro anónimo; la clase %t tiene una función miembro no permitida",
  "reinterpret_cast no estándar",
  "el especificador de formato posicional no puede ser cero",
  "una clase local no puede hacer referencia a un tipo de matriz de longitud variable desde una función de inclusión",
  "el miembro %nd ya tiene un especificador dllexport/dllimport explícito",
  "no se permite una matriz de longitud variable en un tipo de valor devuelto de función",
  "no se permite un tipo de matriz de longitud variable en un puntero a miembro de tipo %t",
  "el resultado de una expresión de instrucción no puede tener un tipo que requiera una matriz de longitud variable",
  "la compatibilidad con los trígrafos está deshabilitada",
  "el atributo %sq solo puede aparecer en las funciones y variables con vinculación externa",
  "el modo strict no es compatible con el trato del espacio de nombres std como alias para el espacio de nombres global",
  "en la expansión de macro '%s' %p,",
  "<DESCONOCIDO>",
  "",
  "[ las expansiones de macro %d no se muestran ]",
  "en expansión de macro en %p",
  "nombre de operando simbólico %sq no válido",
  "una restricción de coincidencia simbólica debe hacer referencia a uno de los diez primeros operandos",
  "el uso de __if_exists no se admite en este contexto",
  "el bloque __if_exists no se cerró en el mismo ámbito en el que se abrió",
  "una variable de subproceso local no se puede inicializar dinámicamente",
  "la conversión coloca el calificador '__unaligned'",
  "el tipo entero subyacente al tipo de enumeración no puede representar algunos valores del enumerador",
  "no se permite el argumento predeterminado en una declaración de plantilla de clase friend",
  "literal de carácter con varios caracteres (posible problema de portabilidad)",
  "se esperaba un tipo class, struct o union",
  "el segundo operando de offsetof debe ser un campo",
  "el segundo operando de offsetof no puede ser un campo de bits",
  "no se puede aplicar offsetof a un miembro de una base virtual",
  "offsetof aplicado a un tipo distinto de una clase de diseño estándar",
  "No se permiten argumentos predeterminados en una declaración \"friend\" de una función miembro",
  "No se permiten argumentos predeterminados en las declaraciones \"friend\" que no son definiciones",
  "no se permite una nueva declaración de %nd que se declaró anteriormente como friend con argumentos predeterminados",
  "calificador no válido para %t (no se permite aquí una clase derivada)",
  "calificador no válido para la definición de la clase %t",
  "no hay ninguna push_macro anterior para %sq",
  "literal de cadena de tipo ancho no permitido",
  null,
  "%sq solo se permite en C",
  "__ptr32 y __ptr64 deben seguir a '*'",
  "no se pueden aplicar tanto __ptr32 como __ptr64",
  "la lista de argumentos de plantilla de %sq debe coincidir con la lista de parámetros",
  "no se permite un tipo de clase incompleta",
  "no se admiten los tipos enteros complejos",
  "__real e __imag solo se pueden aplicar a valores complejos",
  "se ha aplicado __real o __imag a un valor real",
  "%nd se declaró como deprecated (%sq)",
  "nueva definición de %nd no válida",
  "se ha aplicado dllimport/dllexport a un miembro de un espacio de nombres sin nombre",
  "__thiscall solo puede aparecer en declaraciones de funciones miembro no estáticas",
  "__thiscall no se permite en una función con un parámetro de puntos suspensivos",
  "la especialización explícita de %n debe preceder a su primer uso (%p)",
  "un tipo de clase sellado no se puede usar como clase base",
  "modificador de clase duplicado",
  "una función miembro no puede tener tanto el modificador 'abstract' como 'sealed'",
  "un miembro de tipo sellado no puede ser virtual puro",
  "una función no virtual no se puede declarar con el modificador 'abstract' o 'sealed'",
  "la función miembro declarada con 'override' no invalida un miembro de clase base",
  "no se puede invalidar el elemento %nd sellado",
  "%nd se declaró con el modificador de clase 'abstract'",
  "en la línea ",
  " de ",
  "con ",
  "palabra clave",
  "macro",
  "etiqueta",
  "parámetro de plantilla",
  "tipo",
  "unión",
  "clase",
  "estructura",
  "parámetro template de plantilla",
  "plantilla",
  "plantilla de clase",
  "enumeración",
  "parámetro",
  "parámetro de controlador",
  "variable",
  "sin tipo",
  "constante",
  "función",
  "función sobrecargada",
  "miembro",
  "campo",
  "espacio de nombres",
  "registro con nombre",
  "espacio de dirección con nombre",
  "plantilla de función",
  "se basa en un argumento de plantilla",
  "se basa en argumentos de plantilla",
  " (se declara ",
  "(al final del código fuente)",
  "Al final del código fuente",
  "Línea",
  "línea",
  "col.",
  "nota",
  "Nota",
  "advertencia",
  "Advertencia",
  "error",
  "Error",
  "error grave",
  "Error grave",
  "error de la línea de comandos",
  "Error de la línea de comandos",
  "Error interno",
  "Error interno",
  null,
  null,
  "Se ha alcanzado el límite de error.",
  "Bucle de error interno",
  "Bucle en el procesamiento de un error grave.",
  null,
  "temporal",
  "resultado de preprocesamiento",
  "lista sin procesar",
  "referencia cruzada",
  "lenguaje intermedio (1)",
  "lenguaje intermedio (2)",
  "lenguaje intermedio (3)",
  "lenguaje intermedio (4)",
  "lenguaje intermedio (5)",
  "lenguaje intermedio (6)",
  "lenguaje intermedio (7)",
  "lenguaje intermedio (8)",
  "lenguaje intermedio (9)",
  null,
  null,
  null,
  null,
  null,
  "falta la marca que indica que no se puede definir de nuevo",
  "falta el modo después de ','",
  "falta el nombre de macro",
  "valor que indica que no se puede definir de nuevo no válido",
  "modificador de función duplicado",
  "carácter no válido para el literal char16_t",
  null,
  "convención de llamada %s no reconocida, debe ser una de las siguientes:",
  null,
  null,
  null,
  "el tipo subyacente del tipo de enumeración debe ser un tipo entero",
  "%t no puede representar algunas constantes de enumerador",
  "%sq no se permite en el modo actual",
  "la opción type traits helpers solo se puede usar al compilar C++",
  "el atributo 'centinela' requiere un parámetro de puntos suspensivos",
  "el argumento debe ser un valor de puntero nulo constante",
  "no hay un número de argumentos suficiente para el valor sentinel",
  "el argumento sentinel debe corresponder a un parámetro de puntos suspensivos",
  "__declspec(implementation_key(...) solo puede aparecer entre #pragma start_map_region y #pragma stop_map_region",
  "#pragma start_map_region ya activa: se ha omitido pragma",
  "no hay ninguna #pragma start_map_region activa actualmente: se ha omitido pragma",
  "%n no se puede usar para denominar un destructor (se requiere un nombre de tipo)",
  "literal de carácter ancho vacío no estándar tratado como L'\\0'",
  "'typename' no se puede especificar aquí",
  "un operador delete no ubicado debe estar visible en una clase con un destructor virtual",
  "la vinculación de nombre está en conflicto con la declaración anterior de %nd",
  "el alias crea un ciclo de entidades con alias",
  null,
  "una variable con duración de almacenamiento estática asignada en un registro específico no se puede declarar con un inicializador",
  "una variable asignada en un registro específico debe poder copiarse de forma trivial",
  "se descartó el significado predefinido de %no",
  null,
  "tipo de clase no adecuado para su uso con designadores",
  null,
  "el calificador de unión anónima no es estándar",
  "se ha omitido el calificador de unión anónima",
  null,
  "se ha omitido __declspec(%s) (no tiene significado para un struct de C)",
  "los especificadores después de coma entre declaraciones no son estándar",
  "se ha omitido el especificador no estándar",
  "se omiten los atributos de una declaración de enumeración que no sea también una definición",
  "la declaración de una referencia con 'mutable' no es estándar",
  "una declaración de condiciones para una matriz siempre es true",
  "error de aserción estática con %sq",
  "el atributo visibility se ha omitido porque entra en conflicto con una declaración anterior",
  "el nombre de campo se resuelve en más de un desplazamiento; vea %nod1 y %nod2",
  "%sq no es un nombre de campo",
  "el valor de la etiqueta de caso ya ha aparecido en este modificador %p",
  "una función miembro no puede tener vinculación interna",
  "la declaración oculta %n integrado",
  "la declaración sobrecarga %n integrado",
  "la opción para enumerar las definiciones de macro no se puede especificar al compilar más de una unidad de traducción",
  "paréntesis inesperado tras la declaración de %n (¿lista de parámetros con formato incorrecto o inicializador no válido?)",
  "el uso de paréntesis alrededor de un inicializador de cadena no es estándar",
  "__interfaz",
  "una variable declarada con un especificador de tipo auto no puede aparecer en su propio inicializador",
  "no se puede deducir el tipo 'auto'",
  "la inicialización con '{...}' no está permitida para el tipo 'auto'",
  "el tipo 'auto' no puede aparecer en el tipo de matriz de nivel superior",
  "el tipo 'auto' no puede aparecer en el tipo de función de nivel superior",
  "un miembro de tipo %t no puede tener un inicializador in-class",
  "un miembro con un inicializador in-class debe ser const",
  "no se puede deducir el tipo 'auto' (se requiere un inicializador)",
  "el tipo 'auto' es %t1 para esta entidad, pero anteriormente se suponía que era %t2",
  "declaración de constructor no válida",
  "uso no válido de un calificador de tipo",
  "una unión no puede ser abstracta ni estar sellada",
  "no se permite aquí 'auto'",
  "definición del tipo de clase base no completada aún",
  "'extern template' no puede hacer referencia a una especialización de %nd static",
  "\"extern template\" no puede ir después de la creación de una instancia explícita de %n",
  "__declspec(restrict) requiere una función que devuelva un tipo de puntero",
  "la opción 'report_gnu_extensions' solo es válida en los modos GNU C y GNU C++",
  "los tipos de matriz de longitud variable no son estándar",
  "los designadores no son estándar",
  "esta sintaxis de designador es una extensión de GNU",
  "los literales compuestos no son estándar",
  "las expresiones de instrucción son una extensión de GNU",
  "el nombre asm se ha omitido para la entidad previamente definida",
  "los atributos son una extensión de GNU",
  "la sintaxis asm extendida es una funcionalidad de GNU",
  "las declaraciones asm de tipo volatile son una extensión de GNU",
  "los especificadores de nombre asm son una extensión de GNU",
  "el calificador '__restrict' no es estándar",
  "'typeof' es una extensión de GNU",
  "la modificación del tamaño o tipo signed/unsigned de un typedef no es estándar",
  "las matrices de longitud cero son una extensión de GNU",
  "los miembros de matriz flexible no son estándar",
  "el atributo 'nonnull' hace referencia a un parámetro que no es un puntero",
  "el argumento para el atributo 'nonnull' es mayor que el número de parámetros",
  "ningún parámetro tiene tipo de puntero",
  "se ha proporcionado un argumento nulo para el parámetro marcado con el atributo 'nonnull'",
  "el destructor para %t1 se ha suprimido porque no se puede obtener acceso al destructor para %t2",
  "el destructor suprimido para %t es necesario",
  "la rutina es tanto 'inline' como 'noinline'",
  "rutina de limpieza no válida",
  "el atributo 'cleanup' requiere una duración de almacenamiento automática",
  "el atributo 'cleanup' no se aplica a los parámetros",
  "la rutina de limpieza tiene un tipo no válido",
  "la llamada de la rutina de limpieza requiere una conversión sospechosa",
  "__sptr y __uptr deben seguir a '*'",
  "no se pueden especificar tanto __sptr como __uptr",
  "la conversión de puntero de ampliación de %t1 a %t2 extiende el bit de signo",
  "__sptr y __uptr no se aplican a los tipos de puntero a miembro",
  "la declaración del operador de asignación de copia para %t se ha suprimido porque %n es const",
  "la declaración del operador de asignación de copia para %t se ha suprimido porque %n tiene un tipo de referencia",
  "la declaración del operador de asignación de copia para %t1 se ha suprimido porque también se suprimió la de %t2",
  "la declaración del operador de asignación de copia para %t1 se ha suprimido porque la de %t2 es ambigua",
  "la declaración del operador de asignación de copia para %t1 se ha suprimido porque no se puede obtener acceso a la de %t2",
  "la declaración del constructor de copia para %t1 se ha suprimido porque también se suprimió la de %t2",
  "la declaración del constructor de copia para %t1 se ha suprimido porque la de %t2 es ambigua",
  "la declaración del constructor de copia para %t1 se ha suprimido porque no se puede obtener acceso a la de %t2",
  "no se llamará al destructor para %t1 porque es inaccesible y se suprimió el destructor para %t2",
  "la definición al final del archivo no va seguida de punto y coma o de un declarador",
  "el primer argumento debe ser un puntero a un tipo de enumeración o entero",
  "las operaciones sincronizadas solo son válidas en los objetos de tamaño 1, 2, 4 u 8",
  "se han omitido los argumentos adicionales",
  "'=' supuso el siguiente nombre de macro %sq en la definición de la línea de comandos",
  "se requiere un espacio en blanco entre el nombre de macro %sq y su texto de reemplazo",
  "no se usa el resultado de la llamada",
  "el atributo 'warn_unused_result' se omite para el tipo de valor devuelto void",
  null,
  "dllimport/dllexport se omite en la nueva declaración con el uso de un nombre completo",
  "hay demasiados caracteres en el literal de caracteres; se omiten los caracteres iniciales sobrantes",
  "%n no se puede declarar como inline después de su definición %p",
  null,
  null,
  "un argumento de plantilla no puede hacer referencia a un tipo sin vinculación de nombre",
  "'virtual' se omite aquí",
  "un argumento de plantilla no puede hacer referencia a un tipo de matriz de longitud variable",
  "un nombre de carácter universal no puede designar un punto de código suplente",
  "#include_next no se puede usar en el archivo de código fuente principal",
  "%no1 no se puede especificar en una definición de miembro de plantilla; se presupone %no2 en su lugar",
  "el atributo %sq se omite en una declaración de función local",
  "la concatenación con %sq en %n no crea un token válido",
  "%no ambiguo (se presupone %n2)",
  "no se permite un calificador de tipo en una función miembro static",
  "no se permite un calificador de tipo en un constructor o destructor",
  "no se permite un calificador de tipo en operator new u operator delete",
  "no se permite un calificador de tipo en una función que no sea miembro",
  "el argumento para %s tiene efectos secundarios, pero no se evalúa",
  "tipo de código fuente Unicode no reconocido (debe ser uno de los siguientes: UTF-8, UTF-16, UTF-16LE o UTF-16BE): %s",
  "el carácter Unicode con valor hexadecimal %s no se puede representar en la salida de preprocesamiento",
  "la prioridad de constructor o destructor solicitada está reservada para uso interno",
  "pragma GCC no reconocida",
  "directiva pragma GCC visibility no reconocida",
  "tipo de visibility no reconocido",
  "la pragma visibility estaba aún activa",
  "no hay visibility push coincidente",
  "typeid de tipo incompleto",
  null,
  "se presupone que la matriz %n tiene un elemento",
  "el atributo vector_size requiere un tipo aritmético o de enumeración",
  "el tamaño de vector es demasiado grande",
  "el número de elementos de un vector debe ser una potencia de dos",
  "el tamaño de vector debe ser un múltiplo del tamaño del elemento",
  "operación mixta vectorial escalar no permitida",
  "la operación requiere dos vectores del mismo tamaño",
  "no se permite un tamaño de vector dependiente de plantilla",
  null,
  null,
  "el atributo vector_size no se permite con un tipo de elemento complejo",
  null,
  "la operación vector requiere tipos de elemento idénticos",
  "la operación vector no se aplica a un vector con un tipo no entero",
  "no se puede abrir el archivo %s (código de error %sq2).",
  "no se puede abrir el archivo %s. %sq2: %s3",
  "encabezado precompilado",
  "macro predefinida",
  "C generado",
  "C++ generado",
  "origen",
  "error al escribir en el archivo %s: %s2",
  "no es un archivo normal",
  "es un directorio",
  "nombre de archivo no válido",
  "lista de definiciones",
  "Solicitud de creación de una instancia",
  "plantilla exportada",
  "información de exportación",
  "información de plantilla",
  "resultado de IL",
  "la conversión coloca el calificador '__restrict'",
  "no se puede obtener memoria asignada para %sq: %s2",
  "se ha omitido el calificador de restricción",
  null,
  "una matriz de elementos que contiene un miembro de matriz flexible no es estándar",
  "un parámetro de plantilla no puede tener un tipo de vector",
  "la inicialización de %n1 se realizará antes que la de %n2",
  null,
  "el tipo de herencia se omite en un especificador enum",
  null,
  "el modificador se omite en un especificador enum",
  "el carácter identificador no se puede representar en Unicode",
  "el nombre de encabezado contiene caracteres que no se pueden representar en Unicode",
  "%sq no es un nombre de configuración regional válido",
  "la declaración de una lista de parámetros void con un parámetro de plantilla no es estándar",
  "la opción de lambda solo se puede usar al compilar C++",
  "la captura explícita coincide con la predeterminada",
  "%n no es una variable",
  "una variable con duración de almacenamiento estática no se puede capturar en una lambda",
  "'this' no se puede capturar por referencia",
  "'this' no se puede usar en el cuerpo de esta lambda",
  "no se puede hacer referencia a un miembro de una unión anónima de ámbito externo en el cuerpo de una lambda",
  "no se puede hacer referencia a una variable local de función de inclusión en el cuerpo de una lambda a menos que esté en la lista de capturas",
  "referencia no válida a una variable local de ámbito externo en el cuerpo de una lambda",
  "no se puede capturar una variable local externa al ámbito de la función actual",
  "no se puede hacer referencia a la función de inclusión 'this' en el cuerpo de una lambda a menos que esté en la lista de capturas",
  null,
  "la variable lambda capturada de tipo %t1 no se puede copiar en un campo closure class de tipo %t2",
  "directorio de plantillas no válido: %s",
  "error",
  "errores",
  "error grave",
  "errores graves",
  "y",
  "en la compilación de '%s'.",
  "en esta compilación.",
  "el valor de enumeración está fuera del intervalo de su tipo subyacente (%t)",
  "'\\' seguido de un espacio en blanco no es una inserción de línea",
  "esta conversión dynamic_cast no se puede realizar sin información del tipo de runtime, que se ha deshabilitado",
  "la conversión en %t es ambigua; se ha seleccionado la base directa",
  "un búfer interno sería demasiado grande",
  "se ha usado el controlador de excepciones de C++, pero no se ha especificado la semántica de control de excepciones",
  "se ha omitido el calificador de tipo en el constructor",
  "una variable capturada por una lambda no puede tener un tipo que requiera una matriz de longitud variable",
  "conversión entre tipos de vector no compatibles",
  "se esperaba '{' como introducción de un cuerpo de lambda",
  "la opción de referencia a un valor R solo se puede usar al compilar C++",
  "no se permite un calificador de tipo en una lambda",
  "un nombre no puede aparecer más de una vez en una lista de capturas",
  "se han omitido los argumentos de plantilla explícitos",
  "no se permite una lambda en una expresión constante",
  "%t no es un tipo de clase",
  "'delete' aplicado a un tipo de puntero a matriz se trata como delete[]",
  "'delete' aplicado a un tipo de puntero a matriz no es estándar; se trata como delete[]",
  "no se puede llamar a %n con la lista de argumentos dada",
  "una referencia a un valor R no se puede enlazar a un valor L",
  "un parámetro de plantilla sin tipo no puede tener un tipo de referencia a un valor R",
  "Los calificadores de tipo se omiten (el tipo subyacente es una referencia)",
  "%n, que se declaró con un tipo local, se debe definir en esta unidad de traducción",
  "%n, que se declaró con un tipo sin vinculación, se debe definir en esta unidad de traducción",
  "el operando de un dynamic_cast de referencia a un valor R debe tener un tipo de clase completa",
  "'= default' solo puede aparecer en los constructores predeterminados, constructores de copia/movimiento, operadores de asignación de copia/movimiento y destructores",
  "'= delete' solo puede aparecer en la primera declaración de una función",
  "no se puede hacer referencia a %npd; es una función eliminada",
  "no se permite una lambda en una expresión no evaluada",
  "__builtin_va_arg_pack o __builtin_va_arg_pack_len solo puede aparecer en una función insertada con un parámetro de puntos suspensivos",
  "No se puede especificar \"= default\" en una declaración \"friend\"",
  "se esperaba una palabra clave de C++",
  null,
  "el desplazamiento no es constante",
  "tipo de #pragma comment %sq no reconocido",
  "la opción para controlar si 'auto' es un especificador de tipo solo se puede usar al compilar C++",
  "la opción para controlar si 'auto' es una clase de almacenamiento solo se puede usar al compilar C++",
  "no pueden estar deshabilitados ambos significados de 'auto', como especificador de tipo y de clase de almacenamiento",
  "cadena no válida en #pragma comment",
  "la función eliminada invalida %n, que no se ha eliminado",
  "la función no eliminada invalida %n, que se ha eliminado",
  "no se puede hacer referencia al constructor predeterminado de %t: es una función eliminada",
  "no se permite una referencia a un valor R como tipo catch",
  "los argumentos predeterminados de %n no son compatibles con una declaración en otra unidad de traducción",
  "los argumentos predeterminados de %n eran distintos durante la compilación de %sq",
  null,
  "el inicializador de %n es distinto en otra unidad de traducción",
  "el inicializador de %n era distinto durante la compilación de %sq",
  "no se permite un designador en un tipo dependiente de plantilla",
  "tipo de conformidad no reconocido",
  "se esperaba 'on' u 'off'",
  "la pila #pragma conform(forScope) está vacía",
  "ninguna entrada anterior de #pragma conform(forScope) coincide con %sq",
  "el comportamiento de forScope no es estándar",
  "el comportamiento de forScope es estándar",
  "la función 'main' no se puede eliminar",
  "Los calificadores de tipo carecen de sentido aquí",
  "tipo no válido para el operador de asignaciones con valor predeterminado",
  "no se puede asignar un valor predeterminado a las plantillas de función",
  "tipo no válido para el constructor con valor predeterminado",
  "la llamada a función requiere un argumento",
  "la llamada a función requiere un argumento de punto flotante real",
  "no se puede asignar un valor predeterminado a un constructor de copia con un argumento predeterminado",
  "una función predeclarada no se puede eliminar",
  "instrucción dependiente vacía en la instrucción if",
  "instrucción dependiente vacía en la cláusula 'else' de la instrucción if",
  "no se puede hacer referencia a %nfd, que se requiere para la copia eliminada; es una función eliminada",
  "primer parámetro %t de 'main' no estándar, se esperaba 'int'",
  "número de parámetros para 'main' no estándar, se esperaban cero o dos parámetros",
  "segundo parámetro %t de 'main' no estándar, se esperaba 'char *[]' o 'char **'",
  "%sq se especificó como directorio de inclusión tanto del sistema como ajeno al sistema; la segunda entrada se omitirá",
  "la opción para controlar los constructores de movimiento y de asignación de movimiento solo se puede usar al compilar C++",
  null,
  null,
  "un tipo de valor devuelto final requiere el especificador de tipo 'auto'",
  "un tipo de valor devuelto final no puede aparecer en un declarador anidado",
  "un declarador de función con un tipo de valor devuelto final debe ir precedido de un especificador de tipo 'auto' simple",
  "la función 'auto' requiere un tipo de valor devuelto final",
  "una plantilla de miembro no puede tener un especificador puro",
  "literal de cadena demasiado largo: se omitieron los caracteres sobrantes",
  "la opción para controlar la palabra clave nullptr solo se puede usar al compilar C++",
  "std::nullptr_t convertido en booleano",
  null,
  null,
  "el atributo %sq no permite una lista de argumentos vacía",
  "el atributo aparece más de una vez",
  "el atributo %sq no se aplica aquí",
  "el atributo %sq no se aplica a los campos de bits",
  "el atributo %sq requiere un campo de bits",
  "el atributo %sq no se aplica a las funciones miembro",
  "el atributo %sq requiere una función miembro",
  "el atributo %sq no se aplica a las funciones virtuales",
  "el atributo %sq requiere una función virtual",
  "el atributo %sq no se aplica a las funciones virtuales puras",
  "el atributo %sq requiere una función virtual pura",
  "el atributo %sq no se aplica a las variables de registro",
  "el atributo %sq requiere una variable de registro",
  "el atributo %sq no estaba en la declaración original",
  "no se permiten aquí atributos",
  "el atributo %sq debe aparecer en una definición de clase",
  "'final' aplicado a una función virtual pura",
  "no se puede invalidar 'final' %nd",
  "static %n tratado como extern porque se hacía referencia a él pero no se definió",
  "la opción para habilitar la inserción de tipo GNU-C89 solo se puede usar al compilar C",
  "la función se declaró previamente sin el atributo 'gnu_inline'",
  "el atributo 'gnu_inline' se omite en las funciones que no son insertadas",
  "%n se declaró previamente sin el atributo carries_dependency",
  "inicializador no válido para la matriz %n",
  "se debe especificar el modo C++11 o C++14 cuando se compila la biblioteca del runtime",
  "el atributo %sq no se aplica a los tipos de función",
  "el atributo %sq requiere un tipo de función",
  "el atributo %sq no se aplica a las funciones miembro no estáticas",
  "el atributo %sq no se aplica a las variables automáticas",
  "el atributo %sq requiere una variable automática",
  "el atributo %sq no se aplica a una variable o función con vinculación externa",
  "el atributo %sq requiere una variable local",
  "los atributos se omiten aquí",
  "el atributo no se aplica a ninguna entidad",
  "sustitución de argumentos de atributo incorrecta",
  "el argumento del atributo 'tls_model' debe ser 'global-dynamic', 'local-dynamic', 'initial-exec' o 'local-exec'",
  "la declaración %p especificó un argumento 'tls_model' diferente",
  "el atributo %sq no se aplica a las funciones insertadas",
  "el atributo %sq requiere una función insertada",
  "ambos nombres de archivo de un pragma include_alias deben usar los mismos caracteres delimitadores",
  "comparación entre operandos con signo y sin signo",
  "el atributo %sq se omitió en el tipo sin nombre",
  "el atributo %sq se omitió porque no está acompañado de una definición",
  "la localidad del subproceso no es compatible con una declaración anterior de %nd",
  "no se puede hacer referencia a esta variable local de función de inclusión en este cuerpo lambda porque una expresión lambda de inclusión no permite capturas implícitas",
  "este argumento de atributo contiene paréntesis, corchetes o llaves desemparejados",
  "una llamada a __builtin_fpclassify requiere cinco argumentos enteros seguidos de un argumento de punto flotante",
  "el último argumento de una llamada a __builtin_fpclassify debe tener un tipo de punto flotante real",
  "la alineación no se puede establecer en un valor inferior a la alineación predeterminada",
  "No se permiten atributos en creaciones de instancias explícitas",
  "el atributo %sq no se aplica a una definición",
  "el atributo %sq requiere una definición",
  "Los atributos estándar no pueden aparecer en declaraciones \"friend\" que no sean definiciones",
  "la alineación especificada (%s1) es diferente de la alineación (%s2) especificada en una declaración anterior",
  "el atributo de alineación debe aparecer también en la definición %p",
  "%n no se puede usar en el type-id de la declaración de alias",
  "plantilla de alias",
  "%t no puede ser transparente porque su primer campo tiene un tipo de punto flotante",
  "%t no puede ser transparente porque su primer campo es un campo de bits",
  "la función virtual de una clase 'base_check' invalida una clase base pero le falta el atributo 'override'",
  "atributo 'hiding' especificado en una declaración que no oculta una declaración de clase base",
  "atributo 'hiding' especificado en una declaración a la que se hace referencia mediante la declaración using %p",
  "el atributo 'hiding' es necesario en una declaración (en una clase 'base_check') que oculta %nd",
  "%n no está definido en esta unidad de traducción pero depende de un tipo local",
  "%n no está definido en esta unidad de traducción pero depende de un tipo sin vinculación",
  "falta el atributo %sq en otra unidad de traducción",
  "el atributo %sq está en conflicto con otra unidad de traducción",
  "la opción 'nonstd_gnu_keywords' solo es válida en los modos GNU C y GNU C++",
  "el uso de una variable const en una expresión constante no es un uso estándar en C",
  "no se puede especificar un inicializador para un miembro de matriz flexible con duración de almacenamiento automática",
  null,
  "no se puede usar un tipo de clase 'final' como clase base",
  "las plantillas exportadas ya no están en el lenguaje C++ estándar",
  "no se permite un designador dependiente de una plantilla",
  "el segundo operando de offsetof no puede ser un campo con tipo de referencia",
  "los elementos temporales de larga duración no son compatibles con otras funcionalidades de lenguaje nuevas solicitadas",
  "los literales de cadena de caracteres anchos no se entrecomillarán en los diagnósticos",
  "faltan argumentos para el atributo %sq",
  "las opciones 'c++11' y 'c++11_sfinae' requieren una configuración del compilador diferente",
  "el paquete de parámetros de plantilla no aparece al final de la lista de parámetros",
  "no se permite aquí una declaración de paquete de parámetros",
  "un paquete de parámetros no puede tener un valor predeterminado",
  "C++/CLI solo se puede habilitar en el modo Microsoft C++",
  "'value__' no se puede usar como nombre de una constante de enumerador (es un nombre reservado en este contexto)",
  "se requiere un valor de enumerador explícito en un tipo de enumeración con tipo subyacente booleano",
  null,
  "se hizo referencia al paquete de parámetros %sq, pero no se amplió",
  "la expansión del paquete no usa ningún paquete de argumentos",
  "el paquete %sq no tiene el mismo número de elementos que %sq2",
  null,
  "el atributo vector_size no se permite con un tipo de enumeración",
  "una propiedad no puede ser estática y virtual a la vez",
  "una propiedad indizada no puede ser trivial",
  "esta declaración no puede aparecer en una definición de propiedad",
  "no se puede usar un tipo de función calificada para declarar una función de descriptores de acceso",
  "una función de descriptores de acceso no puede tener un parámetro de puntos suspensivos",
  "ya se declaró un descriptor de acceso 'get' para esta propiedad %p",
  "ya se declaró un descriptor de acceso 'set' para esta propiedad %p",
  "un descriptor de acceso 'get' no puede tener un parámetro",
  "el tipo de valor devuelto del descriptor de acceso 'get' no coincide con el tipo de propiedad",
  "el tipo de valor devuelto del descriptor de acceso 'set' debe ser void",
  "una propiedad no puede declarar una lista vacía de índices",
  "un índice de propiedad no puede tener el tipo void",
  "el tipo de índice no coincide con el parámetro correspondiente en el descriptor de acceso 'set'",
  "el tipo de índice no coincide con el parámetro correspondiente en el descriptor de acceso 'get'",
  "falta el tipo de índice en el descriptor de acceso 'set'",
  "falta el tipo de índice en el descriptor de acceso 'get'",
  "falta el parámetro de valor del descriptor de acceso 'set'",
  "la función de descriptores de acceso tiene demasiados parámetros",
  "el último parámetro del descriptor de acceso 'set' no coincide con el tipo de propiedad",
  "%sq requiere el modo C++/CLI",
  "error en la API de Win32 '%s': %s",
  "#using solamente se puede usar en un ámbito global",
  "metadatos",
  "el nombre de miembro %sq está reservado por %nd",
  "se esperaba '['",
  "el modo de %[C++/CLI] requiere microsoft_version >= 1600",
  "una propiedad indizada predeterminada no puede ser estática",
  "un descriptor de acceso de propiedad no puede ser estático y virtual a la vez",
  "un especificador de visibilidad de nivel superior no puede aparecer en una declaración de tipos anidados",
  "un especificador de visibilidad de nivel superior requiere una definición de tipo",
  "una propiedad trivial no puede tener un tipo de referencia",
  "una propiedad trivial no puede tener un tipo const o volatile",
  "%nd se declaró previamente como un tipo de enumeración distinto",
  "una variable capturada por una lambda no puede tener un tipo de clase %[managed]",
  "no se admite la invalidación de una función virtual con un tipo de valor devuelto covariante en una clase %[managed]",
  "no se permite una matriz de identificadores",
  "no se permite un identificador a matriz",
  "no se permite un identificador a función",
  "no se permite un identificador a void",
  "no se permite de identificador a identificador, puntero o referencia",
  "no se permite una referencia de seguimiento a la función",
  null,
  "un campo no puede ser una referencia de seguimiento",
  "una referencia de seguimiento no se puede combinar con una referencia común de esta forma",
  "una variable con una duración de almacenamiento estática no puede tener un tipo de clase ref",
  "una clase %[managed] no puede ser un tipo sin nombre",
  "una clase %[managed] no puede ser local",
  "%nd se declaró previamente como un tipo de clase distinto",
  "%nd se declaró previamente como un tipo de plantilla de clase distinto",
  "los miembros de datos literal solamente pueden ser miembros de clases %[managed]",
  "se debe inicializar un miembro de datos literal",
  "no se permite un miembro de datos literal de tipo %t",
  "const no tiene efecto en un miembro de datos literal",
  "los miembros de datos initonly solamente pueden ser miembros de clases %[managed]",
  "const no tiene efecto en un miembro de datos initonly",
  "%nd no tiene un descriptor de acceso 'get'",
  "%nd no tiene un descriptor de acceso 'set'",
  "un constructor estático no puede tener parámetros",
  "un constructor estático no puede ser una plantilla de miembro",
  "no se permite un valor L compuesto como operando de salida asm",
  "las propiedades solamente pueden ser miembros de clases %[managed]",
  "no se permite un calificador de tipo en una función miembro de una clase %[managed]",
  "no se permite un puntero común a una clase interface o ref de %[C++/CLI]",
  "no se permite una referencia común a una clase interface o ref de %[C++/CLI]",
  "el especificador de invalidación no denomina una función miembro de clase base",
  "el especificador de invalidación designa un miembro %nd no virtual",
  "la función miembro invalida %nd1 que ya se ha invalidado con %nd2",
  "se permite un especificador de visibilidad como máximo",
  "el tipo %t usado para la definición de delegado no es un tipo de función",
  "los tipos de miembro delegado solamente pueden ser miembros de clases %[managed]",
  "no se permite una referencia de seguimiento a un tipo delegado",
  "no se permite aquí un tipo delegado",
  "la expansión del paquete produjo una lista vacía de expresiones y aquí se requiere una expresión",
  "un evento no puede ser estático y virtual a la vez",
  "los eventos solamente pueden ser miembros de clases %[managed]",
  "esta declaración no puede aparecer en una definición de evento",
  "el tipo de evento debe ser de identificador a delegado",
  "ya se declaró un descriptor de acceso 'add' para este evento %p",
  "ya se declaró un descriptor de acceso 'remove' para este evento %p",
  "ya se declaró un descriptor de acceso 'raise' para este evento %p",
  "un descriptor de acceso de eventos no puede ser estático y virtual a la vez",
  "el tipo de valor devuelto de los descriptores de acceso 'add' y 'remove' debe ser void",
  "falta el parámetro de valor del descriptor de acceso de eventos",
  "la función de descriptores de acceso tiene demasiados parámetros",
  "el tipo %t1 del parámetro del descriptor de acceso de eventos no coincide con el tipo de evento (%t2)",
  "el tipo del descriptor de acceso 'raise' no coincide con el tipo de invocación del delegado del evento",
  "una definición de evento debe incluir los descriptores de acceso 'add' y 'remove'",
  "una función de conversión estática debe aceptar exactamente un argumento",
  "el operador estático debe tener un parámetro de tipo T, T&, T%% o T^ con T = %t",
  "el operando de sizeof... debe ser un nombre de paquete de parámetros",
  "el operador sizeof... solamente se puede usar en una plantilla variádica",
  "aquí no puede aparecer un nombre de evento",
  "no se permite un identificador a una clase no %[managed]",
  "no se permite un identificador para un tipo de enumeración sin ámbito",
  "el atributo 'property' no se permite en una clase %[managed]",
  "un especificador puro ('= 0') seguido de una definición no es estándar",
  "el tipo nullptr %[managed] no se puede usar aquí",
  "el operador '&' no se puede usar para aceptar la dirección de un objeto con un tipo de clase ref",
  "no se permite una matriz de clase %[managed]",
  "una variable con una duración de almacenamiento estática no puede tener un tipo de referencia de seguimiento o identificador",
  "una variable capturada por una lambda no puede ser una referencia de seguimiento o identificador",
  "una matriz de parámetros %[C++/CLI] requiere un identificador a un tipo %[cli::array] unidimensional",
  "no se pudieron importar los metadatos del archivo %sq",
  "el espacio de nombres cli no se puede ampliar",
  "el tipo de elemento de %[cli::array] debe ser un tipo de valor o identificador",
  "número de dimensiones no válido para el tipo %[cli::array]",
  "un elemento cli::interior_ptr/cli::pin_ptr debe señalar a una clase estándar, una clase value, un entero, un identificador o un puntero estándar",
  "%t no puede ser un miembro de clase",
  "no se permite un parámetro de tipo cli::pin_ptr",
  "declaración de finalizador no válida",
  "un finalizador no puede tener parámetros",
  "no se permite un calificador de tipo en un finalizador",
  "un tipo de valor devuelto no se puede especificar en un finalizador",
  "una declaración using no puede asignar nombre a un finalizador",
  "el nombre de finalizador debe estar completo",
  "el calificador del nombre de finalizador %t1 no coincide con el tipo %t2",
  "%n no se puede usar para denominar un finalizador (se requiere un nombre de tipo)",
  "nombre de finalizador no válido para el tipo %t",
  "la referencia al finalizador es ambigua; se podría usar tanto %n1 como %n2",
  "un finalizador solamente puede ser miembro de una clase ref",
  null,
  "el tipo usado como nombre de finalizador no coincide con el tipo %t",
  "no existe un finalizador para este tipo",
  "el operador '%%' solamente se puede usar en un objeto con un tipo de clase %[managed]",
  "no se permite un puntero, identificador o referencia a un elemento cli::interior_ptr",
  "no se permite un puntero, identificador o referencia a un elemento cli::pin_ptr",
  "no se permite un puntero o referencia a una matriz de %[C++/CLI]",
  "no se permite aquí un tipo de matriz de %[C++/CLI]",
  "una clase ref de %[C++/CLI] solamente puede derivarse de otra clase ref o de clases interface",
  "una clase value de %[C++/CLI] solamente puede derivarse de clases interface",
  "una clase interface de %[C++/CLI] solamente puede derivarse de clases interface",
  "una clase ref puede tener como máximo una clase base ref directa (%t ya es este tipo de base)",
  "una clase estándar no se puede derivar de una clase %[managed]",
  "una clase %[managed] no puede tener una base virtual",
  "una clase %[managed] no puede tener una base 'private' o 'protected'",
  "el modificador 'override' requiere una declaración de función virtual con una palabra clave 'virtual' explícita",
  "el modificador 'abstract' requiere una declaración de función virtual con una palabra clave 'virtual' explícita",
  "el modificador 'sealed' requiere una declaración de función virtual con una palabra clave 'virtual' explícita",
  "un especificador de invalidación con nombre requiere una declaración de función virtual con la palabra clave 'virtual' explícita",
  "no se permite el tipo de valor devuelto cli::pin_ptr",
  "el atributo %sq se aplica solamente en el modo %[C++/CLI]",
  "una referencia simple (que no sea de seguimiento) no se puede enlazar a una entidad en el montón administrado",
  "ensamblado portable",
  "'%s' no se cargó de los ensamblados predeterminados",
  "la sintaxis de inicialización de la lista es una funcionalidad de C++11",
  "el operando de sizeof no puede ser un tipo de clase ref o interface",
  "número de subíndices no válido para este tipo de %[cli::array]",
  "un puntero a miembro no es válido para una clase %[managed]",
  "la función miembro virtual privada de clase %[managed] no es 'sealed'",
  "no se permite un modificador en un destructor",
  "no se permite un modificador en un finalizador",
  "'virtual' no tiene efecto en un destructor de una clase %[managed]",
  "se requiere 'new' u 'override' porque esta declaración coincide con %nd",
  "se requiere 'new' o 'virtual' porque esta declaración coincide con %nd",
  "'new' u 'override' no son válidos aquí porque el elemento %nd correspondiente es miembro de una interfaz",
  "modificador 'new' sin un miembro de clase base ref correspondiente",
  "se invalidó %nd con acceso reducido",
  "una referencia de tipo %t1 no se puede inicializar con un valor de tipo %t2",
  "un constructor de copia no se puede declarar en una clase value",
  "un constructor predeterminado no se puede declarar en una clase value",
  "un destructor no se puede declarar en una clase value",
  "un operador de asignaciones no se puede declarar en una clase value",
  "una clase no value %t no puede coincidir con el tipo de un miembro de una clase value",
  "la opción 'cppcli' requiere una configuración del compilador diferente",
  "no se permiten especificaciones de excepción en las funciones miembro de clases %[managed]",
  "una clase %[managed] no puede incluir una declaración friend",
  null,
  null,
  "no se permite una definición de clase local en una función miembro de una clase %[managed]",
  "no se permite una lambda local en una función miembro de una clase %[managed]",
  "una función miembro de un tipo de clase interface de %[C++/CLI] no puede tener una definición",
  "una definición de propiedad debe incluir al menos un descriptor de acceso ('get' o 'set')",
  "la propiedad indizada predeterminada entra en conflicto con %nd",
  "%n1 no se puede usar porque sigue a un paquete de parámetros y no se puede deducir de los parámetros de %n2",
  "esta expansión del paquete produjo más de una expresión y aquí se requiere una sola expresión",
  "el tipo debe corresponder a System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64 o System::UInt64",
  "llamada de un objeto de un tipo de identificador sin ninguna función de conversión u operator() adecuados para el tipo de puntero a función",
  "una declaración de paquete de parámetros sin nombre no puede incluirse entre paréntesis",
  "las plantillas variádicas solo se pueden habilitar al compilar C++",
  "la definición de propiedad entra en conflicto con %nd",
  "propiedad sobrecargada",
  "propiedad",
  "un parámetro genérico no puede tener un valor predeterminado",
  "un elemento genérico solamente puede tener parámetros de tipo",
  "para poder usarlo con instrucciones 'for each', el tipo %t debe proporcionar la función miembro no estática %sq",
  "'for each' no puede usar el miembro %n porque es estático",
  "en esta instrucción 'for each', no se puede llamar a ninguna instancia de %no con una lista de argumentos vacía",
  "'for each' no puede usar la función miembro 'MoveNext' porque el tipo de valor devuelto no es válido",
  "una instrucción 'for each' no puede funcionar en una expresión de tipo %t",
  "para poder usarlo con instrucciones 'for each', el tipo %t debe proporcionar una propiedad %sq no indizada",
  null,
  "en esta instrucción 'for each', %t2 no es un enumerador válido (devuelto por 'GetEnumerator' de %t1)",
  "se esperaba 'in'",
  "la clase %t no tiene ningún operador de asignaciones adecuado (tras la síntesis del operador)",
  "%sq no es un parámetro genérico",
  "%sq no es un parámetro genérico de la lista de parámetros genéricos más interna",
  "restricción genérica no válida",
  "uso no válido del miembro de evento (solo se admiten la suscripción, cancelación de suscripción e invocación)",
  "la invocación de un evento sin un descriptor de acceso 'raise' no es válida",
  "solamente '+=' y '-=' son válidos para los eventos",
  "no se permite el elemento typeid de un tipo %[managed]",
  "no se permite el elemento typeid de un tipo de puntero %[managed]",
  "el nombre seguido de '::typeid' debe ser un nombre de tipo",
  "un miembro %sq de este tipo está reservado dentro de una clase %[managed]. ¿Se trata de un destructor?",
  "un miembro %sq de este tipo está reservado dentro de una clase %[managed]. ¿Se trata de un finalizador?",
  "Falta %[System]::IDisposable::Dispose o no es válido",
  "Falta %[System]::Object::Finalize o no es válido",
  "%n no invalida %[System]::Object::Finalize",
  "el operando de un dynamic_cast de identificador debe ser un identificador a un tipo de clase completa",
  "el operando de un dynamic_cast de referencia de seguimiento debe ser un valor L de un tipo de clase completa",
  "el tipo incluido en dynamic_cast para un tipo de referencia de seguimiento o identificador debe hacer referencia a una clase completa",
  "un puntero interno no se puede convertir en puntero nativo",
  "los operadores de conversión explícitos solo se pueden declarar en tipos de clase ref y value",
  "los operadores de conversión explícitos no pueden ser virtuales",
  "la expresión debe tener un tipo aritmético o de enumeración sin ámbito",
  "la expresión debe tener un tipo aritmético, de enumeración sin ámbito o de puntero",
  "la expresión debe tener un tipo entero o de enumeración sin ámbito",
  "la expresión debe tener un tipo entero, de enumeración sin ámbito o de punto fijo",
  "un operador binario integrado aplicado a una enumeración con ámbito requiere dos operandos del mismo tipo",
  "%[gcnew] no puede asignar una entidad de tipo %t",
  "no se puede usar sintaxis de colocación con %[gcnew]",
  "new solo se puede usar con tipos de valor simples",
  "new no se puede usar en una clase %[managed] (debe usarse %[gcnew] en su lugar)",
  "new no se puede usar en un tipo de identificador",
  "el elemento %[gcnew] de una matriz de %[C++/CLI] debe tener un inicializador nuevo o un inicializador de matriz",
  "un inicializador de matriz solo se puede usar para inicializar un tipo de matriz de %[C++/CLI]",
  "%[gcnew] no admite auto",
  "hay demasiados límites de matriz",
  "no hay suficientes límites de matriz",
  "no hay suficientes argumentos para %nf",
  "hay demasiados argumentos para %nf",
  "clase genérica",
  "ninguna declaración de %nf acepta el número de argumentos genéricos proporcionado",
  "inicializador de delegado no válido: debe ser una función",
  "inicializador de delegado no válido: más de una función coincide con el tipo delegado",
  "inicializador de delegado no válido: la función no coincide con el tipo delegado",
  "inicializador de delegado no válido: se requiere un objeto además de una función",
  "inicializador de delegado no válido: la función no es miembro de una clase %[managed]",
  "inicializador de delegado no válido: el objeto no es necesario para la función especificada",
  "inicializador de delegado no válido: el tipo del objeto es %t1, pero se espera el tipo %t2",
  "no se permite la aceptación de la dirección de una función miembro de una clase %[managed]",
  "inicializador de delegado no válido: se esperaba '(<función-dirección>)' u '(<objeto-identificador>, <miembro-dirección>)'",
  "error de la clase al implementar el miembro de interfaz %nd",
  "%[gcnew] no se puede usar para asignar una matriz nativa",
  "una clase interface de %[C++/CLI] no puede declarar un operador de asignaciones",
  "una clase interface de %[C++/CLI] no puede estar sellada",
  null,
  "una declaración de destructor o finalizador no puede incluir un especificador de invalidación con nombre",
  "un especificador de invalidación no puede designar un destructor o finalizador",
  "un especificador de invalidación con nombre solamente se permite en una clase %[managed]",
  "ningún miembro designado por el especificador de invalidación con nombre coincide con el tipo de este miembro",
  "una declaración de constructor estático no puede incluir un especificador de invalidación con nombre",
  "un tipo de enumeración con ámbito debe tener un nombre",
  "no se permite la transferencia de control a un bloque finally",
  "No se permite una instrucción \"return\" en un bloque finally",
  "el bloque try requiere al menos un controlador o una cláusula finally",
  "un objeto %[managed] debe iniciarse por identificador",
  "un objeto %[managed] debe detectarse por identificador",
  "una instrucción break no se puede usar en un bloque finally",
  "una instrucción continue no se puede usar en un bloque finally",
  "no se puede usar offsetof integrado si los subíndices están sobrecargados",
  "restricción duplicada",
  "más de una restricción de clase: %t1 y %t2",
  "más de una cláusula de restricciones para %n",
  "los miembros de datos estáticos initonly deben tener un inicializador o inicializarse en un constructor estático",
  "Los atributos de GNU no tienen ningún efecto en una nueva declaración de plantilla",
  "Los atributos de GNU no tienen ningún efecto en una nueva declaración de plantilla (en su lugar se aplican los atributos de la declaración %p original)",
  "una matriz de parámetros %[C++/CLI] debe ser el último parámetro",
  "una función con una matriz de parámetros %[C++/CLI] no puede tener argumentos predeterminados",
  "una matriz de parámetros %[C++/CLI] no puede ir seguida de un parámetro de puntos suspensivos",
  "no se permite una matriz de parámetros %[C++/CLI] en una lista de parámetros de función del operador",
  "__inline y __forceinline no se permiten aquí",
  "un miembro de datos no puede tener un tipo de clase interface de %[C++/CLI]",
  "una variable no puede tener un tipo de clase interface de %[C++/CLI]",
  "un parámetro no puede tener un tipo de clase interface de %[C++/CLI]",
  "un tipo de valor devuelto de función no puede ser un tipo de clase interface de %[C++/CLI]",
  "no se permite una matriz de tipo de parámetro genérico",
  "no se permite un puntero, identificador o referencia a un tipo de parámetro genérico",
  "un campo initonly no puede tener un tipo de clase ref",
  "una referencia no se puede enlazar a un campo initonly",
  "no se permite la aceptación de la dirección de un campo initonly",
  "un campo initonly solo se puede modificar mediante el constructor de instancias de su clase contenedora",
  "un campo initonly estático solo se puede modificar mediante el constructor estático de su clase contenedora",
  "la función miembro se invocará en una copia del campo initonly",
  "la expresión debe tener un tipo de identificador o puntero, pero tiene el tipo %t",
  "para copiar un valor L aquí, se usa un constructor de movimiento o de asignación de movimiento, lo cual puede destruir el objeto de origen",
  "la selección de miembros en una entidad genérica de %[C++/CLI] debe usar la sintaxis '->', no '.'",
  "un tipo de clase ref no se puede derivar de %t",
  "una clase genérica debe ser %[managed] (es decir, una clase ref, value o interface)",
  "una clase sellada no se puede usar como restricción",
  "el tipo incluido en dynamic_cast no puede ser un tipo genérico que pueda ser un tipo de valor",
  "un nombre de carácter universal debe designar un punto de código válido",
  "las restricciones genéricas no coinciden con las de %nd",
  "__underlying_type solo se aplica a los tipos de enumeración",
  "se esperaba solo una expresión de operando para esta conversión",
  "el carácter Unicode con valor hexadecimal %s no se puede representar en la página de códigos predeterminada del sistema",
  "conversión no estándar de un puntero a miembro enlazado a un puntero a función",
  "el especificador de acceso %s1 está desusado; use %s2 en su lugar",
  "no se permite una función de descriptores de acceso estáticos en una definición de propiedad o evento no estático",
  "%t tiene una restricción tanto de clase value como de clase ref",
  "%t1 y %t2 implican restricciones de tipo naked circulares",
  "%t no es una restricción de un tipo válido",
  "no se usa el archivo de encabezado precompilado %sq (porque está incompleto)",
  "%t no es un argumento genérico válido",
  "atributo assembly_info aplicado a un tipo no válido",
  "%t1 no cumple la restricción de clase ref del parámetro genérico %t2",
  "%t1 no cumple la restricción de clase value del parámetro genérico %t2",
  "%t1 no cumple la restricción %[gcnew] del parámetro genérico %t2 porque es abstracto",
  "%t1 no cumple la restricción %[gcnew] del parámetro genérico %t2 porque no tiene un constructor predeterminado público",
  "el parámetro genérico %t1 no cumple la restricción %[gcnew] del parámetro genérico %t2 porque no tiene la restricción %[gcnew]",
  "%t1 no cumple la restricción de tipo %t3 del parámetro genérico %t2",
  "la restricción del parámetro genérico %t difiere de la declaración anterior (%p)",
  "un miembro de una clase %[managed] no puede ser una matriz estándar",
  "un miembro de una clase no %[managed] no puede ser un identificador",
  "un miembro de una clase no %[managed] no puede ser una referencia de seguimiento",
  "reinterpret_cast de identificador no seguro",
  "un argumento de plantilla no puede hacer referencia a un parámetro de tipo genérico",
  "no se permite una lista de expresiones en esta operación de subíndice (use paréntesis para un operador de coma de nivel superior)",
  "la expresión debe tener un tipo de puntero a objeto o de identificador a tipo de matriz %[C++/CLI], pero tiene el tipo %t",
  "atributo no reconocido",
  "un miembro de una clase %[managed] no puede ser de un tipo de clase no %[managed]",
  "un miembro de una clase no %[managed] no puede tener un tipo de clase ref o interface",
  "en ",
  "un delegado no se puede declarar como una plantilla",
  "un genérico no se puede especializar de forma explícita",
  "un genérico no se puede declarar en una plantilla de clase",
  "una plantilla no se puede declarar en una clase genérica",
  "un campo literal no se puede declarar como 'static'",
  "'long float' es una extensión no estándar, use 'double' en su lugar",
  "una clase estándar no se puede anidar en una clase %[managed]",
  "__clrcall solo es válido en modo C++/CLI",
  "__clrcall no se permite en una función con un parámetro de puntos suspensivos",
  "%sq no se permite aquí",
  "no se puede usar un evento o propiedad trivial para invalidar %nd",
  "se esperaba un nombre de variable de iterador",
  "el tipo de iterador de esta instrucción 'for each' es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "el tipo de iterador de esta instrucción 'for each' es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "el tipo de iterador de esta instrucción 'for each' es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "el atributo de empaquetado del tipo primario se omite para este campo de tipo de clase %t que no tiene un diseño estándar",
  "no se ha implementado %nd porque esta declaración no es pública y no tiene un especificador de invalidación con nombre",
  "en esta declaración falta el atributo gnu_inline especificado en la declaración anterior %p",
  "una función de miembro de una clase %[managed] no puede tener un parámetro de puntos suspensivos",
  "el elemento %n declarado anteriormente no es válido como iterador de una instrucción 'for each'",
  "se ha omitido la convención de llamada porque el tipo de función implica un parámetro genérico; se usa __clrcall en su lugar",
  "un tipo de función que implique un parámetro genérico no puede tener un parámetro de puntos suspensivos",
  "se requiere 'virtual' para invalidar el elemento %nd correspondiente",
  "se requiere 'virtual' para implementar el elemento %nd correspondiente",
  "un miembro de datos initonly no puede ser volátil",
  "un miembro %sq de este tipo está reservado en una clase %[managed]; los operadores %[C++/CLI] se deben declarar con la palabra clave 'operator'",
  "una referencia de seguimiento a un elemento no constante no se puede enlazar a una constante",
  "aquí se omiten los atributos porque no se aplican a una entidad declarada",
  "no se permite una referencia de seguimiento a %[System]::String",
  "uso no válido de una clase genérica %t con restricciones pendientes (probablemente debido a un archivo de metadatos no válido)",
  "una cláusula de restricción pendiente se permite únicamente para declaraciones de clase genérica (pero no definiciones de clase genérica)",
  "no se permite aquí una lista de inicializadores vacía",
  "una plantilla no se puede declarar en una clase %[managed]",
  "no se permite aquí una declaración genérica",
  "los tipos de interfaz no pueden tener elementos genéricos de miembros",
  "el carácter Unicode que no es Latino-1 se truncó a un byte de nivel bajo",
  "para poder usarlo con instrucciones 'for' basadas en intervalo, el tipo %t debe proporcionar la función %sq",
  "el tipo de iterador de esta instrucción 'for' basada en intervalo es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "el tipo de iterador de esta instrucción 'for' basada en intervalo es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "el tipo de iterador de esta instrucción 'for' basada en intervalo es %t, que no es un tipo de puntero ni un tipo de clase de iterador",
  "una instrucción 'for' basada en intervalo no puede funcionar en una matriz de tamaño desconocido o en el tipo %t incompleto",
  "los tipos de valor devuelto para las funciones 'begin' y 'end' usadas en una instrucción 'for' basada en intervalo deben ser iguales (el tipo de valor devuelto de 'begin' es %t1 y el de 'end' es %t2)",
  "no se puede obtener acceso a %nfd, que se requiere para destruir un objeto temporal eliminado",
  "en esta instrucción 'for' basada en intervalo, ninguna instancia de %no coincide con la lista de argumentos",
  "esta instrucción 'for' basada en intervalo requiere una función %sq adecuada y no se encontró ninguna",
  "esta instrucción 'for each' requiere una función %sq adecuada y no se encontró ninguna",
  "%t tiene una representación de metadatos que no se puede representar con %[C++/CLI]",
  "se esperaba '...'",
  "el elemento %t de la lista __implements no es una interfaz",
  "una lista __implements debe preceder a las declaraciones de función virtual",
  "el elemento %t especificó '__implements...' en su lista de bases, pero falta una lista __implements coincidente",
  "se debe usar el resultado de desreferenciar un identificador a un tipo de clase ref o interface",
  null,
  "se esperaba un elemento ')'; se ha omitido pragma",
  "una declaración using o de acceso no puede aparecer en una clase administrada",
  "Nota: se podía haber llamado a %nd, pero no se tuvo en cuenta porque es inaccesible",
  "una función miembro abstracta de una clase administrada de C++/CLI no puede tener una definición",
  "la declaración de este elemento 'operator*' como unario puede cambiar el significado de desreferenciar un identificador (usar operadores de miembro estático para indicar explícitamente los tipos aplicables)",
  "administrado",
  "C++/CX",
  "C++/CLI",
  "Asignación de C++/CX",
  "default",
  "asignación de cli",
  "cli::array",
  "Platform::Array",
  "Matriz de C++/CLI",
  "Matriz de C++/CX",
  "Sistema",
  "Plataforma",
  "gcnew",
  "ref new",
  "una clase interface no puede contener un miembro de datos no estático",
  "el elemento system_header de #pragma GCC no se puede usar en el archivo de código fuente principal",
  "%n es demasiado grande para insertarla",
  " (declarado implícitamente)",
  "la opción para controlar las operaciones de movimiento solamente se puede usar cuando se compila en C++",
  "las operaciones de movimiento no se pueden generar cuando los constructores rvalue son constructores de copia",
  "la opción para controlar las operaciones de movimiento no se puede usar cuando las referencias rvalue están deshabilitadas",
  "'final' no se puede usar para las clases administradas (use 'sealed' en su lugar)",
  "no se permite una conversión a la clase de interfaz CLI %t -- ¿pretendía convertir a controlador?",
  "no se puede crear un objeto de una clase de interfaz CLI",
  "esta declaración oculta la declaración no estándar de %nd debido a que los tipos subyacentes son incompatibles",
  "el resultado de la comparación de puntero es constante, pues el operando nunca puede ser nulo",
  "no se puede inicializar el valor de un objeto del tipo incompleto %t",
  "no se puede inicializar el valor de una referencia",
  "se esperaba '(' o' {'",
  "la inicialización de lista de copia no puede usar un constructor marcado como 'explicit'",
  "no se permite un puntero a miembro de tipo void",
  "no se permite un puntero a miembro de tipo referencia",
  "no se permite un puntero a miembro de tipo controlador",
  "No se permite aquí una lista entre llaves",
  "no se permite un miembro de operador->* en una clase administrada",
  "los metadatos del ensamblado hacen referencia a un ensamblado no existente",
  "el atributo %sq2 entra en conflicto con el atributo anterior %sq1",
  "%nd se declaró anteriormente con un tipo base distinto",
  "no se pueden usar aquí 'enum class' ni 'enum struct' (use 'enum' en su lugar)",
  "solo se permite un nivel de llaves en un inicializador para un objeto de tipo %t",
  "no se puede usar %nd como nombre de tipo de enumeración",
  null,
  "un inicializador entre llaves no se puede usar con 'new auto'",
  "la definición de std::initializer_list no contiene el constructor esperado",
  "la declaración oculta %nd",
  "lista de parámetros de plantilla no válida para std::initializer_list (debe ser un parámetro de tipo ordinario sin valor predeterminado)",
  "no se puede pasar una lista entre llaves para un parámetro de puntos suspensivos",
  "es necesario #include <lista_de_inicializadores> antes de usar std::initializer_list, incluido un uso implícito",
  "la palabra clave 'inline' no se puede usar en una declaración de alias de espacio de nombres",
  "la declaración de %n anterior no se declaró como inline",
  "%n se declaró anteriormente como inline",
  "el primer argumento debe ser una constante de tipo entero",
  "un designador no se puede usar con un tipo %t no agregado",
  "Un designador de un miembro de unión anónima solo puede aparecer entre las llaves correspondientes a esa unión anónima",
  "las etiquetas de prototipo de función solo se pueden habilitar cuando se compila C",
  "no se pueden omitir las llaves para este inicializador de subobjeto",
  "conversión de restricción no válida de %t1 a %t2",
  "conversión de restricción no válida de %t1 a %t2: el valor constante no se ajusta al tipo de destino",
  "no se permite la conversión al tipo de matriz incompleto %t",
  "conversión de restricción no válida de %t1 a %t2: el valor constante no se puede representar exactamente en el tipo de destino",
  "un inicializador entre paréntesis para una entidad que no es una clase debe ser una expresión, no una lista entre llaves",
  "una lista entre llaves no proporciona un tipo devuelto para este lambda",
  "la especificación de excepción declarada es incompatible con la que se ha generado",
  "los tipos de enumeración con ámbito son una funcionalidad de C++11",
  "un tipo de función no se puede inicializar con un valor",
  "no se permite la inicialización con lista de un tipo de objeto %t porque el tipo está incompleto",
  "std::initializer_list tiene un destructor y se supone que no debe tenerlo; la biblioteca no está bien configurada",
  "los tipos base de enumeración explícita son una funcionalidad de C++11",
  "esta expresión constante tiene el tipo %t1 en lugar del tipo %t2 requerido",
  "es probable que un elemento 'new' de un objeto std::initializer_list no funcione según lo esperado porque la matriz subyacente se destruirá al final de la expresión completa",
  "En archivo de macro predefinido",
  null,
  "'defined' es siempre false en una expansión de macro en modo Microsoft",
  "%t no puede ser el tipo de elemento de una lista de inicializadores porque no es un tipo de objeto completo",
  "delimitadores no coincidentes en la expresión de argumento predeterminada",
  "conversión no estándar de un puntero a miembro a un puntero de función",
  "las especificaciones de excepción dinámica están desusadas",
  "%n no se puede especializar parcialmente en el ámbito actual",
  "%nd se declaró previamente como constexpr",
  "%nd no se declaró previamente como constexpr",
  "falta el inicializador para la variable constexpr",
  "'constexpr' no es válido aquí",
  "Una función constexpr debe contener exactamente una instrucción \"return\"",
  "la instrucción no puede aparecer en una función constexpr",
  "la instrucción no puede aparecer en un constructor constexpr",
  "una función no puede ser constexpr y virtual a la vez en este modo",
  "una función constexpr no puede tener un tipo de valor devuelto %t no literal",
  "una función constexpr no puede tener un parámetro de tipo %t no literal",
  "el uso no secuencial de %n en la expresión puede producir resultados no definidos",
  "el tercer argumento opcional de una llamada a __builtin_assumed_aligned debe tener un tipo entero",
  "un destructor no puede ser constexpr",
  "la dirección proporcionada para mmap debe estar alineada en el límite de página: %s",
  "el cuerpo de un constructor constexpr no puede ser un bloque try de función",
  "constexpr %nf no proporciona ningún inicializador para:",
  "%n",
  "la llamada al constructor predeterminado de %t no genera un valor constante",
  "el constructor predeterminado de %t no es constexpr",
  "una variable constexpr debe tener un tipo literal o un tipo de referencia",
  "un constructor para una clase con bases virtuales no puede ser constexpr",
  "la llamada a función debe tener un valor constante en una expresión constante",
  "la función 'main' no se puede declarar como constexpr",
  null,
  "una definición de tipo de enumeración o clase no puede aparecer en el cuerpo de un constructor o una función constexpr",
  "aquí solo se permiten atributos de tipo GNU",
  "uso no estándar de 'auto' para deducir el tipo de un inicializador y para anunciar un tipo de valor devuelto final",
  "la declaración de una lista de parámetros void con un tipo void calificado no es estándar",
  "se ha omitido el calificador en esta declaración local",
  "esta expresión constante tiene el tipo %t en lugar del tipo %s requerido",
  "La creación de una instancia de __bases o __direct_bases requiere un tipo de clase",
  "el argumento de __bases y __direct_bases debe ser un parámetro de plantilla de tipo",
  "%s solamente se puede utilizar en contextos de plantilla",
  "el valor devuelto de la función constexpr no es constante",
  "el constructor constexpr llama a un elemento %n que no es constexpr",
  "el constructor no puede ser constexpr porque el inicializador de %n no es una expresión constante",
  "inicializador no constante para un constructor constexpr",
  "el constructor predeterminado generado para %t no se puede usar en un inicializador para su propio miembro de datos",
  "La creación de una instancia del inicializador de %n depende de su propio valor",
  "el constructor predeterminado al que se le asigna un valor predeterminado no puede ser constexpr porque el constructor predeterminado correspondiente declarado implícitamente no sería constexpr",
  null,
  "número binario no válido",
  "una unión puede tener como máximo un inicializador de campo; %nd también tiene un inicializador",
  null,
  "un constructor constexpr de una unión debe inicializar uno de sus campos",
  "un constructor constexpr no puede inicializar una unión anónima (definida como %p)",
  "una declaración de miembro de datos estático constexpr requiere un inicializador in-class",
  "las opciones de profundidad o recuento máximo de constexpr solo se pueden usar al compilar C++",
  "expresión no plegada a una constante debido a una complejidad excesiva de la llamada a la función constexpr",
  "las opciones de unión sin restricciones solo se pueden usar al compilar C++",
  "el constructor constexpr debe inicializar la clase base directa %t",
  "es probable que la creación de un objeto std::initializer_list en un inicializador de campo no funcione según lo esperado porque la matriz subyacente se destruirá al final de la expresión completa",
  "'this' no se puede usar en una expresión constante",
  null,
  "\"constexpr\" no se permite en una directiva de creación de una instancia explícita",
  "no se puede determinar la especificación de excepción del constructor predeterminado debido a una dependencia circular",
  "la unión anónima definió %p",
  "este constructor usa el inicializador de %nd, lo que daría como resultado una recursividad no enlazada",
  null,
  "no se permite un inicializador en una declaración local de una variable extern",
  "no se permite un inicializador en una declaración local de una variable de registro con nombre",
  null,
  "las uniones sin restricciones no se pueden habilitar en el modo Microsoft",
  "el constructor delega en sí mismo directa o indirectamente",
  "un constructor de delegación no puede tener otros inicializadores de miembro",
  "no se permite aquí un calificador de referencia",
  "la sobrecarga de dos funciones miembro con los mismos tipos de parámetro requiere que ambas o ninguna tengan calificadores de referencia",
  "carácter no válido en el delimitador de cadena sin formato",
  "no se encontró el paréntesis de cierre del delimitador de cadena sin formato en los 16 caracteres; se omitió el indicador de cadena sin formato",
  "no se encontró el delimitador de cierre para la cadena sin formato",
  "un paquete de parámetros debe ser el argumento de plantilla final en una especialización parcial",
  "una función de puntero a miembro con el tipo %t solo se puede usar con un objeto de valor L",
  "una función de puntero a miembro con el tipo %t solo se puede usar con un objeto de valor R",
  "el parámetro de este constructor de copia con valor predeterminado no puede ser const porque un parámetro de constructor de copia base o miembro no es de tipo const",
  "el parámetro de este operador de asignación con valor predeterminado no puede ser const porque un parámetro de asignación de copias base o miembro no es de tipo const",
  "una unión anónima debe contener al menos un miembro de datos no estático",
  "la opción \"delegating_constructors\" requiere una configuración de compilador diferente",
  "se omiten las reducciones en la alineación",
  "el operando de un const_cast para un tipo de referencia rvalue no puede ser un prvalue sin clase",
  "la expresión debe ser un lvalue o xvalue",
  "la conversión puede cambiar el valor",
  "la conversión de un literal de cadena a 'char *' está en desuso",
  "la conversión de un literal de cadena a puntero a carácter (no constante) está en desuso",
  "\"override\" y \"final\" son características de C++11",
  "las referencias a rvalue no se permiten como tipos de especificación de excepción",
  "el atributo %sq no se aplica a parámetros de controlador",
  "el atributo %sq requiere un parámetro de controlador",
  "alignas no se aplica aquí",
  "el operador 'alignof' estándar no acepta un argumento de expresión (use un tipo es su lugar)",
  "calificador no válido para %t (no se permite aquí una clase derivada)",
  "el atributo \"always_inline\" se omite en funciones no insertadas",
  "los constructores de herencia deben heredarse de una clase base directa",
  null,
  "se esperaba una etiqueta",
  "se esperaba un número de operando después de \"%%l\"",
  "el número de operando de \"%%l\" no hace referencia a un argumento de etiqueta válido",
  "las cadenas de tipo ancho no son válidas en una instrucción \"asm\"",
  "el atributo no es estándar",
  "no es una clase base de la clase %t",
  "carácter no identificador en sufijo literal definido por el usuario",
  "un literal multicarácter no puede ser parte de un literal definido por el usuario",
  "un sufijo literal definido por el usuario no coincide con el %sq anterior",
  "el nombre del operador literal no es válido",
  "no se encontró el operador literal definido por el usuario",
  "los operadores literales o la plantilla de operador literal son ambiguos:",
  "un operador literal no puede ser miembro de una clase",
  "un operador literal no puede tener una vinculación de nombre \"C\"",
  "se esperaba al menos un parámetro para un operador literal",
  "hay demasiados parámetros para este operador literal",
  "el tipo de parámetro %t no es válido para el operador literal",
  "Tipo de parámetro entero (%t) no válido para el operador literal; se esperaba un tipo de carácter o unsigned long long",
  "el tipo de parámetro de punto flotante (%t) no es válido para el operador literal; se esperaba long double",
  "el tipo del primer parámetro (%t) no es válido; no se permiten punteros a tipos no constantes",
  "el tipo del segundo parámetro (%t) no es válido para el operador literal; debe ser size_t",
  "Tipo de parámetro de puntero (%t) no válido para el operador literal; se esperaba un puntero a un tipo de carácter",
  "un operador literal no puede tener un parámetro de puntos suspensivos",
  "una plantilla de operador literal no puede tener ningún parámetro",
  "una plantilla de operador literal debe tener una lista de parámetros de plantilla equivalente a \"<char ...>\"",
  "la clase de almacenamiento local de subprocesos no es válida aquí",
  "la declaración de subproceso local sigue a la declaración de no subproceso local (se declaró %p)",
  "la declaración de no subproceso local sigue a la declaración de subproceso local (se declaró %p)",
  "un operador literal no puede tener argumentos predeterminados",
  "el atributo se omite para las variables de subproceso locales",
  "un sufijo literal proporcionado por el usuario debe comenzar por \"_\"",
  "las referencias rvalue son una característica de C++11",
  "las expresiones lambda son una característica de C++11",
  "la sintaxis de atributo estándar es una característica de C++11",
  "los constructores de delegación son una característica de C++11",
  "los constructores de herencia son una característica de C++11",
  "los inicializadores de campos son una característica de C++11",
  "las funciones eliminadas son una característica de C++11",
  "las funciones con valores predeterminados son una característica de C++11",
  "no se permite una clase de almacenamiento en una especialización explícita",
  null,
  "Una enumeración sin ámbito debe ser opaca para que pueda especializarse",
  "una declaración de plantilla de enumeración debe hacer referencia a un miembro anteriormente declarado de una plantilla de clase",
  "se esperaba un operando vectorial",
  "los operandos de origen de intercambio tienen los tipos incompatibles %t1 y %t2",
  "la máscara de ofuscación (tipo %t) no es un vector de enteros",
  "la máscara de ofuscación (tipo %t1) tiene una longitud diferente a la del operando de origen (tipo %t2)",
  "la inicialización estática con un valor de dirección exige un destino del mismo tamaño que la dirección",
  "el argumento para una macro de prueba de funcionalidades debe ser un identificador simple",
  "__has_include_next no se puede usar en el archivo de origen principal",
  "nombre de archivo absoluto usado en __has_include_next",
  "el atributo %sq tiene que aplicarse a un tipo de función",
  null,
  "_Noreturn no se permite aquí",
  "se esperaba un operando de tipo de punto flotante real (no %t)",
  "__builtin_complex exige operandos de tipos compatibles (a diferencia de %t1 y %t2)",
  "ya apareció una asociación predeterminada en esta selección _Generic",
  "aquí no se permite un tipo con una matriz de longitud variable",
  "tipo de asociación duplicado (%t) en la selección _Generic",
  "ninguna asociación coincide con el tipo de selector %t",
  "el tipo de %n (%t) no es compatible con un tipo de resolución ifunc",
  "una función no puede tener atributos ifunc y alias a la vez",
  "una función no puede tener atributos ifunc y weak a la vez",
  "la llamada exige un operando literal de cadena",
  "declaración de constructor de herencia duplicada (antes %p)",
  "'decltype(auto)' debe ser un marcador de posición del tipo completo de la variable (no de un componente de ese tipo)",
  "decltype(auto) no se permite aquí",
  "no se puede deducir \"decltype(auto)\" (inicializador necesario)",
  "no se puede deducir el tipo \"decltype(auto)\"",
  "una declaración de subproceso local de ámbito de bloque tiene que incluir static o extern",
  "el tipo devuelto deducido %t1 entra en conflicto con el tipo %t2 deducido anteriormente",
  "no se puede deducir el tipo devuelto de %nd; no se ha definido",
  "una función virtual no puede tener un tipo devuelto deducido",
  "%n se tratará como una palabra clave contextual a partir de este punto",
  "el espacio de nombres global no tiene miembro real %sq",
  "comparación entre dos tipos de enumeración distintos (%t1 y %t2)",
  "atributo de destino no reconocido",
  "falta la función de destino \"default\"",
  "solo se puede especificar un destino arch=",
  "una clase genérica no puede ser un atributo personalizado",
  "destino de atributo %sq no válido",
  "atributo ambiguo: se podría usar tanto %t1 como %t2",
  "un argumento de atributo con nombre solo puede hacer referencia a un campo de lectura o escritura no estático público o una propiedad escalar",
  "un argumento de atributo con nombre solo puede hacer referencia a un campo no estático o una propiedad escalar de un tipo de parámetro de atributo",
  "argumento de atributo no válido: la expresión debe ser una constante de un tipo de parámetro de atributo",
  "un argumento de atributo no puede usar parámetros de tipo genérico",
  "%t solo se puede usar como un atributo independiente",
  "el destino de atributo 'field' no se puede usar en una propiedad o evento no trivial",
  "destino de atributo no válido para un atributo independiente",
  "destino de atributo no válido para este contexto",
  "el atributo %t no se puede usar aquí",
  "%t está en desuso; use \"...\" para especificar una matriz de parámetros",
  "el espacio de nombres predeterminado no se puede extender",
  "el tipo al que se aplica conversión boxing debe ser un valor class o enum",
  "no se permite una referencia de seguimiento a una clase value",
  "no se permite un identificador para una clase value",
  "no se permite una referencia de seguimiento para una enumeración",
  "no se permite un identificador para una enumeración",
  "no se permite un tipo nativo público",
  "no se permite un tipo anidado público",
  "no se permiten tipos genéricos en C++/CX",
  "no se permiten métodos genéricos en C++/CX",
  "no se permiten restricciones genéricas",
  "los miembros de datos no públicos no están permitidos en tipos de valor públicos de C++/CX",
  "no se permiten miembros de no datos públicos en tipos de valor públicos de C++/CX",
  "no se permiten constructores en tipos de valor públicos de C++/CX",
  "el tipo devuelto del descriptor de acceso 'add' debe ser Windows::Foundation::EventRegistrationToken",
  "el tipo devuelto del descriptor de acceso 'remove' debe ser void",
  "el tipo de parámetro del descriptor de acceso 'remove' debe ser Windows::Foundation::EventRegistrationToken",
  "no se permite un identificador o una referencia a un tipo de parámetro genérico",
  "no se permiten miembros de datos públicos en tipos que no son de valor",
  "C++/CX solo se puede habilitar en el modo Microsoft C++",
  "los modos C++/CLI y C++/CX no se pueden combinar",
  "%sq requiere el modo C++/CX",
  "el modo C++/CX requiere microsoft_version >= 1600",
  "No se permiten campos de literal en C++/CX",
  "una referencia estándar no se puede enlazar a un tipo C++/CX",
  "el tipo debe corresponder a Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64 o default::uint64",
  "un tipo de valor C++/CX no puede tener eventos",
  "un dynamic_cast a un tipo de identificador debe hacer referencia a un tipo de clase completa",
  "Platform::Array solo puede ser unidimensional",
  "no se permite una referencia de seguimiento a un tipo de clase estándar",
  "un tipo de valor C++/CX no puede heredar de una interfaz",
  "un tipo de valor C++/CX no puede contener funciones virtuales",
  "\"partial\" solo se puede aplicar a \"ref class\" o \"ref struct\" en un ámbito global o de espacio de nombres",
  "el parámetro del descriptor de acceso 'set' debe ser de tipo 'const Platform::Array<T>^'",
  "la definición de un tipo C++/CX público no se permite en el ámbito global",
  "no se permite una propiedad indizada con un descriptor de acceso público 'get' o 'set'",
  "no se permite un tipo de delegado anidado público",
  "inicializador de delegado no válido: se esperaba \"(<function-address or functor-object> [, Platform::CallbackContext])\" o \"(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])\"",
  "inicializador de delegado no válido: el objeto debe ser un identificador de una clase %[managed]",
  "C++/CX no admite matrices 'in/out': use 'const Platform::Array<T>^' para 'in' y 'Platform::WriteOnlyArray<T>^' o 'Platform::Array<T>^*' para 'out' en API públicas",
  "falta el atributo \"target\" de %nd",
  "la función de miembro no declarada coincide con los atributos \"target\" de %n",
  "en esta ubicación solo se permiten atributos Microsoft para tipos de interfaces",
  "se necesita una rutina de resolución de varias versiones de función de GNU",
  "un tipo de enumeración declarado en una clase administrada debe incluir una definición",
  "un nombre calificado con decltype no es estándar en este contexto de declaración",
  "la función no virtual no se puede declarar con el modificador \"final\"",
  "no se admite el atributo \"target\" en la función especial",
  "debe ser un literal de cadena de caracteres estrechos",
  "paréntesis desemparejados",
  "no hay \"push_options\" correspondientes",
  "no se permite esta pragma dentro de una función",
  "declarar un operador new o delete \"inline\" no es estándar",
  "in inicializador MEM para un miembro de datos no puede ser una expansión del paquete",
  "las expresiones lambda genéricas no pueden tener valores predeterminados de captura en este modo",
  "Un argumento de plantilla predeterminado de una declaración \"friend\" solo se podría especificar en una definición",
  "una declaración de plantilla friend con un argumento de plantilla predeterminado debe ser la única declaración (primera declaración %p)",
  "una declaración de enumeración opaca no puede formar parte de otra declaración",
  "una declaración de enumeración opaca no es estándar en este contexto",
  "la sintaxis friend ampliada es una característica de C++11",
  "los separadores de dígitos no están habilitados, el apóstrofo inicia un literal de carácter",
  "el separador de dígitos no puede aparecer aquí",
  "\"constexpr\" se ignora aquí en el modo de Microsoft",
  "expresión no válida para el resultado de la expresión de instrucción",
  "el identificador es una macro y no un sufijo literal",
  "no se puede llamar a %nd en un valor L",
  "no se puede llamar a %nd en un valor R",
  "no se puede llamar a la función de miembro en un valor L",
  "no se puede llamar a la función de miembro en un valor R",
  "la lista de parámetros de plantilla es demasiado larga",
  "el tipo de plantilla de alias %t1 no es compatible con el tipo anterior de %t2 en la nueva declaración de %nfd",
  "el inicializador de campo %nd no es una expresión constante",
  "el número de restricciones de operandos debe ser el mismo en todas las cadenas de restricciones",
  "la cadena de restricciones contiene demasiadas restricciones alternativas; no se han comprobado todas las restricciones",
  "la llamada mediante la clase incompleta %t siempre producirá un error al crear una instancia",
  "decltype(auto) no puede tener calificadores de tipo agregados",
  "la captura de inicialización %nod no se puede capturar aquí",
  "argumento de tipo %t de plantilla sin tipo no válido",
  "se prescinde del atributo abi_tag (no tiene significado en modo C)",
  "la nueva declaración agrega el atributo abi_tag \"%s\"",
  "se prescinde del atributo abi_tag (sustituido por el atributo abi_tag posterior)",
  "la declaración anterior de %nd no tenía ningún atributo abi_tag",
  "(ver declaración anterior %p)",
  "se prescinde del atributo abi_tag en la especialización",
  "decltype(auto) no puede aparecer en un puntero, una referencia o una construcción puntero a miembro",
  "se esperaba \"class\" o \"typename\"",
  "la expresión de colocación \"new\" hace referencia a un %nd no ubicado",
  "se debe especificar el modo C++14 cuando se compila la biblioteca en tiempo de ejecución",
  "%s",
  "advertencia de la línea de comandos",
  "Advertencia de la línea de comandos",
  "la función de miembro no estática constexpr no estará implícitamente \"const\" en C++14",
  "el tipo de variable %t de la función constexpr no es un tipo literal",
  "la variable de la función constexpr no tiene una duración de almacenamiento automática",
  "la variable de la función constexpr está sin inicializar",
  "la inicialización entre llaves de una variable declarada con un tipo de marcador de posición pero sin \"=\" necesita exactamente un elemento dentro de las llaves",
  "no existe ninguna configuración \"%s\" --target",
  "el atributo no es compatible con configuraciones x86 de 64 bits",
  "\"%s\" requiere un argumento",
  "un constructor o destructor no puede ser una corrutina",
  "%n no puede ser una corrutina",
  "las expresiones co_yield no se permiten en una cláusula catch",
  null,
  null,
  null,
  null,
  "no se encontró la plantilla de clase %sq",
  "use la palabra clave \"typename\" para tratar %n como un tipo en un contexto dependiente",
  "el valor del argumento debe ser menor que la suma de los elementos de vector",
  "%t no tiene ningún miembro %sq",
  "una lista entre llaves no proporciona un tipo de valor devuelto",
  "una expresión co_await debe aparecer en un ámbito de función",
  "no se permite una expresión co_await dentro de una cláusula catch",
  "una corrutina no puede tener un parámetro de puntos suspensivos",
  "para habilitar constexpr como en C++14, se requiere compatibilidad con \"bool\"",
  "el valor constexpr %nd no está definido",
  "esta llamada no se puede evaluar porque la función %nd de destino no es constexpr o no está totalmente definida aún",
  "nota",
  "Nota",
  "unión anónima no válida, no se permite la plantilla de miembro de alias",
  "un valor literal de caracteres UTF-8 no puede ocupar más de una unidad de código",
  "el valor de %nd no puede usarse como una constante",
  "un puntero o una referencia a %nd no puede usarse como una constante",
  "subíndice distinto de cero para un objeto que no es de matriz",
  "no se puede obtener acceso a la posición %d1 en la matriz de %d2 elementos",
  "llamado desde:",
  "acceso no válido al elemento %n1 inactivo de la unión (%n2 está activo)",
  "\"goto\" no se puede ejecutar en contextos de constexpr",
  "falta el valor devuelto",
  "destinatario de la llamada null",
  "intentar desreferenciar un puntero null",
  "intentar obtener acceso a una posición de almacenamiento más allá del final de una matriz de %d elementos",
  "intentar obtener acceso a almacenamiento expirado",
  "intentar obtener acceso a almacenamiento en tiempo de ejecución",
  null,
  "no se puede llamar a un objeto %nd que no es constexpr",
  "no se puede usar la matriz de longitud variable durante la evaluación de constexpr",
  "no se puede realizar un cambio negativo",
  "cantidad de desplazamiento (%d) demasiado grande",
  "el valor excede el rango de %t",
  "error de punto flotante",
  "Intento de desreferenciar un puntero a miembro nulo (miembro de datos)",
  "comparar un puntero con void y un puntero con una función no estándar",
  "error en la inicialización de los metadatos",
  "conversión de base a derivado no válida (el tipo de clase completa es %t)",
  "acceso a %n no válido en un objeto del tipo %t completo",
  "no se permite aquí \"__auto_type\"",
  "\"__auto_type\" no admite varios declaradores",
  "no se admite la inicialización con \"{...}\" para \"__auto_type\"",
  "'__auto_type' debe ser un marcador de posición para el tipo completo de la variable (no para un componente de ese tipo)",
  "una variable declarada con \"__auto_type\" requiere un inicializador",
  "la constante de tipo entero debe ser mayor o igual que cero",
  "el tipo debe ser un tipo entero",
  "la expresión no se puede interpretar",
  "la instrucción no se puede interpretar",
  "uso no válido de la dirección del almacenamiento del intérprete",
  "tipo de constante no válido para la expresión constante",
  "el tipo %t es demasiado grande para la evaluación de expresión constante",
  "tipo %t no válido para la evaluación de expresión constante",
  "la conversión de %t1 en %t2 no es válida en la evaluación de expresión constante",
  "error en la conversión de número de punto flotante",
  null,
  "los tipos de valor devueltos deducidos son una característica de C++14",
  "no se puede evaluar un constructor con un destructor asociado",
  "%n no se inicializó durante la evaluación de constexpr",
  "diferencia de puntero no válida en la evaluación de constexpr",
  "aritmética no válida en un puntero que no es de matriz",
  "no se puede establecer el puntero antes del primer elemento de matriz",
  "una corrutina con un tipo de valor devuelto deducido no es válida",
  "expresión no permitida en un contexto no evaluado",
  null,
  null,
  "no se permite \"return\" en una corrutina: use \"co_return\".",
  "\"co_return\" solo se permite en las corrutinas",
  "no se pueden comparar valores de punto flotante",
  "los valores de puntero no se pueden comparar porque no apuntan al mismo objeto completo o apuntan a subobjetos con distinta accesibilidad",
  "el atributo abi_tag se omite en espacios de nombres no insertados",
  "el atributo abi_tag se omite en espacios de nombres anónimos",
  "el tipo de parámetro de plantilla complex o imaginary no es estándar",
  "no se permite una expresión co_yield fuera de un ámbito de función",
  "la indicación local para el subproceso se omite en una unión anónima",
  null,
  "plantilla de variables",
  "acceso a un objeto no inicializado",
  "intento de leer en almacenamiento volátil",
  "acceso no válido al elemento %n1 inactivo de la unión (no hay campos activos)",
  "no pueden aparecer definiciones de etiqueta en funciones constexpr",
  "no se puede comparar un puntero después del final de una matriz con un puntero a un objeto completo",
  "El tipo de función %t es un tipo no válido para una creación de una instancia de plantilla variable",
  "la variable no puede tener el tipo %t incompleto",
  "acceso a subobjeto no inicializado (%n)",
  "acceso a subobjeto no inicializado (clase base %t)",
  "no se permite una llamada a un pseudodestructor en una expresión constante",
  "intento de modificar almacén de constantes",
  null,
  null,
  "intento de acceso a almacenamiento en una posición posterior a un objeto tratado como matriz de un elemento",
  "no se puede usar reinterpret_cast en la evaluación de una expresión constante",
  "operación no permitida en un puntero nulo",
  "el valor de *this no se puede usar como una constante",
  "la palabra clave 'inline' no se puede usar en una declaración de espacio de nombres anidada",
  "el atributo \"carries_dependency\" se ignora",
  "un valor de tipo \"__event __interface\" no puede tener aquí una definición",
  "un controlador de eventos debe tener un tipo de valor devuelto void o integral",
  "debe haberse definido previamente un valor para \"__event __interface\"",
  "demasiados argumentos de plantilla para %n",
  "enumerador ya declarado (consulte %nd)",
  "la versión de Microsoft que se emula debe ser al menos 1903 para usar '--ms_c++14'",
  "la versión de Microsoft que se emula debe ser al menos 1903 para usar '--ms_c++latest'",
  "el tipo %t no puede ser _Atomic porque es un tipo de función o matriz",
  "el especificador _Atomic(...) no se puede aplicar al tipo calificado %t",
  "acceder al miembro del objeto _Atomic",
  "un campo de bits no puede tener un tipo _Atomic",
  "Los tipos de clase _Atomic están deshabilitados",
  "el constructor constexpr llama al constructor que no es constexpr para la inicialización del subobjeto",
  "se esperaba una coma (la versión de un argumento de static_assert no está habilitada en este modo)",
  "error de aserción estática",
  "como máximo uno de los calificadores _Nullable, _Nonnull y _Null_unspecified puede modificar un tipo",
  "solo se permiten calificadores de nulabilidad en tipos de puntero y de puntero a miembro",
  "la longitud del vector es demasiado grande",
  "el tipo de elemento de vector debe ser integral, enumeración o punto flotante real",
  "la función builtin no está disponible porque no se admiten enteros de 128 bits",
  "la función builtin no está disponible porque no se admiten tipos de vectores",
  "dos corchetes izquierdos consecutivos siempre introducen una lista de atributos, pero aquí no puede aparecer una lista de ese tipo",
  "el atributo \"target\" no reconocido descalifica esta rutina para su uso por la rutina de resolución",
  "%t no es un tipo de vector",
  "los tipos de vector %t1 y %t2 deben tener la misma longitud",
  "los argumentos predeterminados agregados no pueden dar lugar a la declaración de un constructor predeterminado o de copia",
  "un argumento de plantilla sin tipo del tipo de referencia debe enlazarse a una función o a un objeto completo",
  "%t no se permite aquí",
  "no se permite el uso del especificador de clase de almacenamiento \"register\"",
  "el especificador de clase de almacenamiento \"register\" está en desuso",
  "no se permite el incremento de un valor booleano",
  "%sq, declarado como iterador de la instrucción \"for\" basada en intervalo, no se puede volver a declarar en este ámbito",
  "no se puede usar aquí un espacio de nombres de atributo porque se especificó un prefijo \"using\"",
  "no se reconoce el espacio de nombres de atributo %sq",
  "no se permite un inicializador de miembros predeterminado en una clase de valor",
  "\"--implicit_noexcept\" requiere un modo que habilite noexcept",
  "no se puede plegar una operación que implica a la clase base virtual (%t)",
  "la inicialización no es constante",
  "no se puede evaluar el valor de %t incompleto",
  "ignorando el valor devuelto de la rutina declarada con el atributo \"nodiscard\"",
  "ignorando el tipo de valor devuelto con el atributo \"nodiscard\"",
  "el atributo \"nodiscard\" no se aplica a los destructores ni a las rutinas con un tipo de valor devuelto void",
  "El atributo \"fallthrough\" solo se aplica a instrucciones null",
  "El atributo \"fallthrough\" solo puede aparecer dentro de una instrucción switch",
  "la instrucción fallthrough debe preceder a la etiqueta switch case o default",
  "referencia o puntero a objeto temporal con duración limitada",
  "no se puede tomar la dirección de una función con un atributo \"enable_if\" cuya condición no es incondicionalmente verdadera",
  "los atributos \"enable_if\" con condiciones que no son valores constantes no se admiten actualmente",
  "el atributo se declaró aquí",
  "__has_include no puede aparecer fuera de #if",
  "no se puede agregar la clase base CComCoClass",
  "no es una cadena terminada en NULL",
  "el tipo no escalar \"%t\" no se puede usar en una llamada a un pseudodestructor",
  "la dirección de \"weak\" %n no es constante",
  "demasiadas sustituciones recursivas de firmas de plantilla de función",
  "especificador no válido para declaración de enlace estructurado",
  "sintaxis de enlace estructurado no válida",
  "falta el inicializador",
  "el tipo %t no tiene componentes con los que enlazar",
  "demasiados identificadores",
  "hay más elementos que nombres de enlaces",
  "\"std::tuple_element\" no definido",
  "no se puede crear una instancia de \"std::tuple_element\" para <%s, %t>",
  "no se puede llamar a la función miembro \"get<%s>()\" para el tipo %t",
  "ninguna instancia de %no coincide con la lista de argumentos",
  "este enlace estructurado requiere una función %sq adecuada y no se encontró ninguna",
  "un enlace estructurado no se puede declarar \"inline\"",
  "un enlace estructurado no se puede declarar \"constexpr\"",
  "un enlace estructurado no puede declarar una clase de almacenamiento explícita",
  "std::tuple_size<%t>::value no es una expresión de constante integral válida",
  "una declaración de condición debe declarar una variable",
  "una declaración de condición debe incluir un inicializador",
  "no se permite un inicializador entre paréntesis para una declaración de condición",
  "una declaración de condición solo puede declarar una variable",
  "un enlace estructurado no puede enlazar con un tipo de clausura",
  "no se puede enlazar con un elemento %n no público",
  "no se puede enlazar con un tipo %t incompleto",
  "esta declaración no es válida aquí",
  "el cuerpo de una función constexpr no puede ser un bloque try de función",
  "no se permite la transferencia de control a un bloque constexpr if",
  "no se puede capturar un enlace estructurado",
  "la versión de Microsoft que se emula debe ser al menos 1911 para usar \"--ms_c++17\"",
  "intento de lectura más allá del final del objeto",
  "las expresiones lambda constexpr no están habilitadas en este modo",
  "una expresión de constante no puede contener una expresión lambda",
  "el valor supera el número de argumentos de plantilla",
  "el segundo operador de la expresión fold binaria no coincide con el primero",
  "operador de expresión fold no válido",
  "una expresión fold binaria no se puede aplicar a dos paquetes de parámetros",
  "expansión vacía no válida para esta expresión fold",
  "un miembro de datos no estático no se puede declarar como inline",
  "la expresión fold no hace referencia a un paquete de parámetros",
  "no se pueden sobrecargar dos funciones con los mismos tipos de parámetros pero especificaciones de excepción distintas",
  "no se permiten especificaciones de excepción dinámicas en este modo",
  null,
  "operando no válido para el especificador noexcept",
  "no puede aparecer una expresión lambda en el especificador noexcept de una plantilla",
  "no se puede obtener acceso a %nfd",
  "especificador no válido en la declaración de plantilla de enumeración",
  "Esta configuración no admite tipos de punto flotante de 80 bits",
  "Esta configuración no admite tipos de punto flotante de 128 bits",
  "valor del enumerador no válido",
  "debe ser un tipo calificado _Atomic",
  "el tipo de elemento de matriz debe estar completo",
  "se ha suprimido el atributo always_inline para esta función",
  "aquí no se permite un valor negativo",
  "un elemento de empaquetado de enteros no puede coincidir con %n",
  "un elemento de empaquetado de enteros no puede coincidir con %n",
  "designador inesperado",
  "no se puede evaluar __builtin_offsetof",
  "no se puede definir la guía de deducción %t",
  "la guía de deducción debe declararse en el mismo ámbito que %n",
  "especificador no válido para la declaración de la guía de deducción (solo se permite \"explicit\")",
  "no se puede acceder al elemento mutable %n de una constante en una expresión constante",
  "el modificador de función no se aplica a una declaración de miembro estático",
  "el atributo \"overloadable\" requiere una declaración de función de prototipo",
  "no se puede deducir el tipo de parámetro de plantilla \"auto\" %t1 de %t2",
  "el nombre de la clase de plantilla debe ser un marcador de posición para el tipo completo que se está inicializando (no para un componente de ese tipo)",
  "las declaraciones de alias son una característica de C++11",
  "las plantillas de alias son una característica de C++11",
  "El tipo de valor devuelto debe designar directamente una especialización de la plantilla de clase asociada.",
  "la inicialización de lista de copia no puede usar un elemento %n de tipo \"explicit\"",
  "guía de deducción",
  "Valor no válido para un operador literal definido por el usuario.",
  "__has_cpp_attribute no puede aparecer fuera de #if o #elif",
  "la guía de deducción debe declararse con la misma accesibilidad que %n",
  "no se permite el uso de lambda en este contexto",
  "la alineación especificada no es equivalente a la declaración anterior",
  "no hay ninguna alineación especificada en la definición; la declaración anterior especificaba una alineación",
  "la función builtin no está disponible porque no se admiten tipos de punto flotante de 128 bits",
  "el desplazamiento a la izquierda de un valor negativo tiene un comportamiento indefinido",
  "los designadores de matriz no son estándar en C++",
  "los designadores encadenados no son estándar en C++",
  "la mezcla de inicializadores designados y no designados no es estándar en C++",
  "los inicializadores sin orden no son estándar en C++",
  "una plantilla de operador literal debe tener una lista de parámetros de plantilla equivalente a \"<typename T, T ...>\"",
  "no se permite un designador duplicado",
  "conflictos de atributo con el atributo likely/unlikely anterior",
  "la captura por copia implícita de \"this\" está en desuso",
  "no se permite una lista de parámetros de plantilla vacía en una expresión lambda",
  "la versión de Microsoft que se emula debe ser al menos 1920 para usar \"--ms_c++20\"",
  "El argumento pragma STDC no se acepta en este modo.",
  "Las instrucciones constexpr if son una característica de C++17",
  "no se permite la expansión del paquete en una lista de inicializadores designados",
  "el designador de campo no tiene ningún valor",
  "una unión puede tener como máximo un inicializador de campo",
  "se encontró un tipo std::%s no válido (debe incluirse <compare>)",
  "tipos no válidos (%t1 y %t2) para el operador integrado<=>",
  "las expresiones fold no son estándar en este modo",
  "el directorio especificado mediante la opción --current_directory no es un directorio: %s",
  "Advertencia de PCH",
  "el elemento stop del encabezado debe estar en el ámbito global. No se generó un archivo PCH IntelliSense.",
  "llamada de macro en curso. No se generó un archivo PCH IntelliSense.",
  "el elemento stop del encabezado no está en el ámbito de archivo. No se generó un archivo PCH IntelliSense.",
  "no puede haber un elemento stop de encabezado en una macro o un bloque #if. No se generó un archivo PCH IntelliSense.",
  "no puede haber un elemento stop de encabezado en un bloque de vinculación. No se generó un archivo PCH IntelliSense.",
  "no se encuentra una ubicación adecuada para el elemento stop del encabezado. No se generó un archivo PCH IntelliSense.",
  "no se pueden usar directivas line en un archivo PCH. No se generó un archivo PCH IntelliSense.",
  "especificador de restricción no válido",
  "La función %nfd con restricción amp debe llamarse desde una función con el mismo tipo de restricción",
  "la función %nfd1 tiene especificadores de restricción que no permiten llamar a la función %nfd2",
  "ningún candidato de sobrecarga tiene especificadores de restricción correctos",
  "%t no se permite en la función %nfd con restricción amp",
  "tipo %t no válido en puntero this para la función miembro %nfd con restricción amp",
  "Tipo de valor devuelto %t no válido para la función %nfd con restricción amp",
  "Tipo de parámetro %t no válido para la función %nfd con restricción amp",
  null,
  "Clase de almacenamiento %s no válida en la función %nfd con restricción amp",
  "%s no se permite en la función %nfd con restricción amp",
  "conversión no válida en la función con restricción amp",
  "especificación de excepción no permitida en la función con restricción amp",
  "Direccionamiento indirecto no válido en la función %nfd con restricción amp",
  "Las llamadas a funciones virtuales no son válidas en la función %nfd con restricción amp",
  "Las llamadas a funciones indirectas no son válidas en la función %nfd con restricción amp",
  "no se permite aquí la clase de almacenamiento tile_static",
  "Etiqueta no válida en la función %nfd con restricción amp",
  "Campo de bits no válido para la función %nfd con restricción amp",
  "Puntos suspensivos no válidos para la función %nfd con restricción amp",
  "base virtual no válida para el tipo %nfd compatible con amp",
  "Referencia externa no válida en la función %nfd con restricción amp",
  "El valor constante está fuera del intervalo admitido en la función %nfd con restricción amp",
  "valor de pragma pack %s no válido para la función con restricción amp",
  "no se permiten especificadores de restricción superpuestos",
  "los especificadores de restricción del destructor deben cubrir la unión de los especificadores de restricción de todos los constructores",
  null,
  "nostdlib requiere al menos un uso forzado",
  null,
  null,
  null,
  null,
  "no se admiten varios especificadores de restricción en funciones extern de \"C\"",
  "no se permiten funciones de puntero a miembro, punteros de función, referencias a funciones con especificador de restricción \"amp\"",
  "La clase base, el miembro de datos o el elemento de matriz deben estar al menos 4 bytes alineados para la función con restricción amp %nfd",
  "el desplazamiento de un miembro de datos debe ser un múltiplo de su alineación natural para la función con restricción amp %nfd",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "Las variables tile_static no pueden tener un inicializador",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "/clr:nostdlib requiere que mscorlib.dll esté en la lista de usos forzados",
  "/clr:netcore con /clr:nostdimport requiere que System.Runtime.dll, System.Runtime.Extensions.dll, System.Runtime.InteropServices.dll y System.Runtime.CompilerServices.VisualC.dll estén en la lista de objetos using forzados",
  null,
  null,
  null,
  null,
  null,
  "<error de emisión de diagnóstico>",
  "Hay demasiados errores como para que el motor de IntelliSense funcione correctamente. Puede que algunos no se vean en el editor.",
  "la asignación al anacronismo \"this\" no es compatible con el modo C++11",
  "error desconocido. No se generó un archivo Intellisense PCH.",
  "No se pueden asignar una o varias rutas remotas a las rutas locales actuales. La experiencia con IntelliSense puede degradarse.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "se esperaba \">>>\"",
  "no se encuentra la declaración __cudaPushCallConfiguration. La instalación del kit de herramientas de CUDA puede estar dañada.",
  "El inicializador de estilo C++17 no es estándar en este modo",
  "la captura de *this no es estándar en este modo",
  "El prefijo del atributo \"using\" de estilo C++17 no es estándar en este modo",
  "Los espacios de nombres anidados de estilo C++17 no son estándar en este modo",
  "solo puede aparecer uno de los elementos \"constexpr\", \"consteval\" y \"constinit'' en una declaración",
  "una función no puede ser consteval y virtual a la vez en este modo",
  "\"consteval\" no se permite en una directiva de creación de una instancia explícita",
  "\"consteval\" no es válido aquí",
  "un destructor no puede ser consteval",
  "un constructor para una clase con bases virtuales no puede ser consteval",
  "\"consteval\" no se permite en la declaración de un miembro de datos estático o variable",
  "%nd se declaró previamente como consteval",
  "%nd no se declaró previamente como consteval",
  "la función \"main\" no se puede declarar como consteval",
  "la llamada a consteval %n no generó una expresión constante válida",
  "dirección de consteval %n en el resultado de la expresión constante",
  "un miembro consteval no puede reemplazar a un elemento %n que no es consteval",
  "un miembro que no es consteval no puede reemplazar a un elemento %n que es consteval",
  "enlace estructurado",
  "el valor dynamic_cast para un subobjeto de tipo %t1 no es válido (el tipo más derivado es %t2)",
  "el identificador __VA_OPT__ solo puede aparecer en las listas de reemplazos de las macros variádicas",
  "__VA_OPT__ no puede aparecer en un operando __VA_OPT__",
  "falta el paréntesis de cierre para __VA_OPT__",
  "__VA_OPT__ debe estar seguido de \"(\"",
  "\"##\" no puede aparecer en primer lugar en un operando __VA_OPT__",
  "\"##\" no puede aparecer en último lugar en un operando __VA_OPT__",
  "Los espacios de nombres insertados y anidados de estilo C++20 no son estándar en este modo",
  "no se puede convertir el puntero a clase base %t2 en un puntero a clase derivada %t1: intente apuntar más allá del objeto más derivado",
  null,
  "no se puede usar \"main\" como nombre de variable global o vinculación de lenguaje C dada",
  "no se puede declarar la función \"main\" en una especificación de vinculación",
  "no se permite un enlace estructurado en una condición",
  "se requiere un identificador de espacio de nombres de atributo delante de \"::\"",
  "solo se permite un espacio de nombres de atributo",
  "no se permite \"return\" aquí",
  "no se puede combinar un enlace estructurado con otros declaradores",
  "no se puede crear una rama fuera de un contexto de evaluación de constantes",
  "no se permiten plantillas de enlace estructurado",
  "un inicializador entre paréntesis debe ser una expresión, no una lista entre llaves",
  "no se pueden deducir los argumentos de plantilla de clase",
  "un operador new o delete no se puede declarar como \"consteval\"",
  "la dirección de una función consteval no se puede usar aquí",
  "la alineación de un tipo de función (%t) no es estándar",
  "la alineación de una matriz de límite no especificado no es estándar en C",
  "Una variable no puede tener los atributos \"internal_linkage\" y \"common\" juntos",
  "El atributo \"internal_linkage\" no aparecía en una declaración anterior",
  "no se ha encontrado ningún candidato de deducción de argumentos de plantilla viable para %n",
  "no se permite una llamada de constructor completa",
  "un operador de comparación predeterminado debe ser un miembro o un elemento de confianza de la clase a la que se aplica",
  "tipo %t incorrecto para el parámetro del operador de comparación con valores predeterminados (debe ser una \"referencia a const X\", donde X es el tipo de clase envolvente)",
  "el tipo de valor devuelto del operador de comparación con valores predeterminados debe ser \"bool\"",
  "un operador de comparación de miembros con valores predeterminados debe ser \"const\"",
  null,
  "un tipo de promesa %t de corrutina no puede tener \"return_void\" y \"return_value\" establecidos a la vez",
  "\"return_value\" ha declarado %p",
  "\"return_void\" ha declarado %p",
  "Falta una instrucción co_return cuando %t no tiene \"return_void\" al final de %n",
  "no se encontró ninguna variante nothrow de \"operator new\" global para la asignación de estado de la corrutina",
  "no se encontró ninguna instancia de \"operador delete\" viable para la desasignación de estado de la corrutina",
  "una función constexpr no puede ser una corrutina",
  "el operando para esta expresión %s se resuelve en un tipo %t que no es de clase",
  "no se permite una expresión co_await en un inicializador estático",
  "la expresión co_await que llama a %n debe ser de tipo nothrow",
  "demasiadas operaciones de reescritura de comparación recursiva",
  "un tipo de valor devuelto deducible para un operador <=> predeterminado debe ser \"auto\"",
  "copia implícita de un origen no constante",
  "un enlace estructurado no puede declarar una clase de almacenamiento explícita que no sea static o thread_local",
  "no se admiten los operadores de comparación con valores predeterminados para los campos de propiedad de Microsoft no triviales",
  "el tipo de comparación estándar (%t) debe ser un tipo de clase con un solo miembro de datos no estático de tipo entero",
  "no se encontró ningún miembro de datos estático constexpr %sq en %t",
  "número de elementos (%d) demasiado grande para la asignación dinámica",
  "solicitud de asignación dinámica de constexpr demasiado grande",
  "desasignación del almacenamiento que no se asignó dinámicamente",
  "el tamaño de la desasignación (%d1) no corresponde al tamaño asignado (%d2)",
  "la asignación se produjo aquí",
  "el tipo de desasignación (%t1) no corresponde al tipo de asignación (%t2)",
  "no se desasignaron algunas asignaciones dinámicas (número total = %d)",
  "%n intrínseco declarado con una firma inesperada (tipo %t)",
  ">> salida de std::__report_constexpr_value",
  ">> finalizar salida de std::__report_constexpr_value",
  "no se puede usar una matriz con un tamaño de matriz dependiente en la evaluación de constexpr",
  "ignorando el valor devuelto de la rutina declarada con el atributo \"nodiscard\" (%sq)",
  "ignorando el tipo de valor devuelto con el atributo \"nodiscard\" (%sq)",
  "el constructor usado para crear el objeto descartado tiene el atributo \"nodiscard\"",
  "el constructor usado para crear el objeto descartado tiene el atributo \"nodiscard\" (%sq)",
  "el tipo de objeto descartado tiene el atributo \"nodiscard\"",
  "el tipo de objeto descartado tiene el atributo \"nodiscard\" (%sq)",
  "una referencia de pseudodestructor solo se puede usar para una llamada a un pseudodestructor",
  "no se permite una llamada explícita a un destructor en una expresión constante",
  "Un operador de coma sin paréntesis en una expresión de subíndice de matriz está en desuso",
  "el número de elementos asignados dinámicamente (%d) es demasiado pequeño para el inicializador",
  "un operando volatile para la expresión %s está en desuso",
  "el uso del resultado de una asignación a un objeto escalar volatile está en desuso",
  "un tipo de destino volatile para una expresión de asignación compuesta está en desuso",
  "un parámetro de función volatile está en desuso",
  "un tipo de valor devuelto volatile está en desuso",
  "el uso de un calificador volatile en un enlace estructurado está en desuso",
  "el argumento \"ext_vector_type\" debe estar comprendido entre 1 y 2047",
  "el atributo \"ext_vector_type\" solo puede aparecer en un objeto typedef",
  "el atributo \"ext_vector_type\" solo se aplica a tipos de punto flotante o enteros",
  "esta macro de prueba de funcionalidades se ignora (y devuelve 0) en el modo de compilación actual",
  "no se puede evaluar un inicializador de agregado con varios elementos para una unión",
  "El elemento %nd seleccionado para la reescritura del operador no devuelve un tipo bool",
  "una expresión \"new\" que llama a una función de asignación específica de clase no se puede evaluar como constante",
  "una expresión de colocación \"new\" no se puede evaluar como constante",
  "la eliminación mediante un puntero de subobjeto requiere un destructor virtual",
  "%npTd, con argumentos inversos",
  "el operando de __INTADDR__ debe estar desplazado respecto al puntero nulo",
  "La construcción _Generic coincide con varios tipos",
  "la otra coincidencia es %t",
  "el atributo \"availability\" usado aquí se ignora",
  "La instrucción del inicializador de estilo C++20 en una instrucción \"for\" basada en intervalo no es estándar en este modo",
  "co_await solo se puede aplicar a una instrucción for basada en intervalo",
  "no se puede deducir el tipo de intervalo en el bucle \"for\" basado en intervalo",
  "las variables insertadas son una característica de C++17",
  "el operador de destrucción requiere %t como primer parámetro",
  "un operador de destrucción \"delete\" no puede tener parámetros distintos de std::size_t y std::align_val_t",
  "las opciones de clase abstracta flexible solo se pueden usar al compilar C++",
  "inicio no válido de la expresión en la cláusula requires",
  "una expresión cast en una cláusula requires debe estar entre paréntesis",
  "este operador no puede aparecer en el nivel superior (sin paréntesis) de una cláusula requires",
  "la restricción atómica debe tener un tipo bool",
  "error de sustitución de la restricción atómica",
  "restricción atómica no constante",
  "la restricción atómica se evalúa como false",
  "la restricción de plantilla no se cumple",
  "la definición de concepto no puede aparecer en este ámbito",
  "nueva declaración de %nd no válida",
  "error de sustitución de los argumentos %T para concept-id",
  "el concepto es false para los argumentos %T",
  "no se permite una cláusula requires aquí (no es una función basada en plantilla)",
  "plantilla de concepto",
  "la cláusula requires es incompatible con %nfd",
  "se esperaba un atributo",
  null,
  "se esperaba un nombre de tipo",
  "no se permite un parámetro de puntos suspensivos en una expresión requires",
  "el parámetro sin nombre de la expresión requires no tiene ningún efecto",
  "se esperaba un nombre de concepto",
  "la llamada a %s que aparece en una expresión constante siempre genera \"true\"",
  "la llamada a %s que aparece en un contexto consteval siempre genera \"true\"",
  "la llamada a %s que aparece en una función que no es constexpr siempre genera \"false\"",
  "error de la restricción de tipo de %t",
  "no se puede usar la opción \"export\" en los modos en los que estén habilitados los módulos de C++",
  "una declaración de fragmento de módulo global debe preceder a cualquier otra declaración",
  "una declaración de módulo solo puede ir precedida de un fragmento de módulo global",
  "un fragmento de módulo privado debe ir precedido de una declaración de módulo",
  "no se puede exportar un fragmento de módulo de %s",
  "no se puede declarar más de un módulo",
  "no se puede declarar más de un fragmento de módulo de %s",
  "un módulo debe declararse con un nombre que no esté vacío",
  "%sq no es un encabezado que se pueda importar",
  "no se puede importar un módulo sin nombre",
  "un módulo no puede tener una dependencia de interfaz de sí mismo",
  "el módulo %sq ya se ha importado",
  "archivo de módulo",
  "no se encuentra el archivo del módulo %sq",
  "No se puede importar el archivo de módulo %sq.",
  "se esperaba %s1, pero se encontró %s2 en su lugar",
  "al abrir el archivo de módulo %sq",
  "nombre de partición %sq desconocido",
  "un archivo de módulo desconocido",
  "un archivo de módulo de encabezado importable",
  "un archivo de módulo EDG",
  "un archivo de módulo IFC",
  "un archivo de módulo inesperado",
  "el tipo del segundo operando %t2 debe tener el mismo tamaño que %t1",
  "el tipo debe poder copiarse de forma trivial",
  "no se admite el tipo %t para la evaluación constexpr de __builtin_bit_cast",
  "no se admiten los tipos de clase con campos de bits %t para la evaluación constexpr de __builtin_bit_cast",
  "un miembro de datos no estático del tipo de referencia %t impide la evaluación constexpr de __builtin_bit_cast",
  "un tipo volatile %t impide la evaluación constexpr de __builtin_bit_cast",
  "un tipo de unión, puntero o puntero a miembro %t impide la evaluación constexpr de __builtin_bit_cast",
  "%npTd, heredado mediante el uso de la declaración %p",
  "no se puede realizar la construcción de subobjetos de %t para los constructores de herencia; se elimina el constructor predeterminado implícito",
  "%n debe devolver void",
  "inicio de declaración de miembro no válido",
  "se esperaba \"auto\"",
  "este operador no está permitido en este punto; incluya la expresión \"new\" anterior entre paréntesis",
  "uso no válido del concepto",
  "un operador de comparación de miembros con valores predeterminados no puede estar calificado con \"&&\"",
  "la función de comparación constexpr predeterminada llama a una función %nd que no es constexpr",
  "la comparación de memoria de constexpr solo se admite para objetos de matriz de enteros o enteros",
  "una plantilla de concepto no puede tener restricciones asociadas",
  "no se permite \"export\"",
  "no se permite la exportación de miembros de clases individuales",
  "una declaración exportada debe introducir un nombre",
  "una declaración de exportación no puede contener otra declaración de exportación (declaración %p anterior)",
  "una declaración de exportación no puede contener una declaración de importación de módulo",
  "una declaración de exportación solo puede aparecer en una unidad de interfaz de módulo",
  "una declaración de exportación no puede exportar un nombre con vinculación interna",
  "la declaración using incluye %nfd",
  "la función builtin no está disponible porque no se admiten tipos de punto flotante __fp16",
  "una expresión requires debe especificar al menos un requisito",
  "\"constexpr\" no es válido aquí",
  "\"constinit\" solo es válido para las declaraciones de variables con duración de almacenamiento estático o de subproceso",
  "la variable constinit requiere la inicialización dinámica",
  "la variable se declaró previamente con \"constinit\" %p",
  "uso del declarador de función no prototipo",
  "el argumento no puede tener un tipo calificado constante",
  "no se permite un puntero a miembro de un tipo %t incompleto",
  "la expansión del paquete en la captura de inicialización no está habilitada en este modo",
  "la expansión del paquete en la captura de inicialización es una característica de C++20",
  "un operador de comparación con valor predeterminado en una definición de clase debe ser la primera declaración de ese operador de comparación (%nd)",
  "una expansión del paquete en una captura de inicialización solo se puede usar en una plantilla variádica",
  "la restricción de tipo usa %nd, que no es un concepto de tipo (es decir, una plantilla de concepto cuyo primer parámetro es un parámetro de tipo)",
  "el tipo de marcador de posición %t deducido generó un error en la restricción de tipo",
  "el constructor predeterminado de %t no es elegible",
  "el destructor de %t es ambiguo debido a restricciones desordenadas",
  "el destructor de %t no es elegible debido a restricciones con errores",
  "candidato destructor ambiguo",
  "una función virtual no puede tener una cláusula requires final",
  "%nd no cumple sus restricciones",
  "el resultado del calificador decltype %t no es una clase ni una enumeración",
  "la comparación es ambigua en C++ 20 estándar porque el operador de comparación implicado con los parámetros inversos es una coincidencia igualmente buena. Esto suele deberse a que falta un calificador \"const\" en el operador de comparación; vea %nod",
  "identificador de concepto no válido",
  "error de sustitución de los argumentos %T para la cláusula requires",
  "no se cumplen las restricciones de %nd",
  "el tipo de variable %t de la función constexpr tiene clases base virtuales",
  "una expresión constante no puede asignar un subobjeto base virtual (para el tipo %t)",
  "un parámetro de plantilla de tipo de clase debe ser un tipo de clase estructural",
  "la compatibilidad con los literales UTF-8 requiere compatibilidad con u-literal.",
  "la asignación de archivos de módulo para \"%s\" se especificó más de una vez",
  "la asignación de unidades de encabezado para \"%s\" se especificó más de una vez",
  "no se especificó ninguna asignación para \"%s\"",
  "la asignación del archivo de módulo para \"%s\" no es válida",
  "no se encuentra el encabezado \"%s\" para importar",
  "hay más de un archivo de la lista de archivos de módulo que coincide con \"%s\"",
  "el archivo de módulo que se encontró para \"%s\" es para otro módulo",
  "cualquier tipo de archivo de módulo",
  "no se puede leer el archivo de módulo",
  "la función integrada no está disponible porque no se admite el tipo char8_t con las opciones actuales",
  "no se puede especificar la opción de línea de comandos --ms_await si están habilitadas las corrutinas de C++ 20",
  "uso no estándar de %nod de constructor explícito para la inicialización predeterminada del elemento de agregado",
  "el origen o el destino del intento intrínseco de tipo memcpy no apunta a un objeto",
  "intentos intrínsecos de tipo memcpy para copiar los tipos %t1 y %t2 diferentes de forma representativa",
  "intentos intrínsecos de tipo memcpy para copiar el tipo %t que no se puede copiar de forma trivial",
  "intentos intrínsecos de tipo memcpy para copiar el objeto parcial",
  "intentos intrínsecos de tipo memcpy para copiar más allá del límite de matriz",
  "intentos intrínsecos de tipo memcpy para copiar los intervalos de bytes solapados (con la operación memmove correspondiente en su lugar)",
  "una declaración \"friend\" con una cláusula requires final debe ser una definición",
  "la expresión debe tener un tipo aritmético o de puntero, pero tiene el tipo %t",
  "la expresión debe tener un tipo aritmético, de enumeración o de puntero, pero tiene el tipo %t",
  "la expresión debe tener un tipo aritmético, de enumeración sin ámbito o de puntero, pero tiene el tipo %t",
  "la expresión debe tener un tipo de puntero, pero tiene el tipo %t",
  "el operador -> o ->* se aplica a %t, en lugar de a un tipo de puntero",
  "no se permite un tipo %t de clase incompleta",
  "no se puede interpretar el diseño de bits de este destino de compilación",
  "no hay ningún operador correspondiente al operador IFC %sq",
  "no hay ninguna convención de llamada correspondiente a la convención de llamada IFC %sq",
  "el módulo %sq contiene construcciones no admitidas",
  "construcción IFC no admitida: %sq",
  "__is_signed ya no es una palabra clave a partir de este punto",
  "una dimensión de matriz debe tener un valor entero sin signo constante",
  "El archivo IFC %sq tiene la versión no compatible %d1.%d2",
  "los módulos no están habilitados en este modo",
  "No se permite \"import\" en un nombre de módulo",
  "No se permite usar \"módulo\" en un nombre de módulo",
  null,
  null,
  "%n no es un tipo de enumeración",
  "el enumerador %no2 entra en conflicto con %n1",
  "el enumerador %no ya se ha declarado en el ámbito %p",
  "la especificación \"throw()\" no forma parte de C++20 y versiones posteriores",
  "más que la entrada en el mapa de la unidad del encabezado coincide con \"%s\"",
  "el diagnóstico #pragma debe tener un argumento \"push\" o \"pop\"",
  "no se encontró ninguna \"diagnóstico 'push' de #pragma\" que coincidiera con este \"diagnóstico 'pop'\"",
  "%sq no puede ser una macro cuando se usa en una directiva \"import\" o \"module\"",
  "esta directiva solo puede aparecer en el ámbito de espacio de nombres global",
  "una declaración \"export\" solo puede aparecer en un ámbito global o de espacio de nombres",
  "%sq se analiza como identificador en lugar de como palabra clave porque los tokens posteriores no coinciden con los de una directiva de preprocesador",
  "parece ser el inicio de una directiva de preprocesador, pero la ausencia de un \";\" seguida inmediatamente por una nueva línea impide eso",
  "parece que se trata de una directiva de preprocesamiento de módulos, pero estas directivas no pueden aparecer dentro de una expansión de macro",
  "una directiva \"module\" no puede aparecer en el ámbito de la inclusión condicional (por ejemplo, #if, #else, #elseif, etc.)",
  "se ha omitido la importación de %sq",
  "el tipo de promesa %t debe declarar get_return_object_on_allocation_failure como una función miembro estática que no requiera argumentos",
  "una plantilla de alias no se puede especializar explícitamente",
  "para que coincida con este \"{\"",
  "en esta invocación de macro",
  "la llamada requiere una conversión de argumento ambigua",
  "la declaración propiedad del módulo %s está en conflicto con %nd",
  "la declaración propiedad del módulo global entra en conflicto con %nd propiedad de un módulo con nombre",
  "el primer argumento de un atributo \"malloc\" debe ser una función",
  "no se puede capturar %nod",
  "no se puede capturar \"this\"",
  "ya está en contexto de consteval",
  "'if consteval' y 'if not consteval' requieren instrucciones dependientes limitadas",
  "'if consteval' y 'if not consteval' no tienen sentido en una función que no es constexpr",
  "no se permite la transferencia del control a una instrucción 'if consteval' o 'if not consteval'",
  "constant-evaluation no puede pasar por la declaración de una variable con duración de almacenamiento estático o de subproceso",
  "no se permite el calificador mutable en una expresión lambda con un parámetro \"this\" explícito",
  "una función miembro declarada con 'static' no puede tener un parámetro 'this' explícito",
  "un parámetro 'this' explícito debe ser el primer parámetro declarado",
  "“this” no se permite aquí",
  "no se puede establecer de forma predeterminada una función de comparación con 'this' explícita",
  "una función explícita 'this' requiere un operando selector",
  "'if consteval' y 'if not consteval' no son estándar en este modo",
  "omitir '()' en un declarador lambda no es estándar en este modo",
  "no se permite una cláusula trailing-requires-clause cuando se omite la lista de parámetros lambda",
  "se solicitó una partición no válida del módulo %sq",
  "módulo %sq1 partición no definida (se considera que es %sq2) solicitada",
  "módulo %sq1, posición de archivo %d1 (posición relativa %d2) solicitada para la partición %sq2, que está vacía",
  "módulo %sq1, posición de archivo %d1 (posición relativa %d2) solicitada para la partición %sq2, que es anterior al inicio de la partición",
  "módulo %sq1, posición de archivo %d1 (posición relativa %d2) solicitada para la partición %sq2, que desborda el final de su partición",
  "módulo %sq1 posición de archivo %d1 (posición relativa %d2) solicitada para la partición %sq2, que está mal alineada con sus elementos de particiones",
  "del subcampo %sq",
  "de la partición %sq elemento %d1 (posición de archivo %d2, posición relativa %d3)",
  "los atributos lambda no son estándar aquí",
  "el identificador %sq podría confundirse con uno visualmente similar que aparece %p",
  "este comentario contiene caracteres de control de formato Unicode sospechosos",
  "esta cadena contiene caracteres de control de formato Unicode que podrían dar lugar a un comportamiento inesperado en tiempo de ejecución",
  "Se encontró %d1 advertencia suprimida al procesar el módulo %sq1",
  "Se encontraron %d1 advertencias suprimidas al procesar el módulo %sq1",
  "Se encontró un error suprimido %d1 al procesar el módulo %sq1",
  "Se encontraron %d1 errores suprimidos al procesar el módulo %sq1",
  "Incluido",
  "Suprimido",
  "una función miembro virtual no puede tener un parámetro 'this' explícito",
  "tomar la dirección de una función explícita \"this\" requiere un nombre completo",
  "la formación de la dirección de una función explícita 'this' requiere el operador '&'",
  "no se puede usar un literal de cadena para inicializar un miembro de matriz flexible",
  "La representación IFC de la definición de la función %sq no es válida",
  "se realizó una corrección para quitar un parámetro \"this\" implícito",
  "no se usó un gráfico IFC UniLevel para especificar parámetros",
  "el gráfico de definición de parámetros IFC especificó %d1 parámetros, mientras que la declaración IFC especificó %d2 parámetros",
  "el gráfico de definición de parámetros IFC especificó %d1 parámetro, mientras que la declaración IFC especificó %d2 parámetros",
  "el gráfico de definición de parámetros IFC especificó %d1 parámetros, mientras que la declaración IFC especificó %d2 parámetro",
  "Falta la representación IFC de la definición de la función %sq",
  "el modificador de función no se aplica a la declaración de plantilla de miembro",
  "la selección de miembros implica demasiados tipos anónimos anidados",
  "no hay ningún tipo común entre los operandos",
  "se esperaba un puntero a miembro",
  "un miembro de matriz flexible no se puede declarar en un tipo que de otro modo estaría vacío",
  "se esperaba que 'std::source_location::__impl' se definiera a una clase con solo los miembros de datos '_M_function_name', '_M_file_name', '_M_column', '_M_line'",
  "durante la inicialización de 'std::source_location::__impl', el número de columna desborda el miembro '_M_column' de tipo %t",
  "durante la inicialización de 'std::source_location::__impl', el número de línea desborda el miembro '_M_line' de tipo %t",
  "una constante de caracteres UTF-16 no puede ocupar más de una unidad de código; valor truncado",
  "ambos argumentos deben tener el mismo tipo",
  "el tipo %t no es válido como argumento para este elemento integrado",
  "llamado desde %nd:",
  "un tipo calificado no es estándar para campos de bits anónimos",
  "el tipo de elemento de la condición de vector (%t1) debe tener el mismo tamaño que el tipo de elemento del resultado (%t2)",
  "el tipo de operando de vector de punto flotante (%t) no tiene ningún tipo de vector entero coincidente",
  "aún no se ha implementado la limpieza de expresiones \"requires\""
]