[
  "nieznany błąd",
  "ostatni wiersz w pliku nie jest zakończony znakiem nowego wiersza",
  "ostatni wiersz w pliku jest zakończony ukośnikiem",
  "dyrektywa #include dla pliku %sq powoduje, że plik dołącza siebie",
  "brak pamięci",
  null,
  "niezamknięty komentarz na końcu pliku",
  "nierozpoznany token",
  "brak cudzysłowu zamykającego",
  "zagnieżdżony komentarz jest niedozwolony",
  "znak „#” jest nieoczekiwany w tym miejscu",
  "nierozpoznana dyrektywa przetwarzania wstępnego",
  "analizowanie rozpocznie się ponownie od tego miejsca po poprzednim błędzie składniowym",
  "oczekiwano nazwy pliku",
  "dodatkowy tekst po oczekiwanym zakończeniu dyrektywy przetwarzania wstępnego",
  null,
  null,
  "oczekiwano znaku „]”",
  "oczekiwano znaku „)”",
  "dodatkowy tekst po oczekiwanym zakończeniu liczby",
  "identyfikator %sq jest niezdefiniowany",
  "kwalifikatory typu nie mają znaczenia w tej deklaracji",
  "nieprawidłowa liczba szesnastkowa",
  "stała całkowita jest za duża",
  "nieprawidłowa cyfra ósemkowa",
  "ciąg w cudzysłowie powinien zawierać co najmniej jeden znak",
  "za dużo znaków w stałej znakowej",
  "wartość znaku jest poza zakresem",
  "wyrażenie musi mieć stałą wartość",
  "oczekiwano wyrażenia",
  "stała zmiennoprzecinkowa jest poza zakresem",
  "wyrażenie musi mieć typ całkowity",
  "wyrażenie musi mieć typ arytmetyczny",
  "oczekiwano numeru wiersza",
  "nieprawidłowy numer wiersza",
  "dyrektywa #error: %s",
  "brak elementu #if dla tej dyrektywy",
  "brak elementu #endif dla tej dyrektywy",
  "dyrektywa jest niedozwolona — dyrektywa #else już wystąpiła",
  "dzielenie przez zero",
  "oczekiwano identyfikatora",
  "wyrażenie musi mieć typ arytmetyczny lub wskaźnikowy",
  "typy argumentów operacji są niezgodne (%t1 i %t2)",
  null,
  "wyrażenie musi mieć typ wskaźnikowy",
  "nie można użyć dyrektywy #undef dla tej wstępnie zdefiniowanej nazwy",
  "nazwa %no jest wstępnie zdefiniowana; próba ponownego zdefiniowania została zignorowana",
  "niezgodna ponowna definicja makra %nod",
  null,
  "zduplikowana nazwa parametru makra",
  "dyrektywa „##” nie może być pierwszym elementem definicji makra",
  "dyrektywa „##” nie może być ostatnim elementem definicji makra",
  "oczekiwano nazwy parametru makra",
  "oczekiwano znaku „:”",
  "za mało argumentów w wywołaniu %n",
  "za dużo argumentów w wywołaniu %n",
  "argument operacji sizeof nie może być funkcją",
  "ten operator jest niedozwolony w wyrażeniu stałym",
  "ten operator jest niedozwolony w wyrażeniu przetwarzania wstępnego",
  "wywołanie funkcji jest niedozwolone w wyrażeniu stałym",
  "ten operator jest niedozwolony w wyrażeniu stałej całkowitej",
  "wynik operacji całkowitoliczbowej jest poza zakresem",
  "licznik przesunięć jest ujemny",
  "licznik przesunięć jest za duży",
  "deklaracja nie deklaruje niczego",
  "oczekiwano znaku „;”",
  "wartość wyliczenia jest poza zakresem typu „int”",
  "oczekiwano znaku „}”",
  "konwersja liczby całkowitej spowodowała zmianę znaku",
  "konwersja liczby całkowitej spowodowała obcięcie",
  "niekompletny typ jest niedozwolony",
  "argument operacji sizeof nie może być polem bitowym",
  null,
  null,
  null,
  "argument „*” musi być wskaźnikiem, ale ma typ %t",
  "argument makra jest pusty",
  "ta deklaracja nie zawiera klasy magazynu lub specyfikatora typu",
  "deklaracja parametru nie może mieć inicjatora",
  "oczekiwano specyfikatora typu",
  "nie można określić klasy magazynu w tym miejscu",
  "nie można określić więcej niż jednej klasy magazynu",
  "klasa magazynu nie jest pierwsza",
  "kwalifikator typu jest określony więcej niż raz",
  "nieprawidłowa kombinacja specyfikatorów typu",
  "nieprawidłowa klasa magazynu dla parametru",
  "nieprawidłowa klasa magazynu dla funkcji",
  "nie można użyć specyfikatora typu w tym miejscu",
  "tablica funkcji jest niedozwolona",
  "tablica wartości void jest niedozwolona",
  "funkcja zwracająca funkcję jest niedozwolona",
  "funkcja zwracająca tablicę jest niedozwolona",
  "parametrów listy identyfikatorów można używać tylko w definicji funkcji",
  "typ funkcji nie może pochodzić z typu typedef",
  "rozmiar tablicy musi być większy niż zero",
  "tablica jest za duża",
  "jednostka translacji musi zawierać co najmniej jedną deklarację",
  "funkcja nie może zwracać wartości tego typu",
  "tablica nie może zawierać elementów tego typu",
  "deklaracja w tym miejscu musi deklarować parametr",
  "zduplikowana nazwa parametru",
  "element %sq został już zadeklarowany w bieżącym zakresie",
  "deklaracja przekazująca dalej typ wyliczenia jest niestandardowa",
  "klasa jest za duża",
  "struktura lub związek są za duże",
  "nieprawidłowy rozmiar pola bitowego",
  "nieprawidłowy typ pola bitowego",
  "pole bitowe o zerowej długości musi być nienazwane",
  "pole bitowe ze znakiem mające długość 1",
  "wyrażenie poprzedzające nawiasy wskazujące na wywołanie musi mieć typ (wskaźnika do) funkcji",
  "oczekiwano definicji lub nazwy tagu",
  "instrukcja jest nieosiągalna",
  "oczekiwano instrukcji „while”",
  null,
  "element %n został przywołany, ale nie jest zdefiniowany",
  "instrukcji continue można użyć tylko w pętli",
  "instrukcji break można użyć tylko w pętli lub w instrukcji switch",
  "element %n typu innego niż void powinien zwracać wartość",
  "funkcja typu void nie może zwracać wartości",
  "rzutowanie na typ %t jest niedozwolone",
  "typ zwracanej wartości nie jest zgodny z typem funkcji",
  "etykiety case można użyć tylko w instrukcji switch",
  "etykiety default można użyć tylko w instrukcji switch",
  null,
  "etykieta default została już użyta w tej instrukcji switch",
  "oczekiwano znaku „(”",
  "wyrażenie musi być l-wartością",
  "oczekiwano instrukcji",
  "pętla jest nieosiągalna",
  "funkcja o zakresie bloku może mieć tylko klasę magazynu extern",
  "oczekiwano znaku „{”",
  "wyrażenie musi mieć typ wskaźnika do klasy, ale ma typ %t",
  "wyrażenie musi mieć typ wskaźnika do struktury lub unii, ale ma typ %t",
  "oczekiwano nazwy składowej",
  "oczekiwano nazwy pola",
  "element %n nie ma składowej %sq",
  "element %n nie ma pola %sq",
  "wyrażenie musi być modyfikowalną l-wartością",
  "pobieranie adresu zmiennej rejestru jest niedozwolone",
  "pobieranie adresu pola bitowego jest niedozwolone",
  "za dużo argumentów w wywołaniu funkcji",
  "nienazwane parametry prototypowane są niedozwolone, jeśli występuje zawartość",
  "wyrażenie musi mieć typ wskaźnika do obiektu, ale ma typ %t",
  "program jest za duży lub zbyt skomplikowany, aby go skompilować",
  "nie można użyć wartości typu %t1 do zainicjowania jednostki typu %t2",
  "nie można zainicjować elementu %n",
  "zbyt wiele wartości inicjatora",
  "deklaracja jest niezgodna z elementem %nfd",
  "element %n został już zainicjowany",
  "deklaracja o zakresie globalnym nie może mieć tej klasy magazynu",
  "nazwa typu nie może zostać ponownie zadeklarowana jako parametr",
  "nazwa typu typedef nie może zostać ponownie zadeklarowana jako parametr",
  "konwersja niezerowej liczby całkowitej na wskaźnik",
  "wyrażenie musi mieć typ klasy, ale ma typ %t",
  "wyrażenie musi mieć typ struktury lub unii, ale ma typ %t",
  "starszy operator przypisania",
  "przestarzały inicjator",
  "wyrażenie musi być wyrażeniem stałej całkowitej",
  "wyrażenie musi być l-wartością lub desygnatorem funkcji",
  "deklaracja jest niezgodna z poprzednim elementem %nod",
  "nazwa zewnętrzna powoduje konflikt z nazwą zewnętrzną elementu %nd",
  "nierozpoznana dyrektywa #pragma",
  null,
  "nie można otworzyć pliku tymczasowego %sq: %s2",
  "nazwa katalogu plików tymczasowych jest za długa (%sq)",
  "za mało argumentów w wywołaniu funkcji",
  "nieprawidłowa stała zmiennoprzecinkowa",
  "argument typu %t1 jest niezgodny z parametrem typu %t2",
  "typ funkcji jest niedozwolony w tym miejscu",
  "oczekiwano deklaracji",
  "wskaźnik wskazuje poza obiekt podstawowy",
  "nieprawidłowa konwersja typu",
  "konflikt zewnętrznego/wewnętrznego wiązania z poprzednią deklaracją %p",
  "wartość zmiennoprzecinkowa nie mieści się w wymaganym typie całkowitym",
  "wyrażenie nie ma żadnego efektu",
  "indeks poza zakresem",
  null,
  "element %n został zadeklarowany, ale nie jest przywoływany",
  "zastosowanie operatora „&” do tablicy nie ma żadnego efektu",
  "prawy argument operacji „%%” wynosi zero",
  "argument jest niezgodny z parametrem formalnym",
  "argument jest niezgodny z odpowiadającą konwersją ciągu formatu",
  "nie można otworzyć pliku źródłowego %sq (brak katalogów na liście wyszukiwania)",
  "typ rzutowania musi być wartością całkowitą",
  "typ rzutowania musi być wartością arytmetyczną lub wskaźnikiem",
  "inicjacja dynamiczna w nieosiągalnym kodzie",
  "bezcelowe porównanie wartości całkowitej bez znaku z zerem",
  "prawdopodobnie użyto operatora „=” zamiast operatora „==”",
  "typ wyliczeniowy mieszany z innym typem",
  "błąd podczas zapisywania pliku %s",
  "nieprawidłowy plik języka pośredniego",
  "kwalifikator typu jest bez znaczenia w przypadku typu rzutowania",
  "nierozpoznana sekwencja ucieczki znaku",
  "użyto zera dla niezdefiniowanego identyfikatora przetwarzania wstępnego %sq",
  "oczekiwano ciągu asm",
  "funkcja asm musi być prototypowana",
  "funkcja asm nie może zawierać wielokropka",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "błąd podczas usuwania pliku %sq: %s2",
  "wartość całkowita nie mieści się w wymaganym typie zmiennoprzecinkowym",
  "wartość zmiennoprzecinkowa nie mieści się w wymaganym typie zmiennoprzecinkowym",
  "wynik operacji zmiennoprzecinkowej jest poza zakresem",
  "funkcja %sq jest zadeklarowana niejawnie",
  "ciąg formatu wymaga dodatkowych argumentów",
  "ciąg formatu kończy się przed tym argumentem",
  "nieprawidłowa konwersja ciągu formatu",
  "rekursja makra",
  "przecinek końcowy jest niestandardowy",
  "pole bitowe nie może zawierać wszystkich wartości typu wyliczeniowego",
  "niestandardowy typ pola bitowego",
  "deklaracja nie jest widoczna poza funkcją",
  "starszy typ typedef „void” został zignorowany",
  "lewy argument operacji nie jest strukturą lub związkiem zawierającym to pole",
  "wskaźnik nie wskazuje struktury lub związku zawierających to pole",
  "zmienna %sq została zadeklarowana z nigdy niezakończonym typem",
  "wyrażenie kontrolne jest stałą",
  "wyrażenie selektora jest stałą",
  "nieprawidłowy specyfikator parametru",
  "nieprawidłowy specyfikator poza deklaracją klasy",
  "zduplikowany specyfikator w deklaracji",
  "unia nie może mieć klasy bazowej",
  "określanie wielu specyfikatorów kontroli dostępu jest niedozwolone",
  "brak definicji klasy lub struktury",
  "nazwa kwalifikowana nie jest składową klasy %t lub jej klas bazowych",
  "niestatyczne odwołanie do składowej musi być określone względem konkretnego obiektu",
  "niestatyczna składowa danych nie może być zdefiniowana poza swoją klasą",
  "element %n został już zdefiniowany",
  "wskaźnik do odwołania jest niedozwolony",
  "odwołanie do odwołania jest niedozwolone",
  "odwołanie do typu void jest niedozwolone",
  "tablica odwołań jest niedozwolona",
  "odwołanie %n wymaga inicjatora",
  "oczekiwano znaku „,”",
  "nazwa typu jest niedozwolona",
  "definicja typu jest niedozwolona",
  "nieprawidłowa ponowna deklaracja nazwy typu %nod",
  "stała %n wymaga inicjatora",
  "słowa kluczowego „this” można użyć tylko wewnątrz niestatycznej funkcji składowej",
  "wartość stała jest nieznana",
  "brak jawnego typu (przyjęto typ „int”)",
  "kontrola dostępu nie jest określona (domyślnie %sq)",
  "nie została użyta nazwa klasy lub struktury",
  "zduplikowana nazwa klasy bazowej",
  "nieprawidłowa klasa bazowa",
  "element %nd jest niedostępny",
  "element %no jest niejednoznaczny",
  "lista parametrów starszego typu (anachronizm)",
  "deklaracja nie może występować po instrukcji wykonywalnej w bloku",
  "konwersja do niedostępnej klasy bazowej %t jest niedozwolona",
  null,
  null,
  null,
  null,
  "nieprawidłowo zakończone wywołanie makra",
  null,
  "nazwa, po której następują znaki „::”, musi być nazwą klasy lub przestrzeni nazw",
  "nieprawidłowa deklaracja elementu zaprzyjaźnionego",
  "konstruktor ani destruktor nie może zwracać wartości",
  "nieprawidłowa deklaracja destruktora",
  "deklaracja składowej o takiej samej nazwie jak jego klasa",
  "kwalifikator zakresu globalnego (wiodące znaki „::”) jest niedozwolony",
  "zakres globalny nie zawiera elementu %sq",
  "nazwa kwalifikowana jest niedozwolona",
  "odwołanie o wartości NULL jest niedozwolone",
  "inicjacja za pomocą elementu „{...}” jest niedozwolona dla obiektu typu %t",
  "klasa bazowa %t jest niejednoznaczna",
  "klasa pochodna %t1 zawiera więcej niż jedno wystąpienie klasy %t2",
  "nie można przekonwertować wskaźnika do klasy bazowej %t2 na wskaźnik do klasy pochodnej %t1, ponieważ klasa bazowa jest wirtualna",
  "żadne wystąpienie konstruktora %no nie jest zgodne z listą argumentów",
  "konstruktor kopiujący dla klasy %t jest niejednoznaczny",
  "klasa %t nie ma konstruktora domyślnego",
  "element %sq nie jest niestatycznym elementem członkowskim danych ani klasą bazową klasy %t",
  "pośrednia niewirtualna klasa bazowa jest niedozwolona",
  "nieprawidłowa składowa unii — klasa %t zawiera niedozwoloną funkcję składową",
  null,
  "nieprawidłowe użycie tablicy niebędącej l-wartością",
  "oczekiwano operatora",
  "dziedziczona składowa jest niedozwolona",
  "nie można określić, które wystąpienie elementu %n jest zamierzone",
  "wskaźnik do powiązanej funkcji może zostać użyty tylko do wywołania tej funkcji",
  "nazwa typu typedef została już zadeklarowana (z tym samym typem)",
  "element %n został już zdefiniowany",
  null,
  "żadne wystąpienie elementu %n nie jest zgodne z listą argumentów",
  "definicja typu jest niedozwolona w deklaracji zwracanego typu funkcji",
  "argument domyślny nie występuje na końcu listy parametrów",
  "ponowna definicja argumentu domyślnego",
  "więcej niż jedno wystąpienie elementu %n jest zgodne z listą argumentów:",
  "więcej niż jedno wystąpienie konstruktora %no jest zgodne z listą argumentów:",
  "argument domyślny typu %t1 jest niezgodny z parametrem typu %t2",
  "nie można przeciążyć funkcji różniących się tylko typem zwracanej wartości",
  "brak odpowiedniej konwersji elementu %t1 na %t2 zdefiniowanej przez użytkownika",
  null,
  "tylko niestatyczne składowe mogą być wirtualne",
  "obiekt ma kwalifikatory typu niezgodne z funkcją składową",
  "program jest za duży do skompilowania (zbyt wiele funkcji wirtualnych)",
  "zwracany typ nie jest identyczny ani kowariantny w stosunku do zwracanego typu %t przeciążonej funkcji wirtualnej %no",
  "przesłonięcie elementu wirtualnego %n jest niejednoznaczne",
  "czysty specyfikator („= 0”) jest dozwolony tylko dla funkcji wirtualnych",
  "niewłaściwie sformułowany czysty specyfikator (dozwolone jest tylko „= 0”)",
  "inicjator składowej danych jest niedozwolony",
  "obiekt typu klasy abstrakcyjnej %t jest niedozwolony:",
  "funkcja zwracająca klasę abstrakcyjną %t jest niedozwolona:",
  "zduplikowana deklaracja elementu zaprzyjaźnionego",
  "specyfikator inline jest dozwolony tylko dla deklaracji funkcji",
  "specyfikator „inline” jest niedozwolony",
  "nieprawidłowa klasa magazynu dla funkcji ze specyfikatorem inline",
  "nieprawidłowa klasa magazynu dla składowej klasy",
  "lokalna składowa klasy %n wymaga definicji",
  "element %nfd jest niedostępny",
  null,
  "klasa %t nie ma konstruktora kopiującego, który umożliwia skopiowanie obiektu stałego",
  "definiowanie niejawnie zadeklarowanej funkcji składowej jest niedozwolone",
  "klasa %t nie ma odpowiedniego konstruktora kopiującego",
  "specyfikacja wiązania jest niedozwolona",
  "nieznana specyfikacja zewnętrznego wiązania",
  "specyfikacja wiązania jest niezgodna z poprzednim elementem %nod",
  "więcej niż jedno wystąpienie przeciążonej funkcji %no ma powiązanie konsolidacji „C”",
  "klasa %t ma więcej niż jeden konstruktor domyślny",
  "skopiowano wartość do elementu tymczasowego; użyto odwołania do elementu tymczasowego",
  "element „operator%s” musi być funkcją składową",
  "operator nie może być statyczną funkcją składową",
  "argumenty są niedozwolone w przypadku konwersji zdefiniowanej przez użytkownika",
  "za dużo parametrów dla tej funkcji operatora",
  "za mało parametrów dla tej funkcji operatora",
  "operator niebędący elementem członkowskim wymaga parametru z typem klasy",
  "argument domyślny jest niedozwolony",
  "można zastosować więcej niż jedną konwersję elementu %t1 na %t2 zdefiniowaną przez użytkownika:",
  "żaden operator %sq nie pasuje do tych argumentów operacji",
  "więcej niż jeden operator %sq pasuje do tych argumentów operacji:",
  "pierwszy parametr funkcji alokacji musi mieć typ „size_t”",
  "funkcja alokacji musi zwracać typ „void *”",
  "funkcja cofania alokacji musi zwracać typ „void”",
  "pierwszy parametr funkcji cofania alokacji musi mieć typ „void *”",
  null,
  "typ musi być typem obiektu",
  "klasa bazowa %t jest już zainicjowana",
  "wymagana jest nazwa klasy bazowej — przyjęto %t (anachronizm)",
  "element %n został już zainicjowany",
  "brak nazwy składowej lub klasy bazowe",
  "przypisanie do wartości „this” (anachronizm)",
  "użyto słowa kluczowego „overload” (anachronizm)",
  "nieprawidłowa unia anonimowa — niepubliczna składowa jest niedozwolona",
  "nieprawidłowa unia anonimowa — funkcja składowa jest niedozwolona",
  "związek anonimowy w zakresie globalnym lub zakresie przestrzeni nazw musi być zadeklarowany jako statyczny",
  "element %nf nie udostępnia inicjatora dla:",
  "niejawnie wygenerowany konstruktor klasy %t nie może wykonać inicjacji:",
  "element %n nie definiuje konstruktora w celu zainicjowania następujących elementów:",
  "element %n zawiera składową będącą niezainicjowaną wartością stałą lub odwołaniem",
  "element %n zawiera niezainicjowane pole wartości stałej",
  "klasa %t nie ma operatora przypisania umożliwiającego skopiowanie obiektu stałego",
  "klasa %t nie ma odpowiedniego operatora przypisania",
  "niejednoznaczny operator przypisania dla klasy %t",
  null,
  "deklaracja wymaga nazwy typu typedef",
  null,
  "specyfikator „virtual” jest niedozwolony",
  "specyfikator „static” jest niedozwolony",
  "rzutowanie powiązanej funkcji na normalny wskaźnik funkcji (anachronizm)",
  "wyrażenie musi mieć typ wskaźnika do składowej",
  "zignorowano dodatkowy znak „;”",
  "inicjator w obrębie klasy dla niestatycznej składowej jest niestandardowy",
  null,
  "żadne wystąpienie przeciążonego elementu %no nie jest zgodne z listą argumentów",
  null,
  "żadne wystąpienie elementu %n nie jest zgodne z wymaganym typem",
  "użyto wyrażenia usuwania tablicy z określeniem rozmiaru (anachronizm)",
  null,
  "rzutowanie na klasę abstrakcyjną %t jest niedozwolone:",
  "nie można wywołać funkcji „main” ani pobrać jej adresu",
  "nie można określić inicjatora new dla tablicy",
  "nie można ponownie zadeklarować funkcji składowej %no poza jej klasą",
  "wskaźnik do niekompletnego typu klasy %t jest niedozwolony",
  "odwołanie do zmiennej lokalnej w otaczającej funkcji jest niedozwolone",
  "użyto funkcji z jednym argumentem dla przyrostka %sq (anachronizm)",
  null,
  "niejawnie wygenerowany operator przypisania nie może wykonać kopiowania:",
  "rzutowanie na typ tablicy jest niestandardowe (jest traktowane jako rzutowanie na %t)",
  "element %n ma operator new%s(), ale nie ma domyślnego operatora delete%s()",
  "element %n ma domyślny operator delete%s(), ale nie ma operatora new%s()",
  "destruktor klasy bazowej %nod nie jest wirtualny",
  null,
  "nieprawidłowa ponowna deklaracja składowej %npd",
  "nie można zadeklarować funkcji „main” ze specyfikatorem inline",
  "funkcja składowa o takiej samej nazwie jak jej klasa musi być konstruktorem",
  "użyto zagnieżdżonego elementu %n (anachronizm)",
  "destruktor nie może mieć parametrów",
  "konstruktor kopiujący dla klasy %t nie może mieć parametru typu %t",
  "element %n zwraca niekompletny typ %t",
  "element chroniony %nd nie jest dostępny przez obiekt lub wskaźnik %t",
  "parametr jest niedozwolony",
  "deklaracja „asm” jest niedozwolona w tym miejscu",
  "brak odpowiedniej funkcji konwersji elementu %t1 na %t2",
  "usunięto wskaźnik do niekompletnej klasy",
  "brak odpowiedniego konstruktora do przekonwertowania elementu %t1 na %t2",
  "więcej niż jeden konstruktor umożliwia konwertowanie elementu %t1 na %t2:",
  "więcej niż jedna funkcja konwersji umożliwia konwertowanie elementu %t1 na %t2:",
  "więcej niż jedna funkcja konwersji umożliwia konwertowanie elementu %t na typ wbudowany:",
  "wartość stała %n",
  "odwołanie do %n",
  "%npTd",
  "wbudowany operator %sq",
  "%nod, niejednoznaczność przez dziedziczenie",
  "nie można pobrać adresu konstruktora lub destruktora",
  null,
  "użyto wartości tymczasowej jako wartości początkowej odwołania do elementu niebędącego stałą (anachronizm)",
  "nazwa kwalifikowana jest niedozwolona w deklaracji składowej",
  "typ wyliczeniowy mieszany z innym typem (anachronizm)",
  "rozmiar tablicy w instrukcji „new” musi być nieujemny",
  "zwracane jest odwołanie do lokalnej wartości tymczasowej",
  null,
  "deklaracja „enum” jest niedozwolona",
  "pominięto kwalifikatory w odwołaniu powiązania typu %t1 z inicjatorem typu %t2",
  "nie można zainicjować odwołania typu %t1 (bez kwalifikatora const) przy użyciu wartości typu %t2",
  "nie można usunąć wskaźnika do funkcji",
  "funkcja konwersji musi być niestatyczną funkcją składową",
  "deklaracja szablonu nie jest tutaj dozwolona",
  "oczekiwano znaku „<”",
  "oczekiwano znaku „>”",
  "brak deklaracji parametru szablonu",
  "brak listy argumentów dla elementu %nf",
  "za mało argumentów dla elementu %nf",
  "za dużo argumentów dla elementu %nf",
  null,
  "element %n1 nie jest używany w deklaracji typów parametrów elementu %n2",
  "dwa typy zagnieżdżone mają tę samą nazwę: %no1 i %nod2 (zgodność z kompilatorem cfront)",
  "element globalny %no1 został zadeklarowany po elemencie zagnieżdżonym %nod2 (zgodność z kompilatorem cfront)",
  null,
  "więcej niż jedno wystąpienie elementu %n jest zgodne z wymaganym typem",
  "typ „long long” jest niestandardowy",
  "pominięcie elementu %sq jest niestandardowe",
  "nie można określić zwracanego typu dla funkcji konwersji",
  "wykryto podczas:",
  "tworzenie wystąpienia elementu %nt %p",
  "niejawne generowanie elementu %nt %p",
  "za dużo wywołań rekursji przy tworzeniu wystąpienia elementu %n",
  "element %sq nie jest funkcją ani statyczną składową danych",
  "argument typu %t1 jest niezgodny z typem parametru szablonu %t2",
  "inicjacja wymagająca wartości tymczasowej lub konwersji jest niedozwolona",
  "deklaracja elementu %sq powoduje ukrycie parametru funkcji",
  "wartość początkowa odwołania do wartości niebędącej stałą musi być l-wartością",
  "niejawna definicja elementu %nt %p",
  "słowo kluczowe „template” jest niedozwolone",
  "%t to nie jest szablon klasy",
  null,
  "„main” nie jest prawidłową nazwą szablonu funkcji",
  "nieprawidłowe odwołanie do elementu %n (niezgodność miedzy związkiem a elementem niebędącym związkiem)",
  "argument szablonu nie może odwoływać się do typu lokalnego",
  "rodzaj tagu elementu %s jest niezgodny z deklaracją elementu %nfd",
  "w zakresie globalnym nie ma tagu o nazwie %sq",
  "element %n nie ma tagu składowej o nazwie %sq",
  "typ typedef funkcji składowej (dozwolone w celu zgodności z kompilatorem cfront)",
  "elementu %n można użyć tylko w deklaracji wskaźnika do składowej",
  null,
  "argument szablonu nie może odwoływać się do jednostki innej niż zewnętrzna",
  "nazwa, po której następują znaki „::~”, musi być nazwą klasy lub typu",
  null,
  "typ użyty jako nazwa destruktora jest niezgodny z typem %t",
  "element %n został zadeklarowany ponownie ze specyfikatorem „inline” po wywołaniu",
  null,
  "nieprawidłowa klasa magazynu dla deklaracji szablonu",
  "typ %nd jest niedostępny (dozwolone w celu zgodności z kompilatorem cfront)",
  null,
  "nieprawidłowa jawna deklaracja tworzenia wystąpienia",
  "element %nf nie jest jednostką, której wystąpienie można utworzyć",
  "nie można jawnie utworzyć wystąpienia jednostki %n wygenerowanej przez kompilator",
  "nie można jawnie utworzyć wystąpienia elementu %n ze specyfikatorem inline",
  null,
  "nie można utworzyć wystąpienia elementu %n — nie podano definicji szablonu",
  "nie można utworzyć wystąpienia elementu %n — jego specjalizacja została jawnie określona",
  null,
  null,
  "żadne wystąpienie elementu %n nie jest zgodne z określonym typem",
  "deklarowanie pustej listy parametrów z typem typedef jest niestandardowe",
  "użyto globalnego elementu %n1 zamiast %n2 (zgodność z kompilatorem cfront)",
  "nie można ponownie zadeklarować parametru szablonu %sq w tym zakresie",
  "deklaracja elementu %sq powoduje ukrycie parametru szablonu",
  "lista argumentów szablonu musi być zgodna z listą parametrów",
  null,
  "dodatkowy parametr operatora przyrostkowego „operator%s” musi mieć typ „int”",
  "nazwa operatora musi być zadeklarowana jako funkcja",
  "nazwa operatora jest niedozwolona",
  "nie można specjalizować elementu %n w bieżącym zakresie",
  "niestandardowa forma pobierania adresu funkcji składowej",
  "za mało parametrów szablonu — niezgodność z poprzednią deklaracją (zadeklarowano %p)",
  "za dużo parametrów szablonu — niezgodność z poprzednią deklaracją (zadeklarowano %p)",
  "szablon funkcji dla operatora delete(void *) jest niedozwolony",
  "szablon klasy i parametr szablonu nie mogą mieć tej samej nazwy",
  null,
  "argument szablonu nie może odwoływać się do nienazwanego typu",
  "ta operacja na typie wyliczeniowym wymaga odpowiedniej funkcji operatora zdefiniowanej przez użytkownika",
  "kwalifikator typu dla typu referencyjnego jest niedozwolony",
  "nie można przypisać wartości typu %t1 do jednostki typu %t2",
  "bezcelowe porównanie liczby całkowitej bez znaku z ujemną wartością stałą",
  "nie można przekonwertować na niekompletną klasę %t",
  "obiekt stały wymaga inicjatora",
  "obiekt zawiera niezainicjowaną wartość stałą lub składową odwołania",
  "niestandardowa dyrektywa przetwarzania wstępnego",
  "element %n nie może mieć listy argumentów szablonu",
  "oczekiwano inicjacji za pomocą elementu „{...}” dla obiektu agregacji",
  "typy klas wyboru wskaźnika do składowej są niezgodne (%t1 i %t2)",
  "bezcelowa deklaracja elementu zaprzyjaźnionego",
  "użyto znaku „.” zamiast znaków „::” do utworzenia nazwy kwalifikowanej",
  "funkcja bez deklaracji const została wywołana dla obiektu stałego (konstrukcja przestarzała)",
  "instrukcja zależna nie może być deklaracją",
  "parametr nie może być typu void",
  "tworzenie wystąpienia elementu %na %p",
  "trwa przetwarzanie listy argumentów szablonu dla elementu %na %p",
  "ten operator jest niedozwolony w wyrażeniu argumentu szablonu",
  "blok try wymaga co najmniej jednej procedury obsługi",
  "procedura obsługi wymaga deklaracji wyjątku",
  "procedura obsługi jest maskowana przez domyślną procedurę obsługi",
  "procedura obsługi może zostać zamaskowana przez poprzednią procedurę obsługi dla typu %t",
  "użycie lokalnego typu w celu określenia wyjątku",
  "nadmiarowy typ w specyfikacji wyjątku",
  "specyfikacja wyjątku jest niezgodna ze specyfikacją poprzedniego elementu %nd%s",
  "poprzednio określono, że żadne wyjątki nie będą zgłaszane",
  "poprzednio pominięto: %t",
  "poprzednio określono, lecz pominięto w tym miejscu: %t",
  "obsługa wyjątków jest wyłączona",
  "zezwalanie na wszystkie wyjątki jest niezgodne z poprzednim elementem %nd",
  "nie można utworzyć pliku żądania utworzenia wystąpienia %sq",
  "operacja niearytmetyczna jest niedozwolona w argumencie stałej parametryzującej szablon",
  "użycie lokalnego typu do zadeklarowania nielokalnej zmiennej",
  "użycie lokalnego typu do zadeklarowania funkcji",
  "przekazanie sterowania powoduje pominięcie inicjowania elementów:",
  "%nd",
  "przekazanie sterowania od procedury obsługi wyjątku",
  "użyto elementu %n przed ustawieniem jego wartości",
  "element %n ustawiono, lecz nigdy go nie użyto",
  "nie można zdefiniować elementu %n w bieżącym zasięgu",
  "specyfikacja wyjątku jest niedozwolona",
  "konflikt wiązania zewnętrznego/wewnętrznego dla elementu %nfd",
  "element %nf nie będzie wywoływany dla konwersji jawnych ani niejawnych",
  "rodzaj taga %s jest niezgodny z parametrem szablonu typu %t",
  "szablon funkcji dla operatora new(size_t) jest niedozwolony",
  null,
  "wskaźnik do składowej typu %t jest niedozwolony",
  "wielokropek jest niedozwolony na liście parametrów funkcji operatora",
  "ciąg %no jest zarezerwowany do użycia w przyszłości jako słowo kluczowe",
  "nieprawidłowa definicja makra: %s",
  "nieprawidłowe usunięcie definicji makra: %s",
  null,
  null,
  "nazwa pliku IL musi być określona, jeśli dane wejściowe to ",
  null,
  null,
  null,
  null,
  "błąd argumentu opcji debugowania",
  "nieprawidłowa opcja: %s",
  "wewnętrzna baza danych wymaga nazwy pliku IL",
  "nie można otworzyć pliku IL %s",
  "nieprawidłowy numer: %s",
  "niepoprawny identyfikator CPU hosta",
  "nieprawidłowy tryb tworzenia wystąpienia: %s",
  null,
  "nieprawidłowy limit błędów: %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "tabele funkcji wirtualnych można pominąć tylko w przypadku kompilowania kodu C++",
  "opcji wykrywania konstrukcji przestarzałych można użyć tylko w przypadku kompilowania kodu C++",
  "opcji trybu tworzenia wystąpienia można użyć tylko w przypadku kompilowania kodu C++",
  "trybu automatycznego tworzenia wystąpień można użyć tylko w przypadku kompilowania kodu C++",
  "trybu niejawnego dołączania szablonów można użyć tylko w przypadku kompilowania kodu C++",
  "opcji obsługi wyjątków można użyć tylko w przypadku kompilowania kodu C++",
  "tryb z ograniczeniami jest niezgodny z trybem K&R",
  "tryb z ograniczeniami jest niezgodny z trybem cfront",
  "brak nazwy pliku źródłowego",
  "nie można określić plików wyjściowych w przypadku kompilowania wielu plików wejściowych",
  "za dużo argumentów w wierszu polecenia",
  "określono plik wyjściowy, lecz nie jest on potrzebny",
  "wyświetlenie elementu IL wymaga nazwy pliku IL",
  "parametr szablonu nie może być typu void",
  "nadmierne rekursywne tworzenie wystąpień elementu %n spowodowane trybem instantiate-all",
  "tryb z ograniczeniami jest niezgodny z trybem zezwalania na stosowanie konstrukcji przestarzałych",
  "wyrażenie throw nie może być typu void",
  "tryb lokalnego tworzenia wystąpień jest niezgodny z trybem automatycznego tworzenia wystąpień",
  "parametr typu klasy abstrakcyjnej %t jest niedozwolony:",
  "tablica klas abstrakcyjnych %t jest niedozwolona:",
  "zmiennoprzecinkowy parametr szablonu jest niestandardowy",
  "ta pragma musi występować bezpośrednio przed deklaracją",
  "ta pragma musi występować bezpośrednio przed instrukcją",
  "ta pragma musi występować bezpośrednio przed deklaracją lub instrukcją",
  "dyektywy pragma tego typu nie można użyć w tym miejscu",
  null,
  "przeciążona funkcja wirtualna %no1 jest tylko częściowo zastąpiona w elemencie %n2",
  "konkretna definicja funkcji wbudowanej szablonu musi występować przed jej pierwszym użyciem",
  "nieprawidłowy tag błędu w opcji kontroli diagnostyki: %s",
  "nieprawidłowy numer błędu w opcji kontroli diagnostyki: %s",
  null,
  null,
  "rzutowanie wskaźnika do funkcji składowej na wskaźnik do funkcji",
  "struktura lub unia nie deklaruje żadnych nazwanych składowych",
  "niestandardowe pole nienazwane",
  "niestandardowa nienazwana składowa",
  null,
  null,
  null,
  "%sq to nie jest nazwa typu",
  "nie można otworzyć prekompilowanego wejściowego pliku nagłówkowego %sq: %s2",
  "prekompilowany plik nagłówka %sq jest nieprawidłowy lub nie został wygenerowany przez tę wersję kompilatora",
  "prekompilowany plik nagłówkowy %sq nie został wygenerowany w tym katalogu",
  "pliki nagłówkowe użyte do wygenerowania prekompilowanego pliku nagłówkowego %sq zostały zmienione",
  "opcje wiersza polecenia nie są zgodne z opcjami użytymi podczas tworzenia prekompilowanego pliku nagłówkowego %sq",
  "początkowa sekwencja dyrektyw preprocesora nie jest zgodna z dyrektywami prekompilowanego pliku nagłówkowego %sq",
  "nie można uzyskać zamapowanej pamięci",
  "„%s”: użycie prekompilowanego pliku nagłówkowego „%s”",
  "„%s”: tworzenie prekompilowanego pliku nagłówkowego „%s”",
  "konflikt użycia pamięci z prekompilowanym plikiem nagłówkowym %sq",
  "nieprawidłowy rozmiar pamięci PCH: %s ",
  "opcje PCH muszą występować pierwsze w wierszu polecenia",
  "brak wystarczającej pamięci, aby można było zaalokować pamięć PCH",
  "prekompilowanych plików nagłówkowych nie można użyć w przypadku kompilowania wielu plików wejściowych",
  "zaalokowano wstępnie ilość pamięci niewystarczającą do wygenerowania prekompilowanych plików nagłówkowych (wymagane %s b)",
  "bardzo duża jednostka w programie uniemożliwia wygenerowanie prekompilowanego pliku nagłówkowego",
  "%sq to nie jest prawidłowy katalog",
  "nie można utworzyć nazwy pliku tymczasowego",
  "słowo kluczowe „restrict” jest niedozwolone",
  "wskaźnik lub odwołanie do typu funkcji nie może mieć kwalifikatora „restrict”",
  null,
  "nie można określić modyfikatora konwencji wywoływania w tym miejscu",
  "konflikt modyfikatorów konwencji wywoływania",
  "tryb z ograniczeniami jest niezgodny z trybem Microsoft",
  "tryb cfront jest niezgodny z trybem Microsoft",
  "konwencja wywoływania określona w tym miejscu została zignorowana",
  "po konwencji wywoływania nie może występować zagnieżdżony deklarator",
  "konwencja wywoływania została zignorowana dla tego typu",
  null,
  "modyfikatory deklaracji są niezgodne z poprzednią deklaracją",
  "modyfikator %sq jest niedozwolony w tej deklaracji",
  "przekazanie sterowania do bloku try",
  "specyfikacja wbudowania jest niezgodna z poprzednim elementem %nod",
  "nie znaleziono zamykającego nawiasu klamrowego definicji szablonu",
  "opcji słowa kluczowego wchar_t można użyć tylko w przypadku kompilowania kodu C++",
  "nieprawidłowa wartość wyrównania pakowania",
  "oczekiwano stałej całkowitej",
  "wywołanie czystej funkcji wirtualnej",
  "nieprawidłowy ciąg identyfikatora pliku źródłowego",
  "szablonu klasy nie można zdefiniować w deklaracji elementu zaprzyjaźnionego",
  "słowo kluczowe „asm” jest niedozwolone",
  "słowo kluczowe „asm” musi zostać użyte w definicji funkcji",
  "funkcja „asm” jest niestandardowa",
  "parametr wielokropka bez parametrów jawnych jest niestandardowy",
  "parametr „&...” jest niestandardowy",
  "nieprawidłowe użycie parametru „&...”",
  null,
  "użyto zmiennej tymczasowej dla początkowej wartości odwołania do elementu zadeklarowanego jako const volatile (konstrukcja przestarzała)",
  "odwołania typu %t1 nie można zainicjować za pomocą wartości typu %t2",
  "wartość początkowa odwołania do elementu zadeklarowanego jako const volatile musi być wartością lvalue",
  "opcji zgodności SVR4 C można użyć tylko w przypadku kompilowania kodu ANSI C",
  "użycie deklaracji elementu %nd spoza zasięgu",
  "tryb z ograniczeniami nie jest zgodny z trybem SVR4 C",
  "wywołania funkcji %nd nie można umieścić jako śródwierszowego",
  "elementu %n nie można umieścić jako śródwierszowego",
  "nieprawidłowy katalog PCH: %s",
  "oczekiwano słowa kluczowego __except lub __finally",
  "instrukcji __leave można użyć tylko w ramach instrukcji __try",
  "wykryto podczas tworzenia wystąpienia elementu %nt %p",
  "wykryto podczas niejawnego generowania elementu %nt %p",
  "wykryto podczas tworzenia wystąpienia elementu %na %p",
  "wykryto podczas przetwarzania listy argumentów szablonu dla elementu %na %p",
  "wykryto podczas niejawnego definiowania elementu %na %p",
  "elementu %sq nie znaleziono na stosie wyrównania pakowania",
  "pusty stos wyrównania pakowania",
  "opcji RTTI można użyć tylko w przypadku kompilowania kodu C++",
  "element %nfd wymagany dla kopii, która została wyeliminowana, jest niedostępny",
  "elementu %nf wymaganego dla kopii, która została wyeliminowana, nie można wywoływać, ponieważ parametru odwołania nie można powiązać z P-wartością",
  "element <typeinfo> musi być dołączony przed użyciem instrukcji typeid",
  "element %s nie umożliwia rzutowania z usuwaniem kwalifikatora const ani innych kwalifikatorów typu",
  "typ w operatorze dynamic_cast musi być wskaźnikiem lub odwołaniem do kompletnego typu klasy lub typu void *",
  "operand operatora dynamic_cast użytego dla wskaźnika musi być wskaźnikiem do kompletnego typu klasy",
  "operand operatora dynamic_cast użytego dla odwołania musi być L-wartością kompletnego typu klasy",
  "operand operatora dynamic_cast użytego w czasie wykonywania musi być typu klasy polimorficznej",
  "opcji bool można użyć tylko w przypadku kompilowania kodu C++",
  null,
  "typ tablicowy jest niedozwolony w tym miejscu",
  "oczekiwano znaku „=”",
  null,
  "elementu %sq zadeklarowanego w warunku nie można zadeklarować ponownie w tym zasięgu",
  "domyślne argumenty szablonu są niedozwolone dla szablonów funkcji",
  "oczekiwano znaku „,” lub „>”",
  "oczekiwano listy parametrów szablonu",
  "zwiększanie wartości logicznej jest przestarzałe",
  "typ logiczny jest niedozwolony",
  "przesunięcie klasy bazowej %no1 w ramach klasy %no2 jest za duże",
  "wyrażenie musi być typu logicznego (lub możliwe do przekonwertowania na typ logiczny)",
  "opcji new i delete dla tablicy można użyć tylko w przypadku kompilowania kodu C++",
  "%n to nie jest nazwa zmiennej",
  "modyfikator __based jest niedozwolony w tym miejscu",
  "modyfikator __based nie występuje przed operatorem wskaźnika, modyfikator __based został zignorowany",
  "zmienna w modyfikatorze __based musi być typu wskaźnikowego",
  "typ w operatorze const_cast musi być wskaźnikiem, odwołaniem lub wskaźnikiem do składowej typu obiektowego",
  "operator const_cast może dopasować tylko kwalifikatory typu, nie może zmienić typu podstawowego",
  "słowo kluczowe mutable jest niedozwolone",
  "ponowna deklaracja elementu %n jest niedozwolona, jeśli zmienia sposób dostępu do niego",
  null,
  "użycie alternatywnego tokenu „<:” prawdopodobnie jest niezamierzone",
  "użycie alternatywnego tokenu „%%:” prawdopodobnie jest niezamierzone",
  "definicja przestrzeni nazw jest niedozwolona",
  "nazwa musi być nazwą przestrzeni nazw",
  "definicja aliasu przestrzeni nazw jest niedozwolona",
  "wymagana jest nazwa kwalifikowana za pomocą przestrzeni nazw",
  "nazwa przestrzeni nazw jest niedozwolona",
  "nieprawidłowa kombinacja atrybutów biblioteki DLL",
  "%n to nie jest szablon klasy",
  "tablica z niekompletnym typem elementu jest niestandardowa",
  "operatora alokacji nie można zadeklarować w przestrzeni nazw",
  "operatora cofania alokacji nie można zadeklarować w przestrzeni nazw",
  "wystąpił konflikt elementu %np1 z deklaracją using elementu %np2",
  "wystąpił konflikt elementu %np1 używającego deklaracji using z elementem %npd2",
  "opcji przestrzeni nazw można użyć tylko w przypadku kompilowania kodu C++",
  "deklaracja using została zignorowana — odnosi się do bieżącej przestrzeni nazw",
  "wymagana jest nazwa kwalifikowana nazwą klasy",
  "typy argumentów: (%s)",
  "typy operandów: %s",
  null,
  "element %n nie ma rzeczywistej składowej %sq",
  null,
  "określono niezgodne atrybuty pamięci",
  "atrybut pamięci został zignorowany",
  "po atrybucie pamięci nie może następować zagnieżdżony deklarator",
  "atrybut pamięci określono więcej niż raz",
  "konwencja wywoływania została określona więcej niż raz",
  "kwalifikator typu jest niedozwolony",
  "elementu %npd1 użyto przed zadeklarowaniem jego szablonu",
  "statycznych i niestatycznych funkcji składowych z tymi samymi typami parametrów nie można przeciążyć",
  "nie ma wcześniejszej deklaracji elementu %np",
  "identyfikator szablonu jest niedozwolony",
  "nazwa kwalifikowana za pomocą nazwy klasy jest niedozwolona",
  "elementu %n nie można zadeklarować ponownie w bieżącym zasięgu",
  "nazwa kwalifikowana jest niedozwolona w deklaracji składowej przestrzeni nazw",
  "%n to nie jest nazwa typu",
  "jawne tworzenie wystąpienia jest niedozwolone w bieżącym zasięgu",
  "nie można jawnie utworzyć wystąpienia elementu %n w bieżącym zasięgu",
  "wystąpienie elementu %n utworzono jawnie więcej niż raz",
  "słowa kluczowego typename można użyć tylko w szablonie",
  "opcji special_subscript_cost można użyć tylko w przypadku kompilowania kodu C++",
  "opcji typename można użyć tylko w przypadku kompilowania kodu C++",
  "niejawnej opcji typename można użyć tylko w przypadku kompilowania kodu C++",
  "niestandardowy znak na początku definicji makra przypominającej obiekt",
  "specyfikacja wyjątku dla wirtualnego elementu %n1 jest niezgodna ze specyfikacją przesłoniętego elementu %n2",
  "konwersja ze wskaźnika na mniejszą liczbę całkowitą",
  "specyfikacja wyjątku dla niejawnie zadeklarowanego wirtualnego elementu %n1 jest niezgodna ze specyfikacją przesłoniętego elementu %n2",
  "element %no1 niejawnie wywołany z elementu %np2 jest niejednoznaczny",
  "opcji „explicit” można użyć tylko w przypadku kompilowania kodu C++",
  "słowo kluczowej „explicit” jest niedozwolone",
  "wystąpił konflikt deklaracji z elementem %sq (zarezerwowana nazwa klasy)",
  "tylko konstrukcja „()” jest dozwolona jako inicjator tablicy %n",
  "specyfikacja „virtual” jest niedozwolona w deklaracji szablonu funkcji",
  "nieprawidłowa anonimowa unia — szablon składowej klasy jest niedozwolony",
  "głębokość zagnieżdżenia szablonu jest niezgodna z poprzednią deklaracją elementu %n",
  "ta deklaracja nie może zawierać wielu klauzul „template <...>”",
  "opcji sterowania zasięgiem inicjacji pętli for można użyć tylko w przypadku kompilowania kodu C++",
  "elementu %sq zadeklarowanego w ramach inicjacji pętli for nie można ponownie zadeklarować w tym zasięgu",
  "odwołanie do elementu %nd1 — w przypadku starych reguł dotyczących zasięgu inicjacji pętli for byłby to element %nd2",
  "opcji umożliwiającej kontrolowanie ostrzeżeń dotyczących różnic inicjowania pętli for można użyć tylko w przypadku kompilowania kodu C++",
  "definicja wirtualnego elementu %n jest wymagana w tym miejscu",
  "pusty komentarz został zinterpretowany jako operator wklejania tokenu „##”",
  "klasa magazynu jest niedozwolona w deklaracji elementu zaprzyjaźnionego",
  "lista parametrów szablonu dla elementu %no jest niedozwolona w tej deklaracji",
  "Element %n nie jest prawidłowym szablonem składowej klasy",
  "to nie jest prawidłowa deklaracja klasy składowej lub szablonu funkcji",
  "po deklaracji szablonu zawierającej listę parametrów szablonu nie może następować jawna deklaracja specjalizacji",
  "jawna specjalizacja elementu %n1 musi poprzedzać pierwsze użycie elementu %n2",
  "jawna specjalizacja jest niedozwolona w bieżącym zasięgu",
  "częściowa specjalizacja elementu %n jest niedozwolona",
  "%nf to nie jednostka, którą można jawnie specjalizować",
  "jawna specjalizacja elementu %n musi występować przed jego pierwszym użyciem",
  "parametru szablonu %sq nie można użyć w uszczegółowionym specyfikatorze typu",
  "specjalizowanie elementu %n wymaga składni „template<>”",
  null,
  null,
  "opcji „old_specializations” można użyć tylko w przypadku kompilowania kodu C++",
  "specjalizowanie elementu %n bez składni „template<>” jest niestandardowe",
  "ta deklaracja może nie mieć zewnętrznego wiązania „C”",
  "%sq nie jest nazwą klasy lub szablonu funkcji w bieżącym zasięgu",
  "określenie domyślnego argumentu podczas ponownego deklarowania nieprzywoływanego szablonu funkcji jest niestandardowe",
  "określenie domyślnego argumentu podczas ponownego deklarowania już przywołanego szablonu funkcji jest niestandardowe",
  "nie można przekonwertować wskaźnika do składowej klasy bazowej %t2 na wskaźnik do składowej klasy pochodnej %t1 — klasa bazowa jest wirtualna",
  "specyfikacja wyjątku jest niezgodna ze specyfikacją elementu %nd%s",
  "zezwalanie na wszystkie wyjątki jest niezgodne z elementem %nd",
  "nieoczekiwany koniec wyrażenia argumentu domyślnego",
  "domyślne inicjowanie odwołania jest niedozwolone",
  "niezainicjowany element %n ma stałą składową",
  "niezainicjowana klasa bazowa %t ma stałą składową",
  "stały element %n wymaga inicjatora — klasa %t nie ma konstruktora domyślnego określonego przez użytkownika",
  "stały obiekt wymaga inicjatora — klasa %t nie ma konstruktora domyślnego określonego przez użytkownika",
  "opcji „implicit_extern_c_type_conversion” można użyć tylko w przypadku kompilowania kodu C++",
  "tryb z ograniczeniami jest niezgodny z regułami zachowywania wartości typu long",
  "kwalifikator typu nie ma znaczenia dla zwracanego typu",
  "w definicji funkcji kwalifikator typu dla zwracanego typu „void” jest niedozwolony",
  "deklaracja statycznej składowej danych jest niedozwolona w tej klasie",
  "utworzenie wystąpienia szablonu spowodowało powstanie nieprawidłowej deklaracji funkcji",
  "element „...” jest niedozwolony",
  "opcji „extern_inline” można użyć tylko w przypadku kompilowania kodu C++",
  "element %n ze specyfikatorem extern inline został przywołany, lecz nie jest zdefiniowany",
  "nieprawidłowa nazwa destruktora dla typu %t",
  null,
  "odwołanie do destruktora jest niejednoznaczne — można użyć zarówno destruktora %n1, jak i %n2",
  "funkcja %n ze specyfikatorem virtual inline nie została nigdy zdefiniowana",
  "element %n nie został nigdy przywołany",
  "tylko jedną składową unii można określić na liście inicjatorów konstruktora",
  "obsługa operatorów „new[]” i „delete[]” jest wyłączona",
  "użyto typu „double” zamiast „long double” w wygenerowanym kodzie C",
  "element %n nie ma odpowiadającego operatora delete%s (do wywołania w przypadku zgłoszenia wyjątku podczas inicjowania zaalokowanego obiektu)",
  "obsługa funkcji usuwania dla miejsca umieszczenia jest wyłączona",
  "żaden odpowiedni operator delete nie jest widoczny",
  "wskaźnik lub odwołanie do niekompletnego typu jest niedozwolone",
  "nieprawidłowa specjalizacja częściowa — element %n jest już całkowicie specjalizowany",
  "niezgodne specyfikacje wyjątku",
  "zwracanie odwołania do zmiennej lokalnej",
  "pominięcie jawnego typu jest niestandardowe (przyjęto typ „int”)",
  "więcej niż jedna specjalizacja częściowa jest zgodna z listą argumentów szablonu %n",
  "%no",
  "lista argumentów szablonu jest niedozwolona w deklaracji szablonu podstawowego",
  "częściowe specjalizacje nie mogą mieć domyślnych argumentów szablonu",
  "element %n1 nie jest używany lub nie można go określić na podstawie listy argumentów szablonu elementu %n2",
  null,
  "lista argumentów szablonu specjalizacji częściowej zawiera argument stałej parametryzującej szablon, którego typ zależy od parametru szablonu",
  "ta częściowa specjalizacja zostałaby użyta do utworzenia wystąpienia elementu %n",
  "ta częściowa specjalizacja spowodowałaby, że tworzenie wystąpienia elementu %n byłoby niejednoznaczne",
  "wyrażenie musi być typu całkowitego lub wyliczeniowego",
  "wyrażenie musi być typu arytmetycznego lub wyliczeniowego",
  "wyrażenie musi być typu arytmetycznego, wyliczeniowego lub wskaźnikowego",
  "typ rzutowania musi być całkowity lub wyliczeniowy",
  "typ rzutowania musi być arytmetyczny, wyliczeniowy lub wskaźnikowy",
  "wyrażenie musi być wskaźnikiem do kompletnego typu obiektu",
  null,
  "argument stałej parametryzującej szablon częściowej specjalizacji musi być nazwą parametru stałej parametryzującej szablon lub stałą",
  "zwracany typ nie jest taki sam jak zwracany typ %t przesłoniętej funkcji wirtualnej %no",
  "opcji „guiding_decls” można użyć tylko w przypadku kompilowania kodu C++",
  "częściowa specjalizacja szablonu klasy musi być zadeklarowana w przestrzeni nazw, do której należy",
  "%n to czysta funkcja wirtualna",
  "czysty element wirtualny %n nie ma elementu przesłaniającego",
  "atrybuty __declspec zostały zignorowane",
  "nieprawidłowy znak w wierszu danych wejściowych",
  "funkcja zwraca niekompletny typ %t",
  "efekt tej dyrektywy „#pragma pack” jest lokalny dla elementu %n",
  "%s to nie jest szablon",
  "deklaracja elementu zaprzyjaźnionego nie może deklarować częściowej specjalizacji",
  "specyfikacja wyjątku została zignorowana",
  "deklaracja typu „size_t” jest niezgodna z oczekiwanym typem %t",
  "spacja jest wymagana między sąsiadującymi ogranicznikami „>” na zagnieżdżonych listach argumentów szablonu (ciąg „>>” to operator przesunięcia bitowego w prawo)",
  "nie można ustawić ustawień regionalnych %sq, aby umożliwić przetwarzanie znaków wielobajtowych",
  "nieprawidłowa sekwencja znaków wielobajtowych",
  "utworzenie wystąpienia szablonu spowodowało wystąpienie nieoczekiwanego typu funkcji %t1 (znaczenie nazwy mogło zostać zmienione po zadeklarowaniu szablonu — typ szablonu to %t2)",
  "niejednoznaczna deklaracja kierująca — więcej niż jeden szablon funkcji %no jest zgodny z typem %t",
  "operacja dająca wynik niecałkowity jest niedozwolona w argumencie stałej parametryzującej szablon",
  "opcji „embedded_c++” można użyć tylko w przypadku kompilowania kodu C++",
  "dialekt Embedded C++ nie obsługuje szablonów",
  "dialekt Embedded C++ nie ma obsługi wyjątków",
  "dialekt Embedded C++ nie obsługuje przestrzeni nazw",
  "dialekt Embedded C++ nie obsługuje informacji o typie w czasie wykonywania",
  "dialekt Embedded C++ nie obsługuje nowej składni operatora cast",
  "dialekt Embedded C++ nie obsługuje deklaracji using",
  "dialekt Embedded C++ nie obsługuje słowa kluczowego „mutable”",
  "dialekt Embedded C++ nie obsługuje dziedziczenia wielokrotnego ani wirtualnego",
  "nieprawidłowy numer wersji Microsoft: %s",
  "reprezentacja wskaźnika do składowej %sq została już ustawiona dla elementu %n",
  "elementu %t1 nie można użyć do określenia konstruktora dla elementu %t2",
  "nieprawidłowy sufiks stałej całkowitej",
  "operand operatora __uuidof musi być typem klasy lub wyliczeniowym, dla którego określono instrukcję __declspec(uuid('...'))",
  "nieprawidłowy ciąg identyfikatora GUID w instrukcji __declspec(uuid('...'))",
  "opcji „vla” można użyć tylko w przypadku kompilowania kodu C",
  "tablica zmiennej długości z nieokreśloną granicą jest niedozwolona",
  "jawna lista argumentów szablonu jest niedozwolona w tej deklaracji",
  "jednostka z powiązaniem nie może być typu obejmującego tablicę zmiennej długości",
  "tablica zmiennej długości nie może mieć statycznego okresu przechowywania",
  "%n to nie jest szablon",
  "wymiar tablicy zmiennej długości (zadeklarowano %p)",
  "oczekiwano argumentu szablonu",
  null,
  "operator inny niż członkowski wymaga parametru typu klasy lub wyliczeniowego",
  "opcji „enum_overloading” można użyć tylko w przypadku kompilowania kodu C++",
  null,
  "kwalifikator nazwy destruktora %t1 nie jest zgodny z typem %t2",
  "kwalifikator typu został zignorowany",
  "opcji „nonstd_qualifier_deduction” można używać tylko w przypadku kompilowania kodu C++",
  "funkcja z deklaracją „dllimport” może nie być zdefiniowana",
  "nieprawidłowa specyfikacja właściwości — poprawna forma to __declspec(property(get=nazwa1,put=nazwa2))",
  "właściwość została już określona",
  "specyfikator __declspec(property) jest niedozwolony w tej deklaracji",
  "składowa jest zadeklarowana ze specyfikatorem __declspec(property), lecz funkcja „get” nie jest określona",
  "brak elementu %sq funkcji „get” specyfikatora __declspec(property)",
  "składowa jest zadeklarowana za pomocą deklaracji __declspec(property), ale nie określono żadnej funkcji „put”",
  "brak elementu %sq funkcji „put” specyfikatora __declspec(property)",
  "niejednoznaczne odwołanie do składowej klasy — użyto elementu %nd1 preferowanego w stosunku do %nd2",
  null,
  null,
  null,
  "nie można przekonwertować wskaźnika do składowej klasy pochodnej %t1 na wskaźnik do składowej klasy bazowej %t2 — klasa bazowa jest wirtualna",
  "nieprawidłowy katalog dla plików tworzenia wystąpienia: %s",
  "opcji „one_instantiation_per_object” można użyć tylko w przypadku kompilowania kodu C++",
  null,
  null,
  "nazwy pliku z informacjami o tworzeniu wystąpień nie można określić przy kompilowaniu wielu plików wejściowych",
  "opcji „one_instantiation_per_object” nie można użyć przy kompilowaniu wielu plików wejściowych",
  "więcej niż jedna opcja wiersza polecenia jest zgodna ze skrótem „--%s”:",
  "--%s",
  "kwalifikatory typu określone dla typów funkcji zostały zignorowane",
  null,
  "opcji wczesnego/późnego rozstrzygnięcia remisu można użyć tylko w przypadku kompilowania kodu C++",
  "nieprawidłowe użycie makra va_start",
  "nieprawidłowe użycie makra va_arg",
  "nieprawidłowe użycie makra va_end",
  "opcji oczekujących operacji tworzenia wystąpień można użyć tylko w przypadku tworzenia kodu C++",
  "nieprawidłowy katalog plików #import: %s",
  "katalog importu można określić tylko w trybie Microsoft",
  "składowa typu odniesienia jest niedozwolona w unii",
  "instrukcji „typedef” nie można określić w tym miejscu",
  "ponowna deklaracja elementu %n powoduje zmianę sposobu dostępu do niego",
  "kwalifikowana nazwa klasy lub przestrzeni nazw jest wymagana",
  "zwracany typ „int” został pominięty w deklaracji funkcji „main”",
  "reprezentacja wskaźnika do składowej %sq jest zbyt restrykcyjna dla elementu %n",
  "brak instrukcji return na końcu elementu %n typu innego niż void",
  "zduplikowana deklaracja using elementu %no została zignorowana",
  "wyliczeniowe pola bitowe nigdy nie mają znaku, lecz wyliczenie %t zawiera ujemny moduł wyliczający",
  "opcji „class_name_injection” można użyć tylko w przypadku kompilowania kodu C++",
  "opcji „arg_dep_lookup” można użyć tylko w przypadku kompilowania kodu C++",
  "opcji „friend_injection” można użyć tylko w przypadku kompilowania kodu C++",
  "nazwa po słowie kluczowym „template” musi określać szablon",
  null,
  "niestandardowa deklaracja elementu zaprzyjaźnionego dotycząca klasy lokalnej — nie ma wcześniejszej deklaracji w zawierającym zasięgu",
  "określenie domyślnego argumentu w tej deklaracji jest niestandardowe",
  "opcji „nonstd_using_decl” można użyć tylko w przypadku kompilowania kodu C++",
  "zwracanym typem funkcji „main” musi być typ „int”",
  "parametr stałej parametryzującej szablon nie może być typu klasy",
  "nie można określić domyślnego argumentu szablonu w deklaracji składowej szablonu klasy poza jego klasą",
  "instrukcja return jest niedozwolona w procedurze obsługi bloku try konstruktora",
  "desygnatory zwykłe i rozszerzone nie mogą być łączone w wyznaczeniu inicjatora",
  "drugi indeks nie może być mniejszy niż pierwszy",
  null,
  "opcji „extended_designators” można użyć tylko w przypadku kompilowania kodu C",
  "zadeklarowany rozmiar pola bitowego jest większy niż rozmiar typu pola bitowego — został obcięty do %s bitów",
  "typ użyty jako nazwa konstruktora nie jest zgodny z typem %t",
  "użycie typu bez powiązania w celu zadeklarowania zmiennej z powiązaniem",
  "użycie typu bez wiązania w celu zadeklarowania funkcji",
  "nie można określić zwracanego typu w konstruktorze",
  "nie można określić zwracanego typu w destruktorze",
  "nieprawidłowo sformatowana uniwersalna nazwa znaku",
  "uniwersalna nazwa znaku określa nieprawidłowy znak",
  "uniwersalna nazwa znaku nie może określać znaku w podstawowym zestawie znaków",
  "ten znak uniwersalny jest niedozwolony w identyfikatorze",
  "identyfikator __VA_ARGS__ może występować tylko w listach zastępczych makr ze zmienną liczbą argumentów",
  "kwalifikator tej deklaracji elementu zaprzyjaźnionego został zignorowany",
  "desygnatorów zakresu tablicy nie można zastosować dla inicjatorów dynamicznych",
  "nazwa właściwości nie może występować w tym miejscu",
  "słowo kluczowe „inline” użyte jako kwalifikator funkcji zostało zignorowane",
  "opcji „compound_literals” można użyć tylko w przypadku kompilowania kodu C",
  "typ tablicy o zmiennej długości jest niedozwolony",
  "literał złożony jest niedozwolony w wyrażeniu dającym stałą całkowitą",
  "literał złożony typu %t jest niedozwolony",
  "deklaracji elementu zaprzyjaźnionego dotyczącej szablonu nie można użyć w lokalnej klasie",
  "niejednoznaczna operacja „?”: drugi operand typu %t1 można przekonwertować na trzeci operand typu %t2 i odwrotnie",
  "wywołanie obiektu typu klasy bez odpowiedniej funkcji operator() lub funkcji konwersji na typ wskaźnika do funkcji",
  "funkcja zastępcza z konwersji %np",
  "istnieje więcej niż jeden sposób wywołania obiektu typu %t dla listy argumentów:",
  "nazwa została już zadeklarowana w instrukcji typedef (za pomocą podobnego typu)",
  "operator new ani operator delete nie może mieć wewnętrznego wiązania",
  "klasa magazynu ze specyfikatorem „mutable” jest niedozwolona w przypadku anonimowych unii",
  "nieprawidłowy prekompilowany plik nagłówkowy",
  "typ klasy abstrakcyjnej %t jest niedozwolony jako typ w instrukcji catch:",
  "kwalifikowanego typu funkcji nie można użyć do zadeklarowania funkcji nieskładowej ani statycznej funkcji składowej",
  "kwalifikowanego typu funkcji nie można użyć do zadeklarowania parametru",
  "nie można utworzyć wskaźnika ani odwołania do kwalifikowanego typu funkcji",
  "dodatkowe nawiasy klamrowe są niestandardowe",
  "nieprawidłowa definicja makra: %s",
  "odejmowanie typów wskaźnikowych %t1 i %t2 jest niestandardowe",
  "pusta lista parametrów szablonu jest niedozwolona w deklaracji parametrów szablonu szablonu",
  "oczekiwano słowa kluczowego „class”",
  "użycie słowa kluczowego „struct” jest niedozwolone przy deklarowaniu parametru szablonu",
  "element %np2 jest ukryty przez element %no1 — zamierzano przesłonić funkcję wirtualną?",
  "nazwa kwalifikowana jest niedozwolona w deklaracji elementu zaprzyjaźnionego będącej definicją funkcji",
  "element %n1 jest niezgodny z elementem %n2",
  "nie można określić klasy magazynu w tym miejscu",
  "składowa klasy z deklaracją using musi być widoczna w bezpośredniej klasie bazowej",
  null,
  "tryb Sun jest niegodny z trybem cfront",
  "tryb z ograniczeniami jest niezgodny z trybem Sun",
  "tryb Sun jest dozwolony tylko w przypadku kompilowania kodu C++",
  "parametr szablonu szablonu nie może mieć tej samej nazwy co jeden z jego parametrów szablonu",
  "rekursywne tworzenie wystąpienia domyślnego argumentu",
  null,
  "%n to nie jest jednostka, którą można zdefiniować",
  "nazwa destruktora musi być kwalifikowana",
  "nazwy klasy zaprzyjaźnionej nie można rozpoczynać słowem kluczowym „typename”",
  "deklaracja using nie może określać nazwy konstruktora ani destruktora",
  "kwalifikowana deklaracja friend szablonu musi odwoływać się do konkretnego szablonu zadeklarowanego wcześniej",
  "nieprawidłowy specyfikator w deklaracji szablonu klasy",
  "argument jest niezgodny z parametrem formalnym",
  "opcji „dep_name” można użyć tylko w przypadku kompilowania kodu C++",
  "pętla w sekwencji funkcji „operator->” zaczynająca się w klasie %t1",
  "%n nie ma klasy składowej %sq",
  "zasięg globalny nie zawiera klasy o nazwie %sq",
  "rekursywne tworzenie wystąpień domyślnego argumentu szablonu",
  "deklaracje dostępu i deklaracje using nie mogą występować w uniach",
  "%no to nie jest składowa klasy",
  "niestandardowa deklaracja stałej składowej jest niedozwolona",
  "opcji „ignore_std” można użyć tylko w przypadku kompilowania kodu C++",
  "opcji „parse_templates” można użyć tylko w przypadku kompilowania kodu C++",
  "opcji „dep_name” nie można użyć razem z opcją „no_parse_templates”",
  "określone tryby języka są niezgodne",
  "nieprawidłowa ponowna deklaracja zagnieżdżonej klasy",
  "typ zawierający tablicę o nieznanym rozmiarze jest niedozwolony",
  "zmiennej o statycznym okresie przechowywania nie można zdefiniować za pomocą funkcji wbudowanej",
  "jednostki z powiązaniem wewnętrznym nie można przywołać w funkcji wbudowanej z powiązaniem zewnętrznym",
  "typ argumentu %t jest niezgodny z tym makrem funkcji niezależnym od typu",
  "tablica o zmiennej długości %nod",
  "deklaracja elementu zaprzyjaźnionego nie może dodawać argumentów domyślnych do poprzedniej deklaracji",
  "elementu %n nie można zadeklarować w tym zasięgu",
  "zarezerwowanego identyfikatora %sq można użyć tylko wewnątrz funkcji",
  "ten znak uniwersalny nie może rozpoczynać identyfikatora",
  "oczekiwano literału ciągu",
  "nierozpoznana pragma STDC",
  "oczekiwano ciągu „ON”, „OFF” lub „DEFAULT”",
  "pragma STDC może występować tylko między deklaracjami w zasięgu globalnym lub przed wszystkimi instrukcjami i deklaracjami w zasięgu bloku",
  "nieprawidłowe użycie makra va_copy",
  "elementu %s można użyć tylko dla typów zmiennoprzecinkowych",
  "typ złożony jest niedozwolony",
  "nieprawidłowy rodzaj desygnatora",
  "wartości zmiennoprzecinkowej nie można reprezentować dokładnie",
  "wynik złożonej operacji zmiennoprzecinkowej jest poza zakresem",
  "konwersja między liczbami rzeczywistą i zespoloną daje zero",
  "inicjatora nie można określić dla elastycznej tablicy składowej",
  "wyrażenie liczba_zespolona *= liczba_zespolona powoduje ustawienie lewego operandu na zero",
  "standard wymaga określenia typu dla elementu %n przez następującą po nim deklarację (przyjęto typ „int”)",
  "definicja jest wymagana dla wbudowanego elementu %n",
  "konwersja z liczby całkowitej na mniejszy wskaźnik",
  "typ zmiennoprzecinkowy musi być dołączony do specyfikatora typu _Complex lub _Imaginary",
  "typów nie można deklarować w anonimowych uniach",
  "zwracany jest wskaźnik do zmiennej lokalnej",
  "zwracany jest wskaźnik do tymczasowej zmiennej lokalnej",
  "opcji „export” można użyć tylko w przypadku kompilowania kodu C++",
  "opcji „export” nie można użyć razem z opcją „no_dep_name”",
  "opcji „export” nie można użyć razem z opcją „implicit_include”",
  "deklaracja elementu %n jest niezgodna z deklaracją w innej jednostce translacji",
  "druga deklaracja to %p",
  "wykryto podczas kompilacji pomocniczej jednostki translacji %sq",
  "kompilacja pomocniczej jednostki translacji %sq",
  "typ deklaracji pola nie może obejmować tablicy o zmiennej długości",
  "deklaracja elementu %n miała inne znaczenie podczas kompilowania elementu %sq",
  "oczekiwano słowa kluczowego „template”",
  "słowa kluczowego „export” nie można użyć w przypadku jawnego tworzenia wystąpienia",
  "słowa kluczowego „export” nie można użyć w tej deklaracji",
  "składowej nienazwanej przestrzeni nazw nie można zadeklarować przy użyciu słowa kluczowego „export”",
  "szablonu nie można zadeklarować przy użyciu słowa kluczowego „export” po jego zdefiniowaniu",
  "deklaracja nie może mieć etykiety",
  "obsługa wyeksportowanych szablonów jest wyłączona",
  null,
  "element %n został już zdefiniowany podczas kompilowania elementu %sq",
  "element %n jest już zdefiniowany w innej jednostce translacji",
  "niestatycznej zmiennej lokalnej nie można użyć w specyfikacji __based",
  "opcji wyświetlenia zależności pliku Makefile nie można określić podczas kompilowania więcej niż jednej jednostki translacji",
  null,
  "opcji generowania wstępnie przetworzonych danych wyjściowych nie można określić podczas kompilowania więcej niż jednej jednostki translacji",
  "pola o takiej samej nazwie jak jego klasa nie można zadeklarować w klasie przy użyciu konstruktora z zadeklarowanego przez użytkownika",
  "opcji „implicit_include” nie można użyć podczas kompilowania więcej niż jednej jednostki translacji",
  "wyeksportowany plik szablonu %sq jest uszkodzony",
  "nie można utworzyć wystąpienia elementu %n — jego jawna specjalizacja została określona w jednostce translacji zawierającej wyeksportowaną definicję",
  "typ obiektu to: %s",
  "obiekt ma kwalifikatory typu niezgodne ze składową %n",
  "żadne wystąpienie elementu %n nie jest zgodne z listą argumentów i obiektem (kwalifikatory typu obiektu uniemożliwiają zgodność)",
  "atrybut określa tryb niezgodny z elementem %t",
  "nie ma typu o określonej szerokości",
  "atrybut określa nieprawidłową wartość wyrównania",
  "nieprawidłowy atrybut elementu %t",
  null,
  null,
  "atrybut %sq nie przyjmuje argumentów",
  null,
  "oczekiwano nazwy atrybutu",
  "nieznany atrybut %sq",
  "atrybuty nie mogą występować w tym miejscu",
  "nieprawidłowy argument atrybutu %sq",
  null,
  "w instrukcji „goto *wyrażenie” wyrażenie musi być typu „void *”",
  "instrukcja „goto *wyrażenie” jest niestandardowa",
  "pobieranie adresu etykiety jest niestandardowe",
  "nazwa pliku została określona więcej niż raz: %s",
  "dyrektywa #warning: %s",
  null,
  "atrybut „transparent_union” dotyczy tylko unii, a element %t nie jest unią",
  "atrybut „transparent_union” jest ignorowany dla niekompletnych typów",
  "element %t nie może być przezroczysty, ponieważ element %n nie ma tego samego rozmiaru co pierwsze pole",
  "element %t1 nie może być przezroczysty, ponieważ ma pole typu %t2, którego rozmiar jest inny niż rozmiar pierwszego pola",
  null,
  "atrybut %sq nie dotyczy lokalnych zmiennych",
  "atrybuty są niedozwolone w definicji funkcji",
  null,
  "druga stała w zakresie w instrukcji case musi być większa niż pierwsza",
  "nazwa funkcji asm jest niedozwolona w definicji funkcji",
  "nazwa funkcji asm została zignorowana w instrukcji typedef",
  "nieznana nazwa rejestru „%s”",
  null,
  "nieznany modyfikator ograniczenia w funkcji asm „%s”",
  "nieznana litera ograniczenia w funkcji asm „%s”",
  "operand funkcji asm nie ma litery ograniczenia",
  "operand danych wyjściowych funkcji asm musi mieć modyfikator „=” lub „+”",
  "operand danych wejściowych funkcji asm nie może mieć modyfikatora „=” ani „+”",
  null,
  null,
  "rejestr „%s” został użyty więcej niż raz",
  "rejestr „%s” został zarówno użyty, jak i nadpisany",
  "rejestr „%s” został nadpisany więcej niż raz",
  "przeznaczenie rejestru „%s” jest stałe i nie można go użyć w instrukcji asm",
  "przeznaczenie rejestru „%s” jest stałe i nie można go nadpisać w instrukcji asm",
  "pustą listę elementów nadpisywanych należy całkowicie pominąć",
  "oczekiwano operandu funkcji asm",
  "oczekiwano rejestru do nadpisania",
  "atrybut „format” wymaga parametru wielokropka",
  "pierwszy argument podstawienia nie jest pierwszym argumentem zmiennej",
  "indeks argumentu formatu jest większy niż liczba parametrów",
  "argument formatu nie ma typu ciągu",
  "słowa kluczowego „template” można użyć na potrzeby ujednoznacznienia składni tylko w ramach szablonu",
  "opcja debugowania musi zostać określona w wierszu polecenia, aby można było użyć dyrektywy pragma db_opt",
  null,
  "atrybut %sq nie dotyczy typu %t, który nie określa funkcji",
  "operacja arytmetyczna dotycząca wskaźnika wskazującego typ void lub typu funkcji",
  "klasa magazynu musi być określona za pomocą słowa kluczowego auto lub register",
  "typ %t1 zostałby podwyższony do typu %t2 w przypadku przekazania za pomocą parametru wielokropka — zamiast niego należy użyć podanego typu",
  "%sq to nie jest składowa klasy bazowej",
  "słowo kluczowe __super nie może występować po operatorze „::”",
  "słowa kluczowego __super można użyć tylko w zasięgu klasy",
  "po słowie kluczowym __super musi występować operator „::”",
  "[liczba niewyświetlonych kontekstów tworzenia wystąpienia: %d]",
  "nazwa zniekształcona jest za długa",
  "alias deklaracji wskazuje niezdefiniowaną jednostkę %sq",
  "deklaracja nie jest zgodna z jej aliasem %n",
  "jednostka zadeklarowana jako alias nie może mieć definicji",
  "typ pola będący tablicą o zmiennej długości będzie traktowany jako typ pola będący tablicą o zerowej długości",
  "niestandardowe rzutowanie na L-wartość zostało zignorowane",
  "nierozpoznana nazwa flagi: %s",
  "zwracany typ void nie może być kwalifikowany",
  "specyfikator auto został zignorowany w tym miejscu (jest nieprawidłowy według standardu C/C++)",
  "zmniejszenie wyrównania bez atrybutu „packed” zostało zignorowane",
  "szablon składowy odpowiadający elementowi %no jest zadeklarowany jako szablon innego rodzaju w innej jednostce translacji",
  "nadmiarowe inicjatory zostały zignorowane",
  "makro va_start może występować tylko w funkcji z parametrem wielokropka",
  "opcja „short_enums” jest prawidłowa tylko w trybach GNU C i GNU C++",
  "nieprawidłowy plik informacji o eksporcie %sq1 w wierszu numer %s2",
  "wyrażenia instrukcji są dozwolone tylko w zasięgu bloku",
  "z jednostki translacji",
  "nazwa funkcji asm jest ignorowana w przypadku nierejestrowej zmiennej automatycznej",
  null,
  "nierozpoznana pragma UPC",
  "rozmiar współużytkowanego bloku jest niezgodny z poprzednio określonym rozmiarem",
  "przyjęto, że wyrażenie w nawiasach kwadratowych jest specyfikacją rozmiaru bloku, a nie wymiarem tablicy",
  "rozmiar bloku współużytkowanej tablicy musi być większy od zera",
  "podanie wielu rozmiarów bloku jest niedozwolone",
  "kwalifikator strict lub relaxed wymaga kwalifikatora shared",
  "wartość THREADS jest niedozwolona w tym kontekście",
  "określony rozmiar bloku przekracza maksymalną wartość %s",
  "funkcja zwracająca element współużytkowany jest niedozwolona",
  null,
  "jeden wymiar tablicy współużytkowanego typu musi być wielokrotnością wartości THREADS, jeśli liczba wątków nie jest stała",
  "współużytkowany typ wewnątrz struktury lub unii jest niedozwolony",
  "typ parametru nie może być współużytkowany",
  "dynamiczny wymiar wartości THREADS wymaga zdefiniowanego rozmiaru bloku",
  "współużytkowane zmienne muszą mieć specyfikator static lub extern",
  "argument makra upc_blocksizeof jest wskaźnikiem do współużytkowanego typu (nie samym współużytkowanym typem)",
  "wyrażenie koligacji zostało zignorowane w zagnieżdżonym wywołaniu funkcji upc_forall",
  "gałąź prowadząca na zewnątrz lub do wewnątrz pętli upc_forall jest niedozwolona",
  "wyrażenie koligacji musi być typu współużytkowanego lub wskaźnikiem do współużytkowanego typu",
  "koligacja jest typu współużytkowanego (a nie wskaźnikiem do współużytkowanego typu)",
  "współużytkowane typy void* można porównywać tylko pod względem równości",
  "tryb UPC jest niezgodny z trybami C++ i K&R",
  "znak null (o wartości zerowej) w wierszu danych wejściowych został zignorowany",
  "znak null (o wartości zerowej) w stałej ciągu lub znakowej",
  "znak null (o wartości zerowej) w nazwie nagłówka",
  "deklaracja inicjatora pętli for ukrywa deklarację w otaczającym zasięgu",
  "ukryta deklaracja to %p",
  "prototypowa deklaracja elementu %nfd została zignorowana po tej ponownej deklaracji bez prototypu",
  null,
  "element %npd musi mieć zewnętrzne powiązanie C",
  "deklaracja zmiennej ukrywa deklarację inicjatora pętli for",
  "instrukcji typedef %sq nie można użyć w uszczegółowionym specyfikatorze typu",
  "wywołanie stałej zerowej zostało zignorowane",
  "parametru %sq nie można zadeklarować ponownie w klauzuli catch bloku try w funkcji",
  "początkowa jawna specjalizacja elementu %n musi być zadeklarowana w przestrzeni nazw zawierającej szablon",
  "opcja nadpisywania „cc” została zignorowana",
  "po słowie kluczowym „template” musi następować identyfikator",
  "wartość MYTHREAD jest niedozwolona w tym kontekście",
  "kwalifikator układu nie może kwalifikować wskaźnika do elementu ze specyfikatorem shared",
  "kwalifikator układu nie może kwalifikować niekompletnej tablicy",
  "deklaracja elementu %sq powoduje ukrycie parametru procedury obsługi",
  "niestandardowe rzutowanie na typ tablicowy zostało zignorowane",
  "tej pragmy nie można użyć w operatorze _Pragma (należy użyć dyrektywy #pragma)",
  "pole używa dopełniania na końcu takiego jak w klasie bazowej",
  "kompilatory GNU C++ mogą używać dopełniania pól bitowych",
  "element %nd został zadeklarowany jako przestarzały",
  "nazwa funkcji asm jest niedozwolona w deklaracji niestatycznej składowej",
  "nierozpoznany typ funkcji formatu %sq został zignorowany",
  "klasa bazowa %no1 używa dopełniania na końcu takiego jak w klasie bazowej %no2",
  "atrybutu „init_priority” można użyć tylko dla definicji statycznych składowych danych i zmiennych o zasięgu przestrzeni nazw w typach klas",
  "żądany priorytet inicjacji jest zarezerwowany do użytku wewnętrznego",
  "to anonimowe pole unii/struktury jest ukryte przez element %nd",
  "nieprawidłowy numer błędu",
  "nieprawidłowy tag błędu",
  "oczekiwano numeru błędu lub taga błędu",
  "na rozmiar klasy ma wpływ dopełnianie na końcu",
  "etykiety można przywoływać tylko w definicjach funkcji",
  "przekazanie sterowania w wyrażeniu instrukcji jest niedozwolone",
  null,
  "ta instrukcja jest niedozwolona wewnątrz wyrażenia instrukcji",
  "w wyrażeniu instrukcji nie można zdefiniować klasy, która nie jest w prosty sposób możliwa do skopiowania",
  null,
  "dynamicznie inicjowana lokalna zmienna statyczna jest niedozwolona wewnątrz wyrażenia instrukcji",
  "tablica zmiennej długości jest niedozwolona wewnątrz wyrażenia instrukcji",
  "wyrażenie instrukcji jest niedozwolone wewnątrz domyślnego argumentu",
  "niestandardowa konwersja między wskaźnikiem do funkcji a wskaźnikiem do danych",
  "typy interfejsów nie mogą mieć wirtualnych klas bazowych",
  "typy interfejsów nie mogą używać specyfikatora „private” ani „protected”",
  "typy interfejsów mogą pochodzić tylko od innych typów interfejsów",
  "%t to typ interfejsu",
  "typy interfejsów nie mogą mieć składowych utworzonych za pomocą słowa kluczowego typedef",
  "typy interfejsów nie mogą mieć konstruktorów ani destruktorów zadeklarowanych przez użytkownika",
  "typy interfejsów nie mogą mieć operatorów składowych zadeklarowanych przez użytkownika",
  "typów interfejsów nie można deklarować w funkcjach",
  null,
  "typy interfejsów nie mogą mieć składowych danych",
  "typy interfejsów nie mogą zawierać deklaracji elementu zaprzyjaźnionego",
  null,
  "typy interfejsów nie mogą być zagnieżdżonymi typami klas",
  "typy interfejsów nie mogą mieć szablonów składowych",
  "typy interfejsów nie mogą mieć statycznych funkcji składowych",
  "tej pragmy nie można użyć w operatorze __pragma (należy użyć dyrektywy #pragma)",
  "kwalifikator musi być klasą bazową elementu %t",
  "deklaracja musi odpowiadać czystej wirtualnej funkcji członkowskiej we wskazanej klasie bazowej",
  "nadmiar operacji na liczbach całkowitych w obliczeniach wewnętrznych ze względu na rozmiar lub złożoność elementu %t",
  "nadmiar operacji na liczbach całkowitych w obliczeniach wewnętrznych",
  "specyfikator __w64 można określić tylko dla typów int, long i wskaźnikowych",
  "możliwa konwersja zawężająca podczas kompilacji w środowisku, w którym typ int, long lub typy wskaźnikowe mają 64 bity",
  "bieżąca wartość pragmy #pragma pack to %s",
  "argumenty pragmy #pragma pack(show) zostały zignorowane",
  null,
  null,
  "wcześniejszy specyfikator __declspec(align(...)) został zignorowany",
  "oczekiwano wartości argumentu dla parametru atrybutu %sq",
  "nieprawidłowa wartość argumentu dla parametru atrybutu %sq",
  "oczekiwano wartości logicznej dla parametru atrybutu %sq",
  "argument pozycyjny nie może występować w atrybucie po argumencie nazwanym",
  "atrybut %sq1 nie ma parametru o nazwie %sq2",
  "oczekiwano listy argumentów dla atrybutu %sq",
  "oczekiwano znaku „,” lub „]”",
  "argumentowi %sq atrybutu nadano już wartość",
  "nie można przypisać wartości do atrybutu %sq",
  "wyrażenie throw nie może być typu wskaźnika do niekompletnego typu",
  "operator wyrównania zastosowano do niekompletnego typu",
  "elementu %sq można użyć tylko jako samodzielnego atrybutu",
  "atrybutu %sq nie można użyć w tym miejscu",
  null,
  "atrybuty są niedozwolone w tym miejscu",
  "nieprawidłowa wartość argumentu dla parametru atrybutu %sq",
  "za dużo argumentów atrybutu",
  "konwersja z niedostępnej klasy bazowej %t jest niedozwolona",
  "opcja „export” wymaga odrębnych podpisów szablonu",
  "literałów ciągu zawierających różne rodzaje znaków nie można łączyć",
  "usterka układu GNU nie jest emulowana, ponieważ umieszcza wirtualny element podstawowy %no1 poza granicami obiektu %no2",
  "wirtualny element podstawowy %no1 jest umieszczony poza granicami obiektu %no2",
  "niestandardowa nazwa kwalifikowana w deklaracji składowej przestrzeni nazw",
  "zmniejszenie wyrównania zostało zignorowane",
  "kwalifikator const został zignorowany",
  null,
  "nieprawidłowe kwalifikatory funkcji asm kompilatora GNU",
  "typ klasy, który nie może zostać w prosty sposób skopiowany, został przekazany za pomocą argumentu wielokropka",
  "typ klasy, który nie może zostać w prosty sposób skopiowany, nie może być pobierany za pomocą makra va_arg",
  "sufiks „u” lub „U” musi występować przed sufiksem „l” lub „L” w literale stałoprzecinkowym",
  "opcji „fixed_point” można użyć tylko w przypadku kompilowania kodu C",
  "operand całkowity może spowodować nadmiar operacji na liczbach stałoprzecinkowych",
  "stała stałoprzecinkowa jest poza zakresem",
  "wartości stałoprzecinkowej nie można reprezentować dokładnie",
  "stała jest za duża dla wartości typu long long — podano typ unsigned long long (niestandardowy)",
  "kwalifikator układu nie może kwalifikować wskaźnika do typu void ze specyfikatorem shared",
  "zduplikowana wartość THREADS w typie tablicy wielowymiarowej",
  "silna dyrektywa using może występować tylko w zasięgu przestrzeni nazw",
  "element %nf deklaruje funkcję bez szablonu — dodaj <>, aby przywołać wystąpienie szablonu",
  "operacja może spowodować nadmiar dla operacji na liczbach stałoprzecinkowych",
  "wyrażenie musi być typu całkowitego, wyliczeniowego lub stałoprzecinkowego",
  "wyrażenie musi być typu całkowitego lub stałoprzecinkowego",
  "funkcja zadeklarowana ze specyfikatorem „noreturn” używa instrukcji return",
  "nazwa funkcji asm została zignorowana, ponieważ tworzy konflikt z poprzednią deklaracją",
  "składowej klasy określonej za pomocą instrukcji typedef nie można zadeklarować ponownie",
  "pobieranie adresu zmiennej tymczasowej",
  "atrybuty zostały zignorowane w deklaracji klasy, która nie jest jednocześnie definicją",
  "wartość stałoprzecinkowa została niejawnie przekonwertowana na typ zmiennoprzecinkowy",
  "typy stałoprzecinkowe nie mają klasyfikacji",
  "parametr szablonu nie może być typu stałoprzecinkowego",
  "szesnastkowe stałe zmiennoprzecinkowe są niedozwolone",
  "opcja „named_address_spaces” może być używana tylko podczas kompilowania kodu C",
  "wartość zmiennoprzecinkowa nie mieści się w wymaganym typie stałoprzecinkowym",
  "nie można skonwertować wartości dokładnie na wartość stałoprzecinkową",
  "konwersja stałoprzecinkowa spowodowała zmianę znaku",
  "wartość całkowita nie mieści się w wymaganym typie stałoprzecinkowym",
  "wynik operacji stałoprzecinkowej jest poza zakresem",
  "wiele nazwanych przestrzeni adresowych",
  "zmienna z automatycznym okresem magazynu nie może być przechowywana w nazwanej przestrzeni adresowej",
  "typ nie może być kwalifikowany za pomocą nazwanej przestrzeni adresowej",
  "typ funkcji nie może być kwalifikowany za pomocą nazwanej przestrzeni adresowej",
  "typ pola nie może być kwalifikowany za pomocą nazwanej przestrzeni adresowej",
  "wartość stałoprzecinkowa nie mieści się w wymaganym typie zmiennoprzecinkowym",
  "wartość stałoprzecinkowa nie mieści się w wymaganym typie liczb całkowitych",
  "wartość nie mieści się w wymaganym typie stałoprzecinkowym",
  "opcja „named_registers” może być używana tylko podczas kompilowania kodu C",
  "klasa magazynu nazwanego rejestru jest w tym miejscu niedozwolona",
  "ponownie zadeklarowano element %nd przy użyciu niezgodnej klasy magazynu nazwanego rejestru",
  "nie można określić klasy magazynu nazwanego rejestru dla zmiennej z przypisanym aliasem",
  "specyfikator magazynu nazwanego rejestru jest już używany",
  "opcja „embedded_c” nie może być łączona z opcjami służącymi do kontrolowania poszczególnych funkcji zestawu Embedded C",
  "nieprawidłowy katalog EDG_BASE: %s",
  null,
  "nieprawidłowy wpis wstępnie zdefiniowanego makra w wierszu %s: %s2",
  "nieprawidłowa nazwa trybu makra %sq",
  "niezgodna zmiana definicji wstępnie zdefiniowanego makra %sq",
  "ponowna deklaracja elementu %nd nie ma klasy magazynu nazwanego rejestru",
  "nazwany rejestr jest zbyt mały dla typu zmiennej",
  "nie można deklarować tablic przy użyciu klasy magazynu nazwanego rejestru",
  "operacja rzutowania const_cast na typ wyliczenia jest niestandardowa",
  "opcja „embedded_c” może być używana tylko podczas kompilowania kodu C",
  "kwalifikator nazwanej przestrzeni adresowej jest w tym miejscu niedozwolony",
  "pusty inicjator jest nieprawidłowy dla tablicy z nieokreśloną granicą",
  "funkcja zwraca niekompletny typ klasy %t",
  "element %n został już zainicjowany. Inicjator poza klasą zostanie zignorowany.",
  "deklaracja ukrywa element %nd",
  "nie można przydzielić parametru w nazwanej przestrzeni adresowej",
  "nieprawidłowy sufiks w stałej stałoprzecinkowej lub zmiennoprzecinkowej",
  "nie można przydzielić zmiennej rejestru w nazwanej przestrzeni adresowej",
  "oczekiwano „SAT” lub „DEFAULT”",
  "element %n nie ma odpowiedniego składowego operatora delete%s (do wywołania w przypadku zgłoszenia wyjątku podczas inicjowania przydzielonego obiektu)",
  "nie można zadeklarować zmiennej lokalnej wątku przy użyciu atrybutu „dllimport” lub „dllexport”",
  "typ zwracany funkcji nie może być kwalifikowany za pomocą nazwanej przestrzeni adresowej",
  "nie można określić inicjatora dla elastycznej składowej tablicy, której elementy mają destruktor inny niż prosty",
  "nie można określić inicjatora dla pośredniej, elastycznej składowej tablicy",
  "nieprawidłowy numer wersji GNU: %s",
  "atrybuty zmiennej pojawiające się po inicjatorze w nawiasach są ignorowane",
  "wynik tego rzutowania nie może być używany jako l-wartość",
  "negacja wartości stałoprzecinkowej bez znaku",
  null,
  null,
  "nazwy rejestru mogą być używane tylko dla zmiennych rejestru",
  "zmienne nazwanego rejestru nie mogą mieć typu void",
  null,
  "parametry nie mogą mieć specyfikatorów zakresu linku",
  "wiele specyfikatorów zakresu linku",
  "specyfikatory zakresu linku mogą występować tylko w funkcjach i zmiennych z zewnętrznym powiązaniem",
  "ponowna deklaracja nie może osłabić zakresu linku",
  "specyfikator zakresu linku jest niedozwolony w tej deklaracji",
  "niestandardowa nazwa kwalifikowana w globalnej deklaracji zakresu",
  "niejawna konwersja 64-bitowego typu całkowitego na mniejszy typ całkowity (potencjalny problem z przenośnością)",
  "jawna konwersja 64-bitowego typu całkowitego na mniejszy typ całkowity (potencjalny problem z przenośnością)",
  "konwersja ze wskaźnika na typ całkowity o tym samym rozmiarze (potencjalny problem z przenośnością)",
  null,
  "specyfikator elementu zaprzyjaźnionego jest niedozwolony w definicji klasy. Specyfikator elementu zaprzyjaźnionego zostanie zignorowany.",
  "magazynu lokalnego wątku mogą używać tylko zmienne statyczne i zewnętrzne",
  "wiele specyfikatorów magazynu lokalnego wątku",
  "nie zdefiniowano wirtualnego elementu %n (nie może być też definiowany w innym miejscu, ponieważ jest składową nienazwanej przestrzeni nazw)",
  "znak powrotu karetki w wierszu w źródle poza komentarzem lub literałem znakowym/ciągu",
  "wyrażenie musi mieć typ stałoprzecinkowy",
  "nieprawidłowe użycie specyfikatora dostępu jest ignorowane",
  "wskaźnik skonwertowano na wartość logiczną",
  "wskaźnik do składowej skonwertowano na wartość logiczną",
  "zignorowano specyfikator magazynu",
  "atrybuty dllexport i dllimport są ignorowane w szablonach klas",
  "specyfikacja atrybutu dllexport/dllimport klasy bazowej różni się od specyfikacji klasy pochodnej",
  "ponowna deklaracja nie może dodać atrybutu dllexport/dllimport do elementu %nod",
  "atrybut dllexport/dllimport powoduje konflikt z elementem %nod; Przyjęto atrybut dllexport.",
  "nie można zdefiniować jednostki atrybutu dllimport",
  "atrybut dllexport/dllimport wymaga zewnętrznego wiązania",
  "składowa klasy zadeklarowana przy użyciu atrybutu dllexport/dllimport nie może sama zostać zadeklarowana z takim specyfikatorem",
  "pole typu klasy bez interfejsu biblioteki DLL używane w klasie z interfejsem biblioteki DLL",
  "deklaracja składowej w nawiasach jest niestandardowa",
  "zignorowano biały znak między ukośnikiem odwrotnym i znakiem nowego wiersza w operacji łączenia wierszy",
  "atrybut dllexport/dllimport powoduje konflikt z elementem %nod; Pominięto atrybut dllexport/dllimport.",
  "nieprawidłowa składowa dla anonimowej klasy składowej — klasa %t ma niedozwoloną funkcję składową",
  "niestandardowa instrukcja reinterpret_cast",
  "pozycyjny specyfikator formatu nie może być zerem",
  "klasa lokalna nie może odwoływać się do typu tablicy o zmiennej długości z funkcji otaczającej",
  "składowa %nd ma już jawny specyfikator atrybutu dllexport/dllimport",
  "tablica o zmiennej długości jest niedozwolona w typie zwracanym funkcji",
  "typ tablicy o zmiennej długości jest niedozwolony we wskaźniku do składowej typu %t",
  "wynik wyrażenia instrukcji nie może mieć typu obejmującego tablicę o zmiennej długości",
  "obsługa elementów trigraph jest wyłączona",
  "atrybut %sq może występować tylko w funkcjach i zmiennych z zewnętrznym powiązaniem",
  "tryb z ograniczeniami jest niezgodny z traktowaniem przestrzeni nazw std jako aliasu dla globalnej przestrzeni nazw",
  "w rozwinięciu makra „%s” %p",
  "<NIEZNANE>",
  "",
  "[liczba niewyświetlanych rozwinięć makr: %d]",
  "w rozszerzeniu makra w położeniu %p",
  "nieprawidłowa nazwa symboliczna argumentu operacji %sq",
  "symboliczne ograniczenie dopasowania musi odwoływać się do jednego z pierwszych dziesięciu argumentów operacji",
  "użycie instrukcji __if_exists nie jest obsługiwane w tym kontekście",
  "blok __if_exists nie jest zamknięty w tym samym zakresie, w którym został otwarty",
  "nie można dynamicznie inicjować zmiennej lokalnej wątku",
  "konwersja powoduje porzucenie kwalifikatora „__unaligned”",
  "niektóre wartości modułu wyliczającego nie mogą być reprezentowane przez typ całkowity, który jest bazowy dla typu wyliczenia",
  "argument domyślny jest niedozwolony w deklaracji zaprzyjaźnionego szablonu klasy",
  "literał znaków z wieloma znakami (potencjalny problem z przenośnością)",
  "oczekiwano typu class, struct lub union",
  "drugi argument operacji makra offsetof musi być polem",
  "drugi argument operacji makra offsetof nie może być polem bitowym",
  "nie można zastosować makra offsetof do składowej wirtualnej bazy",
  "makro OffsetOf zostało zastosowane względem typu innego niż klasa z układem standardowym",
  "argumenty domyślne są niedozwolone w deklaracji elementu zaprzyjaźnionego dotyczącej funkcji składowej",
  "argumenty domyślne są niedozwolone w deklaracjach elementów zaprzyjaźnionych, które nie są definicjami",
  "ponowna deklaracja elementu %nd zadeklarowanego poprzednio jako element zaprzyjaźniony z argumentami domyślnymi jest niedozwolona",
  "nieprawidłowy kwalifikator dla elementu %t (klasa pochodna jest w tym miejscu niedozwolona)",
  "nieprawidłowy kwalifikator dla definicji klasy %t",
  "brak wcześniejszej dyrektywy push_macro dla elementu %sq",
  "niedozwolony literał ciągu typu wide",
  null,
  "element %sq jest dozwolony tylko w kodzie C",
  "typy __ptr32 i __ptr64 muszą następować po znaku „*”",
  "nie mogą być stosowane oba typy __ptr32 i __ptr64",
  "lista argumentów szablonu %sq musi być zgodna z listą parametrów",
  "niekompletny typ klasy jest niedozwolony",
  "złożone typy całkowite nie są obsługiwane",
  "symbole __real i __imag mogą być stosowane tylko do wartości złożonych",
  "symbol __real/__imag zastosowano do wartości rzeczywistej",
  "element %nd został zadeklarowany jako przestarzały (%sq)",
  "nieprawidłowa ponowna definicja elementu %nd",
  "atrybut dllimport/dllexport zastosowano do składowej nienazwanej przestrzeni nazw",
  "konwencja __thiscall może występować tylko w deklaracjach niestatycznych funkcji składowych",
  "konwencja __thiscall jest niedozwolona w funkcji z parametrem wielokropka",
  "jawna specjalizacja elementu %n musi poprzedzać jego pierwsze użycie (%p)",
  "typ klasy zapieczętowanej nie może być używany jako klasa bazowa",
  "zduplikowany modyfikator klasy",
  "funkcja składowa nie może mieć obu modyfikatorów „abstract” i „sealed”",
  "zapieczętowana składowa nie może być tylko wirtualna",
  "nie można zadeklarować funkcji niewirtualnej przy użyciu modyfikatora „abstract” lub „sealed”",
  "funkcja członkowska zadeklarowana przy użyciu modyfikatora „override” nie przesłania składowej klasy bazowej",
  "nie można przesłonić zapieczętowanego elementu %nd",
  "element %nd zadeklarowano przy użyciu modyfikatora klasy „abstract”",
  "w wierszu ",
  " w ",
  "gdzie ",
  "słowo kluczowe",
  "makro",
  "etykieta",
  "parametr szablonu",
  null,
  null,
  null,
  null,
  "szablon parametryzujący szablon",
  "szablon",
  "szablon klasy",
  null,
  "parametr",
  "parametr procedury obsługi",
  "zmienna",
  "bez typu",
  null,
  "funkcja",
  "funkcja przeciążona",
  "składowa",
  "pole",
  null,
  "nazwany rejestr",
  "nazwana przestrzeń adresowa",
  "szablon funkcji",
  "oparto na argumencie szablonu",
  "oparto na argumentach szablonu",
  " (zadeklarowane ",
  "(na końcu źródła)",
  "Na końcu źródła",
  "Wiersz",
  "wiersz",
  "kol.",
  "uwaga",
  "Uwaga",
  "ostrzeżenie",
  "Ostrzeżenie",
  "błąd",
  "Błąd",
  "błąd krytyczny",
  "Błąd krytyczny",
  "błąd wiersza polecenia",
  "Błąd wiersza polecenia",
  "błąd wewnętrzny",
  "Błąd wewnętrzny",
  null,
  null,
  "Osiągnięto limit błędów.",
  "Pętla błędu wewnętrznego",
  "Przetwarzanie pętli w błędzie krytycznym.",
  null,
  "tymczasowe",
  "dane wyjściowe przetwarzania wstępnego",
  "nieprzetworzona lista",
  "odsyłacz",
  "język pośredni (1)",
  "język pośredni (2)",
  "język pośredni (3)",
  "język pośredni (4)",
  "język pośredni (5)",
  "język pośredni (6)",
  "język pośredni (7)",
  "język pośredni (8)",
  "język pośredni (9)",
  null,
  null,
  null,
  null,
  null,
  "brak flagi cannot-redefine",
  "brak trybu po znaku „,”",
  "brak nazwy makra",
  "nieprawidłowa wartość flagi cannot-redefine",
  "zduplikowany modyfikator funkcji",
  "nieprawidłowy znak dla literału char16_t",
  null,
  "nierozpoznana konwencja wywoływania %s. Musi ona być jedną z następujących:",
  null,
  null,
  null,
  "typ bazowy typu wyliczenia musi być typem całkowitoliczbowym",
  "niektóre stałe modułu wyliczającego nie mogą być reprezentowane przez element %t",
  "element %sq jest niedozwolony w bieżącym trybie",
  "opcja pomocników cech typu może być używana tylko podczas kompilowania kodu C++",
  "atrybut „sentinel” wymaga parametru wielokropka",
  "argument musi być stałą wartością wskaźnika null",
  "niewystarczająca liczba argumentów dla wartości wartownika",
  "argument wartownika musi odpowiadać parametrowi wielokropka",
  "deklaracja __declspec(implementation_key(...) może wystąpić tylko między dyrektywami #pragma start_map_region i #pragma stop_map_region",
  "dyrektywa #pragma start_map_region jest już aktywna: dyrektywa pragma została zignorowana ",
  "żadna dyrektywa #pragma start_map_region nie jest obecnie aktywna: dyrektywa pragma została zignorowana ",
  "element %n nie może być używany do nadawania nazwy destruktorowi (wymagana jest nazwa typu)",
  "niestandardowy, pusty literał znaków typu wide traktowany jako L'\\0'",
  "nie można w tym miejscu określić słowa kluczowego „typename”",
  "niezlokalizowany operator delete musi być widoczny w klasie z wirtualnym destruktorem",
  "powiązanie z nazwą powoduje konflikt z poprzednią deklaracją elementu %nd",
  "alias tworzy cykl jednostek z przypisanym aliasem",
  null,
  "nie można zadeklarować zmiennej ze statycznym okresem magazynu przydzielonym w określonym rejestrze, używając inicjatora",
  "zmienna przydzielona w określonym rejestrze musi być możliwa do skopiowania w prosty sposób",
  "odrzucono wstępnie zdefiniowane znaczenie elementu %no",
  null,
  "typ klasy nieodpowiedni do użycia z desygnatorami",
  null,
  "kwalifikator unii anonimowej jest niestandardowy",
  "zignorowano kwalifikator unii anonimowej",
  null,
  "zignorowano słowo kluczowe __declspec(%s) (w przypadku struktury języka C nie ma ono żadnego znaczenia)",
  "specyfikatory po przecinku między deklaracjami są niestandardowe",
  "zignorowano niestandardowy specyfikator",
  "atrybuty są ignorowane w deklaracji wyliczenia, która nie jest też definicją",
  "deklarowanie odwołania ze słowem kluczowym „mutable” jest niestandardowe",
  "deklaracja warunku dla tablicy zawsze ma wartość true",
  "nie powiodła się asercja statyczna z %sq",
  "zignorowano atrybut widoczności, ponieważ powoduje konflikt z poprzednią deklaracją",
  "nazwa pola wskazuje na więcej niż jedno przesunięcie — zobacz %nod1 i %nod2",
  "%sq nie jest nazwą pola",
  "wartość etykiety case pojawiła się już w tej instrukcji switch %p",
  "funkcja składowa nie może mieć wiązania wewnętrznego",
  "deklaracja ukrywa wbudowany element %n",
  "deklaracja przeciąża wbudowany element %n",
  "opcja wyświetlająca definicje makr nie może być określona podczas kompilowania więcej niż jednej jednostki translacji",
  "nieoczekiwany nawias po deklaracji elementu %n (być może zniekształcona lista parametrów lub nieprawidłowy inicjator)",
  "nawiasy otaczające inicjator ciągu są niestandardowe",
  "__interface",
  "zmienna zadeklarowana przy użyciu specyfikatora typu auto nie może występować w jego własnym inicjatorze",
  "nie można ustalić typu „auto”",
  "inicjowanie przy użyciu „{...}” jest niedozwolone dla typu „auto”",
  "typ „auto” nie może występować w typie tablicy najwyższego poziomu",
  "typ „auto” nie może występować w typie funkcji najwyższego poziomu",
  "składowa typu %t nie może mieć inicjatora w obrębie klasy",
  "składowa z inicjatorem w obrębie klasy musi być stałą",
  "nie można ustalić typu „auto” (wymagany inicjator)",
  "typ „auto” dla tej jednostki to %t1, ale poprzednio sugerowano, że będzie to %t2",
  "nieprawidłowa deklaracja konstruktora",
  "nieprawidłowe użycie kwalifikatora typu",
  "unia nie może być abstrakcyjna lub zapieczętowana",
  "typ „auto” jest niedozwolony w tym miejscu",
  "definicja typu klasy bazowej nie została jeszcze zakończona",
  "słowa kluczowe „extern template” nie mogą się odwoływać do specjalizacji elementu statycznego %nd",
  "słowa kluczowe „extern template” nie mogą następować po jawnym tworzeniu wystąpienia elementu %n",
  "słowo kluczowe __declspec(restrict) wymaga funkcji zwracającej typ wskaźnika",
  "opcja „report_gnu_extensions” jest prawidłowa tylko w trybach GNU C i GNU C++",
  "typy tablicy o zmiennej długości są niestandardowe",
  "desygnatory są niestandardowe",
  "ta składnia desygnatora jest rozszerzeniem GNU",
  "literały złożone są niestandardowe",
  "wyrażenia instrukcji są rozszerzeniem GNU",
  "zignorowano nazwę funkcji asm dla poprzednio zdefiniowanej jednostki",
  "atrybuty są rozszerzeniem GNU",
  "rozszerzona składnia funkcji asm jest funkcją GNU",
  "nietrwałe deklaracje funkcji asm są rozszerzeniem GNU",
  "specyfikatory nazwy funkcji asm są rozszerzeniem GNU",
  "kwalifikator „__restrict” jest niestandardowy",
  "operator „typeof” jest rozszerzeniem GNU",
  "modyfikowanie rozmiaru lub znakowości konstrukcji typedef jest niestandardowe",
  "tablice o zerowej długości są rozszerzeniem GNU",
  "elastyczne składowe tablicy są niestandardowe",
  "atrybut „nonnull” odwołuje się do parametru niewskaźnikowego",
  "argument atrybutu „nonnull” jest większy niż liczba parametrów",
  "żaden parametr nie ma typu wskaźnika",
  "argument o wartości null udostępniony dla parametru oznaczono przy użyciu atrybutu „nonnull”",
  "destruktor dla elementu %t1 został pominięty, ponieważ destruktor dla elementu %t2 jest niedostępny",
  "destruktor pominięty dla elementu %t jest wymagany",
  "procedura jest oznaczona jednocześnie jako „inline” i jako „noinline”",
  "nieprawidłowa procedura czyszczenia",
  "atrybut „cleanup” wymaga automatycznego okresu magazynu",
  "atrybut „cleanup” nie dotyczy parametrów",
  "procedura czyszczenia ma nieprawidłowy typ",
  "wywołanie procedury czyszczenia wymaga konwersji elementów podejrzanych",
  "modyfikatory __sptr i __uptr muszą następować po znaku „*”",
  "modyfikatory __sptr i __uptr nie mogą być określone razem",
  "poszerzanie konwersji wskaźnika z %t1 na %t2 powoduje rozszerzenie bitu znaku",
  "modyfikatory __sptr i __uptr nie dotyczą typów wskaźnika do składowej",
  "deklaracja kopiującego operatora przypisania dla elementu %t została pominięta, ponieważ element %n to stała",
  null,
  "deklaracja kopiującego operatora przypisania dla elementu %t1 została pominięta, ponieważ pominięto deklarację elementu %t2",
  "deklaracja kopiującego operatora przypisania dla elementu %t1 została pominięta, ponieważ deklaracja elementu %t2 jest niejednoznaczna",
  "deklaracja kopiującego operatora przypisania dla elementu %t1 została pominięta, ponieważ deklaracja elementu %t2 jest niedostępna",
  "deklaracja konstruktora kopiującego dla elementu %t1 została pominięta, ponieważ pominięto deklarację elementu %t2",
  "deklaracja konstruktora kopiującego dla elementu %t1 została pominięta, ponieważ deklaracja elementu %t2 jest niejednoznaczna",
  "deklaracja konstruktora kopiującego dla elementu %t1 została pominięta, ponieważ deklaracja elementu %t2 jest niedostępna",
  "destruktor dla elementu %t1 nie będzie wywoływany, ponieważ jest niedostępny, a destruktor dla elementu %t2 został pominięty",
  "po definicji na końcu pliku nie następuje średnik lub deklarator",
  "pierwszy argument musi być wskaźnikiem do typu liczby całkowitej lub wyliczenia",
  "operacje synchronizowane są prawidłowe tylko dla obiektów o rozmiarze 1, 2, 4 lub 8",
  "zignorowano dodatkowe argumenty",
  "przyjęto, że po nazwie makra %sq w definicji wiersza polecenia następuje znak „=” ",
  "biały znak jest wymagany między nazwą makra %sq i jego tekstem zastępczym",
  "wynik wywołania nie jest używany",
  "atrybut „warn_unused_result” jest ignorowany dla typu zwracanego void",
  null,
  "atrybut dllimport/dllexport jest ignorowany w ponownej deklaracji przy użyciu nazwy kwalifikowanej",
  "zbyt wiele znaków w literale znakowym — zignorowano dodatkowe znaki wiodące",
  "nie można zadeklarować elementu %n jako inline po jego definicji %p",
  null,
  null,
  "argument szablonu nie może odwoływać się do typu bez wiązania z nazwą",
  "zignorowano „virtual” w tym miejscu",
  "argument szablonu nie może odwoływać się do typu tablicy o zmiennej długości",
  "nazwa zawierająca znaki uniwersalne nie może wyznaczyć zastępczego punktu kodu",
  "dyrektywa #include_next nie może być używana w podstawowym pliku źródłowym",
  "nie można określić elementu %no1 w definicji składowej szablonu — przyjęto w zamian element %no2",
  "atrybut %sq jest ignorowany w deklaracji funkcji lokalnej",
  "konkatenacja z elementem %sq w elemencie %n nie tworzy prawidłowego tokenu",
  "element %no jest niejednoznaczny (przyjęto element %n2)",
  "kwalifikator typu jest niedozwolony w statycznej funkcji składowej",
  "kwalifikator typu jest niedozwolony w konstruktorze lub destruktorze",
  "kwalifikator typu jest niedozwolony w operatorze new lub delete",
  "kwalifikator typu jest niedozwolony w funkcji innej niż członkowska",
  "argument dla %s ma skutki uboczne, ale nie jest oceniony",
  "nierozpoznany rodzaj źródła Unicode (jedna z następujących opcji: UTF-8, UTF-16, UTF-16LE, UTF-16BE): %s",
  "znaku Unicode o wartości szesnastkowej %s nie można przedstawić w danych wyjściowych przetwarzania wstępnego",
  "żądany priorytet konstruktora/destruktora jest zarezerwowany do użytku wewnętrznego",
  "nierozpoznana dyrektywa pragma GCC",
  "nierozpoznana dyrektywa pragma widoczności GCC",
  "nierozpoznany rodzaj widoczności",
  "dyrektywa pragma widoczności była nadal aktywna",
  "brak zgodnego wypychania widoczności",
  "operator typeid niekompletnego typu",
  null,
  "przyjęto, że tablica %n będzie mieć jeden element",
  "atrybut vector_size wymaga typu arytmetycznego lub typu wyliczenia",
  "rozmiar wektora jest zbyt duży",
  "liczba elementów w wektorze musi być potęgą liczby dwa",
  "rozmiar wektora musi wielokrotnością rozmiaru elementu",
  "mieszana operacja wektorowo-skalarna jest niedozwolona",
  "operacja wymaga dwóch wektorów o tym samym rozmiarze",
  "rozmiar wektora zależny od szablonu jest niedozwolony",
  null,
  null,
  "atrybut vector_size jest niedozwolony w przypadku typu złożonego elementu",
  null,
  "operacja wektorowa wymaga identycznych typów elementów",
  "operacja wektorowa nie dotyczy wektora z typem niecałkowitym",
  "nie można otworzyć pliku %s %sq2",
  "nie można otworzyć pliku %s %sq2: %s3",
  "prekompilowany nagłówek",
  "wstępnie zdefiniowane makro",
  "wygenerowany kod C",
  "wygenerowany kod C++",
  "źródło",
  "błąd podczas zapisywania pliku %s: %s2",
  "plik nie jest zwykły",
  "jest katalogiem",
  "nieprawidłowa nazwa pliku",
  "lista definicji",
  "żądanie tworzenia wystąpienia",
  "szablon wyeksportowany",
  "informacje o eksporcie",
  "informacje o szablonie",
  "dane wyjściowe języka pośredniego (IL)",
  "konwersja usuwa kwalifikator „__restrict”",
  "nie można uzyskać zamapowanej pamięci dla elementu %sq: %s2",
  "kwalifikator restrict jest ignorowany",
  null,
  "tablica elementów zawierająca elastyczną składową tablicy jest niestandardowa",
  "parametr szablonu nie może mieć typu wektora",
  "inicjowanie elementu %n1 zostanie wykonane przed inicjowaniem elementu %n2",
  null,
  "rodzaj dziedziczenia jest ignorowany w specyfikatorze wyliczenia",
  null,
  "modyfikator jest ignorowany w specyfikatorze wyliczenia",
  "znak identyfikatora nie może być reprezentowany w standardzie Unicode",
  "nazwa nagłówka zawiera znaki, które nie mogą być reprezentowane w standardzie Unicode",
  "%sq to nieprawidłowa nazwa ustawień regionalnych",
  "deklarowanie listy parametrów void przy użyciu parametru szablonu jest niestandardowe",
  "opcja lambdas może być używana tylko podczas kompilowania kodu C++",
  "jawne przechwytywanie jest zgodne z wartością domyślną",
  "%n nie jest zmienną",
  "zmienna ze statycznym okresem magazynu nie może być przechwytywana w wyrażeniu lambda",
  "słowo kluczowe „this” nie może być przechwytywane przez referencję",
  "Słowo kluczowe „this” nie może być używane wewnątrz treści tego wyrażenia lambda",
  "składowa unii anonimowej o zewnętrznym zakresie nie może być przywoływana wewnątrz treści wyrażenia lambda",
  "zmienna lokalna funkcji otaczającej nie może być przywoływana w treści wyrażenia lambda, chyba że znajduje się ona na liście przechwytywania",
  "nieprawidłowe odwołanie do zmiennej lokalnej o zewnętrznym zakresie w treści wyrażenia lambda",
  "nie można przechwytywać zmiennej lokalnej poza bieżącym zakresem funkcji",
  "słowo kluczowe „this” funkcji otaczającej nie może być przywoływane w treści wyrażenia lambda, chyba że znajduje się ono na liście przechwytywania",
  null,
  "nie można skopiować przechwyconej przez wyrażenie lambda zmiennej typu %t1 do pola klasy zamknięcia typu %t2",
  "nieprawidłowy katalog szablonu: %s",
  "błąd",
  "błędy",
  "błąd krytyczny",
  "błędy krytyczne",
  "oraz",
  "wykryto w kompilacji elementu „%s”.",
  "wykryto w tej kompilacji.",
  "wartość wyliczenia jest poza zakresem jej typu podstawowego (%t)",
  "znak „\\”, po którym następuje biały znak, nie jest znakiem łączenia wierszy",
  "nie można wykonać tej operacji dynamic_cast bez informacji o typie środowiska uruchomieniowego, które są wyłączone",
  "Konwersja do elementu %t jest niejednoznaczna. Wybrano bezpośrednią klasę podstawową.",
  "bufor wewnętrzny byłby zbyt duży",
  "użyto procedury obsługi wyjątków języka C++, ale nie została określona semantyka obsługi wyjątków",
  "w konstruktorze zignorowano kwalifikator typu",
  "zmienna przechwycona przez wyrażenie lambda nie może mieć typu uwzględniającego tablicę o zmiennej długości",
  "konwersja między niezgodnymi typami wektorów",
  "oczekiwano znaku „{” wprowadzającego treść wyrażenia lambda",
  "opcja odwołań do r-wartości może być używana tylko podczas kompilowania kodu C++",
  "kwalifikator typu jest niedozwolony w wyrażeniu lambda",
  "nazwa nie może występować więcej niż raz na liście przechwytywania",
  "zignorowano jawne argumenty szablonu",
  "wyrażenie lambda jest niedozwolone w wyrażeniu stałej",
  "%t nie jest typem klasy",
  "słowo kluczowe „delete” zastosowane do typu wskaźnika do tablicy potraktowano jako delete[]",
  "Słowo kluczowe „delete” zastosowane do typu wskaźnika do tablicy jest niestandardowe. Potraktowano je jako delete[].",
  "elementu %n nie można wywołać przy użyciu podanej listy argumentów",
  "odwołanie do r-wartości nie może być powiązane z l-wartością",
  "parametr szablonu bez typu nie może mieć typu referencyjnego do r-wartości",
  "kwalifikatory typu są ignorowane (typ bazowy to odwołanie)",
  "element %n deklarowany przy użyciu typu lokalnego musi być zdefiniowany w tej jednostce translacji",
  "element %n deklarowany przy użyciu typu bez wiązania musi być zdefiniowany w tej jednostce translacji",
  "argument operacji dynamic_cast odwołania do r-wartości musi mieć kompletny typ klasy",
  "wyrażenie „= default” może występować tylko w konstruktorach domyślnych, konstruktorach kopiujących/przenoszących, kopiujących/przenoszących operatorach przypisania i destruktorach",
  "„= delete” może występować tylko w pierwszej deklaracji funkcji",
  "element %npd nie może być przywoływany — jest to usunięta funkcja",
  "wyrażenie lambda jest niedozwolone w wyrażeniu, którego nie obliczono",
  "funkcja __builtin_va_arg_pack/__builtin_va_arg_pack_len może występować tylko w funkcji wbudowanej z parametrem wielokropka",
  "„= default” nie można określić w deklaracji elementu zaprzyjaźnionego",
  "oczekiwano słowa kluczowego języka C++",
  null,
  "przesunięcie nie jest stałą",
  "dla dyrektywy #pragma znaleziono nierozpoznany typ komentarza %sq",
  "opcja kontrolująca, czy słowo kluczowe „auto” to specyfikator typu, może być używana tylko podczas kompilowania kodu C++",
  "opcja kontrolująca, czy słowo kluczowe „auto” to klasa magazynu, może być używana tylko podczas kompilowania kodu C++",
  "znaczenia „auto” specyfikatora typu i specyfikatora klasy magazynu nie mogą być oba wyłączone",
  "nieprawidłowy ciąg w komentarzu dyrektywy #pragma",
  "usunięta funkcja przesłania nieusuniętą funkcję %n",
  "nieusunięta funkcja przesłania usuniętą funkcję %n",
  "nie można przywoływać domyślnego konstruktora elementu %t — jest to usunięta funkcja",
  "odwołanie do r-wartości jest niedozwolone jako typ przechwytywania",
  "domyślne argumenty elementu %n są niezgodne z deklaracją w innej jednostce translacji",
  "domyślne argumenty elementu %n były inne podczas kompilacji elementu %sq",
  null,
  "inicjator dla elementu %n różni się w innej jednostce translacji",
  "inicjator dla elementu %n był inny podczas kompilacji elementu %sq",
  "desygnator do typu zależnego od szablonu jest niedozwolony",
  "nierozpoznany rodzaj zgodności",
  "oczekiwano „on” lub „off”",
  "stos dyrektywy #pragma conform(forScope) jest pusty",
  "brak poprzedniej pozycji dyrektywy #pragma conform(forScope) zgodnej z elementem %sq",
  "zachowanie atrybutu forScope jest niestandardowe",
  "zachowanie atrybutu forScope jest standardowe",
  "nie można usunąć funkcji „main”",
  "kwalifikatory typu nie mają w tym miejscu znaczenia",
  "nieprawidłowy typ dla domyślnego operatora przypisania",
  "szablony funkcji nie mogą być domyślnymi",
  "nieprawidłowy typ dla domyślnego konstruktora",
  "wywołanie funkcji wymaga jednego argumentu",
  "wywołanie funkcji wymaga rzeczywistego argumentu zmiennoprzecinkowego",
  "konstruktor kopiujący z domyślnym argumentem nie może być domyślny",
  "nie można usunąć wcześniej zadeklarowanej funkcji",
  "pusta instrukcja zależna w instrukcji if",
  "pusta instrukcja zależna w klauzuli „else” instrukcji if",
  "element %nfd wymagany dla kopii, która została wyeliminowana, nie może być przywoływany — jest to usunięta funkcja",
  "Niestandardowy pierwszy parametr %t funkcji „main”. Oczekiwano „int”.",
  "Niestandardowa liczba parametrów funkcji „main”. Oczekiwana liczba parametrów to zero lub dwa.",
  "Niestandardowy drugi parametr %t funkcji „main”. Oczekiwano „char *[]” lub „char **”.",
  "element %sq określono jako systemowy i niesystemowy katalog dołączenia — pozycja niesystemowa będzie ignorowana",
  "opcja kontrolująca konstruktory przenoszące i przenoszące operatory przypisania może być używana tylko podczas kompilowania kodu C++",
  null,
  null,
  "końcowy typ zwracany wymaga specyfikatora typu „auto”",
  "końcowy typ zwracany nie może występować w zagnieżdżonym deklaratorze",
  "deklarator funkcji z końcowym typem zwracanym musi być poprzedzony prostym specyfikatorem typu „auto”",
  "funkcja „auto” wymaga końcowego typu zwracanego",
  "szablon składowej nie może mieć czystego specyfikatora",
  "zbyt długi literał ciągu — zignorowano nadmiarowe znaki",
  "opcja kontrolująca słowo kluczowe nullptr może być używana tylko podczas kompilowania kodu C++",
  "typ std::nullptr_t skonwertowano na typ logiczny",
  null,
  null,
  "atrybut %sq nie zezwala na pustą listę argumentów",
  "atrybut występuje więcej niż raz",
  "atrybut %sq nie ma w tym miejscu zastosowania",
  "atrybut %sq nie ma zastosowania do pól bitowych",
  "atrybut %sq wymaga pola bitowego",
  "atrybut %sq nie ma zastosowania do funkcji składowych",
  "atrybut %sq wymaga funkcji składowej",
  "atrybut %sq nie ma zastosowania do funkcji wirtualnych",
  "atrybut %sq wymaga funkcji wirtualnej",
  "atrybut %sq nie ma zastosowania do czystych funkcji wirtualnych",
  "atrybut %sq wymaga czystej funkcji wirtualnej",
  "atrybut %sq nie ma zastosowania do zmiennych rejestru",
  "atrybut %sq wymaga zmiennej rejestru",
  "atrybut %sq nie wystąpił w oryginalnej deklaracji",
  "atrybuty są niedozwolone w tym miejscu",
  "atrybut %sq musi występować w definicji klasy",
  "modyfikator „final” zastosowano do czystej funkcji wirtualnej",
  "nie można przesłonić modyfikatora „final” %nd",
  "statyczny element %n potraktowano jako zewnętrzny, ponieważ został przywołany, ale nie zdefiniowany",
  "opcja włączająca wbudowywanie w stylu GNU-C89 może być używana tylko podczas kompilowania kodu C",
  "funkcja została poprzednio zadeklarowana bez atrybutu „gnu_inline”",
  "atrybut „gnu_inline” jest ignorowany w funkcjach innych niż wbudowane",
  "funkcja %n została poprzednio zadeklarowana bez atrybutu carries_dependency",
  "nieprawidłowy inicjator dla tablicy %n",
  "podczas tworzenia biblioteki środowiska uruchomieniowego należy określić tryb C++11 lub C++14",
  "atrybut %sq nie ma zastosowania do typów funkcji",
  "atrybut %sq wymaga typu funkcji",
  "atrybut %sq nie ma zastosowania do niestatycznych funkcji składowych",
  "atrybut %sq nie ma zastosowania do automatycznych zmiennych",
  "atrybut %sq wymaga automatycznej zmiennej",
  "atrybut %sq nie ma zastosowania do zmiennej lub funkcji z zewnętrznym powiązaniem",
  "atrybut %sq wymaga zmiennej lokalnej",
  "atrybuty zignorowano w tym miejscu",
  "atrybut nie ma zastosowania do żadnej jednostki",
  "zamiana niepoprawnego argumentu atrybutu",
  "argument atrybutu „tls_model” musi mieć wartość „global-dynamic”, „local-dynamic”, „initial-exec” lub „local-exec”",
  "w deklaracji %p określono inny argument „tls_model”",
  "atrybut %sq nie ma zastosowania do funkcji wbudowanych",
  "atrybut %sq wymaga funkcji wbudowanej",
  "obie nazwy plików w dyrektywie pragma include_alias muszą używać tych samych znaków ograniczających",
  "porównanie między argumentami operacji ze znakiem i bez znaku",
  "zignorowano atrybut %sq w nienazwanym typie",
  "zignorowano atrybut %sq, ponieważ nie następuje po nim żadna definicja",
  "umiejscowienie wątku jest niezgodne z poprzednią deklaracją elementu %nd",
  "ta zmienna lokalna funkcji otaczającej nie może być przywoływana w treści tego wyrażenia lambda, ponieważ otaczające wyrażenie lambda nie zezwala na niejawne przechwytywania",
  "ten argument atrybutu zawiera niedopasowane nawiasy, nawiasy kwadratowe lub nawiasy klamrowe",
  "wywołanie funkcji __builtin_fpclassify wymaga pięciu argumentów całkowitoliczbowych, po których następuje jeden argument zmiennoprzecinkowy",
  "ostatni argument w wywołaniu funkcji __builtin_fpclassify musi mieć rzeczywisty typ zmiennoprzecinkowy",
  "nie można ustawić wyrównania na mniejsze niż domyślne wyrównanie",
  "atrybuty są niedozwolone w jawnych tworzeniach wystąpień",
  "atrybut %sq nie ma zastosowania do definicji",
  "atrybut %sq wymaga definicji",
  "standardowe atrybuty nie mogą występować w deklaracjach elementów zaprzyjaźnionych, które nie są definicjami",
  "określone wyrównanie (%s1) różni się od wyrównania (%s2) określonego w poprzedniej deklaracji",
  "atrybut wyrównania musi również występować w definicji %p",
  "element %n nie może być używany w identyfikatorze typu deklaracji aliasu",
  "szablon aliasu",
  "element %t nie może być przezroczysty, ponieważ jego pierwsze pole ma typ zmiennoprzecinkowy",
  "element %t nie może być przezroczysty, ponieważ jego pierwsze pole to pole bitowe",
  "funkcja wirtualna klasy „base_check” przesłania składową klasy bazowej, ale nie ma atrybutu „override”",
  "atrybut „hiding” określono w deklaracji, która nie ukrywa deklaracji klasy bazowej",
  "atrybut „hiding” określono w deklaracji, do której odwołuje się deklaracja using %p",
  "atrybut „hiding” jest wymagany w deklaracji (w klasie „base_check”), która ukrywa element %nd",
  "element %n nie jest zdefiniowany w tej jednostce translacji, ale zależy od typu lokalnego",
  "element %n nie jest zdefiniowany w tej jednostce translacji, ale zależy od typu bez wiązania",
  "brak atrybutu %sq w innej jednostce translacji",
  "atrybut %sq powoduje konflikt z inną jednostką translacji",
  "opcja „nonstd_gnu_keywords” jest poprawna tylko w trybach GNU C i GNU C++",
  "użycie zmiennej stałej w wyrażeniu stałej jest niestandardowe w języku C",
  "nie można określić inicjatora dla elastycznej składowej tablicy z automatycznym okresem magazynu",
  null,
  "typ klasy „final” nie może być używany jako klasa bazowa",
  "szablony wyeksportowane nie są już obecne w standardowym języku C++",
  "desygnator zależny od szablonu jest niedozwolony",
  "drugi argument operacji makra offsetof nie może być polem z typem referencyjnym",
  "obiekty tymczasowe o długim czasie życia są niezgodne z innymi żądanymi nowszymi funkcjami języka",
  "literał ciągu znaków typu wide nie będzie podawany w diagnostyce",
  "brak argumentów dla atrybutu %sq",
  "opcje „c++11” i „c++11_sfinae” wymagają innej konfiguracji kompilatora",
  "pakiet parametrów szablonu nie znajduje się na końcu listy parametrów",
  "deklaracja pakietu parametrów nie jest tutaj dozwolona",
  "pakiet parametrów nie może mieć wartości domyślnej",
  "kod C++/CLI może zostać włączony tylko w trybie Microsoft C++",
  "wyrażenie „value__” nie może być używane jako nazwa wartości stałej modułu wyliczającego (w tym kontekście jest to nazwa zastrzeżona)",
  "w typie wyliczenia z typem bazowym Boolean jest wymagana jawna wartość modułu wyliczającego",
  null,
  "utworzono odwołanie do pakietu parametrów %sq, ale nie został on rozwinięty",
  "rozwinięcie pakietu nie korzysta z żadnych pakietów argumentów",
  "pakiet %sq nie zawiera takiej samej liczby elementów jak %sq2",
  null,
  "atrybut vector_size nie jest dozwolony dla typu wyliczenia",
  "właściwość nie może być jednocześnie statyczna i wirtualna",
  "właściwość indeksowania nie może być prosta",
  "ta deklaracja nie może występować w definicji właściwości",
  "nie można używać typu funkcji kwalifikowanej w celu deklarowania funkcji dostępu",
  "funkcja dostępu nie może mieć parametru wielokropka",
  "metoda dostępu „get” została już zadeklarowana dla tej właściwości %p",
  "metoda dostępu „set” została już zadeklarowana dla tej właściwości %p",
  "metoda dostępu „get” nie może posiadać parametru",
  "zwracany typ metody dostępu „get” nie jest zgodny z typem właściwości",
  "zwracany typ metody dostępu „set” musi być typem void",
  "właściwość nie może deklarować pustej listy indeksów",
  "indeks właściwości nie może mieć typu void",
  "typ indeksu nie jest zgodny z odpowiadającym mu parametrem w metodzie dostępu „set”",
  "typ indeksu nie jest zgodny z odpowiadającym mu parametrem w metodzie dostępu „get”",
  "w metodzie dostępu „set” brakuje typu indeksu",
  "w metodzie dostępu „get” brakuje typu indeksu",
  "w metodzie dostępu „set” brakuje parametru wartości",
  "funkcja dostępu ma zbyt wiele parametrów",
  "ostatni parametr metody dostępu „set” nie jest zgodny z typem właściwości",
  "element %sq wymaga trybu C++/CLI",
  "błąd w interfejsie API Win32 „%s”: %s",
  "dyrektywa #using może być używana tylko w zakresie globalnym",
  "metadane",
  "nazwa składowej %sq jest zastrzeżona przez element %nd",
  "oczekiwano „[”",
  "tryb %[C++/CLI] wymaga wersji microsoft_version >= 1600",
  "właściwość indeksowana domyślnie nie może być statyczna",
  "metoda dostępu do właściwości nie może być jednocześnie statyczna i wirtualna",
  "specyfikator widoczności najwyższego poziomu nie może występować w deklaracji typu zagnieżdżonego",
  "specyfikator widoczności najwyższego poziomu wymaga definicji typu",
  "właściwość prosta nie może mieć typu referencyjnego",
  "właściwość prosta nie może być typu const ani volatile",
  "element %nd został wcześniej zadeklarowany jako inny rodzaj typu wyliczenia",
  "zmienna przechwycona przez element lambda nie może mieć klasy typu %[managed]",
  "przesłanianie funkcji wirtualnej za pomocą kowariantnego typu zwracanego jest niedozwolone w klasie typu %[managed]",
  "tablica dojść jest niedozwolona",
  "dojście do tablicy jest niedozwolone",
  "dojście do funkcji jest niedozwolone",
  "dojście do typu void jest niedozwolone",
  "dojście do uchwytu, wskaźnika lub odwołania jest niedozwolone",
  "odwołanie śledzące do funkcji jest niedozwolone",
  null,
  "pole nie może być odwołaniem śledzącym",
  "nie można łączyć w ten sposób odwołania śledzącego ze zwykłym odwołaniem",
  "zmienna ze statycznym okresem magazynu nie może mieć klasy typu referencyjnego",
  "klasa typu %[managed] nie może być nienazwana",
  "klasa typu %[managed] nie może być lokalna",
  "element %nd został wcześniej zadeklarowany jako inny rodzaj klasy",
  "element %nd został wcześniej zadeklarowany jako inny rodzaj szablonu klasy",
  "literały składowych danych mogą być tylko składowymi klas typu %[managed]",
  "literał składowej danych musi być zainicjowany",
  "literał składowej danych typu %t jest niedozwolony",
  "wartość stała nie ma wpływu na literał składowej danych",
  "składowe danych initonly mogą być tylko składowymi klas typu %[managed]",
  "wartość stała nie ma wpływu na składową danych initonly",
  "element %nd nie ma metody dostępu „get”",
  "element %nd nie ma metody dostępu „set”",
  "konstruktor statyczny nie może mieć parametrów",
  "konstruktor statyczny nie może być szablonem składowej",
  "złożone wartościowanie lewostronne nie jest dozwolone jako wyjściowy argument operacji asm",
  "właściwości mogą być tylko składowymi klas typu %[managed]",
  "kwalifikator typu jest niedozwolony dla funkcji składowej klasy typu %[managed]",
  "zwykły wskaźnik do klasy interfejsu lub klasy referencyjnej %[C++/CLI] nie jest dozwolony",
  "zwykłe odwołanie do klasy interfejsu lub klasy referencyjnej %[C++/CLI] nie jest dozwolone",
  "specyfikator przesłonięcia nie nadaje nazwy funkcji członkowskiej klasy bazowej",
  "specyfikator przesłonięcia wyznacza niewirtualną składową %nd",
  "funkcja składowa przesłania element %nd1, który jest już przesłonięty przez element %nd2",
  "dozwolony jest co najwyżej jeden specyfikator widoczności",
  "typ %t użyty w definicji delegata nie jest typem funkcji",
  "typy składowych delegatów mogą być tylko składowymi klas typu %[managed]",
  "odwołanie śledzące do typu delegata nie jest dozwolone",
  "typ delegata nie jest tutaj dozwolony",
  "to rozwinięcie pakietu utworzyło pustą listę wyrażeń, a wyrażenie jest tu potrzebne",
  "zdarzenie nie może być jednocześnie statyczne i wirtualne",
  "zdarzenia mogą być tylko składowymi klas typu %[managed]",
  "ta deklaracja nie może występować w definicji zdarzenia",
  "typ zdarzenia musi być typem dojście-do-delegata",
  "metoda dostępu „add” została już zadeklarowana dla tego zdarzenia %p",
  "metoda dostępu „remove” została już zadeklarowana dla tego zdarzenia %p",
  "metoda dostępu „raise” została już zadeklarowana dla tego zdarzenia %p",
  "metoda dostępu do zdarzeń nie może być jednocześnie statyczna i wirtualna",
  "zwracany typ metod dostępu „add” i „remove” musi być typem void",
  "w metodzie dostępu do zdarzeń brakuje parametru wartości",
  "funkcja dostępu ma zbyt wiele parametrów",
  "typ %t1 parametru metody dostępu do zdarzeń nie jest zgodny z typem zdarzenia (%t2)",
  "typ metody dostępu „raise” nie jest zgodny z typem wywołania delegata zdarzenia",
  "definicja zdarzenia musi zawierać zarówno metodę dostępu „add”, jak i „remove”",
  "statyczna funkcja konwersji musi akceptować dokładnie jeden argument",
  "operator statyczny musi mieć parametr typu T, T&, T%% lub T^, gdzie T = %t",
  "argument operacji sizeof... musi być nazwą pakietu parametrów",
  "operator sizeof... może być używany tylko w szablonie ze zmienną liczbą argumentów",
  "nazwa zdarzenia nie może tutaj występować",
  "dojście do klasy typu innego niż %[managed] nie jest dozwolone",
  "dojście do typu wyliczenia niewystępującego w zakresie nie jest dozwolone",
  "atrybut „property” niedozwolony w klasie typu %[managed]",
  "czysty specyfikator („= 0”), po którym występuje definicja, jest niestandardowy",
  "nie można tutaj użyć wskaźnika nullptr typu %[managed]",
  "nie można użyć operatora „&”, aby pobrać adres obiektu z klasą typu referencyjnego",
  "tablica klasy typu %[managed] nie jest dozwolona",
  "zmienna ze statycznym okresem magazynu nie może mieć odwołania typu śledzącego ani odwołania do dojścia",
  "zmienna przechwycona przez element lambda nie może być odwołaniem do dojścia ani odwołaniem śledzącym",
  "tablica parametrów %[C++/CLI] wymaga dojścia do jednowymiarowego typu %[cli::array]",
  "nie można zaimportować metadanych z pliku %sq",
  "nie można rozszerzyć przestrzeni nazw interfejsu wiersza polecenia",
  "typ elementu tablicy %[cli::array] musi być typem dojścia lub typem wartości",
  "nieprawidłowa liczba wymiarów dla typu %[cli::array]",
  "wskaźnik cli::interior_ptr/cli::pin_ptr musi wskazywać klasę standardową, klasę wartości, liczbę całkowitą, dojście lub wskaźnik standardowy",
  "%t nie może być składową klasy",
  "parametr typu cli::pin_ptr jest niedozwolony",
  "nieprawidłowa deklaracja finalizatora",
  "finalizator może nie mieć parametrów",
  "kwalifikator typu jest niedozwolony na finalizatorze",
  "zwracany typ może nie być określony na finalizatorze",
  "deklaracja using nie może określać finalizatora",
  "nazwa finalizatora musi być kwalifikowana",
  "nazwa kwalifikatora lub finalizatora %t1 nie jest zgodna z typem %t2",
  "nie można użyć %n w celu nazwania finalizatora (wymagana jest nazwa typu)",
  "nieprawidłowa nazwa finalizatora dla typu %t",
  "odwołanie do finalizatora jest niejednoznaczne — można użyć zarówno %n1, jak i %n2",
  "finalizator może być tylko składową klasy referencyjnej",
  null,
  "typ użyty jako nazwa finalizatora nie jest zgodny z typem %t",
  "dla tego typu finalizator nie istnieje",
  "operatora „%%” można użyć tylko na obiekcie z klasą typu %[managed]",
  "wskaźnik, dojście lub odwołanie do wskaźnika cli::interior_ptr jest niedozwolone",
  "wskaźnik, dojście lub odwołanie do wskaźnika cli::pin_ptr jest niedozwolone",
  "wskaźnik lub odwołanie do tablicy %[C++/CLI] jest niedozwolone",
  "typ tablicy %[C++/CLI] nie jest tutaj dozwolony",
  "klasa referencyjna %[C++/CLI] może pochodzić tylko z innej klasy referencyjnej lub z klas interfejsów",
  "klasa wartości %[C++/CLI] może pochodzić tylko z klas interfejsów",
  "klasa interfejsu %[C++/CLI] może pochodzić tylko z klas interfejsów",
  "klasa referencyjna może mieć co najwyżej jedną bezpośrednią referencyjną klasę bazową (%t jest już taką bazą)",
  "klasa standardowa nie może pochodzić z klasy typu %[managed]",
  "klasa typu %[managed] nie może mieć wirtualnej bazy",
  "klasa typu %[managed] nie może mieć bazy „private” lub „protected”",
  "modyfikator „override” wymaga deklaracji funkcji wirtualnej z jawnym słowem kluczowym „virtual”",
  "modyfikator „abstract” wymaga deklaracji funkcji wirtualnej z jawnym słowem kluczowym „virtual”",
  "modyfikator „sealed” wymaga deklaracji funkcji wirtualnej z jawnym słowem kluczowym „virtual”",
  "nazwany specyfikator przesłonięcia wymaga deklaracji funkcji wirtualnej z jawnym słowem kluczowym „virtual”",
  "zwracany typ wskaźnika cli::pin_ptr jest niedozwolony",
  "atrybut %sq ma zastosowanie tylko w trybie %[C++/CLI]",
  "proste (nieśledzące) odwołanie nie może być powiązane z jednostką na stercie zarządzanej",
  "zestaw przenośny",
  "„%s”: nie załadowano z zestawów domyślnych",
  "składnia inicjalizacji listy jest funkcją języka C++11",
  "argument operacji sizeof nie może być typem klasy referencyjnej ani typem klasy interfejsu",
  "nieprawidłowa liczba indeksów dolnych dla tego typu %[cli::array]",
  "wskaźnik do składowej jest nieprawidłowy dla klasy typu %[managed]",
  "prywatna wirtualna funkcja składowa klasy typu %[managed] nie jest oznaczona jako „sealed”",
  "modyfikator nie jest dozwolony na destruktorze",
  "modyfikator nie jest dozwolony na finalizatorze",
  "słowo kluczowe „virtual” nie ma wpływu na destruktora klasy typu %[managed]",
  "wymagane jest słowo kluczowe „new” lub „override”, ponieważ ta deklaracja jest zgodna z elementem %nd",
  "wymagane jest słowo kluczowe „new” lub „virtual”, ponieważ ta deklaracja jest zgodna z elementem %nd",
  "słowa kluczowe „new” i „override” nie są tutaj prawidłowe, ponieważ zgodny element %nd jest składową interfejsu",
  "modyfikator „new” bez elementu członkowskiego referencyjnej klasy bazowej",
  "element %nd przesłonięty za pomocą ograniczonego dostępu",
  "odwołania typu %t1 nie można zainicjować za pomocą wartości typu %t2",
  "nie można zadeklarować konstruktora kopiującego w klasie wartości",
  "nie można zadeklarować konstruktora domyślnego w klasie wartości",
  "nie można zadeklarować destruktora w klasie wartości",
  "nie można zadeklarować operatora przypisania w klasie wartości",
  "klasa bez wartości %t nie może być typem składowej klasy wartości",
  "opcja „cppcli” wymaga innej konfiguracji kompilatora",
  "specyfikacje wyjątków nie są dozwolone na składowych klas typu %[managed]",
  "klasa typu %[managed] nie może deklarować elementu przyjaznego",
  null,
  null,
  "definicja klasy lokalnej nie jest dozwolona w funkcji składowej klasy typu %[managed]",
  "lokalny element lambda nie jest dozwolony w funkcji składowej klasy typu %[managed]",
  "funkcja składowa typu klasy interfejsu %[C++/CLI] nie może mieć definicji",
  "definicja właściwości musi zawierać co najmniej jedną metodę dostępu („get” lub „set”)",
  "właściwość indeksowana domyślnie powoduje konflikt z elementem %nd",
  "nie można użyć elementu %n1, ponieważ znajduje się za pakietem parametrów i nie można go ustalić na podstawie parametrów %n2",
  "to rozwinięcie pakietu utworzyło więcej niż jedno wyrażenie, a tu jest potrzebne jedno wyrażenie",
  "typ musi odpowiadać typowi System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64 lub System::UInt64",
  "wywołanie obiektu typu dojścia bez odpowiedniego operatora() lub funkcji konwersji na typ wskaźnika do funkcji",
  "deklaracja nienazwanego pakietu parametrów nie może być umieszczona w nawiasach",
  "szablony ze zmienną liczbą argumentów można włączać tylko podczas kompilowania kodu w języku C++",
  "definicja właściwości jest w konflikcie z elementem %nd",
  "właściwość przeciążona",
  "właściwość",
  "parametr ogólny nie może mieć wartości domyślnej",
  "ogólny może mieć tylko parametry typów",
  "w celu użycia z instrukcjami „for each” typ %t musi udostępniać niestatyczną funkcję składową %sq",
  "w instrukcji „for each” nie można używać składowej %n, ponieważ jest ona statyczna",
  "w tej instrukcji „for each” żadne wystąpienie funkcji %no nie jest możliwe do wywołania z pustą listą argumentów",
  "w instrukcji „for each” nie można używać funkcji składowej „MoveNext”, ponieważ zwracany typ jest nieprawidłowy",
  "instrukcja „for each” nie może działać na wyrażeniu typu %t",
  "aby można było używać typu %t z instrukcjami „for each”, musi on udostępniać właściwość nieindeksowaną %sq",
  null,
  "w tej instrukcji „for each” %t2 nie jest prawidłowym modułem wyliczającym (zwracanym przez metodę „GetEnumerator” typu %t1)",
  "oczekiwano „in”",
  "klasa %t nie ma odpowiedniego operatora przypisania (po syntezie operatora)",
  "%sq nie jest parametrem ogólnym",
  "%sq nie jest parametrem ogólnym najbardziej wewnętrznej listy parametrów ogólnych",
  "nieprawidłowe ograniczenie ogólne",
  "nieprawidłowe użycie składowej zdarzenia (dozwolone są tylko subskrypcja, anulowanie subskrypcji i wywołanie)",
  "wywoływanie zdarzenia bez metody dostępu „raise” jest nieprawidłowe",
  "tylko operatory „+=” i „-=” są prawidłowe dla zdarzeń",
  "operator typeid typu %[managed] nie jest dozwolony",
  "operator typeid typu wskaźnika %[managed] nie jest dozwolony",
  "nazwa, po której występuje ciąg „::typeid”, musi być nazwą typu",
  "składowa %sq tego typu jest zastrzeżona w obrębie klasy typu %[managed] — zamierzony destruktor?",
  "składowa %sq tego typu jest zastrzeżona w obrębie klasy typu %[managed] — zamierzony finalizator?",
  "brakuje metody %[System]::IDisposable::Dispose lub jest ona nieprawidłowa",
  "brakuje metody %[System]::Object::Finalize lub jest ona nieprawidłowa",
  "%n nie przesłania metody %[System]::Object::Finalize",
  "argument operacji dojścia dynamic_cast musi być dojściem do pełnego typu klasy",
  "argument operacji odwołania śledzącego dynamic_cast musi być wartościowaniem lewostronnym pełnego typu klasy",
  "typ rzutowany w operacji dynamic_cast na typ dojścia lub odwołania śledzącego musi odwoływać się do pełnej klasy",
  "nie można rzutować wskaźnika wewnętrznego na wskaźnik natywny",
  "operatory jawnej konwersji mogą być deklarowane tylko w typach klasy referencyjnej i klasy wartości",
  "operator jawnej konwersji nie może być wirtualny",
  "wyrażenie musi mieć typ arytmetyczny lub typ wyliczenia niewystępującego w zakresie",
  "wyrażenie musi mieć typ arytmetyczny, typ wyliczenia niewystępującego w zakresie lub typ wskaźnika",
  "wyrażenie musi mieć typ całkowitoliczbowy lub typ wyliczenia niewystępującego w zakresie",
  "wyrażenie musi mieć typ całkowitoliczbowy, typ wyliczenia niewystępującego w zakresie lub typ stałoprzecinkowy",
  "wbudowany operator binarny zastosowany do wyliczenia z zakresem wymaga dwóch argumentów operacji tego samego typu",
  "operator %[gcnew] nie może przydzielać jednostki typu %t",
  "składnia położenia nie może być używana z operatorem %[gcnew]",
  "operator new może być używany tylko z prostymi typami wartości",
  "nie można używać operatora new z klasą typu %[managed] (zamiast tego należy użyć operatora %[gcnew])",
  "operator new nie może być używany z typem dojścia",
  "operator %[gcnew] dla tablicy %[C++/CLI] musi mieć inicjatora new lub inicjatora tablicy",
  "inicjator tablicy może być używany tylko w celu inicjowania typu tablicy %[C++/CLI]",
  "operator %[gcnew] nie zezwala na operacje automatyczne",
  "zbyt wiele granic tablicy",
  "zbyt mało granic tablicy",
  "za mało argumentów dla elementu %nf",
  "za dużo argumentów dla elementu %nf",
  "klasa ogólna",
  "żadna deklaracja elementu %nf nie akceptuje liczby podanych argumentów ogólnych",
  "nieprawidłowy inicjator delegata — musi być funkcją",
  "nieprawidłowy inicjator delegata — więcej niż jedna funkcja jest zgodna z typem delegata",
  "nieprawidłowy inicjator delegata — funkcja nie jest zgodna z typem delegata",
  "nieprawidłowy inicjator delegata — oprócz funkcji wymagany jest także obiekt",
  "nieprawidłowy inicjator delegata — funkcja nie jest składową klasy typu %[managed]",
  "nieprawidłowy inicjator delegata — określona funkcja nie potrzebuje obiektu",
  "nieprawidłowy inicjator delegata — obiekt ma typ %t1, a oczekiwano typu %t2",
  "pobieranie adresu funkcji składowej klasy typu %[managed] jest niedozwolone",
  "nieprawidłowy inicjator delegata — oczekiwano elementu „(<adres-funkcji>)” lub „(<dojście-do-obiektu>, <adres-składowej>)”",
  "klasa nie może zaimplementować składowej %nd interfejsu",
  "operator %[gcnew] nie może być używany w celu przydzielania tablicy natywnej",
  "klasa interfejsu %[C++/CLI] nie może deklarować operatora przypisania",
  "klasa interfejsu %[C++/CLI] nie może być zapieczętowana",
  null,
  "deklaracja destruktora lub finalizatora nie może zawierać nazwanego specyfikatora przesłonięcia",
  "specyfikator przesłonięcia nie może wyznaczać destruktora ani finalizatora",
  "nazwany specyfikator przesłonięcia jest dozwolony tylko w klasie typu %[managed]",
  "żadna składowa wyznaczona przez nazwany specyfikator przesłonięcia nie jest zgodna z typem tej składowej",
  "deklaracja konstruktora statycznego nie może zawierać nazwanego specyfikatora przesłonięcia",
  "typ wyliczenia z zakresem musi mieć nazwę",
  "transfer kontroli do bloku Finally jest niedozwolony",
  "instrukcja return w bloku Finally jest niedozwolona",
  "blok try wymaga co najmniej jednej procedury obsługi lub klauzuli finally",
  "obiekt typu %[managed] musi być zgłaszany przez dojście",
  "obiekt typu %[managed] musi być przechwycony przez dojście",
  "instrukcja przerwania nie może być używana w bloku Finally",
  "instrukcja kontynuowania nie może być używana w bloku Finally",
  "wbudowane makro offsetof nie może być używane, gdy indeksowanie dolne jest przeciążone",
  "ograniczenie zduplikowane",
  "więcej niż jedno ograniczenie klasy: %t1 i %t2",
  "więcej niż jedna klauzula ograniczenia dla elementu %n",
  "statyczne składowe danych initonly muszą mieć inicjatora lub być inicjowane w konstruktorze statycznym",
  "atrybuty GNU w ponownej deklaracji szablonu nie mają żadnego skutku",
  "atrybuty GNU w ponownej deklaracji szablonu nie mają żadnego skutku (zamiast tego są stosowane atrybuty oryginalnej deklaracji %p)",
  "tablica parametrów %[C++/CLI] musi być ostatnim parametrem",
  "funkcja z tablicą parametrów %[C++/CLI] nie może mieć argumentów domyślnych",
  "za tablicą parametrów %[C++/CLI] nie może znajdować się parametr wielokropka",
  "tablica parametrów %[C++/CLI] nie jest dozwolona na liście parametrów funkcji operatora",
  "słowa kluczowe __inline i __forceinline nie są tutaj dozwolone",
  "składowa danych nie może mieć typu klasy interfejsu %[C++/CLI]",
  "zmienna nie może mieć typu klasy interfejsu %[C++/CLI]",
  "parametr nie może mieć typu klasy interfejsu %[C++/CLI]",
  "zwracany typ funkcji nie może być typem klasy interfejsu %[C++/CLI]",
  "tablica ogólnego typu parametru nie jest dozwolona",
  "wskaźnik, dojście lub odwołanie do ogólnego typu parametru nie są dozwolone",
  "pole initonly nie może mieć typu klasy referencyjnej ",
  "odwołanie nie może być powiązane z polem initonly",
  "pobieranie adresu pola initonly jest niedozwolone",
  "pole initonly może być modyfikowane tylko przez konstruktora wystąpień klasy, w której występuje",
  "statyczne pole initonly może być modyfikowane tylko przez konstruktora statycznego klasy, w której występuje",
  "funkcja składowa zostanie wywołana podczas kopiowania pola initonly",
  "wyrażenie musi mieć typ wskaźnika lub dojścia, ale ma typ %t",
  "konstruktor przenoszący lub przenoszący operator przypisania jest używany do skopiowania tutaj wartościowania lewostronnego, co może spowodować zniszczenie obiektu źródłowego",
  "dla wyboru składowej na jednostce ogólnej %[C++/CLI] należy użyć składni „->”, a nie „.”",
  "typ klasy referencyjnej nie może pochodzić od typu %t",
  "klasa ogólna musi być klasą typu %[managed] (tj. klasą referencyjną, klasą wartości lub klasą interfejsu)",
  "nie można używać klasy zapieczętowanej jako ograniczenia",
  "typ w operacji dynamic_cast nie może być typem ogólnym, który może być typem wartości",
  "nazwa zawierająca znaki uniwersalne musi wyznaczać prawidłowy punkt kodu",
  "ograniczenia ogólne nie są zgodne z ograniczeniami elementu %nd",
  "słowo kluczowe __underlying_type ma zastosowanie tylko do typów wyliczenia",
  "oczekiwano tylko jednego wyrażenia argumentu operacji dla tego rzutowania",
  "nie można przedstawić znaku Unicode o wartości szesnastkowej %s w domyślnej systemowej stronie kodowej",
  "niestandardowa konwersja powiązania wskaźnika do składowej ze wskaźnikiem funkcji",
  "specyfikator dostępu %s1 jest przestarzały — zamiast tego użyj %s2",
  "statyczna funkcja dostępu nie jest dozwolona w niestatycznej właściwości lub definicji zdarzenia",
  "typ %t ma zarówno ograniczenie klasy referencyjnej, jak i klasy wartości",
  "typy %t1 i %t2 obejmują cykliczne ograniczenia typu z atrybutem „naked”",
  "%t nie jest prawidłowym ograniczeniem typu",
  "prekompilowany plik nagłówkowy %sq nie został użyty (ponieważ jest niekompletny)",
  "%t nie jest prawidłowym argumentem ogólnym",
  "atrybut assembly_info został zastosowany do nieprawidłowego typu",
  "%t1 nie spełnia ograniczenia klasy referencyjnej parametru ogólnego %t2",
  "%t1 nie spełnia ograniczenia klasy wartości parametru ogólnego %t2",
  "%t1 nie spełnia ograniczenia operatora %[gcnew] parametru ogólnego %t2, ponieważ jest abstrakcyjny",
  "%t1 nie spełnia ograniczenia operatora %[gcnew] parametru ogólnego %t2, ponieważ nie ma publicznego konstruktora domyślnego",
  "parametr ogólny %t1 nie spełnia ograniczenia operatora %[gcnew] parametru ogólnego %t2, ponieważ nie ma ograniczenia operatora %[gcnew]",
  "%t1 nie spełnia ograniczenia typu %t3 parametru ogólnego %t2",
  "ograniczenie na parametrze ogólnym %t różni się od poprzedniej deklaracji (%p)",
  "składowa klasy typu %[managed] nie może być tablicą standardową",
  "składowa klasy typu innego niż %[managed] nie może być dojściem",
  "składowa klasy typu innego niż %[managed] nie może być odwołaniem śledzącym",
  "niebezpieczna instrukcja reinterpret_cast dojścia",
  "argument szablonu nie może odwoływać się do parametru typu ogólnego",
  "lista wyrażeń nie jest dozwolona w tej operacji indeksów dolnych (użyj nawiasów wokół operatora przecinka najwyższego poziomu)",
  "wyrażenie musi mieć typ wskaźnika do obiektu lub dojścia do tablicy %[C++/CLI], ale ma typ %t",
  "nierozpoznany atrybut",
  "składowa klasy typu %[managed] nie może mieć klasy typu innego niż %[managed]",
  "składowa klasy typu innego niż %[managed] nie może mieć typu klasy referencyjnej lub typu klasy interfejsu",
  "w ",
  "delegat nie może być deklarowany jako szablon",
  "element ogólny nie może być jawnie specjalizowany",
  "element ogólny nie może być deklarowany w szablonie klasy",
  "szablon nie może być deklarowany w klasie ogólnej",
  "pole literału nie może być deklarowane jako statyczne",
  "„long float” to rozszerzenie niestandardowe — zamiast tego użyj „double”",
  "klasa standardowa nie może być zagnieżdżona w klasie typu %[managed]",
  "wywołanie __clrcall jest prawidłowe tylko w trybie C++/CLI",
  "wywołanie __clrcall jest niedozwolone w przypadku funkcji z parametrem wielokropka",
  "element %sq nie jest tutaj dozwolony",
  "nie można użyć prostej właściwości ani prostego zdarzenia, by przesłonić element %nd",
  "oczekiwano nazwy zmiennej iteratora",
  "typ iteratora w tej instrukcji „for each” jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "typ iteratora w tej instrukcji „for each” jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "typ iteratora w tej instrukcji „for each” jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "atrybut pakowania dla typu nadrzędnego jest ignorowany dla tego pola klasy typu %t o niestandardowym układzie",
  "element %nd nie został zaimplementowany, ponieważ ta deklaracja nie jest publiczna i nie ma nazwanego specyfikatora przesłonięcia",
  "w tej deklaracji brakuje atrybutu gnu_inline określonego w poprzedniej deklaracji %p",
  "funkcja składowa klasy typu %[managed] nie może mieć parametru wielokropka",
  "poprzednio zadeklarowany element %n jest nieprawidłowy jako iterator instrukcji „for each”",
  "konwencja wywołania została zignorowana, ponieważ typ funkcji obejmuje parametr ogólny; w zamian użyto wywołania __clrcall",
  "typ funkcji obejmujący parametr ogólny nie może mieć parametru wielokropka",
  "w celu przesłonięcia zgodnego elementu %nd wymagane jest słowo kluczowe „virtual”",
  "w celu zaimplementowania zgodnego elementu %nd wymagane jest słowo kluczowe „virtual”",
  "składowa danych initonly nie może być nietrwała",
  "składowa %sq tego typu jest zastrzeżona w obrębie klasy typu %[managed] — operatory %[C++/CLI] muszą być deklarowane przy użyciu słowa kluczowego „operator”",
  "odwołanie śledzące do wartości innej niż stała nie może być powiązane z wartością stałą",
  "atrybuty zostały tu zignorowane, ponieważ nie mają zastosowania do zadeklarowanej jednostki",
  "odwołanie śledzące do metody %[System]::String nie jest dozwolone",
  "nieprawidłowe użycie ogólnej klasy %t z oczekującymi ograniczeniami (prawdopodobnie spowodowane przez nieprawidłowy plik metadanych)",
  "klauzula ograniczenia oczekującego jest dozwolona tylko dla deklaracji klasy ogólnej (ale nie dla definicji klasy ogólnej)",
  "pusta lista inicjatora nie jest tutaj dozwolona",
  "nie można deklarować szablonu w klasie typu %[managed]",
  "deklaracja ogólna nie jest tutaj dozwolona",
  "typy interfejsów nie mogą mieć typów ogólnych składowych",
  "znak Unicode inny niż znak Latin-1 obcięto do mniej znaczącego bajtu",
  "aby można było używać typu %t z instrukcjami „for” opartymi na zakresie, musi on udostępniać funkcję %sq",
  "typ iteratora w tej instrukcji „for” opartej na zakresie jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "typ iteratora w tej instrukcji „for” opartej na zakresie jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "typ iteratora w tej instrukcji „for” opartej na zakresie jest typu %t, który nie jest typem wskaźnika ani typem klasy podobnej do iteratora",
  "instrukcja „for” oparta na zakresie nie może wykonywać operacji na tablicy o nieznanym rozmiarze lub niekompletnym typie %t",
  "zwracane typy dla funkcji „begin” i „end” użytych w instrukcji „for” opartej na zakresie muszą być takie same (zwracany typ funkcji „begin” jest %t1, a funkcji „end” jest %t2)",
  "element %nfd, wymagany do zniszczenia wartości tymczasowej, która została wyeliminowana, jest niedostępny",
  "w tej instrukcji „for” opartej na zakresie żadne wystąpienie elementu %no nie jest zgodne z listą argumentów",
  "ta instrukcja „for” oparta na zakresie wymaga odpowiedniej funkcji %sq, a żadnej nie znaleziono",
  "ta instrukcja „for each” wymaga odpowiedniej funkcji %sq, a żadnej nie znaleziono",
  "%t ma reprezentację metadanych, której nie można przedstawić przy użyciu kodu %[C++/CLI]",
  "oczekiwano „...”",
  "%t na liście __implements nie jest interfejsem",
  "lista __implements musi znajdować się przed deklaracjami funkcji wirtualnych",
  "%t ma określone elementy „__implements ...” na swojej liście elementów bazowych, ale brakuje zgodnej listy __implements",
  "musi zostać użyty wynik usunięcia odwołania do dojścia do typu klasy referencyjnej lub klasy interfejsu",
  null,
  "oczekiwano „)”; dyrektywa pragma została zignorowana",
  "deklaracja using i deklaracja dostępu nie mogą występować w klasie zarządzanej",
  "Uwaga: element %nd mógł zostać wywołany, ale nie był brany pod uwagę, ponieważ jest niedostępny",
  "abstrakcyjna funkcja składowa klasy zarządzanej C++/CLI nie może mieć definicji",
  "zadeklarowanie tego operatora jednoargumentowego „operator*” może zmienić znaczenie operacji usuwania odwołania do dojścia (użyj statycznych operatorów składowych, aby jawnie wskazać odpowiednie typy)",
  "zarządzane",
  "C++/CX",
  "C++/CLI",
  "mapowanie C++/CX",
  "domyślne",
  "mapowanie interfejsu cli",
  "cli::array",
  "Platform::Array",
  "tablica C++/CLI",
  "tablica C++/CX",
  "System",
  "Platforma",
  "gcnew",
  "ref new",
  "klasa interfejsu nie może zawierać niestatycznej składowej danych",
  "dyrektywa #pragma GCC system_header nie może być używana w podstawowym pliku źródłowym",
  "element %n jest zbyt duży, aby był śródwierszowy",
  " (zadeklarowano niejawnie)",
  "opcja kontrolowania operacji przenoszenia może być używana tylko podczas kompilowania kodu C++",
  "operacje przenoszenia nie mogą być generowane, kiedy konstruktory wartościowania prawostronnego są konstruktorami kopiującymi",
  "opcja kontrolowania operacji przenoszenia nie może być używana, gdy odwołania do wartościowania prawostronnego są wyłączone",
  "słowo kluczowe „final” nie może być używane dla klas zarządzanych (zamiast tego użyj słowa kluczowego „sealed”)",
  "rzutowanie na klasę interfejsu CLI %t jest niedozwolone — zamierzone rzutowanie na dojście?",
  "nie można utworzyć obiektu klasy interfejsu CLI",
  "ta deklaracja powoduje ukrycie niestandardowej deklaracji elementu %nd, ponieważ typy bazowe są niezgodne",
  "wynik porównania wskaźnika jest wartością stałą, ponieważ argument operacji nigdy nie może być wartością null",
  "obiekt niekompletnego typu %t nie może być inicjowany przez wartość",
  "odwołanie nie może być inicjowane przez wartość",
  "oczekiwano „(” lub „{”",
  "inicjalizacja kopiowania listy nie może używać konstruktora oznaczonego jako „explicit”",
  "wskaźnik do składowej typu void jest niedozwolony",
  "wskaźnik do składowej typu referencyjnego jest niedozwolony",
  "wskaźnik do składowej typu dojścia jest niedozwolony",
  "lista w nawiasach klamrowych nie jest tutaj dozwolona",
  "składowa operatora ->* jest niedozwolona w klasie zarządzanej",
  "metadane zestawu odwołują się do nieistniejącego zestawu",
  "atrybut %sq2 jest w konflikcie z wcześniejszym atrybutem %sq1",
  "element %nd został wcześniej zadeklarowany z innym typem bazowym",
  "nie można tutaj użyć deklaracji „enum class” ani „enum struct” (zamiast tego użyj zwykłej deklaracji „enum”)",
  "tylko jeden poziom nawiasów klamrowych jest dozwolony w przypadku inicjatora dla obiektu typu %t",
  "nie można używać elementu %nd jako nazwy typu wyliczenia",
  null,
  "inicjator w nawiasach klamrowych nie może być używany z obiektem „new auto”",
  "definicja obiektu std::initializer_list nie zawiera oczekiwanego konstruktora",
  "deklaracja ukrywa element %nd",
  "nieprawidłowa lista parametrów szablonu dla obiektu std::initializer_list (powinien to być jeden parametr typu zwykłego bez wartości domyślnej)",
  "lista w nawiasach klamrowych nie może być przekazywana jako parametr wielokropka",
  "dyrektywa #include <lista_inicjatorów> jest potrzebna przed użyciem obiektu std::initializer_list, z uwzględnieniem użycia niejawnego",
  "nie można użyć słowa kluczowego „inline” w deklaracji aliasu przestrzeni nazw",
  "poprzednia deklaracja elementu %n nie była zadeklarowana śródwierszowo",
  "Element %n był wcześniej zadeklarowany śródwierszowo",
  "pierwszy argument musi być całkowitą wartością stałą",
  "desygnator nie może być używany z niezagregowanym typem %t",
  "desygnator dla anonimowej składowej unii może występować tylko w nawiasach klamrowych odpowiadających tej anonimowej unii",
  "tagi prototypu funkcji można włączać tylko podczas kompilowania kodu C",
  "nie można pominąć nawiasów klamrowych dla tego inicjatora podobiektu",
  "nieprawidłowa konwersja zawężająca z %t1 do %t2",
  "nieprawidłowa konwersja zawężająca z %t1 na %t2: wartość stała nie mieści się w typie docelowym",
  "rzutowanie na niekompletny typ tablicy %t jest niedozwolone",
  "nieprawidłowa konwersja zawężająca z %t1 na %t2: nie można dokładnie przedstawić wartości stałej w typie docelowym",
  "inicjator w nawiasach dla jednostki bez klasy musi być wyrażeniem, a nie listą w nawiasach klamrowych",
  "lista w nawiasach klamrowych nie dostarcza zwracanego typu dla tego elementu lambda",
  "zadeklarowana specyfikacja wyjątku jest niezgodna z wygenerowaną",
  "typy wyliczeń z zakresem są funkcją języka C++11",
  "typ funkcji nie może być inicjowany przez wartość",
  "inicjalizacja typu obiektu %t za pomocą listy jest niedozwolona, ponieważ typ jest niekompletny",
  "obiekt std::initializer_list ma destruktora, a nie powinien — biblioteka jest błędnie skonfigurowana",
  "podstawowe typy wyliczenia jawnego są funkcją języka C++11",
  "to wyrażenie stałej ma typ %t1 zamiast wymaganego typu %t2",
  "słowo kluczowe „new” obiektu std::initializer_list prawdopodobnie nie będzie działać zgodnie z oczekiwaniami, ponieważ tablica bazowa zostanie zniszczona na koniec pełnego wyrażenia",
  "We wstępnie zdefiniowanym pliku makro",
  null,
  "argument „defined” zawsze ma wartość false w rozwinięciu makra w trybie Microsoft",
  "typ %t nie może być typem elementu listy inicjatorów, ponieważ nie jest to pełny typ obiektu",
  "niezgodne ograniczniki w domyślnym wyrażeniu argumentu",
  "niestandardowa konwersja wskaźnika do składowej na wskaźnik funkcji",
  "specyfikacje wyjątków dynamicznych są przestarzałe",
  "element %n nie może być częściowo specjalizowany w bieżącym zakresie",
  "element %nd został wcześniej zadeklarowany jako constexpr",
  "element %nd nie został wcześniej zadeklarowany jako constexpr",
  "brak inicjatora dla zmiennej constexpr",
  "słowo kluczowe „constexpr” nie jest tutaj prawidłowe",
  "funkcja constexpr musi zawierać dokładnie jedną instrukcję return",
  "instrukcja nie może występować w funkcji constexpr",
  "instrukcja nie może występować w konstruktorze constexpr",
  "w tym trybie funkcja nie może być jednocześnie zadeklarowana jako constexpr i virtual",
  "funkcja constexpr nie może mieć nieliteralnego zwracanego typu %t",
  "funkcja constexpr nie może mieć parametru nieliteralnego typu %t",
  "nie ułożone sekwencyjnie użycia elementu %n w wyrażeniu mogą dać niezdefiniowane wyniki",
  "opcjonalny trzeci argument wywołania funkcji __builtin_assumed_aligned musi mieć typ całkowitoliczbowy",
  "destruktor nie może być wyrażeniem constexpr",
  "adres podany dla elementu mmap musi zostać wyrównany na granicy strony: %s",
  "treść konstruktora constexpr nie może być blokiem try funkcji",
  "wyrażenie constexpr %nf nie udostępnia żadnego inicjatora dla:",
  "%n",
  "wywołanie domyślnego konstruktora dla elementu %t nie daje w wyniku wartości stałej",
  "domyślny konstruktor dla elementu %t nie jest konstruktorem constexpr",
  "zmienna constexpr musi mieć typ literału lub typ referencyjny",
  "konstruktor dla klasy z wirtualnymi bazami nie może być konstruktorem constexpr",
  "wywołanie funkcji musi mieć wartość stałą w wyrażeniu stałej",
  "słowo kluczowe „main” funkcji nie może być deklarowane jako constexpr",
  null,
  "definicja typu wyliczenia ani klasy nie może występować w treści funkcji ani konstruktora constexpr",
  "tylko atrybuty w stylu GNU są tutaj dozwolone",
  "niestandardowe użycie słowa kluczowego „auto” w celu zarówno ustalenia typu z inicjatora, jak i zaanonsowania końcowego typu zwracanego",
  "deklarowanie listy parametrów void za pomocą kwalifikowanego typu void jest niestandardowe",
  "kwalifikator dla tej deklaracji lokalnej jest ignorowany",
  "to wyrażenie stałej ma typ %t zamiast wymaganego typu %s",
  "tworzenie wystąpienia elementu __bases lub __direct_bases wymaga typu klasy",
  "argument elementów __bases i __direct_bases musi być parametrem szablonu typu",
  "element %s może być używany tylko w kontekstach szablonów",
  "zwrot funkcji constexpr nie jest wartością stałą",
  "konstruktor constexpr wywołuje element %n inny niż constexpr",
  "konstruktor nie może być constexpr, ponieważ inicjator elementu %n nie jest wyrażeniem stałym",
  "inny niż stały inicjator dla konstruktora constexpr",
  "wygenerowany domyślny konstruktor dla elementu %t nie może zostać użyty w inicjatorze dla własnej składowej danych",
  "tworzenie wystąpienia inicjatora elementu %n zależy od jego własnej wartości",
  "konstruktor określony jako domyślny nie może być constexpr, ponieważ odpowiadający mu niejawnie zadeklarowany konstruktor domyślny nie byłby constexpr",
  null,
  "nieprawidłowa liczba binarna",
  "unia może mieć co najwyżej jednego inicjatora pola — element %nd także ma inicjatora",
  null,
  "konstruktor constexpr unii musi inicjować jedno z jego pól",
  "konstruktor constexpr nie inicjuje anonimowej unii (zdefiniowany element %p)",
  "deklaracja składowej danych statycznych constexpr wymaga inicjatora w obrębie klasy",
  "opcje maksymalnej głębokości/liczby constexpr mogą być używane tylko podczas kompilowania kodu C++",
  "wyrażenie nie zostało zwinięte do wartości stałej z powodu nadmiernej złożoności wywołania funkcji constexpr",
  "opcje nieograniczonej unii mogą być używane tylko podczas kompilowania kodu C++",
  "konstruktor constexpr musi inicjować bezpośrednią klasę bazową %t",
  "tworzenie obiektu std::initializer_list w inicjatorze pola prawdopodobnie nie będzie działać zgodnie z oczekiwaniami, ponieważ tablica bazowa zostanie zniszczona na koniec pełnego wyrażenia",
  "słowo kluczowe „this” nie może być używane w wyrażeniu stałej",
  null,
  "słowo kluczowe „constexpr” nie jest dozwolone dla jawnej dyrektywy tworzenia wystąpienia",
  "nie można ustalić specyfikacji wyjątku konstruktora domyślnego z powodu zależności cyklicznej",
  "element %p zdefiniowany przez unię anonimową",
  "ten konstruktor korzysta z inicjatora elementu %nd, co spowoduje niepowiązaną rekursję",
  null,
  "inicjator nie jest dozwolony na lokalnej deklaracji zmiennej extern",
  "inicjator nie jest dozwolony na lokalnej deklaracji zmiennej nazwanego rejestru",
  null,
  "nie można włączać nieograniczonych unii w trybie Microsoft",
  "konstruktor deleguje bezpośrednio lub pośrednio do siebie",
  "konstruktor delegujący nie może mieć innych inicjatorów pamięci",
  "kwalifikator ref nie jest tutaj dozwolony",
  "przeciążanie dwóch funkcji składowych tymi samymi typami parametrów wymaga, aby obydwie funkcje miały kwalifikatory ref lub nie miały kwalifikatorów ref",
  "nieprawidłowy znak w ograniczniku nieprzetworzonego ciągu",
  "w ramach 16 znaków nie odnaleziono nawiasu ograniczającego nieprzetworzony ciąg — zignorowano wskaźnik nieprzetworzonego ciągu",
  "nie można odnaleźć kończącego ogranicznika nieprzetworzonego ciągu",
  "pakiet parametrów musi być ostatnim argumentem szablonu w specjalizacji częściowej",
  "wskaźnik do funkcji składowej o typie %t może być używany tylko z obiektem wartościowanym lewostronnie",
  "wskaźnik do funkcji składowej o typie %t może być używany tylko z obiektem wartościowanym prawostronnie",
  "parametr tego określonego jako domyślny konstruktora kopiującego nie może być wartością stałą, ponieważ parametr podstawowego lub składowego konstruktora kopiującego nie jest wartością stałą",
  "parametr tego określonego jako domyślny operatora przypisania nie może być wartością stałą, ponieważ parametr podstawowego lub składowego kopiującego przypisania nie jest wartością stałą",
  "anonimowa unia musi zawierać co najmniej jedną niestatyczną składową danych",
  "opcja „delegating_constructors” wymaga innej konfiguracji kompilatora",
  "redukcja w wyrównaniu jest ignorowana",
  "argument operacji rzutowania const_cast na typ referencyjny wartościowany prawostronnie nie może być wartością prvalue bez klasy",
  "wyrażenie musi być wartością lvalue lub xvalue",
  "konwersja może zmieniać wartość",
  "konwersja z literału ciągu na parametr „char *” jest przestarzała",
  "konwersja z literału ciągu na wskaźnik do znaku (inny niż stały) jest przestarzała",
  "słowa kluczowe „override” i „final” są funkcjami języka C++11",
  "odwołania do wartości rvalue nie są dozwolone jako typy specyfikacji wyjątków",
  "atrybut %sq nie jest stosowany do parametrów procedury obsługi",
  "atrybut %sq wymaga parametru procedury obsługi",
  "funkcja alignas nie ma tu zastosowania",
  "standardowy operator „alignof” nie akceptuje argumentu wyrażenia (w zamian użyj typu)",
  "nieprawidłowy kwalifikator dla elementu %t (klasa pochodna jest w tym miejscu niedozwolona)",
  "atrybut „always_inline” jest ignorowany w przypadku funkcji innych niż inline",
  "konstruktory dziedziczące muszą być dziedziczone po bezpośredniej klasie bazowej",
  null,
  "oczekiwano etykiety",
  "oczekiwano numeru argumentu operacji za „%%l”",
  "liczba argumentu operacji dla elementu „%%l” nie odwołuje się do prawidłowego argumentu etykiety",
  "ciąg typu wide jest nieprawidłowy w instrukcji „asm”",
  "atrybut jest niestandardowy",
  "nie jest klasą bazową klasy %t",
  "znak elementu innego niż identyfikator w sufiksie literału zdefiniowanego przez użytkownika",
  "literał wieloznakowy nie może być częścią literału zdefiniowanego przez użytkownika",
  "sufiks literału zdefiniowanego przez użytkownika nie jest zgodny z wcześniejszym elementem %sq",
  "nieprawidłowa nazwa operatora literału",
  "nie można odnaleźć operatora literału zdefiniowanego przez użytkownika",
  "niejednoznaczne operatory literałów i/lub szablon operatora literału:",
  "operator literału nie może być składową klasy",
  "operator literału nie może mieć wiązania z nazwą zewnętrznego kodu „C”",
  "oczekiwano co najmniej jednego parametru dla operatora literału",
  "zbyt wiele parametrów dla tego operatora literału",
  "nieprawidłowy typ %t parametru dla operatora literału",
  "nieprawidłowy typ parametru liczby całkowitej (%t) dla operatora literału; oczekiwano typu znaku lub unsigned long long",
  "nieprawidłowy typ parametru zmiennoprzecinkowego (%t) dla operatora literału; oczekiwano typu long double",
  "nieprawidłowy typ pierwszego parametru (%t) dla operatora literału; typ wskaźnika do wartości innej niż stała jest niedozwolony",
  "nieprawidłowy typ drugiego parametru (%t) dla operatora literału; musi być size_t",
  "nieprawidłowy typ parametru wskaźnika (%t) dla operatora literału; oczekiwano wskaźnika do typu znaku",
  "operator literału nie może mieć parametru wielokropka",
  "szablon operatora literału nie może mieć żadnych parametrów",
  "szablon operatora literału musi mieć listę parametrów szablonu odpowiadającą elementowi „<char ...>”",
  "klasa magazynu thread-local nie jest prawidłowa w tym miejscu",
  "deklaracja thread-local znajduje się za deklaracją inną niż thread-local (zadeklarowany element %p)",
  "deklaracja inna niż thread-local znajduje się za deklaracją thread-local (zadeklarowany element %p)",
  "operator literału nie może mieć argumentów domyślnych",
  "atrybut jest ignorowany w przypadku zmiennych thread-local",
  "sufiks literału podany przez użytkownika musi zaczynać się od znaku „_”",
  "odwołania do wartości rvalue są funkcją języka C++11",
  "wyrażenia lambda są funkcją języka C++11",
  "składnia atrybutu standardowego jest funkcją języka C++11",
  "konstruktory delegujące są funkcją języka C++11",
  "konstruktory dziedziczące są funkcją języka C++11",
  "inicjatory pola są funkcją języka C++11",
  "funkcje usunięte są funkcją języka C++11",
  "funkcje domyślne są funkcją języka C++11",
  "klasa magazynu nie jest dozwolona w jawnej specjalizacji",
  null,
  "wyliczenie bez zakresu musi być nieprzezroczyste, aby było specjalizowane",
  "deklaracja szablonu wyliczenia musi odwoływać się do wcześniej zadeklarowanej składowej szablonu klasy",
  "oczekiwano wektora jako argumentu operacji",
  "źródłowe argumenty operacji mieszania losowego mają niezgodne typy %t1 i %t2",
  "maska losowa (typu %t) nie jest wektorem liczb całkowitych",
  "maska losowa (typu %t1) ma inną długość niż źródłowy argument operacji (typu %t2)",
  "inicjowanie statyczne z wartością adresu wymaga użycia miejsca docelowego o tym samym rozmiarze co adres",
  "argument makra feature-test musi być prostym identyfikatorem",
  "nie można użyć atrybutu __has_include_next w podstawowym pliku źródłowym",
  "użyto bezwzględnej nazwy pliku w atrybucie __has_include_next",
  "atrybut %sq musi zostać zastosowany do typu funkcji",
  null,
  "element _Noreturn nie jest dozwolony w tym miejscu",
  "oczekiwano argumentu operacji typu rzeczywistego zmiennoprzecinkowego (a nie %t)",
  "atrybut __builtin_complex wymaga argumentów operacji zgodnych typów (nie tak jak %t1 i %t2)",
  "domyślne skojarzenie już wystąpiło w tym wyborze _Generic",
  "typ obejmujący tablicę o zmiennej długości nie jest dozwolony w tym miejscu",
  "zduplikowany typ skojarzenia (%t) w wyborze _Generic",
  "żadne skojarzenie nie jest zgodne z typem selektora %t",
  "typ elementu %n (%t) jest niezgodny z typem programu rozpoznawania nazw ifunc",
  "funkcja nie może mieć jednocześnie atrybutów ifunc i alias",
  "funkcja nie może mieć jednocześnie atrybutów ifunc i weak",
  "wywołanie wymaga argumentu operacji w formie literału ciągu",
  "zduplikowana deklaracja konstruktora dziedziczącego (poprzednia %p)",
  "element „decltype(auto)” musi być symbolem zastępczym dla kompletnego typu zmiennej (a nie dla składników tego typu)",
  "element decltype(auto) nie jest dozwolony w tym miejscu",
  "nie można wywnioskować elementu „decltype(auto)” (wymagany inicjator)",
  "nie można wywnioskować typu elementu „decltype(auto)”",
  "deklaracja thread-local o zakresie bloku musi zawierać słowo static lub extern",
  "ustalony typ zwracany %t1 pozostaje w konflikcie z typem ustalonym poprzednio %t2",
  "nie można ustalić typu zwracanego elementu %nd; ten typ nie został zdefiniowany",
  "funkcja wirtualna nie może mieć wnioskowanego typu zwracanego",
  "od tego miejsca %n będzie traktowane jako wrażliwe na kontekst słowo kluczowe",
  "globalna przestrzeń nazw nie ma faktycznego elementu członkowskiego %sq",
  "porównanie między dwoma różnymi typami wyliczeniowymi (%t1 i %t2)",
  "nierozpoznany atrybut docelowy",
  "brak funkcji docelowej „default”",
  "można określić tylko jeden element docelowy arch=",
  "klasa ogólna nie może być atrybutem niestandardowym",
  "nieprawidłowy element docelowy atrybutu %sq",
  "niejednoznaczny atrybut — można użyć zarówno elementu %t1, jak i %t2",
  "nazwany argument atrybutu może tylko przywoływać publiczne, niestatyczne pola do zapisu/odczytu lub właściwość skalarną",
  "nazwany argument atrybutu może przywoływać tylko pole niestatyczne lub właściwość skalarną typu parametru atrybutu",
  "nieprawidłowy argument atrybutu — wyrażenie musi być stałą typu parametru atrybutu",
  "argument atrybutu nie może używać parametrów typu ogólnego",
  "element %t może zostać użyty wyłącznie jako atrybut autonomiczny",
  "elementu docelowego atrybutu „field” nie można użyć dla nietrywialnej właściwości/zdarzenia",
  "nieprawidłowy element docelowy atrybutu dla atrybutu autonomicznego",
  "nieprawidłowy element docelowy atrybutu dla tego kontekstu",
  "W tym miejscu nie można użyć atrybutu %t",
  "element %t jest przestarzały; użyj konstrukcji „...”, aby określić tablicę parametrów",
  "nie można rozszerzyć domyślnej przestrzeni nazw",
  "typ opakowany musi być klasą wartości lub wyliczeniem",
  "odwołanie śledzące do klasy wartości jest niedozwolone",
  "dojście do klasy wartości jest niedozwolone",
  "odwołanie śledzące do wyliczenia jest niedozwolone",
  "dojście do wyliczenia jest niedozwolone",
  "publiczny typ natywny jest niedozwolony",
  "publiczny typ zagnieżdżony jest niedozwolony",
  "typy ogólne nie są dozwolone w języku C++/CX",
  "metody ogólne nie są dozwolone w języku C++/CX",
  "ograniczenia ogólne są niedozwolone",
  "niepubliczne składowe danych nie są dozwolone w publicznych typach wartości języka C++/CX",
  "publiczne składowe inne niż elementy danych nie są dozwolone w publicznych typach wartości języka C++/CX",
  "konstruktory nie są dozwolone w publicznych typach wartości języka C++/CX",
  "zwracany typ metody dostępu „add” musi być typem Windows::Foundation::EventRegistrationToken",
  "zwracany typ metody dostępu „remove” musi być typem void",
  "typ parametru metody dostępu „remove” musi być typem Windows::Foundation::EventRegistrationToken",
  "dojście lub odwołanie do ogólnego typu parametru nie jest dozwolone",
  "publiczne elementy członkowskie danych nie są dozwolone w typach bez wartości",
  "Kod C++/CX można włączyć tylko w trybie Microsoft C++",
  "Nie można łączyć trybów C++/CLI i C++/CX",
  "element %sq wymaga trybu C++/CX",
  "Tryb C++/CX wymaga wersji microsoft_version >= 1600",
  "Pola literału nie są dozwolone w języku C++/CX",
  "standardowe odwołanie nie może być powiązane z typem języka C++/CX",
  "typ musi odpowiadać typowi Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64 lub default::uint64",
  "typ wartości języka C++/CX nie może mieć zdarzeń",
  "rzutowanie dynamic_cast na typ dojścia musi odwoływać się do pełnego typu klasy",
  "tablica Platform::Array może być tylko jednowymiarowa",
  "odwołanie śledzące do standardowego typu klasy jest niedozwolone",
  "typ wartości języka C++/CX nie może dziedziczyć z interfejsu",
  "typ wartości języka C++/CX nie może zawierać funkcji wirtualnych",
  "słowo kluczowe „partial” może być stosowane tylko do elementu „ref class” lub „ref struct” w zakresie globalnym lub zakresie przestrzeni nazw",
  "parametr metody dostępu „set” musi mieć typ „const Platform::Array<T>^”",
  "definicja publicznego typu języka C++/CX jest niedozwolona w zasięgu globalnym",
  "właściwość indeksowana z publiczną metodą dostępu „get” lub „set” nie jest dozwolona",
  "publiczny zagnieżdżony typ delegata jest niedozwolony",
  "nieprawidłowy inicjator delegata — oczekiwano elementu „(<adres-funkcji lub obiekt-funkcji> [, Platform::CallbackContext])” lub „(<object handle>, <adres-elementu-członkowskiego> [, Platform::CallbackContext [, bool]])”",
  "nieprawidłowy inicjator delegata — obiekt musi być dojściem do klasy typu %[managed]",
  "język C++/CX nie obsługuje tablic „in/out” — użyj deklaracji „const Platform::Array<T>^” dla tablicy „in” oraz „Platform::WriteOnlyArray<T>^” lub „Platform::Array<T>^*” dla tablicy „out” w publicznych interfejsach API",
  "brak atrybutu „target” dla elementu %nd",
  "żadna zadeklarowana funkcja składowa nie jest zgodna z atrybutami „target” dla elementu %n",
  "Atrybuty firmy Microsoft w tej lokalizacji są dozwolone tylko dla typów interfejsu",
  "Wymagana procedura programu rozpoznającego wiele wersji funkcji GNU",
  "typ wyliczeniowy zadeklarowany w klasie zarządzanej musi obejmować definicję",
  "nazwa kwalifikowana przez deklarację decltype jest niestandardowa w tym kontekście deklaracji",
  "nie można zadeklarować funkcji niewirtualnej przy użyciu modyfikatora „final”",
  "atrybut „target” nie jest obsługiwany w funkcji specjalnej",
  "musi być literałem ciągu typu narrow",
  "niezgodne nawiasy",
  "brak odpowiedniego elementu „push_options”",
  "ta dyrektywa pragma jest niedozwolona w funkcji",
  "deklaracja operatora new lub delete „inline” jest niestandardowa",
  "inicjator pamięci dla składowej danych nie może być rozwinięciem pakietu",
  "ogólne wyrażenia lambda nie mogą mieć wartości domyślnych przechwytywania w tym trybie",
  "domyślny argument szablonu w deklaracji elementu zaprzyjaźnionego może być określony tylko w definicji",
  "deklaracja elementu zaprzyjaźnionego szablonu z domyślnym argumentem szablonu musi być jedyną deklaracją (pierwsza deklaracja: %p)",
  "deklaracja nieprzezroczystego wyliczenia nie może należeć do innej deklaracji",
  "deklaracja nieprzezroczystego wyliczenia jest niestandardowa w tym kontekście",
  "rozszerzona składnia elementu zaprzyjaźnionego jest funkcją języka C++11",
  "separatory cyfr nie zostały włączone, apostrof rozpoczyna literał znakowy",
  "separator cyfr nie może pojawiać się w tym miejscu",
  "element „constexpr” jest ignorowany w trybie Microsoft",
  "nieprawidłowe wyrażenie dla wyniku wyrażenia instrukcji",
  "identyfikator jest makrem, a nie sufiksem literału",
  "nie można wywołać elementu %nd dla wartości lvalue",
  "nie można wywołać elementu %nd dla wartości rvalue",
  "funkcji elementu członkowskiego nie można wywołać dla wartości lvalue",
  "funkcji elementu członkowskiego nie można wywołać dla wartości rvalue",
  "lista parametrów szablonu jest zbyt długa",
  "typ szablonu aliasu %t1 jest niezgodny z poprzednim typem elementu %t2 w ponownej deklaracji elementu %nfd",
  "inicjator pola dla elementu %nd nie jest wyrażeniem stałym",
  "liczba ograniczeń argumentu musi być taka sama w każdym ciągu ograniczenia",
  "ciąg ograniczenia zawiera za dużo ograniczeń alternatywnych; nie wszystkie ograniczenia zostały sprawdzone",
  "wywołanie za pośrednictwem niekompletnej klasy %t będzie zawsze powodowało błąd po utworzeniu wystąpienia",
  "element decltype(auto) nie może mieć dodanych kwalifikatorów typu",
  "elementu init-capture %nod nie można przechwycić w tym miejscu",
  "nieprawidłowy argument szablonu bez typu o typie %t",
  "atrybut abi_tag jest ignorowany (nie ma on znaczenia w trybie C)",
  "ponowna deklaracja dodaje atrybut abi_tag „%s”",
  "atrybut abi_tag jest ignorowany (jest on zastępowany przez późniejszy atrybut abi_tag)",
  "wcześniejsza deklaracja elementu %nd nie miała atrybutu abi_tag",
  "(zobacz wcześniejszą deklarację %p)",
  "atrybut abi_tag jest ignorowany podczas specjalizacji",
  "element decltype(auto) nie może znajdować się we wskaźniku, odwołaniu ani konstrukcji wskaźnika do składowej",
  "oczekiwano wartości „class” lub „typename”",
  "wyrażenie położenia „new” odwołuje się do elementu %nd bez położenia",
  "podczas tworzenia biblioteki środowiska uruchomieniowego należy określić tryb C++14",
  "%s",
  "ostrzeżenie wiersza polecenia",
  "Ostrzeżenie wiersza polecenia",
  "Niestatyczna funkcja składowa constexpr nie będzie niejawnie elementem „const” w języku C++14",
  "typ zmiennej %t w funkcji constexpr nie jest typem literału",
  "zmienna w funkcji constexpr nie ma automatycznego okresu magazynu",
  "nie zainicjowano zmiennej w funkcji constexpr",
  "Inicjowanie w nawiasach klamrowych zmiennej zadeklarowanej przy użyciu typu symbolu zastępczego bez znaku „=” wymaga dokładnie jednego elementu w nawiasach klamrowych",
  "konfiguracja opcji --target elementu „%s” nie istnieje",
  "atrybut nie jest obsługiwany w 64-bitowych konfiguracjach x86",
  "element „%s” wymaga argumentu",
  "konstruktor lub destruktor nie może być koprocedurą",
  "element %n nie może być koprocedurą",
  "wyrażenia co_yield są niedozwolone w klauzuli catch",
  null,
  null,
  null,
  null,
  "nie znaleziono szablonu klasy %sq",
  "użyj słowa kluczowego „typename”, aby traktować element %n jak typ w kontekście zależności",
  "wartość argumentu musi być mniejsza niż suma elementów wektora",
  "element %t nie ma elementu członkowskiego %sq",
  "lista w nawiasach klamrowych nie dostarcza zwracanego typu",
  "wyrażenie co_await musi występować w zakresie funkcji",
  "wyrażenie co_await jest niedozwolone wewnątrz klauzuli „catch”",
  "koprocedura nie może mieć parametru wielokropka",
  "włączenie funkcji constexpr języka C++14 wymaga obsługi elementu „bool”",
  "nie zdefiniowano funkcji constexpr %nd",
  "tego wywołania nie można obliczyć, ponieważ funkcja docelowa %nd nie jest funkcją constexpr lub nie została jeszcze w pełni zdefiniowana",
  "uwaga",
  "Uwaga",
  "nieprawidłowa unia anonimowa — szablon składowej aliasu jest niedozwolony",
  "wartość literału w formacie UTF-8 może zajmować maksymalnie jedną jednostkę kodu",
  "wartości elementu %nd nie można użyć jako stałej",
  "wskaźnika lub odwołania do elementu %nd nie można użyć jako stałej",
  "skrypt o wartości innej niż zero w przypadku obiektu niebędącego tablicą",
  "nie można uzyskać dostępu do pozycji %d1 w tablicy składającej się z następującej liczby elementów: %d2",
  "wywołane z:",
  "nieprawidłowy dostęp do nieaktywnego elementu %n1 unii (element %n2 jest aktywny)",
  "polecenia „goto” nie można wykonywać w kontekstach constexpr",
  "brak wartości zwracanej",
  "element wywoływany ma wartość null",
  "próba wyłuskania pustego wskaźnika",
  "próba uzyskania dostępu do magazynu w pozycji wykraczającej o jeden poza tablicę składającą się z następującej liczby elementów: %d",
  "próba uzyskania dostępu do wygasłego magazynu",
  "próba uzyskania dostępu do magazynu środowiska uruchomieniowego",
  null,
  "nie można wywołać elementu %nd innego niż constexpr",
  "nie można używać tablicy o zmiennej długości podczas obliczania wyrażenia constexpr",
  "nie można wykonać ujemnego przesunięcia",
  "przesunięcie (%d) jest zbyt duże",
  "wartość przekracza zakres dla %t",
  "błąd liczby zmiennoprzecinkowej",
  "próba wyłuskania pustego wskaźnika do składowej (składowej danych)",
  "porównanie wskaźnika z elementem void i wskaźnika z funkcją jest niestandardowe",
  "nie można zainicjować metadanych",
  "nieprawidłowe rzutowanie typu bazowego na pochodny (pełny typ klasy to %t)",
  "nieprawidłowy dostęp do elementu %n w obiekcie, którego pełny typ to %t",
  "element „__auto_type” jest niedozwolony w tym miejscu",
  "element „__auto_type” nie zezwala na wiele deklaratorów",
  "inicjowanie za pomocą deklaracji „{...}” jest niedozwolone dla elementu „__auto_type”",
  "element „__auto_type” musi być symbolem zastępczym dla pełnego typu zmiennej (a nie składnika tego typu)",
  "zmienna zadeklarowana za pomocą elementu „__auto_type” wymaga inicjatora",
  "stała całkowita musi być równa zero lub większa",
  "typ musi być typem całkowitym",
  "nie można zinterpretować wyrażenia",
  "nie można zinterpretować instrukcji",
  "nieprawidłowe użycie adresu magazynu interpretera",
  "nieprawidłowy rodzaj stałej dla wyrażenia stałej",
  "typ %t jest za duży dla szacowania wyrażenia stałej",
  "nieprawidłowy typ %t na potrzeby obliczania wyrażenia stałej",
  "konwersja z typu %t1 na %t2 jest nieprawidłowa w szacowaniu wyrażenia stałej",
  "nie można wykonać konwersji liczby zmiennoprzecinkowej",
  null,
  "wnioskowane typy zwracane są funkcją języka C++14",
  "nie można obliczyć konstruktora ze skojarzonym destruktorem",
  "element %n nie został zainicjowany podczas obliczania elementu ze specyfikatorem constexpr",
  "nieprawidłowa różnica wskaźnika w obliczeniach wyrażenia constexpr",
  "nieprawidłowa operacja arytmetyczna dotycząca wskaźnika typu nietablicowego",
  "nie można ustawić wskaźnika przed pierwszym elementem tablicy",
  "koprocedura z wnioskowanym typem zwracanym jest nieprawidłowa",
  "wyrażenie niedozwolone w kontekście, którego nie obliczono",
  null,
  null,
  "wyrażenie „return” jest niedozwolone w koprocedurze (zamiast tego użyj wyrażenia „co_return”)",
  "wyrażenie „co_return” jest dozwolone tylko w koprocedurach",
  "nie można porównać wartości zmiennoprzecinkowych",
  "nie można porównać wartości wskaźników, ponieważ nie wskazują na ten sam kompletny obiekt lub wskazują na podobiekty o różnej dostępności",
  "ignorowanie atrybutu abi_tag w przestrzeni nazw innej niż inline",
  "ignorowanie atrybutu abi_tag w anonimowej przestrzeni nazw",
  "typ parametru złożonego lub zespolonego szablonu jest niestandardowy",
  "wyrażenie co_yield jest niedozwolone poza zakresem funkcji",
  "ignorowanie wskazania lokalnego wątku dotyczącego unii anonimowej",
  null,
  "szablon zmiennej",
  "dostęp do niezainicjowanego obiektu",
  "próba odczytu z magazynu nietrwałego",
  "nieprawidłowy dostęp do nieaktywnego elementu %n1 unii (żadne pole nie jest aktywne)",
  "definicje etykiet nie mogą występować w funkcjach constexpr",
  "nie można porównać wskaźnika za końcem tablicy ze wskaźnikiem innego kompletnego obiektu",
  "typ funkcji %t jest nieprawidłowym typem na potrzeby tworzenia wystąpienia szablonu zmiennej",
  "zmienna nie może mieć niepełnego typu %t",
  "dostęp do niezainicjowanego podobiektu (%n)",
  "dostęp do niezainicjowanego podobiektu (klasa bazowa: %t)",
  "wywołanie pseudodestruktora jest niedozwolone w wyrażeniu stałym",
  "próba zmodyfikowania magazynu stałych",
  null,
  null,
  "próba uzyskania dostępu do magazynu jedną pozycję za obiektem traktowanym jak tablica z jednym elementem",
  "nie można użyć instrukcji reinterpret_cast na potrzeby obliczania wyrażenia constant-expression",
  "operacja jest niedozwolona dla pustego wskaźnika",
  "nie można użyć wartości elementu *this jako stałej",
  "nie można użyć słowa kluczowego „inline” dla zagnieżdżonej deklaracji przestrzeni nazw",
  "atrybut „carries_dependency” jest ignorowany",
  "atrybut „__event __interface” nie może mieć tutaj definicji",
  "procedura obsługi zdarzeń musi mieć pusty lub całkowity zwracany typ ",
  "atrybut „__event __interface” musiał zostać zdefiniowany wcześniej",
  "zbyt wiele argumentów szablonu dla elementu %n",
  "moduł wyliczający został już zadeklarowany (zobacz %nd)",
  "emulowaną wersją Microsoft musi być co najmniej 1903, aby użyć polecenia „--ms_c++14”",
  "emulowaną wersją Microsoft musi być co najmniej 1903, aby użyć polecenia „--ms_c++latest”",
  "typ %t nie może typem _Atomic, ponieważ jest typem tablicy lub funkcji",
  "nie można zastosować specyfikatora _Atomic(...) do kwalifikowanego typu %t",
  "dostęp do elementu członkowskiego w obiekcie _Atomic",
  "pole bitowe nie może mieć typu _Atomic",
  "typy klasy _Atomic zostały wyłączone",
  "konstruktor elementów constexpr wywołuje konstruktora elementów innych niż constexpr na potrzeby inicjowania podobiektów",
  "oczekiwano przecinka (jednoargumentowa wersja elementu static_assert nie została włączona w tym trybie)",
  "błąd potwierdzenia statycznego",
  "co najwyżej jeden z kwalifikatorów _Nullable, _Nonnull i _Null_unspecified może modyfikować typ",
  "kwalifikatory dopuszczania wartości null są dozwolone tylko w typach: wskaźnik i wskaźnik do składowej",
  "długość wektora jest zbyt duża",
  "typ elementu wektora musi być typem integralnym, wyliczeniem lub rzeczywistą liczbą zmiennoprzecinkową",
  "wbudowana funkcja jest niedostępna, ponieważ 128-bitowe liczby całkowite nie są obsługiwane",
  "wbudowana funkcja jest niedostępna, ponieważ typy wektorów nie są obsługiwane",
  "dwa kolejne lewe nawiasy kwadratowe zawsze wprowadzają listę atrybutów, ale lista atrybutów nie może znajdować się w tym miejscu",
  "nierozpoznany atrybut „target” dyskwalifikuje tę procedurę z użycia przez procedurę programu rozpoznawania nazw",
  "%t nie jest typem wektora",
  "typy wektorów %t1 i %t2 muszą mieć tę samą długość",
  "dodane argumenty domyślne nie mogą prowadzić do deklarowania konstruktora domyślnego lub konstruktora kopiującego",
  "argument szablonu bez typu dla typu referencyjnego musi być powiązany z funkcją lub kompletnym obiektem",
  "element %t nie jest dozwolony w tym miejscu",
  "użycie specyfikatora klasy magazynu „register” nie jest dozwolone",
  "użycie specyfikatora klasy magazynu „register” jest przestarzałe",
  "zwiększanie wartości logicznej nie jest dozwolone",
  "element %sq, zadeklarowany jako iterator instrukcji „for” opartej na zakresie, nie może być ponownie zadeklarowany w tym zakresie",
  "nie można tutaj użyć przestrzeni nazw atrybutu (ponieważ określono prefiks „using”)",
  "przestrzeń nazw atrybutu %sq jest nierozpoznana",
  "inicjator domyślnej składowej nie jest dozwolony w klasie wartości",
  "element „--implicit_noexcept” wymaga trybu umożliwiającego użycie elementu noexcept",
  "nie można złożyć operacji obejmującej wirtualną klasę bazową (%t)",
  "inicjowanie nie jest stałą",
  "nie można obliczyć wartości niekompletnego elementu %t",
  "ignorowanie wartości zwracanej z zadeklarowanej procedury z atrybutem „nodiscard”",
  "ignorowanie typu wartości zwracanej z atrybutem „nodiscard”",
  "atrybut „nodiscard” nie ma zastosowania do destruktorów ani procedur ze zwracanym typem void",
  "atrybut „fallthrough” ma zastosowanie tylko do instrukcji o wartości null",
  "atrybut „fallthrough” może występować tylko w instrukcji zawierającej switch",
  "instrukcja fallthrough musi znajdować się przed etykietą przypadku switch lub wartością domyślną",
  "wskaźnik na element tymczasowy z ograniczonym czasem istnienia lub odwołanie do niego",
  "nie można uzyskać adresu funkcji z atrybutem „enable_if”, której warunek nie jest bezwarunkowo prawdziwy",
  "atrybuty „enable_if” z warunkami, które nie są wartościami stałymi, nie są obecnie obsługiwane",
  "w tym miejscu zadeklarowano atrybut",
  "element __has_include nie może występować poza wyrażeniem #if",
  "nie można dodać klasy bazowej CComCoClass",
  "ciąg inny niż zakończony wartością null",
  "nie można używać typu nieskalarnego %t w wywołaniu pseudodestruktora",
  "adres elementu „weak” %n nie jest stały",
  "zbyt wiele rekursywnych podstawień podpisów szablonów funkcji",
  "nieprawidłowy specyfikator dla deklaracji powiązania ze strukturą",
  "nieprawidłowa składnia powiązania ze strukturą",
  "brak inicjatora",
  "typ %t nie ma składników, z którymi można powiązać",
  "zbyt wiele identyfikatorów",
  "istnieje więcej elementów niż nazw powiązań",
  "nie zdefiniowano elementu „std::tuple_element”",
  "nie można utworzyć wystąpienia elementu „std::tuple_element” dla elementu <%s, %t>",
  "nie można wywołać funkcji składowej „get<%s>()” dla typu %t",
  "żadne wystąpienie elementu %no nie jest zgodne z listą argumentów",
  "to powiązanie ze strukturą wymaga odpowiedniej funkcji %sq, a żadnej nie znaleziono",
  "powiązanie ze strukturą nie może być deklarowane jako „inline”",
  "powiązanie ze strukturą nie może być deklarowane jako „constexpr”",
  "powiązanie ze strukturą nie może być deklarowane jako jawna klasa magazynu",
  "wyrażenie std::tuple_size<%t>::value nie jest prawidłowym integralnym wyrażeniem stałym",
  "w deklaracji warunku musi być zadeklarowana zmienna",
  "deklaracja warunku musi zawierać inicjator",
  "inicjator w nawiasach nie jest dozwolony dla deklaracji warunku",
  "w deklaracji warunku może być deklarowana tylko jedna zmienna",
  "powiązanie ze strukturą nie może wiązać z typem zamkniętym",
  "nie można powiązać z niepublicznym elementem %n",
  "nie można powiązać z niekompletnym typem %t",
  "ta deklaracja nie jest prawidłowa w tym miejscu",
  "treść funkcji wyrażenia stałego nie może być blokiem try funkcji",
  "transfer kontroli do bloku if funkcji wyrażenia stałego jest niedozwolony",
  "nie można przechwycić powiązania ze strukturą",
  "emulowaną wersją Microsoft musi być co najmniej 1911, aby użyć polecenia „--ms_c++17”",
  "próba odczytu poza końcem obiektu",
  "wyrażenia lambda w wyrażeniach stałych nie są włączone w tym trybie",
  "wyrażenie stałe nie może zawierać wyrażenia lambda",
  "wartość przekracza liczbę argumentów szablonu",
  "drugi operator w binarnym wyrażeniu zwijania nie pasuje do pierwszego",
  "nieprawidłowy operator wyrażenia zwijania",
  "wyrażenia binarnego zwijania nie można zastosować do dwóch pakietów parametrów",
  "puste rozszerzenie jest nieprawidłowe dla tego wyrażenia zwijania",
  "niestatyczny element członkowski danych nie może być deklarowany jako wbudowany",
  "wyrażenie zwijania nie odwołuje się do pakietu parametrów",
  "dwie funkcje o takich samych typach parametrów, ale różnych specyfikacjach wyjątków nie mogą być przeciążone",
  "specyfikacje wyjątków dynamicznych nie są dozwolone w tym trybie",
  null,
  "nieprawidłowy argument operacji dla specyfikatora noexcept",
  "wyrażenie lambda nie może wystąpić w specyfikatorze noexcept szablonu",
  "element %nfd jest niedostępny",
  "nieprawidłowy specyfikator w deklaracji szablonu wyliczenia",
  "Typy 80-bitowych liczb zmiennoprzecinkowych nie są obsługiwane w tej konfiguracji",
  "Typy 128-bitowych liczb zmiennoprzecinkowych nie są obsługiwane w tej konfiguracji",
  "nieprawidłowa wartość modułu wyliczającego",
  "musi mieć typ kwalifikowany _Atomic",
  "typ elementu tablicy musi być kompletny",
  "atrybut always_inline został pominięty dla tej funkcji",
  "wartość ujemna nie jest tutaj dozwolona",
  "element pakietu liczb całkowitych nie może być zgodny z: %n",
  "element pakietu liczb całkowitych nie może być zgodny z: %n",
  "nieoczekiwany desygnator",
  "nie można obliczyć wartości __builtin_offsetof",
  "nie można zdefiniować wytycznych wnioskowania %t",
  "wytyczne wnioskowania należy zadeklarować w tym samym zakresie co %n",
  "nieprawidłowy specyfikator deklaracji wytycznych wnioskowania (dozwolony jest tylko specyfikator „jawny”)",
  "nie można uzyskać dostępu do modyfikowalnej %n wartości stałej w wyrażeniu stałym",
  "modyfikator funkcji nie ma zastosowania do deklaracji statycznego elementu członkowskiego",
  "atrybut „overloadable” wymaga deklaracji funkcji prototypowej",
  "nie można wywnioskować parametru szablonu „auto” typu %t1 na podstawie %t2",
  "nazwa szablonu klasy musi być symbolem zastępczym inicjowanego kompletnego typu (a nie składnika tego typu)",
  "deklaracje aliasów są funkcją języka C++11",
  "szablony aliasów są funkcją języka C++11",
  "zwracany typ musi bezpośrednio wyznaczać specjalizację skojarzonego szablonu klasy",
  "element copy-list-initialization nie może używać elementu „explicit” %n",
  "wytyczne wnioskowania",
  "Nieprawidłowa wartość dla operatora literału zdefiniowanego przez użytkownika",
  "atrybut __has_cpp_attribute nie może występować poza wyrażeniem #if ani #elif",
  "wytyczne wnioskowania należy zadeklarować z taką samą dostępnością co %n",
  "lambda nie jest dozwolona w tym kontekście",
  "określone wyrównanie nie jest odpowiednikiem poprzedniej deklaracji",
  "w definicji nie określono wyrównania; poprzednia deklaracja miała określone wyrównanie",
  "funkcja builtin jest niedostępna, ponieważ typy 128-bitowych liczb zmiennoprzecinkowych nie są obsługiwane",
  "przesuwanie wartości ujemnej w lewo ma niezdefiniowane zachowanie",
  "desygnatory tablicy są niestandardowe w języku C++",
  "desygnatory łańcuchowe są niestandardowe w języku C++",
  "mieszanie inicjatorów wyznaczonych i niewyznaczonych jest niestandardowe w języku C++",
  "inicjatory poza kolejnością są niestandardowe w języku C++",
  "szablon operatora literału ciągu musi mieć listę parametrów szablonu odpowiadającą elementowi „<<typename T, T ...>”",
  "desygnator zależny od szablonu jest niedozwolony",
  "atrybut jest w konflikcie z poprzednim atrybutem likely/unlikely",
  "niejawne przechwytywanie by-copy elementu „this” jest przestarzałe",
  "pusta lista parametrów szablonu jest niedozwolona w wyrażeniu lambda",
  "emulowaną wersją Microsoft musi być co najmniej 1920, aby użyć polecenia „--ms_c++20”",
  "Argument pragma STDC nie jest akceptowany w tym trybie",
  "wyrażenie stałe, jeśli instrukcje są funkcją języka C++17",
  "rozwinięcie parametru pack jest niedozwolone na wyznaczonej liście inicjatorów",
  "desygnator pola nie ma wartości",
  "unia może mieć co najwyżej jeden inicjator pola",
  "nie znaleziono prawidłowego typu std::%s (element <compare> musi być dołączony)",
  "nieprawidłowe typy (%t1 i %t2) dla wbudowanego operatora <=>",
  "wyrażenia zwijania są niestandardowe w tym trybie",
  "katalog określony przy użyciu opcji --current_directory nie jest katalogiem: %s",
  "Ostrzeżenie PCH",
  "zatrzymanie nagłówka musi znajdować się w zakresie globalnym. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "wywołanie makra w toku. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "zatrzymanie nagłówka nie znajduje się w zakresie pliku. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "zatrzymanie nagłówka nie może znajdować się w makrze ani bloku #if. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "zatrzymanie nagłówka nie może znajdować się w bloku wiązania. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "nie można znaleźć odpowiedniej lokalizacji zatrzymania nagłówka. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "dyrektywy line nie mogą być używane w PCH. Plik PCH funkcji IntelliSense nie został wygenerowany.",
  "nieprawidłowy specyfikator ograniczenia",
  "funkcja z ograniczeniem amp %nfd musi być wywoływana z funkcji z ograniczeniem amp",
  "funkcja %nfd1 ma specyfikatory ograniczenia, które są niezgodne z funkcją wywołującą %nfd2",
  "żadne przeciążenie kandydujące nie ma poprawnych specyfikatorów ograniczenia",
  "element %t nie jest dozwolony w funkcji z ograniczeniem amp %nfd",
  "niedozwolony typ %t we wskaźniku this dla funkcji składowej ograniczonej przez amp %nfd",
  "niedozwolony zwracany typ %t dla funkcji z ograniczeniem amp %nfd",
  "niedozwolony typ parametru %t dla funkcji z ograniczeniem amp %nfd",
  null,
  "niedozwolona klasa magazynu %s w funkcji z ograniczeniem amp %nfd",
  "element %s nie jest dozwolony w funkcji z ograniczeniem amp %nfd",
  "niedozwolone rzutowanie w funkcji z ograniczeniem amp",
  "specyfikacja wyjątku nie jest dozwolona w funkcji z ograniczeniem amp",
  "niedozwolony element pośredni w funkcji z ograniczeniem amp %nfd",
  "wywołania funkcji wirtualnej są niedozwolone w funkcji z ograniczeniem amp %nfd",
  "pośrednie wywołania funkcji są niedozwolone w funkcji z ograniczeniem amp %nfd",
  "klasa magazynu tile_static nie jest dozwolona w tym miejscu",
  "niedozwolona etykieta w funkcji z ograniczeniem amp %nfd",
  "niedozwolone pole bitowe dla funkcji z ograniczeniem amp %nfd",
  "niedozwolony wielokropek dla funkcji z ograniczeniem amp %nfd",
  "niedozwolona wirtualna podstawa dla typu zgodnego z amp %nfd",
  "niedozwolone odwołanie zewnętrzne w funkcji z ograniczeniem amp %nfd",
  "wartość stała jest poza obsługiwanym zakresem w funkcji z ograniczeniem amp %nfd",
  "niedozwolona wartość dyrektywy pragma pack %s dla funkcji z ograniczeniem amp",
  "nakładające się specyfikatory ograniczenia są niedozwolone",
  "specyfikatory ograniczenia destruktora muszą obejmować unię specyfikatorów ograniczenia na wszystkich konstruktorach",
  null,
  "element nostdlib wymaga co najmniej jednego wymuszonego użycia",
  null,
  null,
  null,
  null,
  "zewnętrzne funkcje języka C nie obsługują wielu specyfikatorów ograniczenia",
  "wskaźniki do funkcji składowej, wskaźniki funkcji, odwołania do funkcji ze specyfikatorem ograniczenia „amp” nie są dozwolone",
  "klasa bazowa, składowa danych lub element tablicy muszą być wyrównane co najmniej o 4 bajty w przypadku funkcji z ograniczeniem amp %nfd",
  "przesunięcie składowej danych musi być wielokrotnością naturalnego wyrównania składowej w przypadku funkcji z ograniczeniem amp %nfd",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "zmienne tile_static nie mogą mieć inicjatora",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "metoda /clr:nostdlib wymaga, aby biblioteka mscorlib.dll znajdowała się na liście wymuszonych użyć",
  "/clr:netcore z elementem /clr:nostdimport wymaga, aby pliki System.Runtime.dll, System.Runtime.Extensions.dll, System.Runtime.InteropServices.dll i System.Runtime.CompilerServices.VisualC.dll znajdowały się na liście wymuszonych użyć",
  null,
  null,
  null,
  null,
  null,
  "<niepowodzenie emisji diagnostycznej>",
  "Aparat funkcji IntelliSense nie może działać prawidłowo, ponieważ istnieje zbyt wiele błędów, z których część może nie być widoczna w edytorze.",
  "przypisanie do przestarzałej konstrukcji „this” nie jest zgodne z trybem C++11",
  "wystąpił nieznany błąd. Nie wygenerowano pliku PCH funkcji IntelliSense.",
  "Nie można zamapować co najmniej jednej ścieżki zdalnej na istniejące ścieżki lokalne. Może to mieć negatywny wpływ na działanie funkcji IntelliSense.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "oczekiwano elementu „>>>”",
  "nie można odnaleźć deklaracji __cudaPushCallConfiguration. Instalacja zestawu narzędzi CUDA może być uszkodzona.",
  "inicjator zgodny ze specyfikacją C++17 jest niestandardowy w tym trybie",
  "przechwycenie wyrażenia *this jest niestandardowe w tym trybie",
  "prefiks atrybutu „using” zgodny ze specyfikacją C++17 jest niestandardowy w tym trybie",
  "zagnieżdżone przestrzenie nazw zgodne ze specyfikacją C++17 są niestandardowe w tym trybie",
  "tylko jeden element „constexpr, „consteval” i „constinit” może występować w deklaracji",
  "funkcja nie może być jednocześnie zadeklarowana jako consteval i virtual w tym trybie",
  "słowo kluczowe „consteval” jest niedozwolone dla jawnej dyrektywy tworzenia wystąpienia",
  "słowo kluczowe „consteval” nie jest prawidłowe w tym miejscu",
  "destruktor nie może mieć deklaracji consteval",
  "konstruktor klasy z wirtualnymi klasami podstawowymi nie może mieć deklaracji consteval",
  "słowo kluczowe „consteval” jest niedozwolone w deklaracji zmiennej lub statycznej składowej danych",
  "element %nd został wcześniej zadeklarowany jako consteval",
  "element %nd nie został wcześniej zadeklarowany jako consteval",
  "funkcja „main” nie może być zadeklarowana jako consteval",
  "wywołanie wyrażenia consteval %n nie wygenerowało prawidłowego wyrażenia stałego",
  "adres wyrażenia consteval %n w wyniku wyrażenia stałego",
  "składowa consteval nie może przesłonić składowej innej niż consteval %n",
  "składowa inna niż consteval nie może przesłonić składowej consteval %n",
  "powiązanie ze strukturą",
  "rzutowanie dynamic_cast na podobiekt typu %t1 jest nieprawidłowe (najbardziej odległy typ pochodny to %t2)",
  "identyfikator __VA_OPT__ może występować tylko w listach zastępczych makr ze zmienną liczbą argumentów",
  "identyfikator __VA_OPT__ nie może występować w operandzie makra __VA_OPT__",
  "brak nawiasu zamykającego dla makra __VA_OPT__",
  "po identyfikatorze __VA_OPT__ musi wystąpić znak „(”",
  "operator „##” nie może być pierwszym elementem operandu makra __VA_OPT__",
  "operator „##” nie może być ostatnim elementem operandu makra __VA_OPT__",
  "zagnieżdżone wbudowane przestrzenie nazw zgodne ze specyfikacją C++20 są niestandardowe w tym trybie",
  "nie można przekonwertować wskaźnika do klasy podstawowej %t2 na wskaźnik do klasy pochodnej %t1 — próba wskazania poza najbardziej odległy obiekt pochodny",
  null,
  "nie można użyć ciągu „main” jako nazwy zmiennej globalnej ani podanego wiązania języka C",
  "nie można zadeklarować funkcji „main” w specyfikacji wiązania",
  "powiązanie ze strukturą jest niedozwolone w warunku",
  "identyfikator przestrzeni nazw atrybutu jest wymagany przed znakami „::”",
  "dozwolona jest tylko jedna przestrzeń nazw atrybutów",
  "element „return” jest niedozwolony w tym miejscu",
  "powiązania ze strukturą nie można łączyć z innymi deklaratorami",
  "nie można rozgałęzić poza kontekstem obliczania stałej",
  "szablony powiązania ze strukturą są niedozwolone",
  "inicjator w nawiasach musi być wyrażeniem, a nie listą w nawiasach klamrowych",
  "nie można wywnioskować argumentów szablonu klasy",
  "operatora new lub delete nie można zadeklarować jako „consteval”",
  "w tym miejscu nie można użyć adresu funkcji consteval",
  "wyrównanie typu funkcji (%t) jest niestandardowe",
  "wyrównanie tablicy nieokreślonego powiązania jest niestandardowe w języku C",
  "zmienna nie może mieć jednocześnie atrybutów „common” i „internal_linkage”",
  "atrybut „internal_linkage” nie pojawił się we wcześniejszej deklaracji",
  "nie znaleziono zdatnego kandydata wnioskowania argumentu szablonu dla elementu %n",
  "wywołanie w pełni kwalifikowanego konstruktora jest niedozwolone",
  "przyjęty domyślnie operator porównania musi być składową lub elementem zaprzyjaźnionym klasy, do której ma zastosowanie",
  "nieprawidłowy typ %t parametru domyślnego operatora porównania (wymagany jest typ „reference to const X”, gdzie X jest typem klasy otaczającej)",
  "zwracanym typem domyślnego operatora porównania musi być „bool”",
  "domyślny operator porównania elementu członkowskiego musi mieć wartość „const”",
  null,
  "Typ obietnicy %t koprocedury nie może mieć ustawionej jednocześnie metody „return_void” i metody „return_value”",
  "metoda „return_value” zadeklarowała element %p",
  "metoda „return_void” zadeklarowała element %p",
  "brak instrukcji co_return, podczas gdy %t nie ma elementu „return_void” na końcu %n",
  "nie znaleziono wariantu nothrow globalnego elementu „operator new” dla alokacji stanu koprocedury",
  "nie znaleziono zdatnego do użycia elementu „operator delete” dla cofania alokacji koprocedury",
  "funkcja constexpr nie może być kokprocedurą",
  "argument operacji dla tego wyrażenia %s jest rozpoznawany jako niebędący klasą typ %t",
  "wyrażenie co_await jest niedozwolone w inicjatorze statycznym",
  "wyrażenie co_await wywołujące funkcję %n musi być niezwracalne",
  "zbyt wiele operacji ponownego zapisywania porównania cyklicznego",
  "możliwy do wnioskowania zwracany typ dla domyślnego operatora<=> musi mieć wartość „auto”",
  "niejawna kopia źródła nie będącego stałą",
  "powiązanie ze strukturą nie może deklarować jawnej klasy magazynu innej niż static lub thread_local",
  "domyślne operatory porównania nie są obsługiwane dla nieprostych pól właściwości firmy Microsoft",
  "standardowy typ porównania (%t) musi być typem klasy z pojedynczym niestatycznym elementem członkowskim danych typu całkowitego",
  "nie znaleziono statycznego elementu członkowskiego danych constexpr %sq w %t",
  "liczba elementów (%d) jest zbyt duża na potrzeby dynamicznej alokacji",
  "żądanie dynamicznej alokacji wyrażenia constexpr jest zbyt duże",
  "cofnięcie alokacji magazynu, który nie został dynamicznie przydzielony",
  "rozmiar cofania alokacji (%d1) nie odpowiada przydzielonemu rozmiarowi (%d2)",
  "tutaj wystąpił przydział",
  "typ cofania alokacji (%t1) nie jest zgodny z typem alokacji (%t2)",
  "nie cofnięto przydziału niektórych dynamicznych alokacji (łączna liczba: %d)",
  "wewnętrzny element %n zadeklarowany z nieoczekiwanym podpisem (typ %t)",
  ">> dane wyjściowe z elementu std::__report_constexpr_value",
  ">> koniec danych wyjściowych z elementu std::__report_constexpr_value",
  "nie można użyć tablicy z rozmiarem tablicy zależnej w ocenie wyrażenia constexpr",
  "ignorowanie wartości zwracanej z procedury zadeklarowanej z atrybutem „nodiscard” (%sq)",
  "ignorowanie typu wartości zwracanej z atrybutem „nodiscard” (%sq)",
  "konstruktor użyty do utworzenia odrzuconego obiektu zawiera atrybut „nodiscard”",
  "konstruktor użyty do utworzenia odrzuconego obiektu zawiera atrybut „nodiscard” (%sq)",
  "typ odrzuconego obiektu zawiera atrybut „nodiscard”",
  "typ odrzuconego obiektu zawiera atrybut „nodiscard” (%sq)",
  "odwołanie do pseudodestruktora może być używane tylko w przypadku wywołania pseudodestruktora",
  "jawne wywołanie destruktora jest niedozwolone w wyrażeniu stałym",
  "nieujęty w nawiasach operator przecinka w wyrażeniu indeksu tablicy jest przestarzały",
  "liczba dynamicznie przydzielonych elementów (%d) jest zbyt mała dla inicjatora",
  "nietrwały operand wyrażenia %s jest przestarzały",
  "używanie wyniku przypisania do nietrwałego obiektu skalarnego jest przestarzałe",
  "nietrwały typ docelowy dla złożonego wyrażenia przypisania jest przestarzały",
  "nietrwały parametr funkcji jest przestarzały",
  "nietrwały typ zwracany jest przestarzały",
  "używanie nietrwałego kwalifikatora w powiązaniu ze strukturą jest przestarzałe",
  "argument „ext_vector_type” musi mieć wartość z zakresu od 1 do 2047",
  "atrybut „ext_vector_type” może występować tylko w elemencie TypeDef",
  "atrybut „ext_vector_type” ma zastosowanie tylko do typów będących liczbami całkowitymi lub zmiennoprzecinkowymi",
  "to makro feature-test jest ignorowane i zwraca wartość 0 w bieżącym trybie kompilacji",
  "nie można ocenić inicjatora agregacji za pomocą wielu elementów dla unii",
  "Element %nd wybrany dla operatora ponownego zapisania nie zwraca typu logicznego",
  "wyrażenie new-expression wywołujące funkcję alokacji specyficzną dla klasy nie może być obliczane jako stała",
  "wyrażenie new umieszczania nie może dawać wartości stałej",
  "usuwanie za pomocą wskaźnika podobiektu wymaga destruktora wirtualnego",
  "%npTd, z odwróconymi argumentami",
  "argument operacji __INTADDR__ musi być odsunięty od wskaźnika o wartości null",
  "Konstrukcja _Generic dopasowuje wiele typów",
  "inne dopasowanie jest %t",
  "użyty tutaj atrybut „availability” jest ignorowany",
  "Instrukcja inicjatora w stylu języka C++20 w instrukcji „for” opartej na zakresie jest niestandardowa w tym trybie",
  "element co_await można zastosować tylko do instrukcji for opartej na zakresie",
  "nie można wywnioskować typu zakresu w pętli „for” opartej na zakresie.",
  "zmienne wbudowane to funkcja języka C++ 17",
  "niszczący operator delete wymaga elementu %t jako pierwszego parametru",
  "niszczący operator delete nie może mieć parametrów innych niż std::size_t i std::align_val_t",
  "opcje swobodnej klasy abstrakcyjnej mogą być używane tylko podczas kompilowania kodu C++",
  "nieprawidłowy początek wyrażenia w klauzuli requires",
  "wyrażenie rzutowania w klauzuli requires musi być ujęte w nawiasy",
  "ten operator nie może być wyświetlany na najwyższym poziomie (bez nawiasów) w klauzuli requires",
  "niepodzielne ograniczenie musi mieć typ bool",
  "niepowodzenie podstawiania niepodzielnego ograniczania",
  "niepodzielne ograniczenie nie jest stałe",
  "niepodzielne ograniczenie zwraca wartość false",
  "ograniczenie szablonu nie zostało spełnione",
  "definicja koncepcji nie może znajdować się w tym zakresie",
  "nieprawidłowa ponowna deklaracja elementu %nd",
  "podstawianie argumentów %T dla identyfikatora koncepcji nie powiodło się",
  "koncepcja jest fałszywa dla argumentów %T",
  "klauzula requires nie jest dozwolona w tym miejscu (nie jest to funkcja z szablonem)",
  "szablon koncepcji",
  "klauzula requires jest niezgodna z elementem %nfd",
  "oczekiwano atrybutu",
  null,
  "oczekiwano nazwy typu",
  "parametr wielokropka nie jest dozwolony w wyrażeniu requires",
  "parametr bez nazwy wyrażeniu requires nie ma żadnego wpływu",
  "oczekiwano nazwy koncepcji",
  "wywołanie elementu %s pojawiające się w wyrażeniu stałym zawsze zwraca wartość „true”",
  "wywołanie elementu %s pojawiające się w kontekście consteval zawsze zwraca wartość „true”",
  "wywołanie %s pojawiające się w funkcji innej niż constexpr zawsze zwraca wartość „false”",
  "ograniczenie typu nie powiodło się dla elementu %t",
  "opcji „export” nie można używać w trybach, w których włączono moduły języka C++",
  "deklaracja fragmentu modułu globalnego musi poprzedzać dowolną inną deklarację",
  "deklarację modułu można poprzedzać tylko fragment modułu globalnego",
  "fragment modułu prywatnego musi być poprzedzony deklaracją modułu",
  "nie można wyeksportować fragmentu modułu %s",
  "nie można zadeklarować więcej niż jednego modułu",
  "nie można zadeklarować więcej niż jednego fragmentu modułu %s",
  "moduł musi być zadeklarowany z niepustą nazwą",
  "%sq nie jest nagłówkiem, który można zaimportować",
  "nie można zaimportować modułu bez nazwy",
  "moduł nie może mieć zależności interfejsu od samego siebie",
  "moduł %sq został już zaimportowany",
  "plik modułu",
  "nie można odnaleźć pliku modułu dla modułu %sq",
  "nie można zaimportować pliku modułu %sq",
  "oczekiwano elementu %s1, zamiast niego znaleziono element %s2",
  "podczas otwierania pliku modułu %sq",
  "nieznana nazwa partycji %sq",
  "nieznany plik modułu",
  "plik modułu z importowalnym nagłówkiem",
  "plik modułu EDG",
  "plik modułu IFC",
  "nieoczekiwany plik modułu",
  "typ drugiego operandu %t2 musi mieć taki sam rozmiar jak element %t1",
  "typ musi być możliwy do skopiowania w prosty sposób",
  "typ %t nie jest obecnie obsługiwany na potrzeby oceny wyrażenia constexpr dla elementu __builtin_bit_cast",
  "typy klas z polami bitowymi %t nie są obecnie obsługiwane na potrzeby oceny wyrażenia constexpr dla elementu __builtin_bit_cast",
  "niestatyczna składowa danych typu referencyjnego %t uniemożliwia ocenę wyrażenia constexpr dla elementu __builtin_bit_cast",
  "typ nietrwały %t uniemożliwia ocenę wyrażenia constexpr dla elementu __builtin_bit_cast",
  "typ unii, wskaźnika lub wskaźnika do składowej %t uniemożliwia ocenę wyrażenia constexpr dla elementu __builtin_bit_cast",
  "%npTd, odziedziczone za pomocą deklaracji %p",
  "nie można wykonać konstrukcji podobiektu %t na potrzeby dziedziczenia konstruktorów — niejawny konstruktor domyślny został usunięty",
  "Element %n musi zwracać wartość void",
  "nieprawidłowy początek deklaracji członkowskiej",
  "oczekiwano elementu „auto”",
  "ten operator jest niedozwolony w tym miejscu; umieść w nawiasie poprzednie nowe wyrażenie",
  "nieprawidłowe użycie koncepcji",
  "domyślny operator porównania elementu członkowskiego nie może być kwalifikowany przez element „&&”",
  "domyślna funkcja porównywania constexpr wywołuje funkcję non-constexpr %nd",
  "Porównywanie pamięci constexpr jest obsługiwane tylko w przypadku obiektów będących liczbami całkowitymi lub tablicami liczb całkowitych",
  "z szablonem koncepcji nie mogą być skojarzone ograniczenia",
  "Polecenie „export” jest niedozwolone",
  "eksportowanie pojedynczych elementów członkowskich klasy jest niedozwolone",
  "wyeksportowana deklaracja musi wprowadzić nazwę",
  "deklaracja eksportu nie może zawierać deklaracji eksportu (poprzednia deklaracja %p)",
  "deklaracja eksportu nie może zawierać deklaracji importu modułu",
  "deklaracja eksportu może występować tylko w jednostce interfejsu modułu",
  "deklaracja eksportu nie może eksportować nazwy z powiązaniem wewnętrznym",
  "deklaracja using zawiera %nfd",
  "funkcja wbudowana jest niedostępna, ponieważ typy liczb zmiennoprzecinkowych __fp16 nie są obsługiwane",
  "wyrażenie requires musi określać co najmniej jedno wymaganie",
  "słowo kluczowe „constinit” nie jest tutaj prawidłowe",
  "element „constinit” jest prawidłowy tylko w deklaracjach zmiennych z czasem trwania magazynowania statycznym lub wątku",
  "Zmienna constinit wymaga inicjowania dynamicznego",
  "zmienna została wcześniej zadeklarowana za pomocą elementu „constinit” %p",
  "Używanie nieprototypowego deklaratora funkcji",
  "argument nie może mieć typu kwalifikowanego jako const",
  "wskaźnik do składowej niepełnego typu %t jest niedozwolony",
  "rozszerzenie pakietu w funkcji init-capture nie jest włączone w tym trybie",
  "rozszerzenie pakietu w funkcji init-capture to funkcja języka C++20",
  "operator porównania przyjęty domyślnie w definicji klasy musi być pierwszą deklaracją tego operatora porównania (%nd)",
  "rozszerzenie pakietu w elemencie init-capture może być używane tylko w szablonie wariadycznym",
  "ograniczenie typu używa elementu %nd, który nie jest koncepcją typu (tj. szablonem koncepcji, którego pierwszym parametrem jest parametr typu)",
  "wywnioskowany typ symbolu zastępczego %t nie spełniał ograniczenia typu",
  "domyślny konstruktor dla elementu %t nie kwalifikuje się",
  "destruktor dla %t jest niejednoznaczny z powodu nieuporządkowanych ograniczeń",
  "destruktor %t dla nie kwalifikuje się z powodu niepowodzenia ograniczeń",
  "niejednoznaczny kandydat destruktora",
  "funkcja wirtualna nie może mieć końcowej klauzuli requires",
  "%nd nie spełnia swoich ograniczeń",
  "wynik %t kwalifikatora decltype nie jest klasą ani wyliczeniem",
  "porównanie jest niejednoznaczne w standardowym języku C++20, ponieważ implikowany operator porównania z odwróconymi parametrami jest równie dobrym dopasowaniem — jest to zwykle spowodowane brakującym kwalifikatorem „const” w operatorze porównania; zobacz %nod",
  "nieprawidłowy identyfikator koncepcji",
  "podstawianie argumentów %T dla klauzuli requires nie powiodło się",
  "ograniczenia dla %nd nie są spełnione",
  "typ zmiennej %t w funkcji constexpr ma wirtualne klasy podstawowe",
  "wyrażenie stałe nie może przydzielić wirtualnego podobiektu podstawowego (dla typu %t)",
  "parametr szablonu typu klasy musi być typu klasy strukturalnej",
  "obsługa literałów UTF-8 wymaga obsługi literału z prefiksem u.",
  "mapowanie pliku modułu dla elementu „%s” zostało określone więcej niż raz",
  "mapowanie jednostki nagłówka dla elementu „%s” zostało określone więcej niż raz",
  "nie określono mapowania dla elementu „%s”",
  "mapowanie pliku modułu dla elementu „%s” jest nieprawidłowe",
  "nie można odnaleźć nagłówka „%s” do zaimportowania",
  "więcej niż jeden plik na liście plików modułu pasuje do elementu „%s”",
  "plik modułu znaleziony dla elementu „%s” jest dla innego modułu",
  "dowolny rodzaj pliku modułu",
  "nie można odczytać pliku modułu",
  "wbudowana funkcja jest niedostępna, ponieważ typ char8_t nie jest obsługiwany z bieżącymi opcjami",
  "nie można określić opcji wiersza polecenia --ms_await, jeśli włączono koprocedury języka C++20",
  "niestandardowe użycie konstruktora jawnego %nod dla domyślnej inicjalizacji elementu agregacji",
  "element źródłowy lub docelowy funkcji wewnętrznej podobnej do memcpy nie wskazuje obiektu",
  "Funkcja wewnętrzna podobna do memcpy próbuje skopiować reprezentacyjnie odrębne typy %t1 i %t2",
  "Funkcja wewnętrzna podobna do memcpy próbuje skopiować typ %t, którego nie można skopiować w sposób trywialny",
  "Funkcja wewnętrzna podobna do memcpy próbuje skopiować częściowy obiekt",
  "Funkcja wewnętrzna podobna do memcpy próbuje skopiować dane spoza granicy tablicy",
  "Funkcja wewnętrzna podobna do memcpy próbuje skopiować nakładające się na siebie zakresy bajtów (zamiast tego zostanie użyta odpowiednia operacja memmove)",
  "deklaracja elementu zaprzyjaźnionego z klauzulą trailing-requires-clause musi być definicją",
  "wyrażenie musi mieć typ arytmetyczny lub typ wskaźnika, ale ma typ %t",
  "wyrażenie musi mieć typ arytmetyczny, typ wyliczeniowy lub typ wskaźnika, ale ma typ %t",
  "wyrażenie musi mieć typ arytmetyczny, typ wyliczenia niewystępującego w zakresie lub typ wskaźnika, ale ma typ %t",
  "wyrażenie musi mieć typ wskaźnika, ale ma typ %t",
  "operator -> lub ->* zastosowane do typu %t zamiast do typu wskaźnika",
  "niekompletny typ klasy %t jest niedozwolony",
  "nie można zinterpretować układu bitowego dla tego elementu docelowego kompilacji",
  "brak odpowiedniego operatora dla operatora IFC %sq",
  "brak odpowiedniej konwencji wywoływania dla konwencji wywoływania IFC %sq",
  "moduł %sq zawiera nieobsługiwane konstrukcje",
  "nieobsługiwana konstrukcja IFC: %sq",
  "Od tego punktu __is_signed nie jest już słowem kluczowym",
  "wymiar tablicy musi mieć stałą wartość całkowitą bez znaku",
  "Plik IFC %sq ma nieobsługiwaną wersję %d1.%d2",
  "moduły nie są włączone w tym trybie",
  "Ciąg „import” nie jest dozwolony w nazwie modułu",
  "Ciąg „module” nie jest dozwolony w nazwie modułu",
  null,
  null,
  "Element %n nie jest typem wyliczenia",
  "moduł wyliczający %no2 powoduje konflikt z elementem %n1",
  "moduł wyliczający %no został już zadeklarowany w tym zakresie %p",
  "Specyfikacja „throw()” nie jest częścią języka C++20 i nowszych",
  "więcej niż wpis na mapie jednostek nagłówka pasuje do „%s”",
  "Diagnostyka #pragma musi mieć argument \"push\" lub \"pop\"",
  "nie znaleziono instrukcji \"#pragma diagnostic push\" pasującej do tego argumentu \"diagnostic pop\"",
  "Element %sq nie może być makrem, gdy jest używany w dyrektywie importu lub modułu",
  "ta dyrektywa może występować tylko w zakresie globalnej przestrzeni nazw",
  "Deklaracja \"export\" może występować tylko w zakresie globalnym lub przestrzeni nazw",
  "Element %sq jest analizowany jako identyfikator, a nie słowo kluczowe, ponieważ tokeny po nim występujące nie pasują do tych, które obowiązują w dyrektywie preprocesora",
  "wydaje się, że jest to początek dyrektywy preprocesora, ale brak elementu \";\", po którym niezwłocznie występuje nowy wiersz to uniemożliwia",
  "wydaje się, że jest to dyrektywa przetwarzania wstępnego modułów, ale takie dyrektywy nie mogą występować w rozszerzeniu makra",
  "Dyrektywa \"module\" nie może pojawiać się w zakresie dołączania warunkowego (np. #if, #else, #elseif itp.)",
  "import elementu %sq został pominięty"
]