import { CodeSnippetInput } from './refactoring-agent';

// Hard-coded initial input.
export const initialCodeSnippetInput: CodeSnippetInput[] = [
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/shader/FillShader.cpp',
		startLine: 73,
		startColumn: 0,
		endLine: 96,
		endColumn: 1
	}
];

// Hard-coded FAR results for individual reference locations.
// TODO: Add more hard-coded FAR results to test with.

export const codeSnippetInputs: CodeSnippetInput[] = [
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/BoardingPanel.cpp',
		startLine: 128, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/BoardingPanel.cpp',
		startLine: 144, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 131, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 184, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 188, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 191, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 229, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/Dialog.cpp',
		startLine: 220, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/Dialog.cpp',
		startLine: 230, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/Engine.cpp',
		startLine: 1243, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/Interface.cpp',
		startLine: 936, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ItemInfoDisplay.cpp',
		startLine: 111, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LoadPanel.cpp',
		startLine: 209, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LoadPanel.cpp',
		startLine: 257, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LoadPanel.cpp',
		startLine: 269, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 79, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 84, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 89, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 114, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 115, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapDetailPanel.cpp',
		startLine: 739, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapPanel.cpp',
		startLine: 410, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapPlanetCard.cpp',
		startLine: 289, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 279, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 310, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 406, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MessageLogPanel.cpp',
		startLine: 67, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 775, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 822, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 827, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 866, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 998, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/Panel.cpp',
		startLine: 307, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/PreferencesPanel.cpp',
		startLine: 1235, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShipInfoDisplay.cpp',
		startLine: 92, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 86, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 759, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 763, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 855, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 856, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 904, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 908, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 937, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 939, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 962, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 977, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 984, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/StartConditionsPanel.cpp',
		startLine: 122, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/TradingPanel.cpp',
		startLine: 103, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/shader/FillShader.h',
		startLine: 28, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/text/Table.cpp',
		startLine: 240, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	},
	{
		textSpan: ``,
		filePath: 'C:/src/endless-sky/source/text/Table.cpp',
		startLine: 255, // -1 of actual line in IDE
		startColumn: 0,
		endLine: 0,
		endColumn: 0
	}
];


/*
// Hard-coded FAR results for entire function scopes.
// TODO: Add more hard-coded FAR results to test with.

export const codeSnippetInputs: CodeSnippetInput[] = [
	{
		textSpan: `void BoardingPanel::Draw()
{
    // Draw a translucent black scrim over everything beneath this panel.
    DrawBackdrop();

    // Draw the list of plunder.
    const Color &opaque = *GameData::Colors().Get("panel background");
    const Color &back = *GameData::Colors().Get("faint");
    const Color &dim = *GameData::Colors().Get("dim");
    const Color &medium = *GameData::Colors().Get("medium");
    const Color &bright = *GameData::Colors().Get("bright");
    FillShader::Fill(Point(-155., -60.), Point(360., 250.), opaque);

    int index = (scroll - 10) / 20;
    int y = -170 - scroll + 20 * index;
    int endY = 60;

    const Font &font = FontSet::Get(14);
    // Y offset to center the text in a 20-pixel high row.
    double fontOff = .5 * (20 - font.Height());
    for( ; y < endY && static_cast<unsigned>(index) < plunder.size(); y += 20, ++index)
    {
        const Plunder &item = plunder[index];

        // Check if this is the selected row.
        bool isSelected = (index == selected);
        if(isSelected)
            FillShader::Fill(Point(-155., y + 10.), Point(360., 20.), back);

        // Color the item based on whether you have space for it.
        const Color &color = item.CanTake(*you) ? isSelected ? bright : medium : dim;
        Point pos(-320., y + fontOff);
        font.Draw(item.Name(), pos, color);
        font.Draw({item.Value(), {260, Alignment::RIGHT}}, pos, color);
        font.Draw({item.Size(), {330, Alignment::RIGHT}}, pos, color);
    }

    // Set which buttons are active.
    Information info;
    if(CanExit())
        info.SetCondition("can exit");
    if(CanTake() == CanTakeResult::CAN_TAKE)
        info.SetCondition("can take");
    if(CanCapture())
        info.SetCondition("can capture");
    if(CanAttack() && (you->Crew() > 1 || !victim->RequiredCrew()))
        info.SetCondition("can attack");
    if(CanAttack())
        info.SetCondition("can defend");

    // This should always be true, but double check.
    int crew = 0;
    if(you)
    {
        crew = you->Crew();
        info.SetString("cargo space", to_string(you->Cargo().Free()));
        info.SetString("your crew", to_string(crew));
        info.SetString("your attack",
            Round(attackOdds.AttackerPower(crew)));
        info.SetString("your defense",
            Round(defenseOdds.DefenderPower(crew)));
    }
    int vCrew = victim ? victim->Crew() : 0;
    if(victim && (canCapture || victim->IsYours()))
    {
        info.SetString("enemy crew", to_string(vCrew));
        info.SetString("enemy attack",
            Round(defenseOdds.AttackerPower(vCrew)));
        info.SetString("enemy defense",
            Round(attackOdds.DefenderPower(vCrew)));
    }
    if(victim && canCapture && !victim->IsYours())
    {
        // If you haven't initiated capture yet, show the self destruct odds in
        // the attack odds. It's illogical for you to have access to that info,
        // but not knowing what your true odds are is annoying.
        double odds = attackOdds.Odds(crew, vCrew);
        if(!isCapturing)
            odds *= (1. - victim->Attributes().Get("self destruct"));
        info.SetString("attack odds",
            Round(100. * odds) + "%");
        info.SetString("attack casualties",
            Round(attackOdds.AttackerCasualties(crew, vCrew)));
        info.SetString("defense odds",
            Round(100. * (1. - defenseOdds.Odds(vCrew, crew))) + "%");
        info.SetString("defense casualties",
            Round(defenseOdds.DefenderCasualties(vCrew, crew)));
    }

    const Interface *boarding = GameData::Interfaces().Get("boarding");
    boarding->Draw(info, this);

    // Draw the status messages from hand to hand combat.
    Point messagePos(50., 55.);
    for(const string &message : messages)
    {
        font.Draw(message, messagePos, bright);
        messagePos.Y() += 20.;
    }
}`,
		filePath: 'C:/src/endless-sky/source/BoardingPanel.cpp',
		startLine: 117,
		startColumn: 0,
		endLine: 216,
		endColumn: 1
	},
	{
		textSpan: `void ConversationPanel::Draw()
{
    // Dim out everything outside this panel.
    DrawBackdrop();

    // Draw the panel itself, stretching from top to bottom of the screen on
    // the left side. The edge sprite contains 10 pixels of the margin; the rest
    // of the margin is included in the filled rectangle drawn here:
    const Color &back = *GameData::Colors().Get("conversation background");
    double boxWidth = WIDTH + 2. * MARGIN - 10.;
    FillShader::Fill(
        Point(Screen::Left() + .5 * boxWidth, 0.),
        Point(boxWidth, Screen::Height()),
        back);

    Panel::DrawEdgeSprite(SpriteSet::Get("ui/right edge"), Screen::Left() + boxWidth);

    // Get the font and colors we'll need for drawing everything.
    const Font &font = FontSet::Get(14);
    const Color &selectionColor = *GameData::Colors().Get("faint");
    const Color &dim = *GameData::Colors().Get("dim");
    const Color &gray = *GameData::Colors().Get("medium");
    const Color &bright = *GameData::Colors().Get("bright");
    const Color &dark = *GameData::Colors().Get("dark");

    // Figure out where we should start drawing.
    Point point(
        Screen::Left() + MARGIN,
        Screen::Top() + MARGIN + scroll);
    // Draw all the conversation text up to this point.
    for(const Paragraph &it : text)
        point = it.Draw(point, gray);

    // Draw whatever choices are being presented.
    if(node < 0)
    {
        // The conversation has already ended. Draw a "done" button.
        static const string done = "[done]";
        int width = font.Width(done);
        int height = font.Height();
        Point off(Screen::Left() + MARGIN + WIDTH - width, point.Y());
        font.Draw(done, off, bright);

        // Handle clicks on this button.
        AddZone(Rectangle::FromCorner(off, Point(width, height)), [this](){ this->Exit(); });
    }
    else if(choices.empty())
    {
        // This conversation node is prompting the player to enter their name.
        Point fieldSize(150, 20);
        const auto layout = Layout(fieldSize.X() - 10, Truncate::FRONT);
        for(int side = 0; side < 2; ++side)
        {
            Point center = point + Point(side ? 420 : 190, 7);
            Point unselected = point + Point(side ? 190 : 420, 7);
            // Handle mouse clicks in whatever field is not selected.
            if(side != choice)
            {
                AddZone(Rectangle(center, fieldSize), [this, side](){ this->ClickName(side); });
                continue;
            }

            // Color selected text box, or flicker if user attempts an error.
            FillShader::Fill(center, fieldSize, (flickerTime % 6 > 3) ? dim : selectionColor);
            if(flickerTime)
                --flickerTime;
            // Fill non-selected text box with dimmer color.
            FillShader::Fill(unselected, fieldSize, dark);
            // Draw the text cursor.
            center.X() += font.FormattedWidth({choice ? lastName : firstName, layout}) - 67;
            FillShader::Fill(center, Point(1., 16.), dim);
        }

        font.Draw("First name:", point + Point(40, 0), dim);
        font.Draw({firstName, layout}, point + Point(120, 0), choice ? gray : bright);

        font.Draw("Last name:", point + Point(270, 0), dim);
        font.Draw({lastName, layout}, point + Point(350, 0), choice ? bright : gray);

        // Draw the OK button, and remember its location.
        static const string ok = "[ok]";
        int width = font.Width(ok);
        int height = font.Height();
        Point off(Screen::Left() + MARGIN + WIDTH - width, point.Y());
        font.Draw(ok, off, bright);

        // Handle clicks on this button.
        AddZone(Rectangle::FromCorner(off, Point(width, height)), SDLK_RETURN);
    }
    else
    {
        string label = "0:";
        int index = 0;
        for(const auto &it : choices)
        {
            ++label[0];

            const auto &paragraph = it.first;

            Point center = point + paragraph.Center();
            Point size(WIDTH, paragraph.Height());

            auto zone = Rectangle::FromCorner(point, size);
            // If the mouse is hovering over this choice then we need to highlight it.
            if(isHovering && zone.Contains(hoverPoint))
                choice = index;

            if(index == choice)
                FillShader::Fill(center + Point(-5, 0), size + Point(30, 0), selectionColor);
            AddZone(zone, [this, index](){ this->ClickChoice(index); });
            ++index;

            font.Draw(label, point + Point(-15, 0), dim);
            point = paragraph.Draw(point, bright);
        }
    }
    // Store the total height of the text.
    maxScroll = min(0., Screen::Top() - (point.Y() - scroll) + font.Height() + 15.);

    // Reset the hover flag. If the mouse is still moving than the flag will be set in the next frame.
    isHovering = false;
}`,
		filePath: 'C:/src/endless-sky/source/ConversationPanel.cpp',
		startLine: 121,
		startColumn: 0,
		endLine: 242,
		endColumn: 1
	},
	{
		textSpan: `void Dialog::Draw()
{
    DrawBackdrop();

    const Sprite *top = SpriteSet::Get(isWide ? "ui/dialog top wide" : "ui/dialog top");
    const Sprite *middle = SpriteSet::Get(isWide ? "ui/dialog middle wide" : "ui/dialog middle");
    const Sprite *bottom = SpriteSet::Get(isWide ? "ui/dialog bottom wide" : "ui/dialog bottom");
    const Sprite *cancel = SpriteSet::Get("ui/dialog cancel");

    // If the dialog is too tall, then switch to wide mode.
    Point textRectSize(Width() - HORIZONTAL_PADDING, 0);
    int maxHeight = Screen::Height() * 3 / 4;
    if(text->GetTextHeight(false) > maxHeight)
    {
        textRectSize.Y() = maxHeight;
        isWide = true;
        // Re-wrap with the new width.
        textRectSize.X() = Width() - HORIZONTAL_PADDING;
        text->SetRect(Rectangle(Point{}, textRectSize));

        if(text->GetLongestLineWidth() <= top->Width() - HORIZONTAL_MARGIN - HORIZONTAL_PADDING)
        {
            // Formatted text is long and skinny (e.g. scan result dialog). Go back
            // to using the default width, since the wide width doesn't help.
            isWide = false;
            textRectSize.X() = Width() - HORIZONTAL_PADDING;
            text->SetRect(Rectangle(Point{}, textRectSize));
        }
    }
    else
        textRectSize.Y() = text->GetTextHeight(false);

    // The height of the bottom sprite without the included button's height.
    const int realBottomHeight = bottom->Height() - cancel->Height();

    int height = TOP_PADDING + textRectSize.Y() + BOTTOM_PADDING +
            (realBottomHeight - BOTTOM_PADDING) * (!isMission && (intFun || stringFun));
    // Determine how many extension panels we need.
    if(height <= realBottomHeight + top->Height())
        extensionCount = 0;
    else
        extensionCount = (height - middle->Height()) / middle->Height();

    // Now that we know how big we want to render the text, position the text area.

    // Get the position of the top of this dialog, and of the input.
    Point pos(0., (top->Height() + extensionCount * middle->Height() + bottom->Height()) * -.5f);
    Point inputPos = Point(0., -(cancel->Height() + INPUT_HEIGHT)) - pos;
    // Resize textRectSize to match the visual height of the dialog, which will
    // be rounded up from the actual text height by the number of panels that
    // were added. This helps correctly position the TextArea scroll buttons.
    textRectSize.Y() = (top->Height() + realBottomHeight - VERTICAL_PADDING) + extensionCount * middle->Height() -
            (realBottomHeight - BOTTOM_PADDING) * (!isMission && (intFun || stringFun));

    Point textPos(Width() * -.5 + LEFT_PADDING, pos.Y() + VERTICAL_PADDING);
    Rectangle textRect = Rectangle::FromCorner(textPos, textRectSize);
    text->SetRect(textRect);

    // Draw the top section of the dialog box.
    pos.Y() += top->Height() * .5;
    SpriteShader::Draw(top, pos);
    pos.Y() += top->Height() * .5;

    // The middle section is duplicated depending on how long the text is.
    for(int i = 0; i < extensionCount; ++i)
    {
        pos.Y() += middle->Height() * .5;
        SpriteShader::Draw(middle, pos);
        pos.Y() += middle->Height() * .5;
    }

    // Draw the bottom section.
    const Font &font = FontSet::Get(14);
    pos.Y() += bottom->Height() * .5;
    SpriteShader::Draw(bottom, pos);
    pos.Y() += (bottom->Height() - cancel->Height()) * .5;

    // Draw the buttons, including optionally the cancel button.
    const Color &bright = *GameData::Colors().Get("bright");
    const Color &dim = *GameData::Colors().Get("medium");
    const Color &back = *GameData::Colors().Get("faint");
    const Color &inactive = *GameData::Colors().Get("inactive");
    const string okText = isMission ? "Accept" : "OK";
    okPos = pos + Point((top->Width() - RIGHT_MARGIN - cancel->Width()) * .5, 0.);
    Point labelPos(
        okPos.X() - .5 * font.Width(okText),
        okPos.Y() - .5 * font.Height());
    font.Draw(okText, labelPos, isOkDisabled ? inactive : (okIsActive ? bright : dim));
    if(canCancel)
    {
        string cancelText = isMission ? "Decline" : "Cancel";
        cancelPos = pos + Point(okPos.X() - cancel->Width() + BUTTON_RIGHT_MARGIN, 0.);
        SpriteShader::Draw(cancel, cancelPos);
        labelPos = {
                cancelPos.X() - .5 * font.Width(cancelText),
                cancelPos.Y() - .5 * font.Height()};
        font.Draw(cancelText, labelPos, !okIsActive ? bright : dim);
    }

    // Draw the input, if any.
    if(!isMission && (intFun || stringFun))
    {
        FillShader::Fill(inputPos, Point(Width() - HORIZONTAL_PADDING, INPUT_HEIGHT), back);

        Point stringPos(
            inputPos.X() - (Width() - HORIZONTAL_PADDING) * .5 + INPUT_LEFT_PADDING,
            inputPos.Y() - .5 * font.Height());
        const auto inputText = DisplayText(input, {static_cast<int>(Width() - HORIZONTAL_PADDING - INPUT_HORIZONTAL_PADDING),
                Truncate::FRONT});
        font.Draw(inputText, stringPos, bright);

        Point barPos(stringPos.X() + font.FormattedWidth(inputText) + INPUT_TOP_PADDING, inputPos.Y());
        FillShader::Fill(barPos, Point(1., INPUT_HEIGHT - INPUT_VERTICAL_PADDING), dim);
    }
}`,
		filePath: 'C:/src/endless-sky/source/Dialog.cpp',
		startLine: 163,
		startColumn: 0,
		endLine: 252,
		endColumn: 1
	},
	{
		textSpan: `void Engine::Draw() const
{
	Point motionBlur = Preferences::Has("Render motion blur") ? centerVelocity : Point();

	Preferences::ExtendedJumpEffects jumpEffectState = Preferences::GetExtendedJumpEffects();
	if(jumpEffectState != Preferences::ExtendedJumpEffects::OFF)
		motionBlur *= 1. + pow(hyperspacePercentage *
			(jumpEffectState == Preferences::ExtendedJumpEffects::MEDIUM ? 2.5 : 5.), 2);

	GameData::Background().Draw(motionBlur,
		(player.Flagship() ? player.Flagship()->GetSystem() : player.GetSystem()));

	static const Set<Color> &colors = GameData::Colors();
	const Interface *hud = GameData::Interfaces().Get("hud");

	// Draw any active planet labels.
	if(Preferences::Has("Show planet labels"))
		for(const PlanetLabel &label : labels)
			label.Draw();

	draw[currentDrawBuffer].Draw();
	batchDraw[currentDrawBuffer].Draw();

	for(const auto &it : statuses)
	{
		static const Color color[16] = {
			*colors.Get("overlay flagship shields"),
			*colors.Get("overlay friendly shields"),
			*colors.Get("overlay hostile shields"),
			*colors.Get("overlay neutral shields"),
			*colors.Get("overlay outfit scan"),
			*colors.Get("overlay outfit scan out of range"),
			*colors.Get("overlay flagship hull"),
			*colors.Get("overlay friendly hull"),
			*colors.Get("overlay hostile hull"),
			*colors.Get("overlay neutral hull"),
			*colors.Get("overlay cargo scan"),
			*colors.Get("overlay cargo scan out of range"),
			*colors.Get("overlay flagship disabled"),
			*colors.Get("overlay friendly disabled"),
			*colors.Get("overlay hostile disabled"),
			*colors.Get("overlay neutral disabled")
		};
		Point pos = it.position * zoom;
		double radius = it.radius * zoom;
		int colorIndex = static_cast<int>(it.type);
		if(it.outer > 0.)
			RingShader::Draw(pos, radius + 3., 1.5f, it.outer,
				Color::Multiply(it.alpha, color[colorIndex]), 0.f, it.angle);
		double dashes = (it.type >= Status::Type::SCAN) ? 0. : 20. * min<double>(1., zoom);
		colorIndex += static_cast<int>(Status::Type::COUNT);
		if(it.inner > 0.)
			RingShader::Draw(pos, radius, 1.5f, it.inner,
				Color::Multiply(it.alpha, color[colorIndex]), dashes, it.angle);
		colorIndex += static_cast<int>(Status::Type::COUNT);
		if(it.disabled > 0.)
			RingShader::Draw(pos, radius, 1.5f, it.disabled,
				Color::Multiply(it.alpha, color[colorIndex]), dashes, it.angle);
	}

	// Draw labels on missiles
	for(const AlertLabel &label : missileLabels)
		label.Draw();

	for(const auto &outline : outlines)
	{
		if(!outline.sprite)
			continue;
		Point size(outline.sprite->Width(), outline.sprite->Height());
		OutlineShader::Draw(outline.sprite, outline.position, size, outline.color, outline.unit, outline.frame);
	}

	// Draw turret overlays.
	if(!turretOverlays.empty())
	{
		const Color &blindspot = *GameData::Colors().Get("overlay turret blindspot");
		const Color &normal = *GameData::Colors().Get("overlay turret");
		PointerShader::Bind();
		for(const TurretOverlay &it : turretOverlays)
			PointerShader::Add(it.position, it.angle, 8 * it.scale, 24 * it.scale, 24 * it.scale,
				it.isBlind ? blindspot : normal);
		PointerShader::Unbind();
	}

	if(flash)
		FillShader::Fill(Point(), Point(Screen::Width(), Screen::Height()), Color(flash, flash));

	// Draw messages. Draw the most recent messages first, as some messages
	// may be wrapped onto multiple lines.
	const Font &font = FontSet::Get(14);
	const vector<Messages::Entry> &messages = Messages::Get(step);
	Rectangle messageBox = hud->GetBox("messages");
	bool messagesReversed = hud->GetValue("messages reversed");
	WrappedText messageLine(font);
	messageLine.SetWrapWidth(messageBox.Width());
	messageLine.SetParagraphBreak(0.);
	Point messagePoint{messageBox.Left(), messagesReversed ? messageBox.Top() : messageBox.Bottom()};
	for(auto it = messages.rbegin(); it != messages.rend(); ++it)
	{
		messageLine.Wrap(it->message);
		int height = messageLine.Height();
		if(messagesReversed)
		{
			if(messagePoint.Y() + height > messageBox.Bottom())
				break;
		}
		else
		{
			messagePoint.Y() -= height;
			if(messagePoint.Y() < messageBox.Top())
				break;
		}
		float alpha = (it->step + 1000 - step) * .001f;
		messageLine.Draw(messagePoint, Messages::GetColor(it->importance, false)->Additive(alpha));
		if(messagesReversed)
			messagePoint.Y() += height;
	}

	// Draw crosshairs around anything that is targeted.
	for(const Target &target : targets)
	{
		Angle a = target.angle;
		Angle da(360. / target.count);

		PointerShader::Bind();
		for(int i = 0; i < target.count; ++i)
		{
			PointerShader::Add(target.center * zoom, a.Unit(), 12.f, 14.f, -target.radius * zoom, target.color);
			a += da;
		}
		PointerShader::Unbind();
	}

	// Draw the heads-up display.
	hud->Draw(info);
	if(hud->HasPoint("radar"))
	{
		radar[currentDrawBuffer].Draw(
			hud->GetPoint("radar"),
			RADAR_SCALE,
			hud->GetValue("radar radius"),
			hud->GetValue("radar pointer radius"));
	}
	if(hud->HasPoint("target") && targetVector.Length() > 20.)
	{
		Point center = hud->GetPoint("target");
		double radius = hud->GetValue("target radius");
		PointerShader::Draw(center, targetVector.Unit(), 10.f, 10.f, radius, Color(1.f));
	}

	// Draw the faction markers.
	if(targetSwizzle && hud->HasPoint("faction markers"))
	{
		int width = font.Width(info.GetString("target government"));
		Point center = hud->GetPoint("faction markers");

		const Sprite *mark[2] = {SpriteSet::Get("ui/faction left"), SpriteSet::Get("ui/faction right")};
		// Round the x offsets to whole numbers so the icons are sharp.
		double dx[2] = {(width + mark[0]->Width() + 1) / -2, (width + mark[1]->Width() + 1) / 2};
		for(int i = 0; i < 2; ++i)
			SpriteShader::Draw(mark[i], center + Point(dx[i], 0.), 1., targetSwizzle);
	}
	if(jumpCount && Preferences::Has("Show mini-map"))
		MapPanel::DrawMiniMap(player, .5f * min(1.f, jumpCount / 30.f), jumpInProgress, step);

	// Draw ammo status.
	double ammoIconWidth = hud->GetValue("ammo icon width");
	double ammoIconHeight = hud->GetValue("ammo icon height");
	ammoDisplay.Draw(hud->GetBox("ammo"), Point(ammoIconWidth, ammoIconHeight));

	// Draw escort status.
	escorts.Draw(hud->GetBox("escorts"));

	if(Preferences::Has("Show CPU / GPU load"))
	{
		string loadString = to_string(lround(load * 100.)) + "% CPU";
		Color color = *colors.Get("medium");
		font.Draw(loadString,
			Point(-10 - font.Width(loadString), Screen::Height() * -.5 + 5.), color);
	}
}`,
		filePath: 'C:/src/endless-sky/source/Engine.cpp',
		startLine: 1155,
		startColumn: 0,
		endLine: 1338,
		endColumn: 1
	},
	{
		textSpan: `void Interface::LineElement::Draw(const Rectangle &rect, const Information &info, int state) const
{
	// Avoid crashes for malformed interface elements that are not fully loaded.
	if(!from.Get() && !to.Get())
		return;
	FillShader::Fill(rect.Center(), rect.Dimensions(), *color);
}`,
		filePath: 'C:/src/endless-sky/source/Interface.cpp',
		startLine: 931,
		startColumn: 0,
		endLine: 937,
		endColumn: 1
	},
	{
		textSpan: `void ItemInfoDisplay::DrawTooltips() const
{
	if(!hoverCount || hoverCount-- < HOVER_TIME || !hoverText.Height())
		return;

	Point textSize(hoverText.WrapWidth(), hoverText.Height() - hoverText.ParagraphBreak());
	Point boxSize = textSize + Point(20., 20.);

	Point topLeft = hoverPoint;
	if(topLeft.X() + boxSize.X() > Screen::Right())
		topLeft.X() -= boxSize.X();
	if(topLeft.Y() + boxSize.Y() > Screen::Bottom())
		topLeft.Y() -= boxSize.Y();

	FillShader::Fill(topLeft + .5 * boxSize, boxSize, *GameData::Colors().Get("tooltip background"));
	hoverText.Draw(topLeft + Point(10., 10.), *GameData::Colors().Get("medium"));
}`,
		filePath: 'C:/src/endless-sky/source/ItemInfoDisplay.cpp',
		startLine: 97,
		startColumn: 0,
		endLine: 113,
		endColumn: 1
	},
	{
	textSpan: `void LoadPanel::Draw()
{
	glClear(GL_COLOR_BUFFER_BIT);
	GameData::Background().Draw(Point());
	const Font &font = FontSet::Get(14);

	Information info;
	if(loadedInfo.IsLoaded())
	{
		info.SetString("pilot", loadedInfo.Name());
		if(loadedInfo.ShipSprite())
		{
			info.SetSprite("ship sprite", loadedInfo.ShipSprite());
			info.SetString("ship", loadedInfo.ShipName());
		}
		if(!loadedInfo.GetSystem().empty())
			info.SetString("system", loadedInfo.GetSystem());
		if(!loadedInfo.GetPlanet().empty())
			info.SetString("planet", loadedInfo.GetPlanet());
		info.SetString("credits", loadedInfo.Credits());
		info.SetString("date", loadedInfo.GetDate());
		info.SetString("playtime", loadedInfo.GetPlayTime());
	}
	else
		info.SetString("pilot", "No Pilot Loaded");

	if(!selectedPilot.empty())
		info.SetCondition("pilot selected");
	if(!player.IsDead() && player.IsLoaded() && !selectedPilot.empty())
		info.SetCondition("pilot alive");
	if(selectedFile.find('~') != string::npos)
		info.SetCondition("snapshot selected");
	if(loadedInfo.IsLoaded())
		info.SetCondition("pilot loaded");

	const Interface *loadPanel = GameData::Interfaces().Get("load menu");

	GameData::Interfaces().Get("menu background")->Draw(info, this);
	loadPanel->Draw(info, this);
	GameData::Interfaces().Get("menu player info")->Draw(info, this);

	// Draw the list of pilots.
	{
		// The list has space for 14 entries. Alpha should be 100% for Y = -157 to
		// 103, and fade to 0 at 10 pixels beyond that.
		const Point topLeft = pilotBox.TopLeft();
		Point currentTopLeft = topLeft + Point(0, -sideScroll);
		const double top = topLeft.Y();
		const double bottom = top + pilotBox.Height();
		const double hTextPad = loadPanel->GetValue("pilot horizontal text pad");
		const double fadeOut = loadPanel->GetValue("pilot fade out");
		for(const auto &it : files)
		{
			const Point drawPoint = currentTopLeft;
			currentTopLeft += Point(0., 20.);

			if(drawPoint.Y() < top - fadeOut)
				continue;
			if(drawPoint.Y() > bottom - fadeOut)
				continue;

			const double width = pilotBox.Width();
			Rectangle zone(drawPoint + Point(width / 2., 10.), Point(width, 20.));
			const Point textPoint(drawPoint.X() + hTextPad, zone.Center().Y() - font.Height() / 2);
			bool isHighlighted = (it.first == selectedPilot || (hasHover && zone.Contains(hoverPoint)));

			double alpha = min((drawPoint.Y() - (top - fadeOut)) * .1,
					(bottom - fadeOut - drawPoint.Y()) * .1);
			alpha = max(alpha, 0.);
			alpha = min(alpha, 1.);

			if(it.first == selectedPilot)
				FillShader::Fill(zone.Center(), zone.Dimensions(), Color(.1 * alpha, 0.));
			const int textWidth = pilotBox.Width() - 2. * hTextPad;
			font.Draw({it.first, {textWidth, Truncate::BACK}}, textPoint, Color((isHighlighted ? .7 : .5) * alpha, 0.));
		}
	}

	// The hover count "decays" over time if not hovering over a saved game.
	if(hoverCount)
		--hoverCount;
	string hoverText;

	// Draw the list of snapshots for the selected pilot.
	if(!selectedPilot.empty() && files.contains(selectedPilot))
	{
		const Point topLeft = snapshotBox.TopLeft();
		Point currentTopLeft = topLeft + Point(0, -centerScroll);
		const double top = topLeft.Y();
		const double bottom = top + snapshotBox.Height();
		const double hTextPad = loadPanel->GetValue("snapshot horizontal text pad");
		const double fadeOut = loadPanel->GetValue("snapshot fade out");
		for(const auto &it : files.find(selectedPilot)->second)
		{
			const Point drawPoint = currentTopLeft;
			currentTopLeft += Point(0., 20.);

			if(drawPoint.Y() < top - fadeOut)
				continue;
			if(drawPoint.Y() > bottom - fadeOut)
				continue;

			const string &file = it.first;
			Rectangle zone(drawPoint + Point(snapshotBox.Width() / 2., 10.), Point(snapshotBox.Width(), 20.));
			const Point textPoint(drawPoint.X() + hTextPad, zone.Center().Y() - font.Height() / 2);
			bool isHovering = (hasHover && zone.Contains(hoverPoint));
			bool isHighlighted = (file == selectedFile || isHovering);
			if(isHovering)
			{
				hoverCount = min(HOVER_TIME, hoverCount + 2);
				if(hoverCount == HOVER_TIME)
					hoverText = TimestampString(it.second);
			}

			double alpha = min((drawPoint.Y() - (top - fadeOut)) * .1,
					(bottom - fadeOut - drawPoint.Y()) * .1);
			alpha = max(alpha, 0.);
			alpha = min(alpha, 1.);

			if(file == selectedFile)
				FillShader::Fill(zone.Center(), zone.Dimensions(), Color(.1 * alpha, 0.));
			size_t pos = file.find('~') + 1;
			const string name = file.substr(pos, file.size() - 4 - pos);
			const int textWidth = snapshotBox.Width() - 2. * hTextPad;
			font.Draw({name, {textWidth, Truncate::BACK}}, textPoint, Color((isHighlighted ? .7 : .5) * alpha, 0.));
		}
	}

	if(!hoverText.empty())
	{
		Point boxSize(font.Width(hoverText) + 20., 30.);

		FillShader::Fill(hoverPoint + .5 * boxSize, boxSize, *GameData::Colors().Get("tooltip background"));
		font.Draw(hoverText, hoverPoint + Point(10., 10.), *GameData::Colors().Get("medium"));
	}
}`,
		filePath: 'C:/src/endless-sky/source/LoadPanel.cpp',
		startLine: 137,
		startColumn: 0,
		endLine: 272,
		endColumn: 1
	},
	{
		textSpan: `void LogbookPanel::Draw()
{
	// Dim out everything outside this panel.
	DrawBackdrop();

	// Draw the panel. The sidebar should be slightly darker than the rest.
	const Color &sideColor = *GameData::Colors().Get("logbook sidebar");
	FillShader::Fill(
		Point(Screen::Left() + .5 * SIDEBAR_WIDTH, 0.),
		Point(SIDEBAR_WIDTH, Screen::Height()),
		sideColor);
	const Color &backColor = *GameData::Colors().Get("logbook background");
	FillShader::Fill(
		Point(Screen::Left() + SIDEBAR_WIDTH + .5 * TEXT_WIDTH, 0.),
		Point(TEXT_WIDTH, Screen::Height()),
		backColor);
	const Color &lineColor = *GameData::Colors().Get("logbook line");
	FillShader::Fill(
		Point(Screen::Left() + SIDEBAR_WIDTH - .5, 0.),
		Point(1., Screen::Height()),
		lineColor);

	Panel::DrawEdgeSprite(SpriteSet::Get("ui/right edge"), Screen::Left() + WIDTH);

	// Colors to be used for drawing the log.
	const Font &font = FontSet::Get(14);
	const Color &dim = *GameData::Colors().Get("dim");
	const Color &medium = *GameData::Colors().Get("medium");
	const Color &bright = *GameData::Colors().Get("bright");

	// Draw the sidebar.
	// The currently selected sidebar item should be highlighted. This is how
	// big the highlight rectangle is.
	Point highlightSize(SIDEBAR_WIDTH - 4., LINE_HEIGHT);
	Point highlightOffset = Point(4. - PAD, 0.) + .5 * highlightSize;
	Point textOffset(0., .5 * (LINE_HEIGHT - font.Height()));
	// Start at this point on the screen:
	Point pos = Screen::TopLeft() + Point(PAD, PAD - categoryScroll);
	for(size_t i = 0; i < contents.size(); ++i)
	{
		if(selectedDate ? dates[i].Month() == selectedDate.Month() : selectedName == contents[i])
		{
			FillShader::Fill(pos + highlightOffset - Point(1., 0.), highlightSize + Point(0., 2.), lineColor);
			FillShader::Fill(pos + highlightOffset, highlightSize, backColor);
		}
		font.Draw(contents[i], pos + textOffset, dates[i].Month() ? medium : bright);
		pos.Y() += LINE_HEIGHT;
	}

	maxCategoryScroll = max(0., maxCategoryScroll + pos.Y() - Screen::Bottom());

	// Parameters for drawing the main text:
	WrappedText wrap(font);
	wrap.SetAlignment(Alignment::JUSTIFIED);
	wrap.SetWrapWidth(TEXT_WIDTH - 2. * PAD);

	// Draw the main text.
	pos = Screen::TopLeft() + Point(SIDEBAR_WIDTH + PAD, PAD + .5 * (LINE_HEIGHT - font.Height()) - scroll);

	// Branch based on whether this is an ordinary log month or a special page.
	auto pit = player.SpecialLogs().find(selectedName);
	if(selectedDate && begin != end)
	{
		const auto layout = Layout(static_cast<int>(TEXT_WIDTH - 2. * PAD), Alignment::RIGHT);
		for(auto it = begin; it != end; ++it)
		{
			string date = it->first.ToString();
			font.Draw({date, layout}, pos + Point(0., textOffset.Y()), dim);
			pos.Y() += LINE_HEIGHT;

			wrap.Wrap(it->second);
			wrap.Draw(pos, medium);
			pos.Y() += wrap.Height() + GAP;
		}
	}
	else if(!selectedDate && pit != player.SpecialLogs().end())
	{
		for(const auto &it : pit->second)
		{
			font.Draw(it.first, pos + textOffset, bright);
			pos.Y() += LINE_HEIGHT;

			wrap.Wrap(it.second);
			wrap.Draw(pos, medium);
			pos.Y() += wrap.Height() + GAP;
		}
	}

	maxScroll = max(0., scroll + pos.Y() - Screen::Bottom());
}`,
		filePath: 'C:/src/endless-sky/source/LogbookPanel.cpp',
		startLine: 72,
		startColumn: 0,
		endLine: 161,
		endColumn: 1
	},
	{
		textSpan: `void MapDetailPanel::DrawInfo()
{
	const Color &dim = *GameData::Colors().Get("dim");
	const Color &medium = *GameData::Colors().Get("medium");

	const Color &back = *GameData::Colors().Get("map side panel background");

	const Interface *planetCardInterface = GameData::Interfaces().Get("map planet card");
	double planetCardHeight = MapPlanetCard::Height();
	double planetWidth = planetCardInterface->GetValue("width");
	const Interface *mapInterface = GameData::Interfaces().Get("map detail panel");
	double minPlanetPanelHeight = mapInterface->GetValue("min planet panel height");
	double maxPlanetPanelHeight = mapInterface->GetValue("max planet panel height");

	const double bottomGovY = mapInterface->GetValue("government Y");
	const Sprite *systemSprite = SpriteSet::Get("ui/map system");

	bool canView = player.CanView(*selectedSystem);

	// Draw the panel for the planets. If the system was not visited, no planets will be shown.
	const double minimumSize = max(minPlanetPanelHeight, Screen::Height() - bottomGovY - systemSprite->Height());
	planetPanelHeight = canView ? min(min(minimumSize, maxPlanetPanelHeight),
		(planetCards.size()) * planetCardHeight) : 0.;
	Point size(planetWidth, planetPanelHeight);
	// This needs to fill from the start of the screen.
	FillShader::Fill(Screen::TopLeft() + Point(size.X() / 2., size.Y() / 2.),
		size, back);

	const double startingX = mapInterface->GetValue("starting X");
	Point uiPoint(Screen::Left() + startingX, Screen::Top());

	// Draw the basic information for visitable planets in this system.
	if(canView && !planetCards.empty())
	{
		uiPoint.Y() -= scroll.AnimatedValue();
		for(auto &card : planetCards)
		{
			// Fit another planet, if we can, also give scrolling freedom to reach the planets at the end.
			// This updates the location of the card so it needs to be called before AvailableSpace().
			card.DrawIfFits(uiPoint);
			uiPoint.Y() += planetCardHeight;
		}
		scroll.SetMaxValue(planetCards.size() * planetCardHeight);
		scroll.SetDisplaySize(PlanetPanelHeight());

		// Edges:
		Point pos(Screen::Left(), Screen::Top());
		const Sprite *bottom = SpriteSet::Get("ui/bottom edge");
		Point edgePos = pos + Point(.5 * size.X(), size.Y());
		Point bottomOff(-23.5, .5 * bottom->Height() - 1);
		SpriteShader::Draw(bottom, edgePos + bottomOff);

		const Sprite *right = SpriteSet::Get("ui/right edge");
		Point rightOff(.5 * (size.X() + right->Width()) - 1, -right->Height() / 2.);
		SpriteShader::Draw(right, edgePos + rightOff);

		if(scroll.Scrollable())
		{
			const double arrowOffsetX = mapInterface->GetValue("arrow x offset");
			const double arrowOffsetY = mapInterface->GetValue("arrow y offset");

			Point top(Screen::Left() + planetWidth + arrowOffsetX,
				Screen::Top() + arrowOffsetY);
			Point bottom(Screen::Left() + planetWidth + arrowOffsetX,
				Screen::Top() - arrowOffsetY + planetPanelHeight);

			scrollbar.SyncDraw(scroll, top, bottom);
		}
	}

	const double textMargin = mapInterface->GetValue("text margin");
	uiPoint = Point(Screen::Left() + textMargin, Screen::Bottom() - bottomGovY);

	// Draw the information for the government of this system at the top of the trade sprite.
	SpriteShader::Draw(systemSprite, uiPoint + Point(systemSprite->Width() / 2. - textMargin, 0.));

	const Font &font = FontSet::Get(14);
	const Sprite *alertSprite = SpriteSet::Get(commodity == SHOW_DANGER ? "ui/red alert" : "ui/red alert grayed");
	const float alertScale = min<float>(1.f, min<double>(textMargin,
		font.Height()) / max(alertSprite->Width(), alertSprite->Height()));
	SpriteShader::Draw(alertSprite, uiPoint + Point(-textMargin / 2., -7. + font.Height() / 2.), alertScale);

	string systemName = player.KnowsName(*selectedSystem) ?
		selectedSystem->DisplayName() : "Unexplored System";
	const auto alignLeft = Layout(145, Truncate::BACK);
	font.Draw({systemName, alignLeft}, uiPoint + Point(0., -7.), medium);

	governmentY = uiPoint.Y() + textMargin;
	string gov = canView ? selectedSystem->GetGovernment()->GetName() : "Unknown Government";
	font.Draw({gov, alignLeft}, uiPoint + Point(0., 13.), (commodity == SHOW_GOVERNMENT) ? medium : dim);
	if(commodity == SHOW_GOVERNMENT)
		PointerShader::Draw(uiPoint + Point(0., 20.), Point(1., 0.),
			10.f, 10.f, 0.f, medium);

	const double tradeHeight = mapInterface->GetValue("trade height");
	uiPoint = Point(Screen::Left() + startingX, Screen::Bottom() - tradeHeight);

	// Trade sprite goes after at the bottom.
	const Sprite *tradeSprite = SpriteSet::Get("ui/map trade");
	SpriteShader::Draw(tradeSprite, uiPoint);
	tradeY = uiPoint.Y() - tradeSprite->Height() / 2. + 15.;

	// Adapt the coordinates for the text (the sprite is drawn from a center coordinate).
	uiPoint.X() -= (tradeSprite->Width() / 2. - textMargin);
	uiPoint.Y() -= (tradeSprite->Height() / 2. - textMargin);
	for(const Trade::Commodity &commodity : GameData::Commodities())
	{
		bool isSelected = false;
		if(static_cast<unsigned>(this->commodity) < GameData::Commodities().size())
			isSelected = (&commodity == &GameData::Commodities()[this->commodity]);
		const Color &color = isSelected ? medium : dim;

		font.Draw(commodity.name, uiPoint, color);

		string price;
		if(canView && selectedSystem->IsInhabited(player.Flagship()))
		{
			int value = selectedSystem->Trade(commodity.name);
			int localValue = (player.GetSystem() ? player.GetSystem()->Trade(commodity.name) : 0);
			// Don't "compare" prices if the current system is uninhabited and
			// thus has no prices to compare to.
			bool noCompare = (!player.GetSystem() || !player.GetSystem()->IsInhabited(player.Flagship()));
			if(!value)
				price = "----";
			else if(noCompare || player.GetSystem() == selectedSystem || !localValue)
				price = to_string(value);
			else
			{
				value -= localValue;
				if(Preferences::Has("Show parenthesis"))
					price += "(";
				if(value > 0)
					price += '+';
				price += to_string(value);
				if(Preferences::Has("Show parenthesis"))
					price += ")";
			}
		}
		else
			price = (canView ? "n/a" : "?");

		const auto alignRight = Layout(140, Alignment::RIGHT, Truncate::BACK);
		font.Draw({price, alignRight}, uiPoint, color);

		if(isSelected)
			PointerShader::Draw(uiPoint + Point(0., 7.), Point(1., 0.), 10.f, 10.f, 0.f, color);

		uiPoint.Y() += 20.;
	}

	if(selectedPlanet && !selectedPlanet->Description().IsEmptyFor()
			&& player.HasVisited(*selectedPlanet) && !selectedPlanet->IsWormhole())
	{
		const Sprite *panelSprite = SpriteSet::Get("ui/description panel");
		Point pos(Screen::Right() - descriptionXOffset - .5f * panelSprite->Width(),
			Screen::Top() + .5f * panelSprite->Height());
		SpriteShader::Draw(panelSprite, pos);

		description->SetText(selectedPlanet->Description().ToString());
		if(!descriptionVisible)
		{
			AddChild(description);
			descriptionVisible = true;
		}

		selectedSystemOffset = -150;
	}
	else
	{
		RemoveChild(description.get());
		descriptionVisible = false;
	}
}`,
		filePath: 'C:/src/endless-sky/source/MapDetailPanel.cpp',
		startLine: 714,
		startColumn: 0,
		endLine: 886,
		endColumn: 1
	},
	{
		textSpan: `void MapPanel::FinishDrawing(const string &buttonCondition)
{
	// Display the name of and distance to the selected system.
	DrawSelectedSystem();

	// Draw the buttons to switch to other map modes.

	// Remember which buttons we're showing.
	MapPanel::buttonCondition = buttonCondition;

	Information info;
	info.SetCondition(buttonCondition);
	const Interface *mapInterface = GameData::Interfaces().Get("map");
	if(player.MapZoom() >= static_cast<int>(mapInterface->GetValue("max zoom")))
		info.SetCondition("max zoom");
	if(player.MapZoom() <= static_cast<int>(mapInterface->GetValue("min zoom")))
		info.SetCondition("min zoom");
	const Interface *mapButtonUi = GameData::Interfaces().Get(Screen::Width() < 1280
		? "map buttons (small screen)" : "map buttons");
	mapButtonUi->Draw(info, this);

	// Draw the tooltips.

	if(hoverSystem && hoverCount >= HOVER_TIME)
	{
		// Create the tooltip text.
		if(tooltip.empty())
		{
			MapPanel::SystemTooltipData t = escortSystems.at(hoverSystem);

			if(hoverSystem == &playerSystem)
			{
				if(player.Flagship())
					--t.activeShips;
				if(t.activeShips || t.parkedShips || !t.outfits.empty())
					tooltip = "You are here, with:\n";
				else
					tooltip = "You are here.";
			}
			// If you have both active and parked escorts, call the active ones
			// "active escorts." Otherwise, just call them "escorts."
			if(t.activeShips && t.parkedShips)
				tooltip += to_string(t.activeShips) + (t.activeShips == 1 ? " active escort\n" : " active escorts\n");
			else if(t.activeShips)
				tooltip += to_string(t.activeShips) + (t.activeShips == 1 ? " escort" : " escorts");
			if(t.parkedShips)
				tooltip += to_string(t.parkedShips) + (t.parkedShips == 1 ? " parked escort" : " parked escorts");
			if(!t.outfits.empty())
			{
				if(t.activeShips || t.parkedShips)
					tooltip += "\n";

				unsigned sum = 0;
				for(const auto &it : t.outfits)
					sum += it.second;

				tooltip += to_string(sum) + (sum == 1 ? " stored outfit" : " stored outfits");

				if(HasMultipleLandablePlanets(*hoverSystem) || t.outfits.size() > 1)
					for(const auto &it : t.outfits)
						tooltip += "\n - " + to_string(it.second) + " on " + it.first->DisplayName();
			}

			hoverText.Wrap(tooltip);
		}
		if(!tooltip.empty())
		{
			// Add 10px margin to all sides of the text.
			Point size(hoverText.WrapWidth(), hoverText.Height() - hoverText.ParagraphBreak());
			size += Point(20., 20.);
			Point topLeft = (hoverSystem->Position() + center) * Zoom();
			// Do not overflow the screen dimensions.
			if(topLeft.X() + size.X() > Screen::Right())
				topLeft.X() -= size.X();
			if(topLeft.Y() + size.Y() > Screen::Bottom())
				topLeft.Y() -= size.Y();
			// Draw the background fill and the tooltip text.
			FillShader::Fill(topLeft + .5 * size, size, *GameData::Colors().Get("tooltip background"));
			hoverText.Draw(topLeft + Point(10., 10.), *GameData::Colors().Get("medium"));
		}
	}

	// Draw a warning if the selected system is not routable.

	if(selectedSystem != &playerSystem && !distance.HasRoute(*selectedSystem))
	{
		static const string UNAVAILABLE = "You have no available route to this system.";
		static const string UNKNOWN = "You have not yet mapped a route to this system.";
		const string &message = player.CanView(*selectedSystem) ? UNAVAILABLE : UNKNOWN;
		info.SetString("route error", message);
	}

	mapInterface->Draw(info, this);
}`,
		filePath: 'C:/src/endless-sky/source/MapPanel.cpp',
		startLine: 333,
		startColumn: 0,
		endLine: 434,
		endColumn: 1
	},
	{
		textSpan: `void MapPlanetCard::Highlight(double availableSpace) const
{
	const Interface *planetCardInterface = GameData::Interfaces().Get("map planet card");
	const double width = planetCardInterface->GetValue("width");

	FillShader::Fill(Point(Screen::Left() + width / 2., yCoordinate + availableSpace / 2.),
		Point(width, availableSpace), *GameData::Colors().Get("item selected"));
}`,
		filePath: 'C:/src/endless-sky/source/MapPlanetCard.cpp',
		startLine: 284,
		startColumn: 0,
		endLine: 291,
		endColumn: 1
	},
	{
		textSpan: `void MapSalesPanel::DrawPanel() const
{
	const Color &back = *GameData::Colors().Get("map side panel background");
	FillShader::Fill(
		Point(Screen::Left() + WIDTH * .5, 0.),
		Point(WIDTH, Screen::Height()),
		back);

	Panel::DrawEdgeSprite(SpriteSet::Get("ui/right edge"), Screen::Left() + WIDTH);
}`,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 276,
		startColumn: 0,
		endLine: 285,
		endColumn: 1
	},
	{
		textSpan: `void MapSalesPanel::DrawInfo() const
{
	if(selected >= 0)
	{
		const Sprite *left = SpriteSet::Get("ui/left edge");
		const Sprite *bottom = SpriteSet::Get(compare >= 0 ? "ui/bottom edges" : "ui/bottom edge");
		const Sprite *box = SpriteSet::Get(compare >= 0 ? "ui/thumb boxes" : "ui/thumb box");

		const ItemInfoDisplay &selectedInfo = SelectedInfo();
		const ItemInfoDisplay &compareInfo = CompareInfo();
		int height = max<int>(selectedInfo.AttributesHeight(), box->Height());
		int width = selectedInfo.PanelWidth();
		if(compare >= 0)
		{
			height = max(height, compareInfo.AttributesHeight());
			width += box->Width() + compareInfo.PanelWidth();
		}

		const Color &back = *GameData::Colors().Get("map side panel background");
		Point size(width, height);
		Point topLeft(Screen::Right() - size.X(), Screen::Top());
		FillShader::Fill(topLeft + .5 * size, size, back);

		Point leftPos = topLeft + Point(
			-.5 * left->Width(),
			size.Y() - .5 * left->Height());
		SpriteShader::Draw(left, leftPos);
		// The top left corner of the bottom sprite should be 10 x units right
		// of the bottom left corner of the left edge sprite.
		Point bottomPos = leftPos + Point(
			10. + .5 * (bottom->Width() - left->Width()),
			.5 * (left->Height() + bottom->Height()));
		SpriteShader::Draw(bottom, bottomPos);

		if(compare >= 0)
		{
			compareInfo.DrawAttributes(topLeft);
			topLeft.X() += compareInfo.PanelWidth() + box->Width();

			SpriteShader::Draw(box, topLeft + Point(-50., 100.));
			DrawSprite(topLeft + Point(-95., 5.), SelectedSprite(), SelectedSpriteSwizzle());
			DrawSprite(topLeft + Point(-95., 105.), CompareSprite(), CompareSpriteSwizzle());
		}
		else
		{
			SpriteShader::Draw(box, topLeft + Point(-60., 50.));
			DrawSprite(topLeft + Point(-95., 5.), SelectedSprite(), SelectedSpriteSwizzle());
		}
		selectedInfo.DrawAttributes(topLeft);
	}
}`,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 289,
		startColumn: 0,
		endLine: 339,
		endColumn: 1
	},
	{
		textSpan: `void MapSalesPanel::Draw(Point &corner, const Sprite *sprite, const Swizzle *swizzle, bool isForSale,
		bool isSelected, const string &name, const string &variantName,
		const string &price, const string &info, const std::string &storage)
{
	const Font &font = FontSet::Get(14);
	const Color &selectionColor = *GameData::Colors().Get("item selected");

	// Set the padding so the text takes the same height overall,
	// regardless of whether it's three lines of text or four.
	const auto pad = storage.empty() && variantName.empty() ? PAD : (PAD * 2. / 3.);
	const auto lines = storage.empty() && variantName.empty() ? 3 : 4;
	Point nameOffset(ICON_HEIGHT, .5 * (ICON_HEIGHT - (lines - 1) * pad - lines * font.Height()));
	Point priceOffset(ICON_HEIGHT, nameOffset.Y() + font.Height() + pad);
	Point infoOffset(ICON_HEIGHT, priceOffset.Y() + font.Height() + pad);
	Point storageOffset(ICON_HEIGHT, infoOffset.Y() + font.Height() + pad);
	Point variantOffset = priceOffset;
	if(!variantName.empty())
	{
		priceOffset = infoOffset;
		infoOffset = storageOffset;
	}
	Point blockSize(WIDTH, ICON_HEIGHT);

	if(corner.Y() < Screen::Bottom() && corner.Y() + ICON_HEIGHT >= Screen::Top())
	{
		if(isSelected)
			FillShader::Fill(corner + .5 * blockSize, blockSize, selectionColor);

		DrawSprite(corner, sprite, swizzle);

		const Color &mediumColor = *GameData::Colors().Get("medium");
		const Color &dimColor = *GameData::Colors().Get("dim");
		const Color textColor = isForSale ? mediumColor : storage.empty()
			? dimColor : Color::Combine(.5f, mediumColor, .5f, dimColor);
		auto layout = Layout(static_cast<int>(WIDTH - ICON_HEIGHT - 1), Truncate::BACK);
		font.Draw({name, layout}, corner + nameOffset, textColor);
		if(!variantName.empty())
			font.Draw({"\t" + variantName, layout}, corner + variantOffset, textColor);
		font.Draw({price, layout}, corner + priceOffset, textColor);
		font.Draw({info, layout}, corner + infoOffset, textColor);
		if(!storage.empty())
			font.Draw({storage, layout}, corner + storageOffset, textColor);
	}
	zones.emplace_back(corner + .5 * blockSize, blockSize, zones.size());
	corner.Y() += ICON_HEIGHT;
}`,
		filePath: 'C:/src/endless-sky/source/MapSalesPanel.cpp',
		startLine: 380,
		startColumn: 0,
		endLine: 425,
		endColumn: 1
	},
	{
		textSpan: `void MessageLogPanel::Draw()
{
	// Dim out everything outside this panel.
	DrawBackdrop();

	// Draw the panel.
	const Color &backColor = *GameData::Colors().Get("message log background");
	FillShader::Fill(
		Point(Screen::Left() + .5 * width, 0.),
		Point(width, Screen::Height()),
		backColor);

	Panel::DrawEdgeSprite(SpriteSet::Get("ui/right edge"), Screen::Left() + width);

	Information info;
	if(messages.empty())
		info.SetCondition("empty");
	else
	{
		const Font &font = FontSet::Get(14);

		// Parameters for drawing messages:
		WrappedText messageLine(font);
		messageLine.SetAlignment(Alignment::LEFT);
		messageLine.SetWrapWidth(width - 2. * PAD);

		// Draw messages.
		Point pos = Screen::BottomLeft() + Point(PAD, scroll);
		for(const auto &it : messages)
		{
			if(importantOnly && (it.second == Messages::Importance::Low || it.second == Messages::Importance::High))
				continue;

			messageLine.Wrap(it.first);
			pos.Y() -= messageLine.Height();
			if(pos.Y() >= Screen::Top() - 3 * font.Height())
				messageLine.Draw(pos, *Messages::GetColor(it.second, true));
		}

		maxScroll = max(0., scroll - pos.Y() + Screen::Top());
	}

	if(importantOnly)
		info.SetCondition("important messages only");

	GameData::Interfaces().Get("message log")->Draw(info, this);
}`,
		filePath: 'C:/src/endless-sky/source/MessageLogPanel.cpp',
		startLine: 60,
		startColumn: 0,
		endLine: 106,
		endColumn: 1
	},
	{
		textSpan: `Point MissionPanel::DrawPanel(Point pos, const string &label, int entries, bool sorter) const
{
	const Color &back = *GameData::Colors().Get("map side panel background");
	const Color &text = *GameData::Colors().Get("medium");
	const Color separatorLine = text.Opaque();
	const Color &title = *GameData::Colors().Get("bright");
	const Color &highlight = *GameData::Colors().Get("dim");

	// Draw the panel.
	Point size(SIDE_WIDTH, 20 * entries + 40);
	FillShader::Fill(pos + .5 * size, size, back);

	// Edges:
	const Sprite *bottom = SpriteSet::Get("ui/bottom edge");
	Point edgePos = pos + Point(.5 * size.X(), size.Y());
	Point bottomOff(0., .5 * bottom->Height());
	SpriteShader::Draw(bottom, edgePos + bottomOff);

	const Sprite *left = SpriteSet::Get("ui/left edge");
	const Sprite *right = SpriteSet::Get("ui/right edge");
	double dy = .5 * left->Height();
	Point leftOff(-.5 * (size.X() + left->Width()), 0.);
	Point rightOff(.5 * (size.X() + right->Width()), 0.);
	while(dy && edgePos.Y() > Screen::Top())
	{
		edgePos.Y() -= dy;
		SpriteShader::Draw(left, edgePos + leftOff);
		SpriteShader::Draw(right, edgePos + rightOff);
		edgePos.Y() -= dy;
	}

	const Font &font = FontSet::Get(14);
	pos += Point(10., 10. + (20. - font.Height()) * .5);

	// Panel sorting
	const Sprite *rush[2] = {
			SpriteSet::Get("ui/sort rush include"), SpriteSet::Get("ui/sort rush separate") };
	const Sprite *acceptable[2] = {
			SpriteSet::Get("ui/sort unacceptable include"), SpriteSet::Get("ui/sort unacceptable separate") };
	const Sprite *sortIcon[4] = {
			SpriteSet::Get("ui/sort abc"), SpriteSet::Get("ui/sort pay"),
			SpriteSet::Get("ui/sort speed"), SpriteSet::Get("ui/sort convenient") };
	const Sprite *arrow[2] = {
			SpriteSet::Get("ui/sort descending"), SpriteSet::Get("ui/sort ascending") };

	// Draw Sorting Columns
	if(entries && sorter)
	{
		SpriteShader::Draw(arrow[player.ShouldSortAscending()], pos + Point(SIDE_WIDTH - 15., 7.5));

		SpriteShader::Draw(sortIcon[player.GetAvailableSortType()], pos + Point(SIDE_WIDTH - 45., 7.5));

		SpriteShader::Draw(acceptable[player.ShouldSortSeparatePossible()], pos + Point(SIDE_WIDTH - 75., 7.5));

		SpriteShader::Draw(rush[player.ShouldSortSeparateDeadline()], pos + Point(SIDE_WIDTH - 105., 7.5));

		if(hoverSort >= 0)
			FillShader::Fill(pos + Point(SIDE_WIDTH - 105. + 30 * hoverSort, 7.5), Point(22., 16.), highlight);
	}

	// Panel title
	font.Draw(label, pos, title);
	FillShader::Fill(
		pos + Point(.5 * size.X() - 5., 15.),
		Point(size.X() - 10., 1.),
		separatorLine);

	pos.Y() += 5.;

	return pos;
}`,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 765,
		startColumn: 0,
		endLine: 835,
		endColumn: 1
	},
	{
		textSpan: `Point MissionPanel::DrawList(const list<Mission> &list, Point pos, const std::list<Mission>::const_iterator &selectIt,
	bool separateDeadlineOrPossible) const
{
	const Font &font = FontSet::Get(14);
	const Color &highlight = *GameData::Colors().Get("faint");
	const Color &unselected = *GameData::Colors().Get("medium");
	const Color &selected = *GameData::Colors().Get("bright");
	const Color &dim = *GameData::Colors().Get("dim");
	const Sprite *fast = SpriteSet::Get("ui/fast forward");
	bool separated = false;

	for(auto it = list.begin(); it != list.end(); ++it)
	{
		if(!it->IsVisible())
			continue;

		pos.Y() += 20.;
		if(separateDeadlineOrPossible && !separated
				&& ((player.ShouldSortSeparateDeadline() && it->Deadline())
						|| (player.ShouldSortSeparatePossible() && !it->CanAccept(player))))
		{
			pos.Y() += 8.;
			separated = true;
		}

		bool isSelected = it == selectIt;
		if(isSelected)
			FillShader::Fill(
				pos + Point(.5 * SIDE_WIDTH - 5., 8.),
				Point(SIDE_WIDTH - 10., 20.),
				highlight);

		if(it->Deadline())
			SpriteShader::Draw(fast, pos + Point(-4., 8.));

		const Color *color = nullptr;
		bool canAccept = (&list == &available ? it->CanAccept(player) : IsSatisfied(*it));
		if(!canAccept)
		{
			if(it->Unavailable().IsLoaded())
				color = &it->Unavailable();
			else
				color = &dim;
		}
		else if(isSelected)
		{
			if(it->Selected().IsLoaded())
				color = &it->Selected();
			else
				color = &selected;
		}
		else
		{
			if(it->Unselected().IsLoaded())
				color = &it->Unselected();
			else
				color = &unselected;
		}

		font.Draw({it->Name(), {SIDE_WIDTH - 11, Truncate::BACK}}, pos, *color);
	}

	return pos;
}`,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 839,
		startColumn: 0,
		endLine: 902,
		endColumn: 1
	},
	{
		textSpan: `void MissionPanel::DrawTooltips()
{
	if(hoverSort < 0 || hoverSortCount < HOVER_TIME)
		return;

	// Create the tooltip text.
	if(tooltip.empty())
	{
		if(hoverSort == 0)
			tooltip = "Filter out missions with a deadline";
		else if(hoverSort == 1)
			tooltip = "Filter out missions that you can't accept";
		else if(hoverSort == 2)
		{
			switch(player.GetAvailableSortType())
			{
				case 0:
					tooltip = "Sort alphabetically";
					break;
				case 1:
					tooltip = "Sort by payment";
					break;
				case 2:
					tooltip = "Sort by distance";
					break;
				case 3:
					tooltip = "Sort by convenience: "
							"Prioritize missions going to a planet or system that is already a destination of one of your missions";
					break;
			}
		}
		else if(hoverSort == 3)
			tooltip = "Sort direction";

		hoverText.Wrap(tooltip);
	}
	if(!tooltip.empty())
	{
		// Add 10px margin to all sides of the text.
		Point size(hoverText.WrapWidth(), hoverText.Height() - hoverText.ParagraphBreak());
		size += Point(20., 20.);
		Point topLeft = Point(Screen::Left() + SIDE_WIDTH - 120. + 30 * hoverSort, Screen::Top() + 30.);
		// Draw the background fill and the tooltip text.
		FillShader::Fill(topLeft + .5 * size, size, *GameData::Colors().Get("tooltip background"));
		hoverText.Draw(topLeft + Point(10., 10.), *GameData::Colors().Get("medium"));
	}
}`,
		filePath: 'C:/src/endless-sky/source/MissionPanel.cpp',
		startLine: 955,
		startColumn: 0,
		endLine: 1001,
		endColumn: 1
	},
	{
		textSpan: `void Panel::DrawBackdrop() const
{
	if(!GetUI()->IsTop(this))
		return;

	// Darken everything but the dialog.
	const Color &back = *GameData::Colors().Get("dialog backdrop");
	FillShader::Fill(Point(), Point(Screen::Width(), Screen::Height()), back);
}`,
		filePath: 'C:/src/endless-sky/source/Panel.cpp',
		startLine: 300,
		startColumn: 0,
		endLine: 308,
		endColumn: 1
	},
	{
		textSpan: `void PreferencesPanel::DrawTooltips()
{
	if(hoverItem.empty())
	{
		// Step the tooltip timer back.
		hoverCount -= hoverCount ? 1 : 0;
		return;
	}

	// Step the tooltip timer forward [0-60].
	hoverCount += hoverCount < HOVER_TIME;

	if(hoverCount < HOVER_TIME)
		return;

	// Create the tooltip text.
	if(tooltip.empty())
	{
		tooltip = GameData::Tooltip(hoverItem);
		// No tooltip for this item.
		if(tooltip.empty())
			return;
		hoverText.Wrap(tooltip);
	}

	Point size(hoverText.WrapWidth(), hoverText.Height() - hoverText.ParagraphBreak());
	size += Point(20., 20.);
	Point topLeft = hoverPoint;
	// Do not overflow the screen dimensions.
	if(topLeft.X() + size.X() > Screen::Right())
		topLeft.X() -= size.X();
	if(topLeft.Y() + size.Y() > Screen::Bottom())
		topLeft.Y() -= size.Y();
	// Draw the background fill and the tooltip text.
	FillShader::Fill(topLeft + .5 * size, size, *GameData::Colors().Get("tooltip background"));
	hoverText.Draw(topLeft + Point(10., 10.), *GameData::Colors().Get("medium"));
}`,
		filePath: 'C:/src/endless-sky/source/PreferencesPanel.cpp',
		startLine: 1201,
		startColumn: 0,
		endLine: 1237,
		endColumn: 1
	},
	{
		textSpan: `void ShipInfoDisplay::DrawAttributes(const Point &topLeft, const bool sale) const
{
	// Header.
	Point point = Draw(topLeft, attributeHeaderLabels, attributeHeaderValues);

	// Sale info.
	if(sale)
	{
		point = Draw(point, saleLabels, saleValues);

		const Color &color = *GameData::Colors().Get("medium");
		FillShader::Fill(point + Point(.5 * WIDTH, 5.), Point(WIDTH - 20., 1.), color);
	}
	else
		point -= Point(0, 10.);

	// Body.
	point = Draw(point, attributeLabels, attributeValues);

	// Get standard colors to draw with.
	const Color &labelColor = *GameData::Colors().Get("medium");
	const Color &valueColor = *GameData::Colors().Get("bright");

	Table table;
	table.AddColumn(10, {WIDTH - 10, Alignment::LEFT});
	table.AddColumn(WIDTH - 90, {WIDTH - 80, Alignment::RIGHT});
	table.AddColumn(WIDTH - 10, {WIDTH - 20, Alignment::RIGHT});
	table.SetHighlight(0, WIDTH);
	table.DrawAt(point);
	table.DrawGap(10.);

	table.Advance();
	table.Draw("energy", labelColor);
	table.Draw("heat", labelColor);

	for(unsigned i = 0; i < tableLabels.size(); ++i)
	{
		CheckHover(table, tableLabels[i]);
		table.Draw(tableLabels[i], labelColor);
		table.Draw(energyTable[i], valueColor);
		table.Draw(heatTable[i], valueColor);
	}
}`,
		filePath: 'C:/src/endless-sky/source/ShipInfoDisplay.cpp',
		startLine: 81,
		startColumn: 0,
		endLine: 123,
		endColumn: 1
	},
	{
		textSpan: `void DrawTooltip(const string &text, const Point &hoverPoint, const Color &textColor, const Color &backColor)
	{
		constexpr int WIDTH = 250;
		constexpr int PAD = 10;
		WrappedText wrap(FontSet::Get(14));
		wrap.SetWrapWidth(WIDTH - 2 * PAD);
		wrap.Wrap(text);
		int longest = wrap.LongestLineWidth();
		if(longest < wrap.WrapWidth())
		{
			wrap.SetWrapWidth(longest);
			wrap.Wrap(text);
		}

		Point textSize(wrap.WrapWidth() + 2 * PAD, wrap.Height() + 2 * PAD - wrap.ParagraphBreak());
		Point anchor = Point(hoverPoint.X(), min<double>(hoverPoint.Y() + textSize.Y(), Screen::Bottom()));
		FillShader::Fill(anchor - .5 * textSize, textSize, backColor);
		wrap.Draw(anchor - textSize + Point(PAD, PAD), textColor);
	}

	constexpr auto ScrollbarMaybeUpdate = [](const auto &op, ScrollBar &scrollbar,
		ScrollVar<double> &scroll, bool animate)
	{
		if(!op(scrollbar))
			return false;
		scrollbar.SyncInto(scroll, animate ? 5 : 0);
		return true;
	};
}`,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 70,
		startColumn: 1,
		endLine: 93,
		endColumn: 1
	},
	{
		textSpan: `void ShopPanel::DrawShipsSidebar()
{
	const Font &font = FontSet::Get(14);
	const Color &dark = *GameData::Colors().Get("dark");
	const Color &medium = *GameData::Colors().Get("medium");
	const Color &bright = *GameData::Colors().Get("bright");

	sidebarScroll.Step();

	// Fill in the background.
	FillShader::Fill(
		Point(Screen::Right() - SIDEBAR_WIDTH / 2, 0.),
		Point(SIDEBAR_WIDTH, Screen::Height()),
		*GameData::Colors().Get("panel background"));
	FillShader::Fill(
		Point(Screen::Right() - SIDEBAR_WIDTH, 0.),
		Point(1, Screen::Height()),
		*GameData::Colors().Get("shop side panel background"));

	// Draw this string, centered in the side panel:
	static const string YOURS = "Your Ships:";
	Point yoursPoint(Screen::Right() - SIDEBAR_WIDTH, Screen::Top() + 10 - sidebarScroll.AnimatedValue());
	font.Draw({YOURS, {SIDEBAR_WIDTH, Alignment::CENTER}}, yoursPoint, bright);

	// Start below the "Your Ships" label, and draw them.
	Point point(
		Screen::Right() - SIDEBAR_CONTENT / 2 - SIDEBAR_PADDING - 93,
		Screen::Top() + SIDEBAR_CONTENT / 2 - sidebarScroll.AnimatedValue() + 40 - 93);

	const Planet *here = player.GetPlanet();
	int shipsHere = 0;
	for(const shared_ptr<Ship> &ship : player.Ships())
		shipsHere += CanShowInSidebar(*ship, here);
	if(shipsHere < 4)
		point.X() += .5 * ICON_TILE * (4 - shipsHere);

	// Check whether flight check tooltips should be shown.
	const auto flightChecks = player.FlightCheck();
	Point mouse = UI::GetMouse();
	warningType.clear();
	shipName.clear();
	shipZones.clear();

	static const Color selected(.8f, 1.f);
	static const Color unselected(.4f, 1.f);
	for(const shared_ptr<Ship> &ship : player.Ships())
	{
		// Skip any ships that are "absent" for whatever reason.
		if(!CanShowInSidebar(*ship, here))
			continue;

		if(point.X() > Screen::Right())
		{
			point.X() -= ICON_TILE * ICON_COLS;
			point.Y() += ICON_TILE;
		}

		bool isSelected = playerShips.contains(ship.get());
		const Sprite *background = SpriteSet::Get(isSelected ? "ui/icon selected" : "ui/icon unselected");
		SpriteShader::Draw(background, point);
		// If this is one of the selected ships, check if the currently hovered
		// button (if any) applies to it. If so, brighten the background.
		if(isSelected && ShouldHighlight(ship.get()))
			SpriteShader::Draw(background, point);

		const Sprite *sprite = ship->GetSprite();
		if(sprite)
		{
			float scale = ICON_SIZE / max(sprite->Width(), sprite->Height());
			if(Preferences::Has(SHIP_OUTLINES))
			{
				Point size(sprite->Width() * scale, sprite->Height() * scale);
				OutlineShader::Draw(sprite, point, size, isSelected ? selected : unselected);
			}
			else
			{
				const Swizzle *swizzle = ship->CustomSwizzle() ? ship->CustomSwizzle() : GameData::PlayerGovernment()->GetSwizzle();
				SpriteShader::Draw(sprite, point, scale, swizzle);
			}
		}

		shipZones.emplace_back(point, Point(ICON_TILE, ICON_TILE), ship.get());

		if(mouse.Y() < Screen::Bottom() - BUTTON_HEIGHT && shipZones.back().Contains(mouse))
		{
			shipName = ship->Name() + (ship->IsParked() ? "\n" + GameData::Tooltip("parked") : "");
			hoverPoint = shipZones.back().TopLeft();
		}

		const auto checkIt = flightChecks.find(ship);
		if(checkIt != flightChecks.end())
		{
			const string &check = (*checkIt).second.front();
			const Sprite *icon = SpriteSet::Get(check.back() == '!' ? "ui/error" : "ui/warning");
			SpriteShader::Draw(icon, point + .5 * Point(ICON_TILE - icon->Width(), ICON_TILE - icon->Height()));
			if(shipZones.back().Contains(mouse))
				warningType = check;
		}

		if(isSelected && playerShips.size() > 1 && ship->OutfitCount(selectedOutfit))
			PointerShader::Draw(Point(point.X() - static_cast<int>(ICON_TILE / 3), point.Y()),
				Point(1., 0.), 14.f, 12.f, 0., Color(.9f, .9f, .9f, .2f));

		if(ship->IsParked())
		{
			static const Point CORNER = .35 * Point(ICON_TILE, ICON_TILE);
			FillShader::Fill(point + CORNER, Point(6., 6.), dark);
			FillShader::Fill(point + CORNER, Point(4., 4.), isSelected ? bright : medium);
		}

		point.X() += ICON_TILE;
	}
	point.Y() += ICON_TILE;

	if(playerShip)
	{
		point.Y() += SHIP_SIZE / 2;
		point.X() = (Screen::Right() - SIDEBAR_CONTENT / 2) - SIDEBAR_PADDING;
		DrawShip(*playerShip, point, true);

		Point offset(SIDEBAR_CONTENT / -2, SHIP_SIZE / 2);
		const int detailHeight = DrawPlayerShipInfo(point + offset);
		point.Y() += detailHeight + SHIP_SIZE / 2;
	}
	else if(player.Cargo().Size())
	{
		point.X() = Screen::Right() - SIDEBAR_WIDTH + 10;
		font.Draw("cargo space:", point, medium);

		string space = Format::Number(player.Cargo().Free()) + " / " + Format::Number(player.Cargo().Size());
		font.Draw({space, {SIDEBAR_WIDTH - 20, Alignment::RIGHT}}, point, bright);
		point.Y() += 20.;
	}
	sidebarScroll.SetDisplaySize(Screen::Height() - BUTTON_HEIGHT);
	sidebarScroll.SetMaxValue(max(0., point.Y() + sidebarScroll.AnimatedValue() - Screen::Bottom() + Screen::Height()));

	if(sidebarScroll.Scrollable())
	{
		Point top(Screen::Right() - 3, Screen::Top() + 10);
		Point bottom(Screen::Right() - 3, Screen::Bottom() - 80);

		sidebarScrollbar.SyncDraw(sidebarScroll, top, bottom);
	}
}`,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 749,
		startColumn: 0,
		endLine: 892,
		endColumn: 1
	},
	{
		textSpan: `void ShopPanel::DrawDetailsSidebar()
{
	// Fill in the background.
	const Color &line = *GameData::Colors().Get("dim");
	const Color &back = *GameData::Colors().Get("shop info panel background");

	infobarScroll.Step();

	FillShader::Fill(
		Point(Screen::Right() - SIDEBAR_WIDTH - INFOBAR_WIDTH, 0.),
		Point(1., Screen::Height()),
		line);
	FillShader::Fill(
		Point(Screen::Right() - SIDEBAR_WIDTH - INFOBAR_WIDTH / 2, 0.),
		Point(INFOBAR_WIDTH - 1., Screen::Height()),
		back);

	Point point(
		Screen::Right() - SIDE_WIDTH + INFOBAR_WIDTH / 2,
		Screen::Top() + 10 - infobarScroll.AnimatedValue());

	double heightOffset = DrawDetails(point);

	infobarScroll.SetDisplaySize(Screen::Height());
	infobarScroll.SetMaxValue(max(0., heightOffset + infobarScroll.AnimatedValue() - Screen::Bottom()) + Screen::Height());

	if(infobarScroll.Scrollable())
	{
		Point top{Screen::Right() - SIDEBAR_WIDTH - 7., Screen::Top() + 10.};
		Point bottom{Screen::Right() - SIDEBAR_WIDTH - 7., Screen::Bottom() - 10.};

		infobarScrollbar.SyncDraw(infobarScroll, top, bottom);
	}
}`,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 896,
		startColumn: 0,
		endLine: 929,
		endColumn: 1
	},
	{	
		textSpan: `void ShopPanel::DrawButtons()
{
	// The last 70 pixels on the end of the side panel are for the buttons:
	Point buttonSize(SIDEBAR_WIDTH, BUTTON_HEIGHT);
	FillShader::Fill(Screen::BottomRight() - .5 * buttonSize, buttonSize,
		*GameData::Colors().Get("shop side panel background"));
	FillShader::Fill(
		Point(Screen::Right() - SIDEBAR_WIDTH / 2, Screen::Bottom() - BUTTON_HEIGHT),
		Point(SIDEBAR_WIDTH, 1), *GameData::Colors().Get("shop side panel footer"));

	const Font &font = FontSet::Get(14);
	const Color &bright = *GameData::Colors().Get("bright");
	const Color &dim = *GameData::Colors().Get("medium");
	const Color &back = *GameData::Colors().Get("panel background");

	const Point creditsPoint(
		Screen::Right() - SIDEBAR_WIDTH + 10,
		Screen::Bottom() - 65);
	font.Draw("You have:", creditsPoint, dim);

	const auto credits = Format::CreditString(player.Accounts().Credits());
	font.Draw({credits, {SIDEBAR_WIDTH - 20, Alignment::RIGHT}}, creditsPoint, bright);

	const Font &bigFont = FontSet::Get(18);
	const Color &hover = *GameData::Colors().Get("hover");
	const Color &active = *GameData::Colors().Get("active");
	const Color &inactive = *GameData::Colors().Get("inactive");

	const Point buyCenter = Screen::BottomRight() - Point(210, 25);
	FillShader::Fill(buyCenter, Point(60, 30), back);
	bool isOwned = IsAlreadyOwned();
	const Color *buyTextColor;
	if(!CanBuy(isOwned))
		buyTextColor = &inactive;
	else if(hoverButton == (isOwned ? 'i' : 'b'))
		buyTextColor = &hover;
	else
		buyTextColor = &active;
	string BUY = isOwned ? (playerShip ? "_Install" : "_Cargo") : "_Buy";
	bigFont.Draw(BUY,
		buyCenter - .5 * Point(bigFont.Width(BUY), bigFont.Height()),
		*buyTextColor);

	const Point sellCenter = Screen::BottomRight() - Point(130, 25);
	FillShader::Fill(sellCenter, Point(60, 30), back);
	static const string SELL = "_Sell";
	bigFont.Draw(SELL,
		sellCenter - .5 * Point(bigFont.Width(SELL), bigFont.Height()),
		CanSell() ? hoverButton == 's' ? hover : active : inactive);

	const Point leaveCenter = Screen::BottomRight() - Point(45, 25);
	FillShader::Fill(leaveCenter, Point(70, 30), back);
	static const string LEAVE = "_Leave";
	bigFont.Draw(LEAVE,
		leaveCenter - .5 * Point(bigFont.Width(LEAVE), bigFont.Height()),
		hoverButton == 'l' ? hover : active);

	const Point findCenter = Screen::BottomRight() - Point(580, 20);
	const Sprite *findIcon =
		hoverButton == 'f' ? SpriteSet::Get("ui/find selected") : SpriteSet::Get("ui/find unselected");
	SpriteShader::Draw(findIcon, findCenter);
	static const string FIND = "_Find";

	int modifier = Modifier();
	if(modifier > 1)
	{
		string mod = "x " + to_string(modifier);
		int modWidth = font.Width(mod);
		font.Draw(mod, buyCenter + Point(-.5 * modWidth, 10.), dim);
		if(CanSellMultiple())
			font.Draw(mod, sellCenter + Point(-.5 * modWidth, 10.), dim);
	}

	// Draw the tooltip for your full number of credits.
	const Rectangle creditsBox = Rectangle::FromCorner(creditsPoint, Point(SIDEBAR_WIDTH - 20, 15));
	if(creditsBox.Contains(hoverPoint))
		hoverCount += hoverCount < HOVER_TIME;
	else if(hoverCount)
		--hoverCount;

	if(hoverCount == HOVER_TIME)
	{
		string text = Format::Number(player.Accounts().Credits()) + " credits";
		DrawTooltip(text, hoverPoint, dim, *GameData::Colors().Get("tooltip background"));
	}
}`,
		filePath: 'C:/src/endless-sky/source/ShopPanel.cpp',
		startLine: 933,
		startColumn: 0,
		endLine: 1018,
		endColumn: 1
	},
	{
		textSpan: `void StartConditionsPanel::Draw()
{
	glClear(GL_COLOR_BUFFER_BIT);
	GameData::Background().Draw(Point());

	GameData::Interfaces().Get("menu background")->Draw(info, this);
	GameData::Interfaces().Get("start conditions menu")->Draw(info, this);
	GameData::Interfaces().Get("menu start info")->Draw(info, this);

	// Rather than blink list items in & out of existence, fade them in/out over half the entry height.
	const double fadeDistance = .5 * entryBox.Height();
	const double fadeInY = entriesContainer.Top() - fadeDistance + entryTextPadding.Y();
	const double fadeOutY = fadeInY + entriesContainer.Height();

	// Start at the top left of the list and offset by the text margins and scroll.
	auto pos = entriesContainer.TopLeft() - Point(0., entriesScroll);

	const Font &font = FontSet::Get(14);
	for(auto it = scenarios.begin(); it != scenarios.end();
			++it, pos += Point(0., entryBox.Height()))
	{
		// Any scenario wholly outside the bounds can be skipped.
		const auto zone = Rectangle::FromCorner(pos, entryBox.Dimensions());
		if(!(entriesContainer.Contains(zone.TopLeft()) || entriesContainer.Contains(zone.BottomRight())))
			continue;

		// Partially visible entries should fade in or out.
		double opacity = entriesContainer.Contains(zone) ? 1.
			: min(1., max(0., min(pos.Y() - fadeInY, fadeOutY - pos.Y()) / fadeDistance));

		bool isHighlighted = it == startIt || (hasHover && zone.Contains(hoverPoint));
		if(it == startIt)
			FillShader::Fill(zone.Center(), zone.Dimensions(), selectedBackground.Additive(opacity));

		const auto name = DisplayText(it->GetDisplayName(), Truncate::BACK);
		font.Draw(name, pos + entryTextPadding, (isHighlighted ? bright : medium).Transparent(opacity));
	}

	// TODO: Prevent lengthy descriptions from overflowing.
	description.Draw(descriptionBox.TopLeft(), bright);
}`,
		filePath: 'C:/src/endless-sky/source/StartConditionsPanel.cpp',
		startLine: 90,
		startColumn: 0,
		endLine: 130,
		endColumn: 1
	},
	{
		textSpan: `void TradingPanel::Draw()
{
	const Interface *tradeUi = GameData::Interfaces().Get("trade");
	const Rectangle box = tradeUi->GetBox("content");
	const int MIN_X = box.Left();
	const int FIRST_Y = box.Top();

	const Color &back = *GameData::Colors().Get("faint");
	int selectedRow = player.MapColoring();
	if(selectedRow >= 0 && selectedRow < COMMODITY_COUNT)
	{
		const Point center(MIN_X + box.Width() / 2, FIRST_Y + 20 * selectedRow + 33);
		const Point dimensions(box.Width() - 20., 20.);
		FillShader::Fill(center, dimensions, back);
	}

	const Font &font = FontSet::Get(14);
	const Color &unselected = *GameData::Colors().Get("medium");
	const Color &selected = *GameData::Colors().Get("bright");

	int y = FIRST_Y;
	font.Draw("Commodity", Point(MIN_X + NAME_X, y), selected);
	font.Draw("Price", Point(MIN_X + PRICE_X, y), selected);

	string mod = "x " + to_string(Modifier());
	font.Draw(mod, Point(MIN_X + BUY_X, y), unselected);
	font.Draw(mod, Point(MIN_X + SELL_X, y), unselected);

	font.Draw("In Hold", Point(MIN_X + HOLD_X, y), selected);

	y += 5;
	int lastY = y + 20 * COMMODITY_COUNT + 25;
	font.Draw("free:", Point(MIN_X + SELL_X + 5, lastY), selected);
	font.Draw(to_string(player.Cargo().Free()), Point(MIN_X + HOLD_X, lastY), selected);

	int outfits = player.Cargo().OutfitsSize();
	int missionCargo = player.Cargo().MissionCargoSize();
	sellOutfits = false;
	if(player.Cargo().HasOutfits() || missionCargo)
	{
		bool hasOutfits = false;
		bool hasMinables = false;
		for(const auto &it : player.Cargo().Outfits())
			if(it.second)
			{
				bool isMinable = it.first->Get("minable");
				(isMinable ? hasMinables : hasOutfits) = true;
			}
		sellOutfits = (hasOutfits && !hasMinables);

		string str = Format::MassString(outfits + missionCargo) + " of ";
		if(hasMinables && missionCargo)
			str += "mission cargo and other items.";
		else if(hasOutfits && missionCargo)
			str += "outfits and mission cargo.";
		else if(hasOutfits && hasMinables)
			str += "outfits and special commodities.";
		else if(hasOutfits)
			str += "outfits.";
		else if(hasMinables)
			str += "special commodities.";
		else
			str += "mission cargo.";
		font.Draw(str, Point(MIN_X + NAME_X, lastY), unselected);
	}

	int i = 0;
	bool canSell = false;
	bool canBuy = false;
	bool showProfit = false;
	for(const Trade::Commodity &commodity : GameData::Commodities())
	{
		y += 20;
		int price = system.Trade(commodity.name);
		int hold = player.Cargo().Get(commodity.name);

		bool isSelected = (i++ == selectedRow);
		const Color &color = (isSelected ? selected : unselected);
		font.Draw(commodity.name, Point(MIN_X + NAME_X, y), color);

		if(price)
		{
			canBuy |= isSelected;
			font.Draw(to_string(price), Point(MIN_X + PRICE_X, y), color);

			int basis = player.GetBasis(commodity.name);
			if(basis && basis != price && hold)
			{
				string profit = to_string(price - basis);
				font.Draw(profit, Point(MIN_X + PROFIT_X, y), color);
				showProfit = true;
			}
			int level = (price - commodity.low);
			if(level < 0)
				level = 0;
			else if(level >= (commodity.high - commodity.low))
				level = 4;
			else
				level = (5 * level) / (commodity.high - commodity.low);
			font.Draw(TRADE_LEVEL[level], Point(MIN_X + LEVEL_X, y), color);

			font.Draw("[buy]", Point(MIN_X + BUY_X, y), color);
			font.Draw("[sell]", Point(MIN_X + SELL_X, y), color);
		}
		else
		{
			font.Draw("----", Point(MIN_X + PRICE_X, y), color);
			font.Draw("(not for sale)", Point(MIN_X + LEVEL_X, y), color);
		}

		if(hold)
		{
			sellOutfits = false;
			canSell |= (price != 0);
			font.Draw(to_string(hold), Point(MIN_X + HOLD_X, y), selected);
		}
	}

	if(showProfit)
		font.Draw("Profit", Point(MIN_X + PROFIT_X, FIRST_Y), selected);

	Information info;
	if(sellOutfits)
		info.SetCondition("can sell outfits");
	else if(player.Cargo().HasOutfits() || canSell)
		info.SetCondition("can sell");
	if(player.Cargo().Free() > 0 && canBuy)
		info.SetCondition("can buy");
	tradeUi->Draw(info, this);
}`,
		filePath: 'C:/src/endless-sky/source/TradingPanel.cpp',
		startLine: 90,
		startColumn: 0,
		endLine: 219,
		endColumn: 1
	},
	{
		textSpan: `class FillShader {
public:
	static void Init();
	static void Fill(const Point &center, const Point &size, const Color &color);
};`,
		filePath: 'C:/src/endless-sky/source/shader/FillShader.h',
		startLine: 25,
		startColumn: 0,
		endLine: 29,
		endColumn: 2
	},
	{
		textSpan: `void Table::DrawUnderline(const Color &color) const
{
	FillShader::Fill(point + lineOff - Point(0., 2.), lineSize, color);
}`,
		filePath: 'C:/src/endless-sky/source/text/Table.cpp',
		startLine: 238,
		startColumn: 0,
		endLine: 241,
		endColumn: 1
	},
	{
		textSpan: `void Table::DrawHighlight(const Color &color) const
{
	FillShader::Fill(GetCenterPoint(), GetRowSize(), color);
}`,
		filePath: 'C:/src/endless-sky/source/text/Table.cpp',
		startLine: 253,
		startColumn: 0,
		endLine: 256,
		endColumn: 1
	}
];
*/